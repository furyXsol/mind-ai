try {
  let e =
      "undefined" != typeof window
        ? window
        : "undefined" != typeof global
        ? global
        : "undefined" != typeof globalThis
        ? globalThis
        : "undefined" != typeof self
        ? self
        : {},
    t = new e.Error().stack;
  t &&
    ((e._sentryDebugIds = e._sentryDebugIds || {}),
    (e._sentryDebugIds[t] = "8fc6aab8-3247-4f9d-989a-a7a7670a3765"),
    (e._sentryDebugIdIdentifier =
      "sentry-dbid-8fc6aab8-3247-4f9d-989a-a7a7670a3765"));
} catch (e) {}
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [7856],
  {
    458: (e, t, r) => {
      "use strict";
      r.d(t, {
        Vw: () => m,
        Fc: () => d,
        My: () => h,
        Id: () => g,
        O8: () => a,
        qv: () => l,
        po: () => y,
        aZ: () => c,
        Ow: () => o,
        ZJ: () => p,
        DH: () => n,
        ld: () => b,
      });
      let i =
        "object" == typeof globalThis && "crypto" in globalThis
          ? globalThis.crypto
          : void 0;
      var s = r(88487);
      function n(e) {
        return new Uint32Array(
          e.buffer,
          e.byteOffset,
          Math.floor(e.byteLength / 4)
        );
      }
      function a(e) {
        return new DataView(e.buffer, e.byteOffset, e.byteLength);
      }
      function o(e, t) {
        return (e << (32 - t)) | (e >>> t);
      }
      function c(e, t) {
        return (e << t) | ((e >>> (32 - t)) >>> 0);
      }
      let l = 68 === new Uint8Array(new Uint32Array([0x11223344]).buffer)[0];
      function d(e) {
        for (let r = 0; r < e.length; r++) {
          var t;
          e[r] =
            (((t = e[r]) << 24) & 0xff000000) |
            ((t << 8) & 0xff0000) |
            ((t >>> 8) & 65280) |
            ((t >>> 24) & 255);
        }
      }
      let u = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function h(e) {
        (0, s.DO)(e);
        let t = "";
        for (let r = 0; r < e.length; r++) t += u[e[r]];
        return t;
      }
      let f = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function p(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e)
                throw Error("utf8ToBytes expected string, got " + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          (0, s.DO)(e),
          e
        );
      }
      function g(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
          let i = e[r];
          (0, s.DO)(i), (t += i.length);
        }
        let r = new Uint8Array(t);
        for (let t = 0, i = 0; t < e.length; t++) {
          let s = e[t];
          r.set(s, i), (i += s.length);
        }
        return r;
      }
      class m {
        clone() {
          return this._cloneInto();
        }
      }
      function b(e) {
        let t = (t) => e().update(p(t)).digest(),
          r = e();
        return (
          (t.outputLen = r.outputLen),
          (t.blockLen = r.blockLen),
          (t.create = () => e()),
          t
        );
      }
      function y(e = 32) {
        if (i && "function" == typeof i.getRandomValues)
          return i.getRandomValues(new Uint8Array(e));
        if (i && "function" == typeof i.randomBytes) return i.randomBytes(e);
        throw Error("crypto.getRandomValues must be defined");
      }
    },
    1220: (e, t, r) => {
      "use strict";
      r.d(t, { B1: () => l, BX: () => c, KR: () => u, P9: () => d });
      var i = r(29461);
      let s = (e) => "object" == typeof e && null !== e,
        n = new WeakMap(),
        a = new WeakSet(),
        [o] = ((
          e = Object.is,
          t = (e, t) => new Proxy(e, t),
          r = (e) =>
            s(e) &&
            !a.has(e) &&
            (Array.isArray(e) || !(Symbol.iterator in e)) &&
            !(e instanceof WeakMap) &&
            !(e instanceof WeakSet) &&
            !(e instanceof Error) &&
            !(e instanceof Number) &&
            !(e instanceof Date) &&
            !(e instanceof String) &&
            !(e instanceof RegExp) &&
            !(e instanceof ArrayBuffer),
          o = (e) => {
            switch (e.status) {
              case "fulfilled":
                return e.value;
              case "rejected":
                throw e.reason;
              default:
                throw e;
            }
          },
          c = new WeakMap(),
          l = (e, t, r = o) => {
            let s = c.get(e);
            if ((null == s ? void 0 : s[0]) === t) return s[1];
            let d = Array.isArray(e)
              ? []
              : Object.create(Object.getPrototypeOf(e));
            return (
              (0, i.OC)(d, !0),
              c.set(e, [t, d]),
              Reflect.ownKeys(e).forEach((t) => {
                if (Object.getOwnPropertyDescriptor(d, t)) return;
                let s = Reflect.get(e, t),
                  { enumerable: o } = Reflect.getOwnPropertyDescriptor(e, t),
                  c = { value: s, enumerable: o, configurable: !0 };
                if (a.has(s)) (0, i.OC)(s, !1);
                else if (s instanceof Promise)
                  delete c.value, (c.get = () => r(s));
                else if (n.has(s)) {
                  let [e, t] = n.get(s);
                  c.value = l(e, t(), r);
                }
                Object.defineProperty(d, t, c);
              }),
              Object.preventExtensions(d)
            );
          },
          d = new WeakMap(),
          u = [1, 1],
          h = (o) => {
            if (!s(o)) throw Error("object required");
            let c = d.get(o);
            if (c) return c;
            let f = u[0],
              p = new Set(),
              g = (e, t = ++u[0]) => {
                f !== t && ((f = t), p.forEach((r) => r(e, t)));
              },
              m = u[1],
              b = (e = ++u[1]) => (
                m === e ||
                  p.size ||
                  ((m = e),
                  w.forEach(([t]) => {
                    let r = t[1](e);
                    r > f && (f = r);
                  })),
                f
              ),
              y = (e) => (t, r) => {
                let i = [...t];
                (i[1] = [e, ...i[1]]), g(i, r);
              },
              w = new Map(),
              v = (e, t) => {
                if (w.has(e)) throw Error("prop listener already exists");
                if (p.size) {
                  let r = t[3](y(e));
                  w.set(e, [t, r]);
                } else w.set(e, [t]);
              },
              A = (e) => {
                var t;
                let r = w.get(e);
                r && (w.delete(e), null == (t = r[1]) || t.call(r));
              },
              E = (e) => {
                p.add(e),
                  1 === p.size &&
                    w.forEach(([e, t], r) => {
                      if (t) throw Error("remove already exists");
                      let i = e[3](y(r));
                      w.set(r, [e, i]);
                    });
                let t = () => {
                  p.delete(e),
                    0 === p.size &&
                      w.forEach(([e, t], r) => {
                        t && (t(), w.set(r, [e]));
                      });
                };
                return t;
              },
              _ = Array.isArray(o)
                ? []
                : Object.create(Object.getPrototypeOf(o)),
              C = {
                deleteProperty(e, t) {
                  let r = Reflect.get(e, t);
                  A(t);
                  let i = Reflect.deleteProperty(e, t);
                  return i && g(["delete", [t], r]), i;
                },
                set(t, o, c, l) {
                  let u = Reflect.has(t, o),
                    f = Reflect.get(t, o, l);
                  if (u && (e(f, c) || (d.has(c) && e(f, d.get(c))))) return !0;
                  A(o), s(c) && (c = (0, i.Ai)(c) || c);
                  let p = c;
                  if (c instanceof Promise)
                    c.then((e) => {
                      (c.status = "fulfilled"),
                        (c.value = e),
                        g(["resolve", [o], e]);
                    }).catch((e) => {
                      (c.status = "rejected"),
                        (c.reason = e),
                        g(["reject", [o], e]);
                    });
                  else {
                    !n.has(c) && r(c) && (p = h(c));
                    let e = !a.has(p) && n.get(p);
                    e && v(o, e);
                  }
                  return Reflect.set(t, o, p, l), g(["set", [o], c, f]), !0;
                },
              },
              I = t(_, C);
            d.set(o, I);
            let S = [_, b, l, E];
            return (
              n.set(I, S),
              Reflect.ownKeys(o).forEach((e) => {
                let t = Object.getOwnPropertyDescriptor(o, e);
                "value" in t &&
                  ((I[e] = o[e]), delete t.value, delete t.writable),
                  Object.defineProperty(_, e, t);
              }),
              I
            );
          }
        ) => [h, n, a, e, t, r, o, c, l, d, u])();
      function c(e = {}) {
        return o(e);
      }
      function l(e, t, r) {
        let i;
        let s = n.get(e);
        s || console.warn("Please use proxy object");
        let a = [],
          o = s[3],
          c = !1,
          l = o((e) => {
            if ((a.push(e), r)) {
              t(a.splice(0));
              return;
            }
            i ||
              (i = Promise.resolve().then(() => {
                (i = void 0), c && t(a.splice(0));
              }));
          });
        return (
          (c = !0),
          () => {
            (c = !1), l();
          }
        );
      }
      function d(e, t) {
        let r = n.get(e);
        r || console.warn("Please use proxy object");
        let [i, s, a] = r;
        return a(i, s(), t);
      }
      function u(e) {
        return a.add(e), e;
      }
    },
    1262: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "default", {
          enumerable: !0,
          get: function () {
            return a;
          },
        });
      let i = r(12115),
        s = i.useLayoutEffect,
        n = i.useEffect;
      function a(e) {
        let { headManager: t, reduceComponentsToState: r } = e;
        function a() {
          if (t && t.mountedInstances) {
            let s = i.Children.toArray(
              Array.from(t.mountedInstances).filter(Boolean)
            );
            t.updateHead(r(s, e));
          }
        }
        return (
          s(() => {
            var r;
            return (
              null == t ||
                null == (r = t.mountedInstances) ||
                r.add(e.children),
              () => {
                var r;
                null == t ||
                  null == (r = t.mountedInstances) ||
                  r.delete(e.children);
              }
            );
          }),
          s(
            () => (
              t && (t._pendingUpdate = a),
              () => {
                t && (t._pendingUpdate = a);
              }
            )
          ),
          n(
            () => (
              t &&
                t._pendingUpdate &&
                (t._pendingUpdate(), (t._pendingUpdate = null)),
              () => {
                t &&
                  t._pendingUpdate &&
                  (t._pendingUpdate(), (t._pendingUpdate = null));
              }
            )
          ),
          null
        );
      }
    },
    2535: (e, t, r) => {
      "use strict";
      function i(e) {
        return e;
      }
      r.d(t, { U: () => i });
    },
    2648: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(12590);
      i.__exportStar(r(48543), t), i.__exportStar(r(25939), t);
    },
    3285: (e) => {
      function t(e, t) {
        if (!e) throw Error(t || "Assertion failed");
      }
      (e.exports = t),
        (t.equal = function (e, t, r) {
          if (e != t) throw Error(r || "Assertion failed: " + e + " != " + t);
        });
    },
    3824: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { x: () => m });
      var s = r(1220),
        n = r(98866),
        a = r(12319),
        o = r(67243),
        c = r(58653),
        l = r(73442),
        d = r(66254),
        u = r(70417),
        h = r(81701),
        f = r(67869),
        p = r(24369);
      let g = (0, s.BX)({ wcError: !1, buffering: !1, status: "disconnected" }),
        m = {
          state: g,
          subscribeKey: (e, t) => (0, n.u$)(g, e, t),
          _getClient: () => g._client,
          setClient(e) {
            g._client = (0, s.KR)(e);
          },
          async connectWalletConnect() {
            if (a.w.isTelegram() || (a.w.isSafari() && a.w.isIos())) {
              if (i) {
                await i, (i = void 0);
                return;
              }
              if (!a.w.isPairingExpired(g?.wcPairingExpiry)) {
                let e = g.wcUri;
                g.wcUri = e;
                return;
              }
              (i = this._getClient()
                ?.connectWalletConnect?.()
                .catch(() => void 0)),
                (this.state.status = "connecting"),
                await i,
                (i = void 0),
                (g.wcPairingExpiry = void 0),
                (this.state.status = "connected");
            } else await this._getClient()?.connectWalletConnect?.();
          },
          async connectExternal(e, t, r = !0) {
            await this._getClient()?.connectExternal?.(e),
              r && l.W.setActiveNamespace(t);
          },
          async reconnectExternal(e) {
            await this._getClient()?.reconnectExternal?.(e);
            let t = e.chain || l.W.state.activeChain;
            t && d.a.setConnectorId(e.id, t);
          },
          async setPreferredAccountType(e) {
            h.W.setLoading(!0, l.W.state.activeChain);
            let t = d.a.getAuthConnector();
            t &&
              (await t?.provider.setPreferredAccount(e),
              await this.reconnectExternal(t),
              h.W.setLoading(!1, l.W.state.activeChain),
              u.E.sendEvent({
                type: "track",
                event: "SET_PREFERRED_ACCOUNT_TYPE",
                properties: {
                  accountType: e,
                  network: l.W.state.activeCaipNetwork?.caipNetworkId || "",
                },
              }));
          },
          async signMessage(e) {
            return this._getClient()?.signMessage(e);
          },
          parseUnits(e, t) {
            return this._getClient()?.parseUnits(e, t);
          },
          formatUnits(e, t) {
            return this._getClient()?.formatUnits(e, t);
          },
          async sendTransaction(e) {
            return this._getClient()?.sendTransaction(e);
          },
          async getCapabilities(e) {
            return this._getClient()?.getCapabilities(e);
          },
          async grantPermissions(e) {
            return this._getClient()?.grantPermissions(e);
          },
          async walletGetAssets(e) {
            return this._getClient()?.walletGetAssets(e) ?? {};
          },
          async estimateGas(e) {
            return this._getClient()?.estimateGas(e);
          },
          async writeContract(e) {
            return this._getClient()?.writeContract(e);
          },
          async getEnsAddress(e) {
            return this._getClient()?.getEnsAddress(e);
          },
          async getEnsAvatar(e) {
            return this._getClient()?.getEnsAvatar(e);
          },
          checkInstalled(e) {
            return this._getClient()?.checkInstalled?.(e) || !1;
          },
          resetWcConnection() {
            (g.wcUri = void 0),
              (g.wcPairingExpiry = void 0),
              (g.wcLinking = void 0),
              (g.recentWallet = void 0),
              (g.status = "disconnected"),
              p.W.resetTransactions(),
              c.i.deleteWalletConnectDeepLink();
          },
          resetUri() {
            (g.wcUri = void 0), (g.wcPairingExpiry = void 0);
          },
          finalizeWcConnection() {
            let { wcLinking: e, recentWallet: t } = m.state;
            e && c.i.setWalletConnectDeepLink(e),
              t && c.i.setAppKitRecent(t),
              u.E.sendEvent({
                type: "track",
                event: "CONNECT_SUCCESS",
                properties: {
                  method: e ? "mobile" : "qrcode",
                  name: f.I.state.data?.wallet?.name || "Unknown",
                },
              });
          },
          setWcBasic(e) {
            g.wcBasic = e;
          },
          setUri(e) {
            (g.wcUri = e), (g.wcPairingExpiry = a.w.getPairingExpiry());
          },
          setWcLinking(e) {
            g.wcLinking = e;
          },
          setWcError(e) {
            (g.wcError = e), (g.buffering = !1);
          },
          setRecentWallet(e) {
            g.recentWallet = e;
          },
          setBuffering(e) {
            g.buffering = e;
          },
          setStatus(e) {
            g.status = e;
          },
          async disconnect(e) {
            try {
              h.W.setLoading(!0, e),
                await o.U.clearSessions(),
                await l.W.disconnect(e),
                h.W.setLoading(!1, e),
                d.a.setFilterByNamespace(void 0);
            } catch (e) {
              throw Error("Failed to disconnect");
            }
          },
        };
    },
    4058: (e, t, r) => {
      "use strict";
      r.d(t, { Ci: () => a, J8: () => o, MU: () => c });
      var i = r(59350),
        s = r(13933),
        n = r(24250);
      class a extends s.C {
        constructor({
          body: e,
          cause: t,
          details: r,
          headers: s,
          status: a,
          url: o,
        }) {
          super("HTTP request failed.", {
            cause: t,
            details: r,
            metaMessages: [
              a && `Status: ${a}`,
              `URL: ${(0, n.I)(o)}`,
              e && `Request body: ${(0, i.A)(e)}`,
            ].filter(Boolean),
            name: "HttpRequestError",
          }),
            Object.defineProperty(this, "body", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "headers", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "status", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "url", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.body = e),
            (this.headers = s),
            (this.status = a),
            (this.url = o);
        }
      }
      s.C;
      class o extends s.C {
        constructor({ body: e, error: t, url: r }) {
          super("RPC Request failed.", {
            cause: t,
            details: t.message,
            metaMessages: [
              `URL: ${(0, n.I)(r)}`,
              `Request body: ${(0, i.A)(e)}`,
            ],
            name: "RpcRequestError",
          }),
            Object.defineProperty(this, "code", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "data", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.code = t.code),
            (this.data = t.data);
        }
      }
      s.C;
      class c extends s.C {
        constructor({ body: e, url: t }) {
          super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [
              `URL: ${(0, n.I)(t)}`,
              `Request body: ${(0, i.A)(e)}`,
            ],
            name: "TimeoutError",
          });
        }
      }
    },
    4117: (e, t, r) => {
      "use strict";
      var i = r(20920).rotr32;
      function s(e, t, r) {
        return (e & t) ^ (e & r) ^ (t & r);
      }
      (t.ft_1 = function (e, t, r, i) {
        var n;
        return 0 === e
          ? ((n = t) & r) ^ (~n & i)
          : 1 === e || 3 === e
          ? t ^ r ^ i
          : 2 === e
          ? s(t, r, i)
          : void 0;
      }),
        (t.ch32 = function (e, t, r) {
          return (e & t) ^ (~e & r);
        }),
        (t.maj32 = s),
        (t.p32 = function (e, t, r) {
          return e ^ t ^ r;
        }),
        (t.s0_256 = function (e) {
          return i(e, 2) ^ i(e, 13) ^ i(e, 22);
        }),
        (t.s1_256 = function (e) {
          return i(e, 6) ^ i(e, 11) ^ i(e, 25);
        }),
        (t.g0_256 = function (e) {
          return i(e, 7) ^ i(e, 18) ^ (e >>> 3);
        }),
        (t.g1_256 = function (e) {
          return i(e, 17) ^ i(e, 19) ^ (e >>> 10);
        });
    },
    5566: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(12590);
      i.__exportStar(r(2648), t),
        i.__exportStar(r(38053), t),
        i.__exportStar(r(90332), t),
        i.__exportStar(r(25648), t);
    },
    5831: (e, t, r) => {
      "use strict";
      r.d(t, { NBY: () => i, tWt: () => n, Rn0: () => a });
      let i = {
        formatters: void 0,
        fees: void 0,
        serializers: void 0,
        id: 56,
        name: "BNB Smart Chain",
        nativeCurrency: { decimals: 18, name: "BNB", symbol: "BNB" },
        rpcUrls: { default: { http: ["https://56.rpc.thirdweb.com"] } },
        blockExplorers: {
          default: {
            name: "BscScan",
            url: "https://bscscan.com",
            apiUrl: "https://api.bscscan.com/api",
          },
        },
        contracts: {
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 0xf2f12c,
          },
        },
      };
      function s(e) {
        return { formatters: void 0, fees: void 0, serializers: void 0, ...e };
      }
      let n = s({
          id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
          name: "Solana",
          network: "solana-mainnet",
          nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
          blockExplorers: {
            default: { name: "Solscan", url: "https://solscan.io" },
          },
          testnet: !1,
          chainNamespace: "solana",
          caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
          deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
        }),
        a = s({
          id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
          name: "Solana Devnet",
          network: "solana-devnet",
          nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
          blockExplorers: {
            default: { name: "Solscan", url: "https://solscan.io" },
          },
          testnet: !0,
          chainNamespace: "solana",
          caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
          deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K",
        });
      s({
        id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
        name: "Solana Testnet",
        network: "solana-testnet",
        nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
        rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
        blockExplorers: {
          default: { name: "Solscan", url: "https://solscan.io" },
        },
        testnet: !0,
        chainNamespace: "solana",
        caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      }),
        s({
          id: "000000000019d6689c085ae165831e93",
          caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
          chainNamespace: "bip122",
          name: "Bitcoin",
          nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
        }),
        s({
          id: "000000000933ea01ad0ee984209779ba",
          caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
          chainNamespace: "bip122",
          name: "Bitcoin Testnet",
          nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
          rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
          testnet: !0,
        });
    },
    6434: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => n });
      var i = r(11914),
        s = r(34561);
      async function n(
        e,
        { address: t, blockTag: r = "latest", blockNumber: n }
      ) {
        let a = await e.request(
          {
            method: "eth_getTransactionCount",
            params: [t, n ? (0, s.cK)(n) : r],
          },
          { dedupe: !!n }
        );
        return (0, i.ME)(a);
      }
    },
    6578: (e, t, r) => {
      "use strict";
      r.d(t, { z: () => n });
      var i = r(1220);
      let s = (0, i.BX)({
          loading: !1,
          open: !1,
          selectedNetworkId: void 0,
          activeChain: void 0,
          initialized: !1,
        }),
        n = {
          state: s,
          subscribe: (e) => (0, i.B1)(s, () => e(s)),
          set(e) {
            Object.assign(s, { ...s, ...e });
          },
        };
    },
    7208: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => n });
      var i = r(52436),
        s = r(12115);
      function n(e) {
        let {
            children: t,
            config: r,
            initialState: n,
            reconnectOnMount: a = !0,
          } = e,
          { onMount: o } = (function (e, t) {
            let { initialState: r, reconnectOnMount: s } = t;
            return (
              r &&
                !e._internal.store.persist.hasHydrated() &&
                e.setState({
                  ...r,
                  chainId: e.chains.some((e) => e.id === r.chainId)
                    ? r.chainId
                    : e.chains[0].id,
                  connections: s ? r.connections : new Map(),
                  status: s ? "reconnecting" : "disconnected",
                }),
              {
                async onMount() {
                  e._internal.ssr &&
                    (await e._internal.store.persist.rehydrate(),
                    e._internal.mipd &&
                      e._internal.connectors.setState((t) => {
                        let r = new Set();
                        for (let e of t ?? [])
                          if (e.rdns)
                            for (let t of Array.isArray(e.rdns)
                              ? e.rdns
                              : [e.rdns])
                              r.add(t);
                        let i = [];
                        for (let t of e._internal.mipd?.getProviders() ?? []) {
                          if (r.has(t.info.rdns)) continue;
                          let s =
                              e._internal.connectors.providerDetailToConnector(
                                t
                              ),
                            n = e._internal.connectors.setup(s);
                          i.push(n);
                        }
                        return [...t, ...i];
                      })),
                    s
                      ? (0, i.M)(e)
                      : e.storage &&
                        e.setState((e) => ({ ...e, connections: new Map() }));
                },
              }
            );
          })(r, { initialState: n, reconnectOnMount: a });
        r._internal.ssr || o();
        let c = (0, s.useRef)(!0);
        return (
          (0, s.useEffect)(() => {
            if (c.current && r._internal.ssr)
              return (
                o(),
                () => {
                  c.current = !1;
                }
              );
          }, []),
          t
        );
      }
    },
    8821: (e, t, r) => {
      "use strict";
      r.d(t, { Z: () => i });
      let i = {
        getSpacingStyles: (e, t) =>
          Array.isArray(e)
            ? e[t]
              ? `var(--wui-spacing-${e[t]})`
              : void 0
            : "string" == typeof e
            ? `var(--wui-spacing-${e})`
            : void 0,
        getFormattedDate: (e) =>
          new Intl.DateTimeFormat("en-US", {
            month: "short",
            day: "numeric",
          }).format(e),
        getHostName(e) {
          try {
            return new URL(e).hostname;
          } catch (e) {
            return "";
          }
        },
        getTruncateString: ({
          string: e,
          charsStart: t,
          charsEnd: r,
          truncate: i,
        }) =>
          e.length <= t + r
            ? e
            : "end" === i
            ? `${e.substring(0, t)}...`
            : "start" === i
            ? `...${e.substring(e.length - r)}`
            : `${e.substring(0, Math.floor(t))}...${e.substring(
                e.length - Math.floor(r)
              )}`,
        generateAvatarColors(e) {
          let t = e
              .toLowerCase()
              .replace(/^0x/iu, "")
              .replace(/[^a-f0-9]/gu, "")
              .substring(0, 6)
              .padEnd(6, "0"),
            r = this.hexToRgb(t),
            i = getComputedStyle(document.documentElement).getPropertyValue(
              "--w3m-border-radius-master"
            ),
            s = 100 - 3 * Number(i?.replace("px", "")),
            n = `${s}% ${s}% at 65% 40%`,
            a = [];
          for (let e = 0; e < 5; e += 1) {
            let t = this.tintColor(r, 0.15 * e);
            a.push(`rgb(${t[0]}, ${t[1]}, ${t[2]})`);
          }
          return `
    --local-color-1: ${a[0]};
    --local-color-2: ${a[1]};
    --local-color-3: ${a[2]};
    --local-color-4: ${a[3]};
    --local-color-5: ${a[4]};
    --local-radial-circle: ${n}
   `;
        },
        hexToRgb(e) {
          let t = parseInt(e, 16);
          return [(t >> 16) & 255, (t >> 8) & 255, 255 & t];
        },
        tintColor(e, t) {
          let [r, i, s] = e;
          return [
            Math.round(r + (255 - r) * t),
            Math.round(i + (255 - i) * t),
            Math.round(s + (255 - s) * t),
          ];
        },
        isNumber: (e) => /^[0-9]+$/u.test(e),
        getColorTheme: (e) =>
          e
            ? e
            : "undefined" != typeof window && window.matchMedia
            ? window.matchMedia("(prefers-color-scheme: dark)")?.matches
              ? "dark"
              : "light"
            : "dark",
        splitBalance(e) {
          let t = e.split(".");
          return 2 === t.length ? [t[0], t[1]] : ["0", "00"];
        },
        roundNumber: (e, t, r) =>
          e.toString().length >= t ? Number(e).toFixed(r) : e,
        formatNumberToLocalString: (e, t = 2) =>
          void 0 === e
            ? "0.00"
            : "number" == typeof e
            ? e.toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
              })
            : parseFloat(e).toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
              }),
      };
    },
    10562: (e, t, r) => {
      "use strict";
      var i = r(19670),
        s = r(13798),
        n = r(78239),
        a = n.assert,
        o = n.parseBytes,
        c = r(33869),
        l = r(33372);
      function d(e) {
        if (
          (a("ed25519" === e, "only tested with ed25519 so far"),
          !(this instanceof d))
        )
          return new d(e);
        (e = s[e].curve),
          (this.curve = e),
          (this.g = e.g),
          this.g.precompute(e.n.bitLength() + 1),
          (this.pointClass = e.point().constructor),
          (this.encodingLength = Math.ceil(e.n.bitLength() / 8)),
          (this.hash = i.sha512);
      }
      (e.exports = d),
        (d.prototype.sign = function (e, t) {
          e = o(e);
          var r = this.keyFromSecret(t),
            i = this.hashInt(r.messagePrefix(), e),
            s = this.g.mul(i),
            n = this.encodePoint(s),
            a = this.hashInt(n, r.pubBytes(), e).mul(r.priv()),
            c = i.add(a).umod(this.curve.n);
          return this.makeSignature({ R: s, S: c, Rencoded: n });
        }),
        (d.prototype.verify = function (e, t, r) {
          if (
            ((e = o(e)),
            (t = this.makeSignature(t)).S().gte(t.eddsa.curve.n) ||
              t.S().isNeg())
          )
            return !1;
          var i = this.keyFromPublic(r),
            s = this.hashInt(t.Rencoded(), i.pubBytes(), e),
            n = this.g.mul(t.S());
          return t.R().add(i.pub().mul(s)).eq(n);
        }),
        (d.prototype.hashInt = function () {
          for (var e = this.hash(), t = 0; t < arguments.length; t++)
            e.update(arguments[t]);
          return n.intFromLE(e.digest()).umod(this.curve.n);
        }),
        (d.prototype.keyFromPublic = function (e) {
          return c.fromPublic(this, e);
        }),
        (d.prototype.keyFromSecret = function (e) {
          return c.fromSecret(this, e);
        }),
        (d.prototype.makeSignature = function (e) {
          return e instanceof l ? e : new l(this, e);
        }),
        (d.prototype.encodePoint = function (e) {
          var t = e.getY().toArray("le", this.encodingLength);
          return (t[this.encodingLength - 1] |= 128 * !!e.getX().isOdd()), t;
        }),
        (d.prototype.decodePoint = function (e) {
          var t = (e = n.parseBytes(e)).length - 1,
            r = e.slice(0, t).concat(-129 & e[t]),
            i = (128 & e[t]) != 0,
            s = n.intFromLE(r);
          return this.curve.pointFromY(s, i);
        }),
        (d.prototype.encodeInt = function (e) {
          return e.toArray("le", this.encodingLength);
        }),
        (d.prototype.decodeInt = function (e) {
          return n.intFromLE(e);
        }),
        (d.prototype.isPoint = function (e) {
          return e instanceof this.pointClass;
        });
    },
    10763: (e, t, r) => {
      "use strict";
      r.d(t, { F: () => o }), r(77931);
      var i = r(45553),
        s = r(67243),
        n = r(75578),
        a = r(94842);
      class o {
        constructor({ provider: e, caipNetworks: t, namespace: r }) {
          (this.id = i.o.CONNECTOR_ID.WALLET_CONNECT),
            (this.name =
              n.L.ConnectorNamesMap[i.o.CONNECTOR_ID.WALLET_CONNECT]),
            (this.type = "WALLET_CONNECT"),
            (this.imageId =
              n.L.ConnectorImageIds[i.o.CONNECTOR_ID.WALLET_CONNECT]),
            (this.caipNetworks = t),
            (this.provider = e),
            (this.chain = r);
        }
        get chains() {
          return this.caipNetworks;
        }
        async connectWalletConnect() {
          return (
            (await this.authenticate()) ||
              (await this.provider.connect({
                optionalNamespaces: a.k.createNamespaces(this.caipNetworks),
              })),
            {
              clientId: await this.provider.client.core.crypto.getClientId(),
              session: this.provider.session,
            }
          );
        }
        async disconnect() {
          await this.provider.disconnect();
        }
        async authenticate() {
          let e = this.chains.map((e) => e.caipNetworkId);
          return s.U.universalProviderAuthenticate({
            universalProvider: this.provider,
            chains: e,
            methods: c,
          });
        }
      }
      let c = [
        "eth_accounts",
        "eth_requestAccounts",
        "eth_sendRawTransaction",
        "eth_sign",
        "eth_signTransaction",
        "eth_signTypedData",
        "eth_signTypedData_v3",
        "eth_signTypedData_v4",
        "eth_sendTransaction",
        "personal_sign",
        "wallet_switchEthereumChain",
        "wallet_addEthereumChain",
        "wallet_getPermissions",
        "wallet_requestPermissions",
        "wallet_registerOnboarding",
        "wallet_watchAsset",
        "wallet_scanQRCode",
        "wallet_getCallsStatus",
        "wallet_sendCalls",
        "wallet_getCapabilities",
        "wallet_grantPermissions",
        "wallet_revokePermissions",
        "wallet_getAssets",
      ];
    },
    11870: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          __assign: () => n,
          __asyncDelegator: () => v,
          __asyncGenerator: () => w,
          __asyncValues: () => A,
          __await: () => y,
          __awaiter: () => d,
          __classPrivateFieldGet: () => I,
          __classPrivateFieldSet: () => S,
          __createBinding: () => h,
          __decorate: () => o,
          __exportStar: () => f,
          __extends: () => s,
          __generator: () => u,
          __importDefault: () => C,
          __importStar: () => _,
          __makeTemplateObject: () => E,
          __metadata: () => l,
          __param: () => c,
          __read: () => g,
          __rest: () => a,
          __spread: () => m,
          __spreadArrays: () => b,
          __values: () => p,
        });
      var i = function (e, t) {
        return (i =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (e, t) {
              e.__proto__ = t;
            }) ||
          function (e, t) {
            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]);
          })(e, t);
      };
      function s(e, t) {
        function r() {
          this.constructor = e;
        }
        i(e, t),
          (e.prototype =
            null === t
              ? Object.create(t)
              : ((r.prototype = t.prototype), new r()));
      }
      var n = function () {
        return (n =
          Object.assign ||
          function (e) {
            for (var t, r = 1, i = arguments.length; r < i; r++)
              for (var s in (t = arguments[r]))
                Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
            return e;
          }).apply(this, arguments);
      };
      function a(e, t) {
        var r = {};
        for (var i in e)
          Object.prototype.hasOwnProperty.call(e, i) &&
            0 > t.indexOf(i) &&
            (r[i] = e[i]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols)
          for (
            var s = 0, i = Object.getOwnPropertySymbols(e);
            s < i.length;
            s++
          )
            0 > t.indexOf(i[s]) &&
              Object.prototype.propertyIsEnumerable.call(e, i[s]) &&
              (r[i[s]] = e[i[s]]);
        return r;
      }
      function o(e, t, r, i) {
        var s,
          n = arguments.length,
          a =
            n < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (s = e[o]) &&
              (a = (n < 3 ? s(a) : n > 3 ? s(t, r, a) : s(t, r)) || a);
        return n > 3 && a && Object.defineProperty(t, r, a), a;
      }
      function c(e, t) {
        return function (r, i) {
          t(r, i, e);
        };
      }
      function l(e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
          return Reflect.metadata(e, t);
      }
      function d(e, t, r, i) {
        return new (r || (r = Promise))(function (s, n) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              n(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              n(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? s(e.value)
              : ((t = e.value) instanceof r
                  ? t
                  : new r(function (e) {
                      e(t);
                    })
                ).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      }
      function u(e, t) {
        var r,
          i,
          s,
          n,
          a = {
            label: 0,
            sent: function () {
              if (1 & s[0]) throw s[1];
              return s[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (n = { next: o(0), throw: o(1), return: o(2) }),
          "function" == typeof Symbol &&
            (n[Symbol.iterator] = function () {
              return this;
            }),
          n
        );
        function o(n) {
          return function (o) {
            return (function (n) {
              if (r) throw TypeError("Generator is already executing.");
              for (; a; )
                try {
                  if (
                    ((r = 1),
                    i &&
                      (s =
                        2 & n[0]
                          ? i.return
                          : n[0]
                          ? i.throw || ((s = i.return) && s.call(i), 0)
                          : i.next) &&
                      !(s = s.call(i, n[1])).done)
                  )
                    return s;
                  switch (((i = 0), s && (n = [2 & n[0], s.value]), n[0])) {
                    case 0:
                    case 1:
                      s = n;
                      break;
                    case 4:
                      return a.label++, { value: n[1], done: !1 };
                    case 5:
                      a.label++, (i = n[1]), (n = [0]);
                      continue;
                    case 7:
                      (n = a.ops.pop()), a.trys.pop();
                      continue;
                    default:
                      if (
                        !(s = (s = a.trys).length > 0 && s[s.length - 1]) &&
                        (6 === n[0] || 2 === n[0])
                      ) {
                        a = 0;
                        continue;
                      }
                      if (3 === n[0] && (!s || (n[1] > s[0] && n[1] < s[3]))) {
                        a.label = n[1];
                        break;
                      }
                      if (6 === n[0] && a.label < s[1]) {
                        (a.label = s[1]), (s = n);
                        break;
                      }
                      if (s && a.label < s[2]) {
                        (a.label = s[2]), a.ops.push(n);
                        break;
                      }
                      s[2] && a.ops.pop(), a.trys.pop();
                      continue;
                  }
                  n = t.call(e, a);
                } catch (e) {
                  (n = [6, e]), (i = 0);
                } finally {
                  r = s = 0;
                }
              if (5 & n[0]) throw n[1];
              return { value: n[0] ? n[1] : void 0, done: !0 };
            })([n, o]);
          };
        }
      }
      function h(e, t, r, i) {
        void 0 === i && (i = r), (e[i] = t[r]);
      }
      function f(e, t) {
        for (var r in e)
          "default" === r || t.hasOwnProperty(r) || (t[r] = e[r]);
      }
      function p(e) {
        var t = "function" == typeof Symbol && Symbol.iterator,
          r = t && e[t],
          i = 0;
        if (r) return r.call(e);
        if (e && "number" == typeof e.length)
          return {
            next: function () {
              return (
                e && i >= e.length && (e = void 0),
                { value: e && e[i++], done: !e }
              );
            },
          };
        throw TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      }
      function g(e, t) {
        var r = "function" == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var i,
          s,
          n = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(i = n.next()).done; )
            a.push(i.value);
        } catch (e) {
          s = { error: e };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (s) throw s.error;
          }
        }
        return a;
      }
      function m() {
        for (var e = [], t = 0; t < arguments.length; t++)
          e = e.concat(g(arguments[t]));
        return e;
      }
      function b() {
        for (var e = 0, t = 0, r = arguments.length; t < r; t++)
          e += arguments[t].length;
        for (var i = Array(e), s = 0, t = 0; t < r; t++)
          for (var n = arguments[t], a = 0, o = n.length; a < o; a++, s++)
            i[s] = n[a];
        return i;
      }
      function y(e) {
        return this instanceof y ? ((this.v = e), this) : new y(e);
      }
      function w(e, t, r) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var i,
          s = r.apply(e, t || []),
          n = [];
        return (
          (i = {}),
          a("next"),
          a("throw"),
          a("return"),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i
        );
        function a(e) {
          s[e] &&
            (i[e] = function (t) {
              return new Promise(function (r, i) {
                n.push([e, t, r, i]) > 1 || o(e, t);
              });
            });
        }
        function o(e, t) {
          try {
            var r;
            (r = s[e](t)).value instanceof y
              ? Promise.resolve(r.value.v).then(c, l)
              : d(n[0][2], r);
          } catch (e) {
            d(n[0][3], e);
          }
        }
        function c(e) {
          o("next", e);
        }
        function l(e) {
          o("throw", e);
        }
        function d(e, t) {
          e(t), n.shift(), n.length && o(n[0][0], n[0][1]);
        }
      }
      function v(e) {
        var t, r;
        return (
          (t = {}),
          i("next"),
          i("throw", function (e) {
            throw e;
          }),
          i("return"),
          (t[Symbol.iterator] = function () {
            return this;
          }),
          t
        );
        function i(i, s) {
          t[i] = e[i]
            ? function (t) {
                return (r = !r)
                  ? { value: y(e[i](t)), done: "return" === i }
                  : s
                  ? s(t)
                  : t;
              }
            : s;
        }
      }
      function A(e) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var t,
          r = e[Symbol.asyncIterator];
        return r
          ? r.call(e)
          : ((e = p(e)),
            (t = {}),
            i("next"),
            i("throw"),
            i("return"),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function i(r) {
          t[r] =
            e[r] &&
            function (t) {
              return new Promise(function (i, s) {
                !(function (e, t, r, i) {
                  Promise.resolve(i).then(function (t) {
                    e({ value: t, done: r });
                  }, t);
                })(i, s, (t = e[r](t)).done, t.value);
              });
            };
        }
      }
      function E(e, t) {
        return (
          Object.defineProperty
            ? Object.defineProperty(e, "raw", { value: t })
            : (e.raw = t),
          e
        );
      }
      function _(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var r in e) Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return (t.default = e), t;
      }
      function C(e) {
        return e && e.__esModule ? e : { default: e };
      }
      function I(e, t) {
        if (!t.has(e))
          throw TypeError("attempted to get private field on non-instance");
        return t.get(e);
      }
      function S(e, t, r) {
        if (!t.has(e))
          throw TypeError("attempted to set private field on non-instance");
        return t.set(e, r), r;
      }
    },
    11914: (e, t, r) => {
      "use strict";
      r.d(t, {
        IQ: () => u,
        ME: () => d,
        Nx: () => l,
        Sl: () => o,
        uU: () => c,
      });
      var i = r(35276),
        s = r(16871),
        n = r(42438),
        a = r(55563);
      function o(e, { size: t }) {
        if ((0, s.E)(e) > t)
          throw new i.u({ givenSize: (0, s.E)(e), maxSize: t });
      }
      function c(e, t = {}) {
        let { signed: r } = t;
        t.size && o(e, { size: t.size });
        let i = BigInt(e);
        if (!r) return i;
        let s = (e.length - 2) / 2;
        return i <= (1n << (8n * BigInt(s) - 1n)) - 1n
          ? i
          : i - BigInt(`0x${"f".padStart(2 * s, "f")}`) - 1n;
      }
      function l(e, t = {}) {
        let r = e;
        if (
          (t.size && (o(r, { size: t.size }), (r = (0, n.B)(r))),
          "0x00" === (0, n.B)(r))
        )
          return !1;
        if ("0x01" === (0, n.B)(r)) return !0;
        throw new i.H2(r);
      }
      function d(e, t = {}) {
        return Number(c(e, t));
      }
      function u(e, t = {}) {
        let r = (0, a.aT)(e);
        return (
          t.size &&
            (o(r, { size: t.size }), (r = (0, n.B)(r, { dir: "right" }))),
          new TextDecoder().decode(r)
        );
      }
    },
    12182: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => p });
      var i = "[big.js] ",
        s = i + "Invalid ",
        n = s + "decimal places",
        a = s + "rounding mode",
        o = i + "Division by zero",
        c = {},
        l = void 0,
        d = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
      function u(e, t, r, i) {
        var s = e.c;
        if (
          (r === l && (r = e.constructor.RM),
          0 !== r && 1 !== r && 2 !== r && 3 !== r)
        )
          throw Error(a);
        if (t < 1)
          (i =
            (3 === r && (i || !!s[0])) ||
            (0 === t &&
              ((1 === r && s[0] >= 5) ||
                (2 === r && (s[0] > 5 || (5 === s[0] && (i || s[1] !== l))))))),
            (s.length = 1),
            i ? ((e.e = e.e - t + 1), (s[0] = 1)) : (s[0] = e.e = 0);
        else if (t < s.length) {
          if (
            ((i =
              (1 === r && s[t] >= 5) ||
              (2 === r &&
                (s[t] > 5 ||
                  (5 === s[t] && (i || s[t + 1] !== l || 1 & s[t - 1])))) ||
              (3 === r && (i || !!s[0]))),
            (s.length = t),
            i)
          ) {
            for (; ++s[--t] > 9; )
              if (((s[t] = 0), 0 === t)) {
                ++e.e, s.unshift(1);
                break;
              }
          }
          for (t = s.length; !s[--t]; ) s.pop();
        }
        return e;
      }
      function h(e, t, r) {
        var i = e.e,
          s = e.c.join(""),
          n = s.length;
        if (t)
          s =
            s.charAt(0) +
            (n > 1 ? "." + s.slice(1) : "") +
            (i < 0 ? "e" : "e+") +
            i;
        else if (i < 0) {
          for (; ++i; ) s = "0" + s;
          s = "0." + s;
        } else if (i > 0) {
          if (++i > n) for (i -= n; i--; ) s += "0";
          else i < n && (s = s.slice(0, i) + "." + s.slice(i));
        } else n > 1 && (s = s.charAt(0) + "." + s.slice(1));
        return e.s < 0 && r ? "-" + s : s;
      }
      (c.abs = function () {
        var e = new this.constructor(this);
        return (e.s = 1), e;
      }),
        (c.cmp = function (e) {
          var t,
            r = this.c,
            i = (e = new this.constructor(e)).c,
            s = this.s,
            n = e.s,
            a = this.e,
            o = e.e;
          if (!r[0] || !i[0]) return r[0] ? s : i[0] ? -n : 0;
          if (s != n) return s;
          if (((t = s < 0), a != o)) return (a > o) ^ t ? 1 : -1;
          for (s = -1, n = (a = r.length) < (o = i.length) ? a : o; ++s < n; )
            if (r[s] != i[s]) return (r[s] > i[s]) ^ t ? 1 : -1;
          return a == o ? 0 : (a > o) ^ t ? 1 : -1;
        }),
        (c.div = function (e) {
          var t = this.constructor,
            r = this.c,
            i = (e = new t(e)).c,
            s = this.s == e.s ? 1 : -1,
            a = t.DP;
          if (a !== ~~a || a < 0 || a > 1e6) throw Error(n);
          if (!i[0]) throw Error(o);
          if (!r[0]) return (e.s = s), (e.c = [(e.e = 0)]), e;
          var c,
            d,
            h,
            f,
            p,
            g = i.slice(),
            m = (c = i.length),
            b = r.length,
            y = r.slice(0, c),
            w = y.length,
            v = e,
            A = (v.c = []),
            E = 0,
            _ = a + (v.e = this.e - e.e) + 1;
          for (v.s = s, s = _ < 0 ? 0 : _, g.unshift(0); w++ < c; ) y.push(0);
          do {
            for (h = 0; h < 10; h++) {
              if (c != (w = y.length)) f = c > w ? 1 : -1;
              else
                for (p = -1, f = 0; ++p < c; )
                  if (i[p] != y[p]) {
                    f = i[p] > y[p] ? 1 : -1;
                    break;
                  }
              if (f < 0) {
                for (d = w == c ? i : g; w; ) {
                  if (y[--w] < d[w]) {
                    for (p = w; p && !y[--p]; ) y[p] = 9;
                    --y[p], (y[w] += 10);
                  }
                  y[w] -= d[w];
                }
                for (; !y[0]; ) y.shift();
              } else break;
            }
            (A[E++] = f ? h : ++h),
              y[0] && f ? (y[w] = r[m] || 0) : (y = [r[m]]);
          } while ((m++ < b || y[0] !== l) && s--);
          return (
            !A[0] && 1 != E && (A.shift(), v.e--, _--),
            E > _ && u(v, _, t.RM, y[0] !== l),
            v
          );
        }),
        (c.eq = function (e) {
          return 0 === this.cmp(e);
        }),
        (c.gt = function (e) {
          return this.cmp(e) > 0;
        }),
        (c.gte = function (e) {
          return this.cmp(e) > -1;
        }),
        (c.lt = function (e) {
          return 0 > this.cmp(e);
        }),
        (c.lte = function (e) {
          return 1 > this.cmp(e);
        }),
        (c.minus = c.sub =
          function (e) {
            var t,
              r,
              i,
              s,
              n = this.constructor,
              a = this.s,
              o = (e = new n(e)).s;
            if (a != o) return (e.s = -o), this.plus(e);
            var c = this.c.slice(),
              l = this.e,
              d = e.c,
              u = e.e;
            if (!c[0] || !d[0])
              return (
                d[0] ? (e.s = -o) : c[0] ? (e = new n(this)) : (e.s = 1), e
              );
            if ((a = l - u)) {
              for (
                (s = a < 0) ? ((a = -a), (i = c)) : ((u = l), (i = d)),
                  i.reverse(),
                  o = a;
                o--;

              )
                i.push(0);
              i.reverse();
            } else
              for (
                r = ((s = c.length < d.length) ? c : d).length, a = o = 0;
                o < r;
                o++
              )
                if (c[o] != d[o]) {
                  s = c[o] < d[o];
                  break;
                }
            if (
              (s && ((i = c), (c = d), (d = i), (e.s = -e.s)),
              (o = (r = d.length) - (t = c.length)) > 0)
            )
              for (; o--; ) c[t++] = 0;
            for (o = t; r > a; ) {
              if (c[--r] < d[r]) {
                for (t = r; t && !c[--t]; ) c[t] = 9;
                --c[t], (c[r] += 10);
              }
              c[r] -= d[r];
            }
            for (; 0 === c[--o]; ) c.pop();
            for (; 0 === c[0]; ) c.shift(), --u;
            return (
              c[0] || ((e.s = 1), (c = [(u = 0)])), (e.c = c), (e.e = u), e
            );
          }),
        (c.mod = function (e) {
          var t,
            r = this,
            i = r.constructor,
            s = r.s,
            n = (e = new i(e)).s;
          if (!e.c[0]) throw Error(o);
          return ((r.s = e.s = 1), (t = 1 == e.cmp(r)), (r.s = s), (e.s = n), t)
            ? new i(r)
            : ((s = i.DP),
              (n = i.RM),
              (i.DP = i.RM = 0),
              (r = r.div(e)),
              (i.DP = s),
              (i.RM = n),
              this.minus(r.times(e)));
        }),
        (c.neg = function () {
          var e = new this.constructor(this);
          return (e.s = -e.s), e;
        }),
        (c.plus = c.add =
          function (e) {
            var t,
              r,
              i,
              s = this.constructor;
            if (((e = new s(e)), this.s != e.s))
              return (e.s = -e.s), this.minus(e);
            var n = this.e,
              a = this.c,
              o = e.e,
              c = e.c;
            if (!a[0] || !c[0])
              return c[0] || (a[0] ? (e = new s(this)) : (e.s = this.s)), e;
            if (((a = a.slice()), (t = n - o))) {
              for (
                t > 0 ? ((o = n), (i = c)) : ((t = -t), (i = a)), i.reverse();
                t--;

              )
                i.push(0);
              i.reverse();
            }
            for (
              a.length - c.length < 0 && ((i = c), (c = a), (a = i)),
                t = c.length,
                r = 0;
              t;
              a[t] %= 10
            )
              r = ((a[--t] = a[t] + c[t] + r) / 10) | 0;
            for (r && (a.unshift(r), ++o), t = a.length; 0 === a[--t]; )
              a.pop();
            return (e.c = a), (e.e = o), e;
          }),
        (c.pow = function (e) {
          var t = this,
            r = new t.constructor("1"),
            i = r,
            n = e < 0;
          if (e !== ~~e || e < -1e6 || e > 1e6) throw Error(s + "exponent");
          for (n && (e = -e); 1 & e && (i = i.times(t)), (e >>= 1); )
            t = t.times(t);
          return n ? r.div(i) : i;
        }),
        (c.prec = function (e, t) {
          if (e !== ~~e || e < 1 || e > 1e6) throw Error(s + "precision");
          return u(new this.constructor(this), e, t);
        }),
        (c.round = function (e, t) {
          if (e === l) e = 0;
          else if (e !== ~~e || e < -1e6 || e > 1e6) throw Error(n);
          return u(new this.constructor(this), e + this.e + 1, t);
        }),
        (c.sqrt = function () {
          var e,
            t,
            r,
            s = this.constructor,
            n = this.s,
            a = this.e,
            o = new s("0.5");
          if (!this.c[0]) return new s(this);
          if (n < 0) throw Error(i + "No square root");
          0 === (n = Math.sqrt(+h(this, !0, !0))) || n === 1 / 0
            ? (((t = this.c.join("")).length + a) & 1 || (t += "0"),
              (a = (((a + 1) / 2) | 0) - (a < 0 || 1 & a)),
              (e = new s(
                ((n = Math.sqrt(t)) == 1 / 0
                  ? "5e"
                  : (n = n.toExponential()).slice(0, n.indexOf("e") + 1)) + a
              )))
            : (e = new s(n + "")),
            (a = e.e + (s.DP += 4));
          do (r = e), (e = o.times(r.plus(this.div(r))));
          while (r.c.slice(0, a).join("") !== e.c.slice(0, a).join(""));
          return u(e, (s.DP -= 4) + e.e + 1, s.RM);
        }),
        (c.times = c.mul =
          function (e) {
            var t,
              r = this.constructor,
              i = this.c,
              s = (e = new r(e)).c,
              n = i.length,
              a = s.length,
              o = this.e,
              c = e.e;
            if (((e.s = this.s == e.s ? 1 : -1), !i[0] || !s[0]))
              return (e.c = [(e.e = 0)]), e;
            for (
              e.e = o + c,
                n < a && ((t = i), (i = s), (s = t), (c = n), (n = a), (a = c)),
                t = Array((c = n + a));
              c--;

            )
              t[c] = 0;
            for (o = a; o--; ) {
              for (a = 0, c = n + o; c > o; )
                (a = t[c] + s[o] * i[c - o - 1] + a),
                  (t[c--] = a % 10),
                  (a = (a / 10) | 0);
              t[c] = a;
            }
            for (a ? ++e.e : t.shift(), o = t.length; !t[--o]; ) t.pop();
            return (e.c = t), e;
          }),
        (c.toExponential = function (e, t) {
          var r = this,
            i = r.c[0];
          if (e !== l) {
            if (e !== ~~e || e < 0 || e > 1e6) throw Error(n);
            for (r = u(new r.constructor(r), ++e, t); r.c.length < e; )
              r.c.push(0);
          }
          return h(r, !0, !!i);
        }),
        (c.toFixed = function (e, t) {
          var r = this,
            i = r.c[0];
          if (e !== l) {
            if (e !== ~~e || e < 0 || e > 1e6) throw Error(n);
            for (
              r = u(new r.constructor(r), e + r.e + 1, t), e = e + r.e + 1;
              r.c.length < e;

            )
              r.c.push(0);
          }
          return h(r, !1, !!i);
        }),
        (c[Symbol.for("nodejs.util.inspect.custom")] =
          c.toJSON =
          c.toString =
            function () {
              var e = this.constructor;
              return h(this, this.e <= e.NE || this.e >= e.PE, !!this.c[0]);
            }),
        (c.toNumber = function () {
          var e = +h(this, !0, !0);
          if (!0 === this.constructor.strict && !this.eq(e.toString()))
            throw Error(i + "Imprecise conversion");
          return e;
        }),
        (c.toPrecision = function (e, t) {
          var r = this,
            i = r.constructor,
            n = r.c[0];
          if (e !== l) {
            if (e !== ~~e || e < 1 || e > 1e6) throw Error(s + "precision");
            for (r = u(new i(r), e, t); r.c.length < e; ) r.c.push(0);
          }
          return h(r, e <= r.e || r.e <= i.NE || r.e >= i.PE, !!n);
        }),
        (c.valueOf = function () {
          var e = this.constructor;
          if (!0 === e.strict) throw Error(i + "valueOf disallowed");
          return h(this, this.e <= e.NE || this.e >= e.PE, !0);
        });
      var f = (function e() {
        function t(r) {
          if (!(this instanceof t)) return r === l ? e() : new t(r);
          if (r instanceof t)
            (this.s = r.s), (this.e = r.e), (this.c = r.c.slice());
          else {
            if ("string" != typeof r) {
              if (!0 === t.strict && "bigint" != typeof r)
                throw TypeError(s + "value");
              r = 0 === r && 1 / r < 0 ? "-0" : String(r);
            }
            !(function (e, t) {
              var r, i, n;
              if (!d.test(t)) throw Error(s + "number");
              for (
                e.s = "-" == t.charAt(0) ? ((t = t.slice(1)), -1) : 1,
                  (r = t.indexOf(".")) > -1 && (t = t.replace(".", "")),
                  (i = t.search(/e/i)) > 0
                    ? (r < 0 && (r = i),
                      (r += +t.slice(i + 1)),
                      (t = t.substring(0, i)))
                    : r < 0 && (r = t.length),
                  n = t.length,
                  i = 0;
                i < n && "0" == t.charAt(i);

              )
                ++i;
              if (i == n) e.c = [(e.e = 0)];
              else {
                for (; n > 0 && "0" == t.charAt(--n); );
                for (e.e = r - i - 1, e.c = [], r = 0; i <= n; )
                  e.c[r++] = +t.charAt(i++);
              }
            })(this, r);
          }
          this.constructor = t;
        }
        return (
          (t.prototype = c),
          (t.DP = 20),
          (t.RM = 1),
          (t.NE = -7),
          (t.PE = 21),
          (t.strict = !1),
          (t.roundDown = 0),
          (t.roundHalfUp = 1),
          (t.roundHalfEven = 2),
          (t.roundUp = 3),
          t
        );
      })();
      let p = {
        bigNumber: (e) => new f(e ? e : 0),
        multiply(e, t) {
          if (void 0 === e || void 0 === t) return new f(0);
          let r = new f(e),
            i = new f(t);
          return r.times(i);
        },
        formatNumberToLocalString: (e, t = 2) =>
          void 0 === e
            ? "0.00"
            : "number" == typeof e
            ? e.toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
              })
            : parseFloat(e).toLocaleString("en-US", {
                maximumFractionDigits: t,
                minimumFractionDigits: t,
              }),
        parseLocalStringToNumber: (e) =>
          void 0 === e ? 0 : parseFloat(e.replace(/,/gu, "")),
      };
    },
    12232: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => l });
      var i = r(36117),
        s = r(34430),
        n = r(44839),
        a = r(18085);
      i.extend(n), i.extend(a);
      let o = {
          ...s,
          name: "en-web3-modal",
          relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "%d sec",
            m: "1 min",
            mm: "%d min",
            h: "1 hr",
            hh: "%d hrs",
            d: "1 d",
            dd: "%d d",
            M: "1 mo",
            MM: "%d mo",
            y: "1 yr",
            yy: "%d yr",
          },
        },
        c = [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December",
        ];
      i.locale("en-web3-modal", o);
      let l = {
        getMonthNameByIndex: (e) => c[e],
        getYear: (e = new Date().toISOString()) => i(e).year(),
        getRelativeDateFromNow: (e) => i(e).locale("en-web3-modal").fromNow(!0),
        formatDate: (e, t = "DD MMM") => i(e).format(t),
      };
    },
    12319: (e, t, r) => {
      "use strict";
      r.d(t, { w: () => a });
      var i = r(45553),
        s = r(28977),
        n = r(58653);
      let a = {
        isMobile() {
          return (
            !!this.isClient() &&
            !!(
              window?.matchMedia("(pointer:coarse)")?.matches ||
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(
                navigator.userAgent
              )
            )
          );
        },
        checkCaipNetwork: (e, t = "") =>
          e?.caipNetworkId.toLocaleLowerCase().includes(t.toLowerCase()),
        isAndroid() {
          if (!this.isMobile()) return !1;
          let e = window?.navigator.userAgent.toLowerCase();
          return a.isMobile() && e.includes("android");
        },
        isIos() {
          if (!this.isMobile()) return !1;
          let e = window?.navigator.userAgent.toLowerCase();
          return e.includes("iphone") || e.includes("ipad");
        },
        isSafari() {
          return (
            !!this.isClient() &&
            window?.navigator.userAgent.toLowerCase().includes("safari")
          );
        },
        isClient: () => "undefined" != typeof window,
        isPairingExpired: (e) => !e || e - Date.now() <= s.oU.TEN_SEC_MS,
        isAllowedRetry: (e, t = s.oU.ONE_SEC_MS) => Date.now() - e >= t,
        copyToClopboard(e) {
          navigator.clipboard.writeText(e);
        },
        isIframe() {
          try {
            return window?.self !== window?.top;
          } catch (e) {
            return !1;
          }
        },
        getPairingExpiry: () => Date.now() + s.oU.FOUR_MINUTES_MS,
        getNetworkId: (e) => e?.split(":")[1],
        getPlainAddress: (e) => e?.split(":")[2],
        wait: async (e) =>
          new Promise((t) => {
            setTimeout(t, e);
          }),
        debounce(e, t = 500) {
          let r;
          return (...i) => {
            r && clearTimeout(r),
              (r = setTimeout(function () {
                e(...i);
              }, t));
          };
        },
        isHttpUrl: (e) => e.startsWith("http://") || e.startsWith("https://"),
        formatNativeUrl(e, t) {
          if (a.isHttpUrl(e)) return this.formatUniversalUrl(e, t);
          let r = e;
          r.includes("://") ||
            ((r = e.replaceAll("/", "").replaceAll(":", "")), (r = `${r}://`)),
            r.endsWith("/") || (r = `${r}/`),
            this.isTelegram() &&
              this.isAndroid() &&
              (t = encodeURIComponent(t));
          let i = encodeURIComponent(t);
          return { redirect: `${r}wc?uri=${i}`, href: r };
        },
        formatUniversalUrl(e, t) {
          if (!a.isHttpUrl(e)) return this.formatNativeUrl(e, t);
          let r = e;
          r.endsWith("/") || (r = `${r}/`);
          let i = encodeURIComponent(t);
          return { redirect: `${r}wc?uri=${i}`, href: r };
        },
        getOpenTargetForPlatform(e) {
          return "popupWindow" === e
            ? e
            : this.isTelegram()
            ? n.i.getTelegramSocialProvider()
              ? "_top"
              : "_blank"
            : e;
        },
        openHref(e, t, r) {
          window?.open(
            e,
            this.getOpenTargetForPlatform(t),
            r || "noreferrer noopener"
          );
        },
        returnOpenHref(e, t, r) {
          return window?.open(
            e,
            this.getOpenTargetForPlatform(t),
            r || "noreferrer noopener"
          );
        },
        isTelegram: () =>
          "undefined" != typeof window &&
          (!!window.TelegramWebviewProxy ||
            !!window.Telegram ||
            !!window.TelegramWebviewProxyProto),
        preloadImage: async (e) =>
          Promise.race([
            new Promise((t, r) => {
              let i = new Image();
              (i.onload = t),
                (i.onerror = r),
                (i.crossOrigin = "anonymous"),
                (i.src = e);
            }),
            a.wait(2e3),
          ]),
        formatBalance(e, t) {
          let r = "0.000";
          if ("string" == typeof e) {
            let t = Number(e);
            if (t) {
              let e = Math.floor(1e3 * t) / 1e3;
              e && (r = e.toString());
            }
          }
          return `${r}${t ? ` ${t}` : ""}`;
        },
        formatBalance2(e, t) {
          let r;
          if ("0" === e) r = "0";
          else if ("string" == typeof e) {
            let t = Number(e);
            t && (r = t.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0]);
          }
          return { value: r ?? "0", rest: "0" === r ? "000" : "", symbol: t };
        },
        getApiUrl: () => i.o.W3M_API_URL,
        getBlockchainApiUrl: () => i.o.BLOCKCHAIN_API_RPC_URL,
        getAnalyticsUrl: () => i.o.PULSE_API_URL,
        getUUID: () =>
          crypto?.randomUUID
            ? crypto.randomUUID()
            : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
                let t = (16 * Math.random()) | 0;
                return ("x" === e ? t : (3 & t) | 8).toString(16);
              }),
        parseError: (e) =>
          "string" == typeof e
            ? e
            : "string" == typeof e?.issues?.[0]?.message
            ? e.issues[0].message
            : e instanceof Error
            ? e.message
            : "Unknown error",
        sortRequestedNetworks(e, t = []) {
          let r = {};
          return (
            t &&
              e &&
              (e.forEach((e, t) => {
                r[e] = t;
              }),
              t.sort((e, t) => {
                let i = r[e.id],
                  s = r[t.id];
                return void 0 !== i && void 0 !== s
                  ? i - s
                  : void 0 !== i
                  ? -1
                  : +(void 0 !== s);
              })),
            t
          );
        },
        calculateBalance(e) {
          let t = 0;
          for (let r of e) t += r.value ?? 0;
          return t;
        },
        formatTokenBalance(e) {
          let [t, r] = e.toFixed(2).split(".");
          return { dollars: t, pennies: r };
        },
        isAddress(e, t = "eip155") {
          switch (t) {
            case "eip155":
              if (
                /^(?:0x)?[0-9a-f]{40}$/iu.test(e) &&
                (/^(?:0x)?[0-9a-f]{40}$/iu.test(e) ||
                  /^(?:0x)?[0-9A-F]{40}$/iu.test(e))
              )
                return !0;
              return !1;
            case "solana":
              return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(e);
            default:
              return !1;
          }
        },
        uniqueBy(e, t) {
          let r = new Set();
          return e.filter((e) => {
            let i = e[t];
            return !r.has(i) && (r.add(i), !0);
          });
        },
        generateSdkVersion(e, t, r) {
          let i =
            0 === e.length
              ? s.oU.ADAPTER_TYPES.UNIVERSAL
              : e.map((e) => e.adapterType).join(",");
          return `${t}-${i}-${r}`;
        },
        createAccount: (e, t, r, i, s) => ({
          namespace: e,
          address: t,
          type: r,
          publicKey: i,
          path: s,
        }),
        isCaipAddress(e) {
          if ("string" != typeof e) return !1;
          let t = e.split(":"),
            r = t[0];
          return 3 === t.filter(Boolean).length && r in i.o.CHAIN_NAME_MAP;
        },
        isMac() {
          let e = window?.navigator.userAgent.toLowerCase();
          return e.includes("macintosh") && !e.includes("safari");
        },
        formatTelegramSocialLoginUrl(e) {
          let t = `--${encodeURIComponent(window?.location.href)}`,
            r = "state=";
          if ("auth.magic.link" === new URL(e).host) {
            let i = "provider_authorization_url=",
              s = e.substring(e.indexOf(i) + i.length),
              n = this.injectIntoUrl(decodeURIComponent(s), r, t);
            return e.replace(s, encodeURIComponent(n));
          }
          return this.injectIntoUrl(e, r, t);
        },
        injectIntoUrl(e, t, r) {
          let i = e.indexOf(t);
          if (-1 === i)
            throw Error(`${t} parameter not found in the URL: ${e}`);
          let s = e.indexOf("&", i),
            n = t.length,
            a = -1 !== s ? s : e.length,
            o = e.substring(0, i + n),
            c = e.substring(i + n, a);
          return o + (c + r) + e.substring(s);
        },
      };
    },
    12590: (e, t, r) => {
      "use strict";
      r.r(t),
        r.d(t, {
          __assign: () => n,
          __asyncDelegator: () => v,
          __asyncGenerator: () => w,
          __asyncValues: () => A,
          __await: () => y,
          __awaiter: () => d,
          __classPrivateFieldGet: () => I,
          __classPrivateFieldSet: () => S,
          __createBinding: () => h,
          __decorate: () => o,
          __exportStar: () => f,
          __extends: () => s,
          __generator: () => u,
          __importDefault: () => C,
          __importStar: () => _,
          __makeTemplateObject: () => E,
          __metadata: () => l,
          __param: () => c,
          __read: () => g,
          __rest: () => a,
          __spread: () => m,
          __spreadArrays: () => b,
          __values: () => p,
        });
      var i = function (e, t) {
        return (i =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (e, t) {
              e.__proto__ = t;
            }) ||
          function (e, t) {
            for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]);
          })(e, t);
      };
      function s(e, t) {
        function r() {
          this.constructor = e;
        }
        i(e, t),
          (e.prototype =
            null === t
              ? Object.create(t)
              : ((r.prototype = t.prototype), new r()));
      }
      var n = function () {
        return (n =
          Object.assign ||
          function (e) {
            for (var t, r = 1, i = arguments.length; r < i; r++)
              for (var s in (t = arguments[r]))
                Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
            return e;
          }).apply(this, arguments);
      };
      function a(e, t) {
        var r = {};
        for (var i in e)
          Object.prototype.hasOwnProperty.call(e, i) &&
            0 > t.indexOf(i) &&
            (r[i] = e[i]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols)
          for (
            var s = 0, i = Object.getOwnPropertySymbols(e);
            s < i.length;
            s++
          )
            0 > t.indexOf(i[s]) &&
              Object.prototype.propertyIsEnumerable.call(e, i[s]) &&
              (r[i[s]] = e[i[s]]);
        return r;
      }
      function o(e, t, r, i) {
        var s,
          n = arguments.length,
          a =
            n < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (s = e[o]) &&
              (a = (n < 3 ? s(a) : n > 3 ? s(t, r, a) : s(t, r)) || a);
        return n > 3 && a && Object.defineProperty(t, r, a), a;
      }
      function c(e, t) {
        return function (r, i) {
          t(r, i, e);
        };
      }
      function l(e, t) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
          return Reflect.metadata(e, t);
      }
      function d(e, t, r, i) {
        return new (r || (r = Promise))(function (s, n) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              n(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              n(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? s(e.value)
              : ((t = e.value) instanceof r
                  ? t
                  : new r(function (e) {
                      e(t);
                    })
                ).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      }
      function u(e, t) {
        var r,
          i,
          s,
          n,
          a = {
            label: 0,
            sent: function () {
              if (1 & s[0]) throw s[1];
              return s[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (n = { next: o(0), throw: o(1), return: o(2) }),
          "function" == typeof Symbol &&
            (n[Symbol.iterator] = function () {
              return this;
            }),
          n
        );
        function o(n) {
          return function (o) {
            return (function (n) {
              if (r) throw TypeError("Generator is already executing.");
              for (; a; )
                try {
                  if (
                    ((r = 1),
                    i &&
                      (s =
                        2 & n[0]
                          ? i.return
                          : n[0]
                          ? i.throw || ((s = i.return) && s.call(i), 0)
                          : i.next) &&
                      !(s = s.call(i, n[1])).done)
                  )
                    return s;
                  switch (((i = 0), s && (n = [2 & n[0], s.value]), n[0])) {
                    case 0:
                    case 1:
                      s = n;
                      break;
                    case 4:
                      return a.label++, { value: n[1], done: !1 };
                    case 5:
                      a.label++, (i = n[1]), (n = [0]);
                      continue;
                    case 7:
                      (n = a.ops.pop()), a.trys.pop();
                      continue;
                    default:
                      if (
                        !(s = (s = a.trys).length > 0 && s[s.length - 1]) &&
                        (6 === n[0] || 2 === n[0])
                      ) {
                        a = 0;
                        continue;
                      }
                      if (3 === n[0] && (!s || (n[1] > s[0] && n[1] < s[3]))) {
                        a.label = n[1];
                        break;
                      }
                      if (6 === n[0] && a.label < s[1]) {
                        (a.label = s[1]), (s = n);
                        break;
                      }
                      if (s && a.label < s[2]) {
                        (a.label = s[2]), a.ops.push(n);
                        break;
                      }
                      s[2] && a.ops.pop(), a.trys.pop();
                      continue;
                  }
                  n = t.call(e, a);
                } catch (e) {
                  (n = [6, e]), (i = 0);
                } finally {
                  r = s = 0;
                }
              if (5 & n[0]) throw n[1];
              return { value: n[0] ? n[1] : void 0, done: !0 };
            })([n, o]);
          };
        }
      }
      function h(e, t, r, i) {
        void 0 === i && (i = r), (e[i] = t[r]);
      }
      function f(e, t) {
        for (var r in e)
          "default" === r || t.hasOwnProperty(r) || (t[r] = e[r]);
      }
      function p(e) {
        var t = "function" == typeof Symbol && Symbol.iterator,
          r = t && e[t],
          i = 0;
        if (r) return r.call(e);
        if (e && "number" == typeof e.length)
          return {
            next: function () {
              return (
                e && i >= e.length && (e = void 0),
                { value: e && e[i++], done: !e }
              );
            },
          };
        throw TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      }
      function g(e, t) {
        var r = "function" == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var i,
          s,
          n = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(i = n.next()).done; )
            a.push(i.value);
        } catch (e) {
          s = { error: e };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (s) throw s.error;
          }
        }
        return a;
      }
      function m() {
        for (var e = [], t = 0; t < arguments.length; t++)
          e = e.concat(g(arguments[t]));
        return e;
      }
      function b() {
        for (var e = 0, t = 0, r = arguments.length; t < r; t++)
          e += arguments[t].length;
        for (var i = Array(e), s = 0, t = 0; t < r; t++)
          for (var n = arguments[t], a = 0, o = n.length; a < o; a++, s++)
            i[s] = n[a];
        return i;
      }
      function y(e) {
        return this instanceof y ? ((this.v = e), this) : new y(e);
      }
      function w(e, t, r) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var i,
          s = r.apply(e, t || []),
          n = [];
        return (
          (i = {}),
          a("next"),
          a("throw"),
          a("return"),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i
        );
        function a(e) {
          s[e] &&
            (i[e] = function (t) {
              return new Promise(function (r, i) {
                n.push([e, t, r, i]) > 1 || o(e, t);
              });
            });
        }
        function o(e, t) {
          try {
            var r;
            (r = s[e](t)).value instanceof y
              ? Promise.resolve(r.value.v).then(c, l)
              : d(n[0][2], r);
          } catch (e) {
            d(n[0][3], e);
          }
        }
        function c(e) {
          o("next", e);
        }
        function l(e) {
          o("throw", e);
        }
        function d(e, t) {
          e(t), n.shift(), n.length && o(n[0][0], n[0][1]);
        }
      }
      function v(e) {
        var t, r;
        return (
          (t = {}),
          i("next"),
          i("throw", function (e) {
            throw e;
          }),
          i("return"),
          (t[Symbol.iterator] = function () {
            return this;
          }),
          t
        );
        function i(i, s) {
          t[i] = e[i]
            ? function (t) {
                return (r = !r)
                  ? { value: y(e[i](t)), done: "return" === i }
                  : s
                  ? s(t)
                  : t;
              }
            : s;
        }
      }
      function A(e) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var t,
          r = e[Symbol.asyncIterator];
        return r
          ? r.call(e)
          : ((e = p(e)),
            (t = {}),
            i("next"),
            i("throw"),
            i("return"),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function i(r) {
          t[r] =
            e[r] &&
            function (t) {
              return new Promise(function (i, s) {
                !(function (e, t, r, i) {
                  Promise.resolve(i).then(function (t) {
                    e({ value: t, done: r });
                  }, t);
                })(i, s, (t = e[r](t)).done, t.value);
              });
            };
        }
      }
      function E(e, t) {
        return (
          Object.defineProperty
            ? Object.defineProperty(e, "raw", { value: t })
            : (e.raw = t),
          e
        );
      }
      function _(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var r in e) Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return (t.default = e), t;
      }
      function C(e) {
        return e && e.__esModule ? e : { default: e };
      }
      function I(e, t) {
        if (!t.has(e))
          throw TypeError("attempted to get private field on non-instance");
        return t.get(e);
      }
      function S(e, t, r) {
        if (!t.has(e))
          throw TypeError("attempted to set private field on non-instance");
        return t.set(e, r), r;
      }
    },
    13798: (e, t, r) => {
      "use strict";
      var i,
        s = r(19670),
        n = r(23750),
        a = r(78239).assert;
      function o(e) {
        "short" === e.type
          ? (this.curve = new n.short(e))
          : "edwards" === e.type
          ? (this.curve = new n.edwards(e))
          : (this.curve = new n.mont(e)),
          (this.g = this.curve.g),
          (this.n = this.curve.n),
          (this.hash = e.hash),
          a(this.g.validate(), "Invalid curve"),
          a(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      function c(e, r) {
        Object.defineProperty(t, e, {
          configurable: !0,
          enumerable: !0,
          get: function () {
            var i = new o(r);
            return (
              Object.defineProperty(t, e, {
                configurable: !0,
                enumerable: !0,
                value: i,
              }),
              i
            );
          },
        });
      }
      (t.PresetCurve = o),
        c("p192", {
          type: "short",
          prime: "p192",
          p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
          a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
          b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
          n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
          hash: s.sha256,
          gRed: !1,
          g: [
            "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
            "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811",
          ],
        }),
        c("p224", {
          type: "short",
          prime: "p224",
          p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
          a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
          b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
          n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
          hash: s.sha256,
          gRed: !1,
          g: [
            "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
            "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34",
          ],
        }),
        c("p256", {
          type: "short",
          prime: null,
          p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
          a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
          b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
          n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
          hash: s.sha256,
          gRed: !1,
          g: [
            "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
            "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5",
          ],
        }),
        c("p384", {
          type: "short",
          prime: null,
          p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
          a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
          b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
          n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
          hash: s.sha384,
          gRed: !1,
          g: [
            "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
            "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f",
          ],
        }),
        c("p521", {
          type: "short",
          prime: null,
          p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
          a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
          b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
          n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
          hash: s.sha512,
          gRed: !1,
          g: [
            "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
            "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650",
          ],
        }),
        c("curve25519", {
          type: "mont",
          prime: "p25519",
          p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
          a: "76d06",
          b: "1",
          n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
          hash: s.sha256,
          gRed: !1,
          g: ["9"],
        }),
        c("ed25519", {
          type: "edwards",
          prime: "p25519",
          p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
          a: "-1",
          c: "1",
          d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
          n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
          hash: s.sha256,
          gRed: !1,
          g: [
            "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
            "6666666666666666666666666666666666666666666666666666666666666658",
          ],
        });
      try {
        i = r(97919);
      } catch (e) {
        i = void 0;
      }
      c("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: s.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda:
          "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3",
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15",
          },
        ],
        gRed: !1,
        g: [
          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
          i,
        ],
      });
    },
    13933: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => n });
      let i = "2.23.9",
        s = {
          getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: r }) =>
            t ? `${e ?? "https://viem.sh"}${t}${r ? `#${r}` : ""}` : void 0,
          version: `viem@${i}`,
        };
      class n extends Error {
        constructor(e, t = {}) {
          let r =
              t.cause instanceof n
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            a = (t.cause instanceof n && t.cause.docsPath) || t.docsPath,
            o = s.getDocsUrl?.({ ...t, docsPath: a });
          super(
            [
              e || "An error occurred.",
              "",
              ...(t.metaMessages ? [...t.metaMessages, ""] : []),
              ...(o ? [`Docs: ${o}`] : []),
              ...(r ? [`Details: ${r}`] : []),
              ...(s.version ? [`Version: ${s.version}`] : []),
            ].join("\n"),
            t.cause ? { cause: t.cause } : void 0
          ),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "version", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "BaseError",
            }),
            (this.details = r),
            (this.docsPath = a),
            (this.metaMessages = t.metaMessages),
            (this.name = t.name ?? this.name),
            (this.shortMessage = e),
            (this.version = i);
        }
        walk(e) {
          return (function e(t, r) {
            return r?.(t)
              ? t
              : t && "object" == typeof t && "cause" in t && void 0 !== t.cause
              ? e(t.cause, r)
              : r
              ? null
              : t;
          })(this, e);
        }
      }
    },
    14027: (e, t, r) => {
      "use strict";
      let i, s, n, a, o, c, l, d, u, h, f, p, g, m, b, y;
      r.d(t, { S8: () => Y });
      let w = new Map([
        [8217, "apostrophe"],
        [8260, "fraction slash"],
        [12539, "middle dot"],
      ]);
      function v(e) {
        var t;
        let r;
        return (
          (t = (function (e) {
            let t = 0;
            function r() {
              return (e[t++] << 8) | e[t++];
            }
            let i = r(),
              s = 1,
              n = [0, 1];
            for (let e = 1; e < i; e++) n.push((s += r()));
            let a = r(),
              o = t;
            t += a;
            let c = 0,
              l = 0;
            function d() {
              return (
                0 == c && ((l = (l << 8) | e[t++]), (c = 8)), (l >> --c) & 1
              );
            }
            let u = 0x80000000 - 1,
              h = 0;
            for (let e = 0; e < 31; e++) h = (h << 1) | d();
            let f = [],
              p = 0,
              g = 0x80000000;
            for (;;) {
              let e = Math.floor(((h - p + 1) * s - 1) / g),
                t = 0,
                r = i;
              for (; r - t > 1; ) {
                let i = (t + r) >>> 1;
                e < n[i] ? (r = i) : (t = i);
              }
              if (0 == t) break;
              f.push(t);
              let a = p + Math.floor((g * n[t]) / s),
                o = p + Math.floor((g * n[t + 1]) / s) - 1;
              for (; ((a ^ o) & 0x40000000) == 0; )
                (h = ((h << 1) & u) | d()),
                  (a = (a << 1) & u),
                  (o = ((o << 1) & u) | 1);
              for (; a & ~o & 0x20000000; )
                (h = (0x40000000 & h) | ((h << 1) & (u >>> 1)) | d()),
                  (a = (a << 1) ^ 0x40000000),
                  (o = ((0x40000000 ^ o) << 1) | 0x40000001);
              (p = a), (g = 1 + o - a);
            }
            let m = i - 4;
            return f.map((t) => {
              switch (t - m) {
                case 3:
                  return m + 65792 + ((e[o++] << 16) | (e[o++] << 8) | e[o++]);
                case 2:
                  return m + 256 + ((e[o++] << 8) | e[o++]);
                case 1:
                  return m + e[o++];
                default:
                  return t - 1;
              }
            });
          })(
            (function (e) {
              let t = [];
              [
                ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
              ].forEach((e, r) => (t[e.charCodeAt(0)] = r));
              let r = e.length,
                i = new Uint8Array((6 * r) >> 3);
              for (let s = 0, n = 0, a = 0, o = 0; s < r; s++)
                (o = (o << 6) | t[e.charCodeAt(s)]),
                  (a += 6) >= 8 && (i[n++] = o >> (a -= 8));
              return i;
            })(e)
          )),
          (r = 0),
          () => t[r++]
        );
      }
      function A(e, t = 0) {
        let r = [];
        for (;;) {
          let i = e(),
            s = e();
          if (!s) break;
          t += i;
          for (let e = 0; e < s; e++) r.push(t + e);
          t += s + 1;
        }
        return r;
      }
      function E(e) {
        return C(() => {
          let t = A(e);
          if (t.length) return t;
        });
      }
      function _(e) {
        let t = [];
        for (;;) {
          let r = e();
          if (0 == r) break;
          t.push(
            (function (e, t) {
              let r = 1 + t(),
                i = t(),
                s = C(t);
              return I(s.length, 1 + e, t).flatMap((e, t) => {
                let [n, ...a] = e;
                return Array(s[t])
                  .fill()
                  .map((e, t) => {
                    let s = t * i;
                    return [n + t * r, a.map((e) => e + s)];
                  });
              });
            })(r, e)
          );
        }
        for (;;) {
          var r, i;
          let s = e() - 1;
          if (s < 0) break;
          t.push(
            ((r = s), I(1 + (i = e)(), 1 + r, i).map((e) => [e[0], e.slice(1)]))
          );
        }
        return t.flat();
      }
      function C(e) {
        let t = [];
        for (;;) {
          let r = e(t.length);
          if (!r) break;
          t.push(r);
        }
        return t;
      }
      function I(e, t, r) {
        let i = Array(e)
          .fill()
          .map(() => []);
        for (let s = 0; s < t; s++)
          (function (e, t) {
            let r = Array(e);
            for (let s = 0, n = 0; s < e; s++) {
              var i;
              r[s] = n += 1 & (i = t()) ? ~i >> 1 : i >> 1;
            }
            return r;
          })(e, r).forEach((e, t) => i[t].push(e));
        return i;
      }
      function S(e) {
        return `{${e.toString(16).toUpperCase().padStart(2, "0")}}`;
      }
      function x(e) {
        let t = e.length;
        if (t < 4096) return String.fromCodePoint(...e);
        let r = [];
        for (let i = 0; i < t; )
          r.push(String.fromCodePoint(...e.slice(i, (i += 4096))));
        return r.join("");
      }
      function N(e, t) {
        let r = e.length,
          i = r - t.length;
        for (let s = 0; 0 == i && s < r; s++) i = e[s] - t[s];
        return i;
      }
      let T = 55204;
      function P(e) {
        return (e >> 24) & 255;
      }
      function O(e) {
        return 0xffffff & e;
      }
      function k(e) {
        return e >= 44032 && e < T;
      }
      function R(e) {
        i ||
          (function () {
            let e = v(
              "AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA"
            );
            for (let [t, r] of ((i = new Map(
              E(e).flatMap((e, t) => e.map((e) => [e, (t + 1) << 24]))
            )),
            (s = new Set(A(e))),
            (n = new Map()),
            (a = new Map()),
            _(e))) {
              if (!s.has(t) && 2 == r.length) {
                let [e, i] = r,
                  s = a.get(e);
                s || ((s = new Map()), a.set(e, s)), s.set(i, t);
              }
              n.set(t, r.reverse());
            }
          })();
        let t = [],
          r = [],
          o = !1;
        function c(e) {
          let r = i.get(e);
          r && ((o = !0), (e |= r)), t.push(e);
        }
        for (let i of e)
          for (;;) {
            if (i < 128) t.push(i);
            else if (k(i)) {
              let e = i - 44032,
                t = (e / 588) | 0,
                r = ((e % 588) / 28) | 0,
                s = e % 28;
              c(4352 + t), c(4449 + r), s > 0 && c(4519 + s);
            } else {
              let e = n.get(i);
              e ? r.push(...e) : c(i);
            }
            if (!r.length) break;
            i = r.pop();
          }
        if (o && t.length > 1) {
          let e = P(t[0]);
          for (let r = 1; r < t.length; r++) {
            let i = P(t[r]);
            if (0 == i || e <= i) {
              e = i;
              continue;
            }
            let s = r - 1;
            for (;;) {
              let r = t[s + 1];
              if (((t[s + 1] = t[s]), (t[s] = r), !s || (e = P(t[--s])) <= i))
                break;
            }
            e = P(t[r]);
          }
        }
        return t;
      }
      function D(e) {
        return R(e).map(O);
      }
      function M(e) {
        return (function (e) {
          let t = [],
            r = [],
            i = -1,
            s = 0;
          for (let n of e) {
            let e = P(n),
              o = O(n);
            if (-1 == i) 0 == e ? (i = o) : t.push(o);
            else if (s > 0 && s >= e)
              0 == e ? (t.push(i, ...r), (r.length = 0), (i = o)) : r.push(o),
                (s = e);
            else {
              let n = (function (e, t) {
                if (e >= 4352 && e < 4371 && t >= 4449 && t < 4470)
                  return 44032 + (e - 4352) * 588 + (t - 4449) * 28;
                if (k(e) && t > 4519 && t < 4547 && (e - 44032) % 28 == 0)
                  return e + (t - 4519);
                {
                  let r = a.get(e);
                  return r && (r = r.get(t)) ? r : -1;
                }
              })(i, o);
              n >= 0
                ? (i = n)
                : 0 == s && 0 == e
                ? (t.push(i), (i = o))
                : (r.push(o), (s = e));
            }
          }
          return i >= 0 && t.push(i, ...r), t;
        })(R(e));
      }
      let U = (e) => Array.from(e);
      function L(e, t) {
        return e.P.has(t) || e.Q.has(t);
      }
      class B extends Array {
        get is_emoji() {
          return !0;
        }
      }
      function j() {
        let e, t;
        if (o) return;
        let r = v(
            "AEkU4AngDVgB0QKRAQYBOwDqATEAnwDbAIUApABsAOAAbwCRAEYAiQBPAHYAPgA+ACsANwAlAGMAHwAvACsAJQAWAC8AGwAiACIALwAUACsAEQAiAAsAGwARABcAGAA6ACkALAAsADUAFgAsABEAHQAhAA8AGwAdABUAFgAZAA0ADQAXABAAGQAUABIEqgYJAR4UFjfDBdMAsQCuPwFnAKUBA10jAK5/Ly8vLwE/pwUJ6/0HPwbkMQVXBVgAPSs5APa2EQbIwQuUCkEDyJ4zAsUKLwKOoQKG2D+Ob4kCxcsCg/IBH98JAPKtAUECLY0KP48A4wDiChUAF9S5yAwLPZ0EG3cA/QI5GL0P6wkGKekFBIFnDRsHLQCrAGmR76WcfwBbBpMjBukAGwA7DJMAWxVbqfu75wzbIM8IuykDsRQ7APcta6MAoX0YABcEJdcWAR0AuRnNBPoJIEw3CZcJiB4bVllM44NCABMADAAVAA5rVAAhAA4AR+4V2D3zOVjKleYuChAdX01YPewAEwAMABUADmsgXECXAMPrABsAOQzFABsVW6n7Adq4HB0FWwXiAtCfAsSwCkwcpGUUcxptTPUAuw1nAuEACy00iRfJkQKBewETGwC9DWcC4QALLQFIUCWRTAoDLfsFMgnXaRetAddDAEkrEncCMRYhAusnuTdrADnhAfUlAMcOy7UBG2OBALEFAAUAitNJBRvDHwcXAKgn0QGhKy0DmwBnAQoZPu03dAQYFwCqAccCIQDTKxJzOvNQsAWQOncnNUgF+icFWQVYr7gFaTtdQhI6WEGXe5NmX6H4CxMDxQcl8XcjBKNLAlNTAnUbqycBj6OlNVsDRRcEg2EJANEGqz8vIwcpAjldAGsBYR9xAIMdGQCVAUm3ACdpFwGvxQM3LSFDUwFvWQZlAmUA8UkXAykBBQBJQQCrAF0AcwArtQYH8+8ZjX8ACSEAKQCzG0cB0QHbBwsxl3iB6AAKABEANAA9ADgzd3nTwBBfEFwBTQlMbDoVCwKsD6YL5REVDNEqy9PYADSpB+sDUwfrA1MDUwfrB+sDUwfrA1MDUwNTA1McCvAa08AQXw9IBG0FjgWLBNYIgyZJEYEHKAjSVA10HhxHA0UA/CMlSRw7kzMLJUJMDE0DB/w2QmynfTgDRzGrVPWQogPLMk85bAEecRKgACoPcxw1tU5+ekdxoApLT661f0liTmcCvjqoP/gKIQmTb7t3TgY9EBcnoRDzDC8BsQE3DelL1ATtBjcExR95GRUPyZWYCKEt2QzpJt8unYBWI/EqfwXpS/A82QtJUWQPVQthCd86X4FKAx0BCSKHCtkNNQhpEO8KxWcN4RFBBzUD0UmWAKEG/QsNHTEVsSYMYqgLBTlzBvca8guLJqsTJXr4Bc8aHQZJASUa+wDLLuOFrFotXBhPWwX/CyEjwxSkUBwNIUCzeEQaFwcRJaUCjUNsSoNRMh6PIfI8OQ1iLg9ReAfxPAEZSwt9PJpGp0UKEc4+iT1EIkVMKAQxeywrJ4cJyw+BDLV8bgFVCR0JrQxtEy0REzfBCDUHFSmXICcRCB1GkWCWBPObA+8TzQMHBTsJPQcPA7EcKRMqFSUFCYEg0wLvNtEurwKLVnwBEwXHDyEf2xBMR9wO5QiXAmEDfyXnACkVHQATIpcIP18AW4/UUwEuxwjDamgjcANjFONdEW8HjQ5TB6McLxW7HN1wxF4HhgQon6sJVwFxCZUBWwTfCAU1V4ycID1nT4tUGJcgXUE7XfgCLQxhFZtEuYd0AocPZxIXATEBbwc1DP0CcxHpEWcQkQjnhgA1sTP0OiEESyF/IA0KIwNLbMoLIyb1DPRlAZ8SXgMINDl36menYLIgF/kHFTLBQVwh7QuOT8kMmBq9GD5UKhngB7sD7xrvJ+ZBUwX7A58POkkz6gS5C2UIhwk7AEUOnxMH0xhmCm2MzAEthwGzlQNTjX8Ca4sGMwcHAGMHgwV14QAZAqMInwABAMsDUwA1AqkHmQAVAIE9ATkDIysBHeECiwOPCC3HAZErAe8lBBe/DBEA8zNuRgLDrQKAZmaeBdlUAooCRTEBSSEEAUpDTQOrbd0A1wBHBg/bQwERp0bHFt8/AdtrJwDDAPcAATEHAT0ByQHvaQCzAVsLLQmer7EBSeUlAH8AEWcB0wKFANkAMQB77QFPAEkFVfUFzwJLRQENLRQnU10BtwMbAS8BCQB1BseJocUDGwRpB88CEBcV3QLvKgexAyLbE8lCwQK92lEAMhIKNAq1CrQfX/NcLwItbj1MAAofpD7DP0oFTTtPO1Q7TztUO087VDtPO1Q7TztUA5O73rveCmhfQWHnDKIN0ETEOkUT12BNYC4TxC2zFL0VyiVSGTkauCcBJeBVBQ8ALc9mLAgoNHEXuAA7KWSDPWOCHiwKRxzjU41U9C0XAK1LnjOrDagbEUQ8BUN16WImFgoKHgJkfQJiPldJq1c3HAKh8wJolAJmBQKfgDgXBwJmNwJmIgRqBHsDfw8Dfo45AjlzEzl+Oh8fAmwZAjIyOAYCbcMCbarrhi9jQScBYwDaAN0ARgEHlAyJAPoHvgAJsQJ3KwJ2njsCeUc/Ani2GVjXRapG0wJ8OwJ6xAJ9BQJ87AVVBRxH/Eh5XyAAJxFJVEpXERNKyALQ/QLQyEsjA4hLA4fiRMGRLgLynVz/AwOqS8pMKSHLTUhNqwKLOwKK1L0XAxk/YwGzAo4zAo5YPJN9Ao7VAo5YdFGwUzEGUtBUgQKT9wKTCADlABhVGlWrVcwCLBcpkYIy3XhiRTc1ApebAu+uWB2kAFUhApaLApZ4mAClWahaBX1JADcClrEClkpcQFzNApnHAplgXMZdAxUCnJc5vjqZApwSAp+XAp60hgAZCy0mCwKd7QKejgCxOWEwYesCns8CoGoBpQKemxsCnkqhY8RkIyEnAierAiZ6AqD3AqBIAqLZAqHAAqYrAqXKAqf7AHkCp+5oeGit/0VqGGrNAqzfAqyqAq1jAqz+AlcZAlXYArHd0wMfSmyTArK5CQKy5BNs3G1fbURbAyXJArZYNztujAMpQQK4WgK5QxECuSZzcDJw3QK9FQK71nCSAzINAr6Ecf4DM20CvhZzHnNLAsPHAsMAc350RzFBdNwDPKMDPJYDPbsCxXgCxkMCxgyFAshlTQLIQALJSwLJKgJkmQLdznh1XXiqeSFLzAMYn2b+AmHwGe+VIHsHXo5etw0Cz2cCz2grR0/O7w+bAMKpAs9vASXmA04OfkcBAtwjAtuGAtJLA1JYA1NbAP0DVYiAhTvHEulcQYIYgs+CyoOJAtrDAtnahAyERac4A4ahACsDZAqGbVX1AFEC32EC3rRvcwLiK+0QAfMsIwH0lwHyzoMC6+8C6Wx1Aur1AurgAPVDAbUC7oUC65iWppb/Au47A4XcmHVw3HGdAvL/AGUDjhKZjwL3DwORagOSgwL3lAL51QL4YpoYmqe3M5saA51/Av72ARcANZ8Yn68DBYkDpmYDptUAzcEDBmahhKIBBQMMRQELARsHaQZdtWMBALcEZ7sNhx6vCQATcTUAHwMvEkkDhXsBXyMdAIzrAB0A5p8Dm40IswYbn8EApwURu+kdPT4WeAVoNz5AK0IhQrRfcRFfvACWxQUyAJBMGZu5OyZgMhG6zw4vGMYYicn2BVcFWAVXBVgFYwVYBVcFWAVXBVgFVwVYBVcFWEYVCNeFZwICAgpkXukrBMkDsQYvu7sAuwSnuwDnQCkWsgVGPmk+cEI/QrZfdTdf6ABYETOrAIz+zGvL/KbnRno9JiMEKxYnNjV+bd9qwfEZwixpAWvXbjAXBV8FasnBybgIz0lbAAAACnxefYu+ADM/gQADFtEG5a0jBQCMwwsDAQ0A5WUdPSQfSkKxQrxBOCNfJ2A2JzgjCcE9CkQ/Qz54PoE+cD5xAolCvElCO1/LTk9qTQosa1QvagtuH1/gMzobCWebCmIjKzwdJkKrQrwrzAHL/F/JDh8uCQgJIn6d32o6LUoXyavJrAllwcvMCmBBXw/lEKMRAJONHUVCJRupbTnOOAozP0M+cEI/HAcKHUxHbFssLVrhvBIKfe0dK0I/HF0ISgkOM1RDQjcEO0OcLAqBGy1CPxv1CFMiIxgwMQAFj2HwXgpxZMlgC2AtI25DYBk5AhseYLMGAmsQZU5gTREBZOdgFWCVYH1gs2BLYJFoFhcGtQ7cVam8WgtDFqsBuyvNwQIfFQAcAx4BeQJsLzCVUoABigq4RxoA5CN0jgrKDaZN6gGbAoecTwVAXwD39wkANBZXDAulDCQfuq9HAE8MNAAVE58rggh6AtILS2URGwDYTgZ1BAoeWgAxALa4AZonCxZvqyQ4nxkBWwGGCfwD2e0PBqoGSga5AB3LValaCbthE4kLLT8OuwG7ASICR1ooKCggHh8hLBImBiEMjQBUAm5XkEmVAW4fD3FHAdN1D85RIBmpsE3qBxEFTF8A9/cKAHoGJGwKKwulODAtx69WDQsAX7wLAGNAlQh6AOpN7yIbvwAxALa4AZonLTsOzgKQGHtQu1jIdHKO16WbDvWZFT0b7AEpEFwSBg8bAccJOhCTBRArDDYLABEAs84BAgCkAOEAmIIABWtXLwAUAFsbxi5sdioNwRACOyQz0+EcHgsbfQJ7Ls6hHATBCqrxbAA3OS0Opge7CQAQOi7OERkAfavaHA+7GkcczaF3HgE9Kl8cAuugCAHCAULz5B9lAb4Jtwz6CDwKPgAFwAs9AksNuwi8DTwKvC7OoSoJPA67BZgBG2sKD4sa4QHDARELuxY7AKALOxC7BBige9wAO2sMPAACpgm8BRvQ9QUBvgH6bsoGewAHuwG7D00RErwBAQDqAQAAdBVbBhbLFPxvF7sYOwAuuwLrDlaouwAeuwJVICp/AAG7AALjAAg7FTwVuwAbuwG9KOClWw6/xAD0AGj7L7ZtvgNIo7vIqDsDAbuVJ0sAAlsACrsEAOfdGbsIGnsIoQUK/3AA37unuxjbGruji3lyBvupm4MAErsGGwsBvAAAhgBtuwYAC7unOwEaO7oIoZzKAbsL7QfAqTsA4XsBvwAA5QAVuwAG+wAJuwBpiwAauwAOuwIYu45pFfsAAVsADmsALkseAAa7ABe7CCEADUoBwgC3ryYBwAAAtAAOmwG+J+QAsloAHBsBv/7hCqEABcYLFRXbAAebAEK7AQIAabsAC3sAHbsACLsJoQAFygBunxnVAJEIIQAFygABOwAH2wAdmwghAAaaAAl7ABsrAG0bAOa7gAAIWwAUuwkhAAbKAOOLAAk7C6EOxPtfAAc7AG6cQEgARwADOwAJrQM3AAcbABl7Abv/Aab7AAobAAo7AAn7p+sGuwAJGwADCwAQOwAAFDsAEWsAD4sADesADbsAGQsGFhsAFTsAbpsWswG7ALoAEzsDAGkrCgDhSwACOwAEUgAXewUbAAbQABi7AAv7AF+7AGv7AOSLAbsAF3YBvAABcguhAAVKHgF7KFIAOUUA/gcNDHIAKCpwAaQFCF4BvF4jDAkHb0tsXyqJHzwUYi02A6EKtAHYABYC0QNuAXZyR1IUIQNPAhU+ASwGA3NGvHtSekAAKQAxAfsAUwrbAHuQLAErAHblDREyRgFKAFcFAAFQAQeKzAB4OwQgpQBaANYVAJVoNx+LAM1rsQDP1BYIwnVzGxhWHQnRAYiQqyJTU01IEjzCifkAfxw3QCkr4BGXTwByASksMClCGQ8DMFUE98XuAEtl3ABqAnECPxF6Osd4LjXVBgUAEBsdCggMKgQfHSlOU04IuboAChLNACYAARoAhgCJAI41AO4AtADgAJ08ALsAqwCmAKEA8gCfANMAnADrAQwBBwDAAHkAWgDLAM0BBwDXAOsAiACiATUA4wDYANUDAQcqM9TU1NS2wNzN0M5DMhcBTQFXL0cBVQFkAWMBVgFHS0NFaA0BThUHCAMyNgwHACINJCYpLDg6Oj09PT4/DkAeUVFRUVNTUlMpVFVXVlYcXWFhYGJhI2ZocG9ycnJycnJ0dHR0dHR0dHR0dHZ2d3Z1WwBA7ABFAJYAdAAuAGLyAIoAUwBTADMCc+kAh//y8gBgAI/sAJsASwBeAGD5+aoAgQCBAGUAUgCtAB4AsgB/AjwCPwD4AOMA+gD6AOQA+wDlAOUA5ADiACkCdwFNATwBOgFQAToBOgE6ATUBNAE0ATQBGAFUDwArCAAATRcKFgMVFg4AigCSAKIASwBkGAItAHAAaQCRAxIDJCoDHkE+RykAiwJLAMMCUwKgALoCkgKSApICkgKSApIChwKSApICkgKSApICkgKRApEClAKcApMCkgKSApACkAKQApACjgKRAnEB0AKTApsCkgKSApEWeQsA+gUDpwJdAjYXAVAQNQLeEQorEwFKNxNNkQF3pDwBZVkA/wM9RwEAAJMpHhiPagApYABpAC4AiQOUzIvwroRaBborDsIRAZ3VdCoLBCMxbAEzWmwBsgDdfoB/foB+gYKCfoOGhH6FiIaAh4KIgol+in6LfoyKjX6Ofo+CkH6RfpJ+k36Ug5WIloKXftoC2WzhAtdsAIJsJGygAINsbARCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAlmZsAKMDh2wAtGYBBWwAyVFsbADPbAIMbAD2WmwA9gEZAPYA9AD0APUA9AN8XmzUhCNlvwD2APQA9AD1APQcbGwAiVpsAPYAiQEZAPYAiQLsAPYAiQN8XmzUhCNlvxxsAPdabAEZAPYA9gD0APQA9QD0APcA9AD0APUA9AN8XmzUhCNlvxxsbACJWmwBGQD2AIkA9gCJAuwA9gCJA3xebNSEI2W/HGwCQwE2bAJKATlsAkvBbGwCV2xsA54C7AOeA54DnwOfA58DnwN8XmzUhCNlvxxsbACJWmwBGQOeAIkDngCJAuwDngCJA3xebNSEI2W/HGwEN2wAiQQ4AIkGjTFtIC9s1m4DJmwA/QDGWgJsbABVWv4UMgJsbACJAmwAVAEAuV5sAmxebGwAiV5sAmxebD3YAEls1gJsbEZFNiJ9FGVAe8xvEZKvxVfKZszAVTBzYBH2d1iyUXEHH7twNw7eZF5JJRHI5EgaRr5D20/3dfONrFLSq5qSrrgd2CEUq722WBQ/LzpA+bx1oREI5xy4BDSZNun0ZWORUJqInZSyMaioyvfSI0l5uFDzbWaQ28/zdB0hwR4OQZ0/jn9ALSLNikjFYGfqR389qtFlhD3a6KdIh97rhZYpywuLc7o8ql5/X8KCbPU3L/QlmCowhRXhsGDvg6wUNprA9bM/49uxlAj7ZVy3ouEY/BgFXBNyK0TLrSjZWeJm/T4nz6QGLT3cJNtWRZVZTvIdtaxMMJRHgig9+S11LjBh7Inr06ykoch1U097Rw0hvgmOrydQyaWcEQDg0RavuMuT0zYabUZl1e33HNSK1oNUCS03eh+9C2EvF3fq9h+XBaAMFuoWeZf+mfZgL4HzyiKDIUtfNU4oFu0aE9qt3VA3U4D3fOSrAcYVnjG3cSkp1vhXZnp3JQm4JknKdBitO2NVnGCYQwU3YMWHWB87NEd+4AHuOKI8BSIH92reW0pfs+kWCTJxDCbRjFv8Cfc4/DSBYJScJYTeAEgg9wTEvcwd/QuHRHqGzAQ4fXf5FUI1lPrO+fvEcPl4JInM1z9AtBT2bL4QYEREe7KiSnnxTwtmAFjn8lqT3mND8qTktX2F16Ae9cakqJ6/pEQsHURqyqWlRMCzKXRKfCHT7sYHWx9/T/ugYTFY6iVN3Btm58ATJR5alYZybKMWojwOw3HbFn23NFyeLl7+Er82RchyYuBoGQ3j7SAWNxiYvp5U+Fq/DEzB9cG5DlJWsqkosRze92OVlCtQEYo1S1lF72Z8xWc4ld/+fFcfTEDTFb9d8tJGQ75dpJEvcWyGmGBiTbiWDdGOcw93Dmxq5ISUrmasygONfHLvhgo83HQZenbdBtSzBkvYrCEQ/xEDMhMZsN6gqplx5jGG9mSQLhM81UEdEeJ59sdNJDAFy/gPyJoKlwPZgB/MkC/kICLiCB8va+nCdO2ry4aDfkmPFpF/H/SGQ3LJ6aAv9dtJ8DniHtLOckZix0BVb0iR5V3LAp521LBSIi6AtV7r2ZB/hQEvAw54EFNOQcFnl1xGUIc67tqK1INNwD2n/RbwgzO9h45LM6VMuN8V1ZNIQ6t+Xy3lTqyVCD5kqLy/t3/b8MLbgDg8JIWDkSZ+LrGhhr+gYpH+pr1TnCUnZPjpUdw6bSL6MWVXoDDciQDWECwU2e6VEpfrcOBbrSOijqGkEIoJPbpmeJLkcwbvA0yWIixQVjo0HnYh7fji+Dfdq1mtV1lG2Zz9R7eFMHS+FK7nybutu2fwzDpFldO2pZBshsHJWaltn3PWOoGJpCT2jE8EHOuC6FkejNWcfsWCqNqMLP9xTwcWArj2EiiI7D+EaDi7/2cqHL1gPiF6C/J7aUo7RQqogPZ11WqbyP97nsoMxPOC78wZMF7B1Y0g7JNXJV/nN1m4xx8hbqWz07KSaqr5hE4icB326DMR/vUKX9LoNjle/ZWtbUhrTAcsdgrLlG5Ne8aiR0bS/2ZhpNOVVxavWIZsEM/rd68EB4vjbbD13NkMK1qvMk74vGbSkL7ULO0sZ9R6APSCo6KH+Xn98wEdw1bCPAnDTaBsD6sidAGN58uiH4a3ovG1KyZAu2XtyGgF/vgWKGxw9R1lfAVcfuYE71DHuxtTzfGZnHaDpDGWmfEq0N4GawE7yIkaoz8jcmVmzJe1ydM8q0p08YIxFcY1YcqQc1djWBEoNETDFcgk5waRftEJasPREkrV++N/TOKkERF1fCLrXS8DFGYGRBeECMQRNEs0ES3FzUtXCcNxpYEM3Uei6XodZruXUIRnn+UXf2b/r7n1vQutoi6WoIbW7svDNWBbUWcDUc7F9SJK3bvSy9KIqhgyJHoW2Kpvv0J4ob14HFXGWWVsYXJzjwxS+SADShTgCRjhoDgjAYRGxwJ1Vonw+cpnCKhz8NQPrb0SFxHIRbmG95Q2hlC4mDxvPBRbkFa60cvWakd7f0kVBxxktzZ9agPJEWyA63RSHYVqt8cPrs2uFJ3rS3k9ETGKn5+A6F9IOrdZHfT1biEyUJKEvwzuscwshGCBJvd16TrefW03xVnJf4xvs72PdxrMidjJO8EiWyN/VWyB3fv9kc34YIuZTFtXGo9DuG3H1Uka5FgBMwDPEvRcSabi3WakNQkXFecJlFk6buLVk5YHpuKWTw6oF632FPPSVIVl5hgUAeHhj0t/sw/PEEvThLQDDFE34eCg/rLOyXT3r+L98oRKrlTO0MdALYQ3rRQqC7d822dJPGxF1K4J2TtfPSMFaCAg0n0NGk9yiaKKOJD1v2aBX9HUOIawjjfvwCmjHZJTR62R9c9x33JnBjWrN4QYEOmehy0oZMP9XM9Zyi6TYoe07PaLceRXcCWZiY/imRUWW6+mci7+wMxSdwMdbXckXtvhJH8sc4iQcTwm7yp+3f7CaesTTQB2qkgeXh+wFiSMXfMlH7Yil0OoZ2QTtRLTip2O0cLZ4SstqWHZ6H+8A2kZXhpm0kPbL9dUanTOvziqIUh6Ambwa3WrCb2eWbuCN3L1hgWUmjRC3JoL3dBhR3imSQI8xuCMfsszlji7cSShNSYdqCXPxEVwbqO9i5B6hf93YI7aeyI8jxgcVXK0I/klbvhSXjkjOIwZgPdVwmsFW7HGPLUAvDRuKm+itybRg7c8+Yqqjg824Qf+/NxsBSUNAK9KCoJpauFqK0XQULrWYj4FnxeKDuvr54iokpi+D57e6Y1zxRJJdsHnDR3JyraCUufHBRTKODWBVzthjm4k3/Hv+Q990XDVR+KW+TcJX045LW86EKhz/97aqj89A8ZvTk1//tczosU90loIPVaHuWegJU3wP//7XHcO7c0yQM2jM/IhQKrf8hiObHWiWDZManF8Uf/HzbmDfC2wT//aiZ4hGTv/xzgKwdb1sD6cGEkceow0s3b89/zg+3plyRm0HlZi886j5wUwFhdHiDTaBidZRo5cx/tMeLyguOATbzq17ydhzbrpxunuHx6lbFGiO97gsd4dk//7iCIo+Ew+hG2so5kvv+ITG4c1fzHPtu1Xn5QfUnqY3/uByVmB7gmnE/E+5zdm+6nDmoews5fr+NzThdSHzK4bBQOL9c4O8OI0xLSqjJ4lbniLJg1aFpQRLwaSMZmpkC9e/j6FOVrTQ6a/a4alGgfrl2ZL1sbHUQ3DOI7ntq9diHFfm3t1mul3rdJEJCHnlW/hlQntipMrpeMs7fUr6wK370D7VbXH0DUHzdYfRg/6Z11Ult1sffJS+heHbco15Sxy3+rDnPesqH1lajk0yu02hPUvEUqvcUXWXL7Ad0wNGMx5gOle4XJxq/r/YY0xdco2wRSEGwcT7YADlBrHc9ZbvzOL0QwyWCWWChB9Obg800v7tyBWaNvdwz+fL7Ph9i2irEeJkRgOzeEDw+JiD/V93vH9FgMEoFIJMoIuogmicZohf94SBuPn6hXaV9jP4VVVA/bu+Wg8S88GLtmEPSNRLdtlXx2XL/nuM8nKkhnlnjaropiKKLIH94pLIASci0pDBfj9Hi5BfaTSXQg5+PMjQX91Ktk4MOqK1K99l4BRPv5+vNovGZ3IxQv8ICvjV4/diThpoaM8uvd3D9d/DE477w3yAbW3IDm2i73pZ9aEj38JqS6h/s8/xgmUIVcuq2JTgefAyuoafzQxAuRASeg3NtG3ach/JEkyuX+JDt2PnDZTShUhyHHG3ttBg/6lhAchGjLJBtopj4e01MlCp2yqQRTr4sBBXru+lKaoanwYX8y2aWCJiR3KnhCOkYVFSvsO0oDRujUFOEptiNDTYrJoUbvOyvl4AhC9h3wORiTXK1MrpMfnvdnndnR/HRVSusMBgIxwrLdn3vq1VcncPiD0SquTx/kNmxeFyCT4uXVUd9AL+rSGmuq7OOCzDKeVPjiNWVaoP5KOFqYq5Xcuf/xW9S+u9eIq9GAtZWtQlgkRecjRtvG1NR4WXXpn+pwsTBTIy079Ikg8rSef1aVapIFcXCd6C2wHVjLXR+N0tw4Taw6x6H90BFRgNrtlq2up6hHKuV3inM5RJaQWZHd84e6RsKkk9po3dk9by54tpPw7cBkFas/G+GbHwuG+AwP55BZyXILTHCIVrPpXHEaUPYfL6nphJP1Rc10xG4UaCeY4IHCwuur8xmSQDgY4aVwhzWhjbtSHG8JO6P2i2nC9/0Bfx0zk6dYQq3aw7k5vIObD7SEKrxhz0fQ0+YTOfHW23CBNeZci1qNsUDhoeqmfyP6PvjoEjHk8QbrFyQVZPHVWijnb8YCM65iYNoEbvnchStZ/9cKg5Vd45j8KnB6UjzXl/bkyZx7VoD47ocUUi117WwgySSb4rXgLJ52Mv5XJbp3I+uBP81BUvOjy4Cacgi+GWWlC/8dwgqwiojjUBDnEOxyRyowwLQfytFra1OZS4XvRYr4uoamAfG3I/p2bA7G90yqKThH8Ke00Tqd+3l3dmJpaCZelBMYjGqNLVa3SM4+LQeL56gY6Bymy2LQPVOxjWfj5tq4o74swcxhyGJPynkS5xAjOXZP1/FAYcBT3u6qLoIkEfErwo4gozmyI1YCvM0oyI3ghjGPQSsof2sKUhq91WsKy9cYWN+4A2v4pG/Mxpdc6w6kI/HX7Xb0TuihmsiOy2wQIsrZbUmr3OBSUo6oDJNgQp+YqYkgTgYcWZDgawJw3DFfdzT//PhVUidgB2qa8uw/j9ToHBAS33iT8YLhhAfyXG0bQUFp7QmH7oQ3i6Flf4OTZLvJdh8pfuflmWu2ohm5pTiSg1pl3vq9uluTJwqXfh1hqy8e2iHoD+Y35gCIViTo6VOtK5dD8HYClucJucXASzwe2kPj4S4eYQtmkYHagXhAzp/F541xE8YFYqSPszDuz3soWzHy0p3E2jwZNQaIcGU9FNQwQxeDw0ZlK9dxXrj9IUHGUPTOyib8CqXmbZ7Ex54bn1rLx3qqAavu/gh6XjV0GmN1p+yyMK9HN5uYEvxgbAk43tsheREhyI+Q5WLIneKTGPmYiM/lxOp8fvqHy8YgXK0TlMiX0tliLI2JtfmWZP8eVV732sdYm+pcWzDzEmKLJZyeelyaZKkjPnnUO9keDwtgiLnmd5+t+Sr5y8brRnlvxcWEWfCqIALQYHvaXx6jTg4dAlye469uGwwOZVZCILLfGjaMg4LUCNMTtMSp1aC2y/3wR2t1v3w/iNBRQ+bNbtDqL2NAr7K4rUcyqbSpNrXZgAWXvjxBBtfYLK1uRYt3q2pfXJOAL0HtWcEwJLddOSJKV1SwvcvEuzg/4MPnA8MIUJOLqm3qI6wFyN99Ck6zYaV/zGSAzF/PGsaNa4vPLe5QnyuqVUnVQ6xELA6gbe53aGgeke+R/ycb2LJVyc7BhuzI90zA+c6wUDTb7NH//gdDSl2u/aW7lRJm8m1fLtPxcNuEM5JbkOCZKPM88HUsLRoC1pmKKlvWyeAXuxILbu0snpSxf8N+RgtLUSe5n2gdjOjoSTaN7mMZ7bF+cWk/MS8mFD4pcyl5UN7CbpFZH2a+Pm1VAnUTVfbw8qrmz1G9m5aKmRzY1SMhhPrlCn2t4uNUXNA3IFe6NOjSC1DEaAFZAfDlEkQCsbNhsZPj6NQPDSB3tLiTo0ZYoEbIeEIaKtU3Wk60rEszawTFuyHVd365LA/c/uarABN5M5rGq/dqTG3Ilye/5EKiYisisuzqNaZjmWv0z9TORc0CKbaTea214oNM9u2sXUZub/eqM3Pi/PjRSyQiOSwPWif2asTgu6hS6fb5UGosCWxdedMqdViIUUSSdIJx+qQ4KShfTT39VAWZbi+mB+iKICNwpt6cflY57Rcbs6d1kA26Iru73cuxYVlSvuJdcR5VfDYZRk8X0AXePROyw3Le6LaUdmTLzYsoNhhgQpd67xVNiHgk3pakmndeIAtTC4DCXy9oS6eU4CWxDdVmY53pKNbdAKmQsP37lrJZC6iDXMELGKcHjNuuZgcDyY8W/yv6ha3DX7OWm/35fpvhw55oitf4V+GULlcPWYyGGuVBdro19c8u0RDddDun40W7G5cSIzHLh/qZxb59R+EPY+wZ2XerkUim92hhXpKyW6WtAh6zQS97DrPyjCvKi3pCw96LeKynOpyjtsMQc2RmI/20zFOZcSa2AK++PoRcT6zeJyxlBZ7kk5mhqXGkLlM2hFKc+/T544xXP0Ua38Q6xdPTLTeG1PHnLMaOvksUQMrEFTB/lizCirmFQL8zYVU+OTeYQEFaITsBSMMYexS9HkajO2gGIf2micvntCZJsZQEwIH3/4JGJQGflBuH5rNXmnRRYXDQs3ZoEQoMtYDr1kFKUS/siiQSUxcTH9XYeBZiKDDFQoExREO9dddKQLO3BwMHvymCSTFyY+vxn3D27NDx6OlU092D5EDUwilttqVHpjJQDUceJYCLsK2swfXeNUVrBJT/w/sk+7si8rPtiMFis+oxvGdGQxirMBID700T39mULuNHzOyN+xBfcFACZcyngF1aSpv0JPkNUrAZTqfplv509cGXFUiEEm5dZb+OsP/blizqdK45/dSsIrufYTrCPY2lgJD6k6QljTfXVlHfYKSq+MsagyUcaMintyr95bD8kdTAeYNLNsMmo/Wdd8a2nStBP49ARIjqqpUHWY4q4mvO5Cq/CgCP+4/B+5zutGwX5pssgVLr1+fIM7WWLfiUQDk4c6ZdHZOWv5hG3g2dgQ5NXnpIY+BWwJpaouf25bXnjDzbHnQNofH/c6m+dEAS9Gs2h7pFRPKOBDnqswZ8KZjhId1ytHUTs533KwBoSiImoxKQUgZ7z6pA9QB3sZ8Cq0vwutJTTkfbX8AzCpm2cFXx/P22niUMHauU8IGc+78R6TsutoonoqFuoNA3l80t387YHMoL5KGAT1JO4zmx+vJ0LbLHlicHraSVYvJjnO9p++qnWgKw9OwFVVUagvZuf9qfiuum+hIicxP1q4zDnzkHsCNriLxBpxY9N+UOmqzdY1MunLMDgkMyi3uvnN3UBXJeZ8YLs5xr8QrOhimYoKuGBebZHAiBIkViv3DG8k2oNpp5OIgX6ulqaRN8V62QUPjn5tl1kPXhT9bcd8qIm8gi4or/FGbvQ6pgGSHmnayrugmf5E0upGxPRf/3xOtitGMaHLKJVm5zhglmVfI91o0yxhJZVS/5wQ8zfxK8Ylw0WmHXoGfRkoBRx9Hsnl/6sgTjAVwpmNuSeZtBwlX4qB8Bh8lxjqBDIuFGJ4I1wxN0XRlAAslzqMKwQfyA7OkuivCXfv+i+3XmhcBFM2n4jdT+NyUmBnQJPV3F2sZfKvJhUlXzSosFR4VevVVcOkFnnjdiRWc0TeSYxj41sJGYMbZTeLI3GvyZ8/gAAudQ1+4oFX+enX5V49MczGCYVBuoC4kHjp7ZVxj+clBwPr9k+v05SsezQK3enxLs1Nt/N7c7AImVUysjGou4iOohHo83Zs9/MI/OWB+OyXzOBD93NbApGHXrv8CVRHp2bwH+xB55cfNrdqFD35HSMx4iVmtzYAmSCIV8kXsHoq3DIb93riTWbubnjxbBW5zConVtbxLRStXHkIyAByaozME952Gc9aAdAbBpZSVCH88Uwb/4bPTVOVl+WoMYD7JIvK8VcMrJ8zHV4bbG0Dg7Kx17A4ej/ZcZ2Z5pVuVLUH1E/AccUTKm81SE+LQ6STTUDscUk0x2OWIbEORhg69tdoTGNkA1RfkGIRZHr5mCXOpLC55WWzCZoGPFUVtZRHwh0nq039CDdjEPo+JyaxSQAvDgR6Iqvxy0frrtEG1A385N81l05SSzN+IDm9bypF9m92EUqblnauZ5sjc37wRykOdl7w4o8WMgQsjii3EE/aJYDfHs1cH6DNBEujjcCc8qAefYFyIAURDcDnzun5UmkbBQsU4eu/W8I9nBE0qJKTdg2hwjq0+XV7a3TJ7R+alvJZCRia9lJ+grNB9dbrOmWEvUotMjvDhq4wV/kq4fvIBkzUGpDeYH74rne8uU3dgoNZdR9pUL6q9YDNRfOiF6Dyk+SYXQIghTjm9qR4tBHh0gnmF/9q3Qv22EzaLhSvDlDOxMrrCNRmLCl1jApzLrBCPn2mjn5zqK7OYK7VxOfQ5GfBfoPdyQwqFEgCVHkJ9oTnagRM3R0+rsuN5jQv9icCav/p1WqiEXSzCdLd/WEA6z6dDP7tPqPbeDYKAkVcz1lLGbFOC9b7cBd3MV0Ve8dZ89oR7OnxGS7uVpSry8banVZwpJg+nkH1jRBYa2BvBMY2xITH9ERXCjHzdZxs+ipdXP2DY7X+eWiBhtT2L0RRGTLPeazn5tpl4tu8iE2rWig731iuJDRbCHHy+g/Mb9+miAyVqfIpXT/iZeOxOxODO0hEpLM78I1+G2Z45yi3lS1K3m4WMQ559Lp4UML5vZUjYGJuxl+OPpUH5klpyBujkjprhei0TmUik10gjvNUp8mDkWlNKikmYspaVTqewbnOzJrmz8FLIpsT67EJLHIIfeDcWEfiP+DJrZ1jfxpoAb2abeMqLx+9RuZGzQoYtYVGgAWwEM9Kek2vPIeBNAKD6ao7nw6sgvfeLZPoXkbYO/tStHJdKzk+WFSFEU2NcALJAEP6S8pcnqqBBt57dwTrzQNCIdk2SocK4dLRbD/pu/VryKnm65ZYXiJCfHJk3mx9MRSl+nSK6OqEBSoGjz0/LADddwF/HqcfK3K3O+6YUGQcmj8pZL4PhZ6KrGkb8B38FmDvvLd3XQXbvS/FQmrXFTvJNkaN/FGo83KuS43BK1UfVnIqigGkCoP5fBda2MwAGTGNKX9K9t4Bx83pMFc5KSORmWKv+8VoVggWxoaBz3/9IBh6RwLd1tebwy89xvE5z6EEpXpDfrXWfRsMs6+ekUHH6idVosno55+xQ8Zqzelh0bxtJTgCcH3Z3/Cxlx9eNIS4JIFKOAVrDqbrXRszmY55a5+niJGHtkO3b6mnIDxLa1WXc7BAe33mt2KyM4Fbc3R6/WVTQN8QhlqAtave2WsQTqzWeSlKuGUVIJRqtObpv294rS0kDN1RKzdstZTXJebR2HlzsQ4P3NbMHUqFZMZw+/IKXnh4t+lY8qocp/B1oMszR03EFs3bPeND8QkItMvllObeCz3SZAjqZrobmLcrpFyQV7mwBjg3C3C8/bc5goQhv8j/IXMLGnt4mF7tybRDG5G0polxoUScQkPvmnga2/K+aapKeqSL0BTmo1Cm5g+booNOtdyKva2KoefRURaBk7113QKo3y+WTuFKtgETIK8HRluYS9DvlcciCDvnG8UaJRfZE2siZsiTHvRmN80xkUIInHeRZl5Re/+ATL6VhKFi8CZ/n/jbFV6T5pZ+Uoppvsi3qjacVFOJgWWfdlwVHKPW/TJO3na9hRM9bS2yo2rEsC6IBzRReVO6IesJU7PItzOamr+ROFfwGZmZ7ue8HNxAgLJKb7P3p8dMqk6Be5PJaT/5Rdc1deYVihWH9cjVKc9uz5EnfHqxLUkOO8iJUENBNVf5LyNy8zjLu/78k5WNTywiPfYeX3CPk7yc6CI3lum/CEZwfUaNpcI3KsPqfn2lmz3kd/acQjKA1ebkJaiuLD+epQ/Fc1llHXXMzofWzz/Kd29SNmOhcjMWw1jq1g3YfrXZ9rzXDYW4ZttfgfMi6oCUtBs0PkMVuxmq5lxEoCaSXPSqCJJ7MlKdRDidVt0AFlxk5cTdX++sBF2+E35mjwfm8ERVxH0FvuAQtsfA4V2G0TKTUxeyRGVjd/u6F1SvuAiU2/WaQjcNCU4Ep7VunXCYSbZj3U3wzu/LWM5MPlYuyQ3FOOCD/zt7K295hY2JhwF+ODDIZ676vGQFKveEQYkWj7lkK7rVmD7MhU0Y/tF8EcTTpo4/yqOufbd/zWIpMajnbDuWK2vn6OPPtz2rc9MIBNlPd8tt+yf+7SC4wqEPbozKMCwY5Bygx4JmoIEDsixWRDcdHd6S3/dZMHXOJAAv7+NIstl00crgSqHZKAEe4g3G4dzIV51EeZB01r7p8GNlfUnG/GjZgNGsqXZdYMBVtAtFNv3hJWPve4GvqZ2XxuiNkHTz5kxWgr0PjQdJlVywJ9Zf2ZvqeeTbolKtvK54re2Lq5BoyzfsRtvDfyao3kmyFzDQ88nM+qx83w74RDlkngtYiArI05Epre3GgBeSlMig0pE6RGQaFznKkGeb0SozLCyiOtxh7hgwZlbKbClzUUfC8ntMiHUOZE375RhTy9c4DA+oMLkUDkztSybZbdmP1xpaIbjUpPAHBq3cIq+CBFzbMlMMCCkUQ6d9LGV6GYCsYiEWZIy3nBnuxOYXeU4YTGDSin9e4/pCjPtQSHlg5LMEvIlF0ElthqrF129iK2RPBEWd3XWOl3SWV5uz5VUyZYp5kEFmz7QfP/B1W1BBzQ2iTGbSVT79lUHzcGXz3PJceSgz4uknETUwo0xffpr2KUvZF0i/r2sL3IFIClYx8CbIZE6Qt7MDJbOPB3xMScwaOcWG66IJfCnDkb0D2Mb+PHzX+oiCbxeTIogtyN+s2NJirNACk/OACSOTtV6vscwbzW4M168xqaI+RzR47S1nlV/rOoZnid87n/Ima2XYa3un3BuGAisNjb8eLMT9OnMtazQROFCuO1HiZXaOc0oUDbNC4eKLToOx8DzVhMgGA8XIAQ2x3b6I0uEyLssQjJX3QphcUMx4KsMgJ+72km4N2aqkBF2coKmUEt1eqIMGn+5txMT4kYVGd3ALO+y9Z4PP3d3l48JQK8s9ZZ/Qx/+NBKgBEJFlQ32psoJiihGO7FSYM5L81q72kaAYcilEFMG+ZK1BcMqELkflyCV7v8JEXLO4Rf/oZYNZHZVjJhfL6fnpP9Tio3Euue5uS7FMkfGOeRCTrBZ06Caev7tgufeTrX34Ur/Vvc+b8ksiIShNJtuF9WmYxOZ4xg8y6zTdy3KAB2y5kYkcRnXsptWwAFyKZ2I/QGySNeoQLkINUMloC+5L3WuMMx297Q1xUYLKqZ9XHavaobo6QQv4auMm+i84IhxRpPt9nUmcav9NcjCcP+TcMmxsQZ/F3mgeoA0fQgwvTsyXuuTaM3Sqtv2jaaajmaFQpK9W6uIbeqwvSDo34ZrY6elDUHwSCjHRRmlwmyy+eOra64Ssq0XSXYljMHtKY+FShcMkHsEUY/4Bw63dJ6KpwDaxmthlDdbdE+TvYF3v33cGSKqO+1H1pKYhJMvZD5ckQcHyNF8zrtiR5b0ko6NPGoRexUZTYP6VbUdn3zzxGBOi8Z0OqHjGqYxRXwN3mYi0GYEEZYq+Q3QvdKcEHILLLj8S+VFepSfErtmfZCdvxbfIifFSpEzKi+7VJsLMT+zEFeyp1OdwRC1VZrfTLIyR7xTPUcZFYPD9qI7D70uTb4hdpqPXsJIRNYbZtNwch1OI3trh3u2ScoQyM9POnInsUa+OovcwkUP1UfIzPb95n4BaF2ev57NHAej0+BVMF9/Cj9663HN2/JN3SQgslL914bKfiTTDFAz9PlQEL/dSv1H8xl3mtWxh1McFO9EJXlRDaKQDsyKO4vOJW90NFE6yw2tjbc2GeF95sbs0I9enAa6QwQVf/kJQhAD2BzUDKggOyjy1TEhED6sfk+418lQy3c/uj8aw8UEzZ6hIMCd8RohAkumMtIj9m73l2yPWoGHVTPaywkC7Yj9tBM1NxMgcrDwRtk4RO2WHT7Ql5kQCKdJj6kNuOTeyEBYBjLMhGz+O5/YGa84HEiTYEpZ6fFzy26GG2hWtTyteuYrhSyG56BjsT/wQeLRytpTY3D7sIMqZnJ9z1FDrfyjFlGl2TNw9BQysbaxOuwYYZs/7I6BANgkqCknWZC7/BBXvaeKwAmC959I+G39BUE9bExkNlbRoFRyEtNzv+NJ91FuisG3JCS6uYBeRnfv8AkAfKTeg9EYamqnsGfAV7d0f9DghHEQ5IsPGDIUhgoSj7obM4Bu5uhQ3/CYEDTHc92AsFvDK4XGrwUeGBWBHPlS+f4x+CxmmHz2sAGmSFNt65kwZC64mnaoWlu2310laYn8r62AqsR5dfjyK18MEdurdagldzfJtjFXlZs7St4QhdPiye6TPh2/ZAQLU/Fip5s7TDEM16KtRWrK9hmxnQ7bmfa/+7pa10Z8WDPK3NuJ+NN/RAbQ5vHx2uX0Lm7/w7cAEH/hvZA+mt7J7zGw7YtQYwnNN6dpgwkGjjrS3yQoeoYt1EnczmtmJfQZWzUlP3Hlg9Wzlr9IH23q3thGth+QNEANFettxKfskkGOlLk8AqoKJwDqOxAa6UzAx07plSSyNBJSGco9zjnC5gGbDoKvsMDuBR6bGRlGzJ+hFsGa/Izt78aI+WZ6dJlZKp4pGISuv9rV0sAS0MWEwCmfauO7oQZMiakHU35LBxiyJoOMddhUWgcZuC8r4Ksvn75TTcQXLJ7kWtYhGuGqPd9dZuFjBWQHNwosXY5snbHFQq72CvHXhIg+shQxycuLOuWYErwCLZeF24b7F78pO7xw4X6lIAR02hUOf5087Rl0nOaeb6CK4i/KA/EZv76ftOWZtjwxslNr0E/u8rWUmnf3amfg6UZmBAluuoj3Dd7UV+9IAJ6iYcDfSJlgmIImohjfIUMJ27z+opj50Ak9af2LCNrWrBJvMovA1OeNO+MF/MwZvnaCxTgG7Cw4QfSPF6AYCGFt21M8PySZFeV3t2Rqqs5JMzMYzGRgq4o+UaKRgBf9GHi/9X9HXA3wxkCsd/UhnHSh2zUVDiraio/6nP4y3XJqs8ABfALAtCYU7DHPMPRjgcM6Ad/HiSXDAbOdSMkvGZPAkHs8wuQTy6X2Ov/JFvcPuKfV3/r9Q28"
          ),
          i = () => A(r),
          s = () => new Set(i()),
          n = (e, t) => t.forEach((t) => e.add(t));
        (o = new Map(_(r))),
          (c = s()),
          (l = i()),
          (d = new Set(i().map((e) => l[e]))),
          (l = new Set(l)),
          (u = s()),
          (h = s());
        let a = E(r),
          w = r(),
          I = () => {
            let e = new Set();
            return i().forEach((t) => n(e, a[t])), n(e, i()), e;
          };
        (f = C((e) => {
          let t = C(r).map((e) => e + 96);
          if (t.length) {
            let i = e >= w;
            (t[0] -= 32), (t = x(t)), i && (t = `Restricted[${t}]`);
            let s = I();
            return { N: t, P: s, Q: I(), M: !r(), R: i };
          }
        })),
          (p = s()),
          (g = new Map());
        let S = i()
          .concat(U(p))
          .sort((e, t) => e - t);
        for (let { V: e, M: t } of (S.forEach((e, t) => {
          let i = r(),
            s = (S[t] = i ? S[t - i] : { V: [], M: new Map() });
          s.V.push(e), p.has(e) || g.set(e, s);
        }),
        new Set(g.values()))) {
          let r = [];
          for (let t of e) {
            let e = f.filter((e) => L(e, t)),
              i = r.find(({ G: t }) => e.some((e) => t.has(e)));
            i || ((i = { G: new Set(), V: [] }), r.push(i)),
              i.V.push(t),
              n(i.G, e);
          }
          let i = r.flatMap((e) => U(e.G));
          for (let { G: e, V: s } of r) {
            let r = new Set(i.filter((t) => !e.has(t)));
            for (let e of s) t.set(e, r);
          }
        }
        m = new Set();
        let T = new Set(),
          P = (e) => (m.has(e) ? T.add(e) : m.add(e));
        for (let e of f) {
          for (let t of e.P) P(t);
          for (let t of e.Q) P(t);
        }
        for (let e of m) g.has(e) || T.has(e) || g.set(e, 1);
        for (let i of (n(m, R(m).map(O)),
        (b = ((e = []),
        (t = A(r)),
        (function t({ S: r, B: i }, s, n) {
          if (!(4 & r) || n !== s[s.length - 1])
            for (let a of (2 & r && (n = s[s.length - 1]),
            1 & r && e.push(s),
            i))
              for (let e of a.Q) t(a, [...s, e], n);
        })(
          (function e(i) {
            return {
              S: r(),
              B: C(() => {
                let i = A(r).map((e) => t[e]);
                if (i.length) return e(i);
              }),
              Q: i,
            };
          })([]),
          []
        ),
        e)
          .map((e) => B.from(e))
          .sort(N)),
        (y = new Map()),
        b)) {
          let e = [y];
          for (let t of i) {
            let r = e.map((e) => {
              let r = e.get(t);
              return r || ((r = new Map()), e.set(t, r)), r;
            });
            65039 === t ? e.push(...r) : (e = r);
          }
          for (let t of e) t.V = i;
        }
      }
      function F(e) {
        return (W(e) ? "" : `${$(z([e]))} `) + S(e);
      }
      function $(e) {
        return `"${e}"\u200E`;
      }
      function z(e, t = 1 / 0, r = S) {
        var i, s;
        let n = [];
        (i = e[0]),
          j(),
          l.has(i) && n.push(""),
          e.length > t &&
            ((t >>= 1), (e = [...e.slice(0, t), 8230, ...e.slice(-t)]));
        let a = 0,
          o = e.length;
        for (let t = 0; t < o; t++) {
          let i = e[t];
          W(i) && (n.push(x(e.slice(a, t))), n.push(r(i)), (a = t + 1));
        }
        return n.push(x(e.slice(a, o))), n.join("");
      }
      function W(e) {
        return j(), u.has(e);
      }
      function H(e) {
        return Error(`disallowed character: ${F(e)}`);
      }
      function q(e, t) {
        let r = F(t),
          i = f.find((e) => e.P.has(t));
        return (
          i && (r = `${i.N} ${r}`), Error(`illegal mixture: ${e.N} + ${r}`)
        );
      }
      function V(e) {
        return Error(`illegal placement: ${e}`);
      }
      function K(e) {
        return e.filter((e) => 65039 != e);
      }
      let G = "valid";
      function Y(e) {
        var t;
        return (t = (function (e, t, r) {
          if (!e) return [];
          j();
          let i = 0;
          return e.split(".").map((e) => {
            let s = (function (e) {
                let t = [];
                for (let r = 0, i = e.length; r < i; ) {
                  let i = e.codePointAt(r);
                  (r += i < 65536 ? 1 : 2), t.push(i);
                }
                return t;
              })(e),
              n = { input: s, offset: i };
            i += s.length + 1;
            try {
              let e,
                i = (n.tokens = (function (e, t, r) {
                  let i = [],
                    s = [];
                  for (e = e.slice().reverse(); e.length; ) {
                    let n = (function (e, t) {
                      let r,
                        i = y,
                        s = e.length;
                      for (; s && (i = i.get(e[--s])); ) {
                        let { V: n } = i;
                        n &&
                          ((r = n),
                          t && t.push(...e.slice(s).reverse()),
                          (e.length = s));
                      }
                      return r;
                    })(e);
                    if (n) s.length && (i.push(t(s)), (s = [])), i.push(r(n));
                    else {
                      let t = e.pop();
                      if (m.has(t)) s.push(t);
                      else {
                        let e = o.get(t);
                        if (e) s.push(...e);
                        else if (!c.has(t)) throw H(t);
                      }
                    }
                  }
                  return s.length && i.push(t(s)), i;
                })(s, t, r)),
                a = i.length;
              if (!a) throw Error("empty label");
              let u = (n.output = i.flat());
              if (
                (!(function (e) {
                  for (let t = e.lastIndexOf(95); t > 0; )
                    if (95 !== e[--t])
                      throw Error("underscore allowed only at start");
                })(u),
                !(n.emoji = a > 1 || i[0].is_emoji) && u.every((e) => e < 128))
              )
                !(function (e) {
                  if (e.length >= 4 && 45 == e[2] && 45 == e[3])
                    throw Error(
                      `invalid label extension: "${x(e.slice(0, 4))}"`
                    );
                })(u),
                  (e = "ASCII");
              else {
                let t = i.flatMap((e) => (e.is_emoji ? [] : e));
                if (t.length) {
                  if (l.has(u[0])) throw V("leading combining mark");
                  for (let e = 1; e < a; e++) {
                    let t = i[e];
                    if (!t.is_emoji && l.has(t[0]))
                      throw V(
                        `emoji + combining mark: "${x(i[e - 1])} + ${z([
                          t[0],
                        ])}"`
                      );
                  }
                  !(function (e) {
                    let t = e[0],
                      r = w.get(t);
                    if (r) throw V(`leading ${r}`);
                    let i = e.length,
                      s = -1;
                    for (let n = 1; n < i; n++) {
                      t = e[n];
                      let i = w.get(t);
                      if (i) {
                        if (s == n) throw V(`${r} + ${i}`);
                        (s = n + 1), (r = i);
                      }
                    }
                    if (s == i) throw V(`trailing ${r}`);
                  })(u);
                  let r = U(new Set(t)),
                    [s] = (function (e) {
                      let t = f;
                      for (let r of e) {
                        let e = t.filter((e) => L(e, r));
                        if (!e.length) {
                          if (f.some((e) => L(e, r))) throw q(t[0], r);
                          throw H(r);
                        }
                        if (((t = e), 1 == e.length)) break;
                      }
                      return t;
                    })(r);
                  (function (e, t) {
                    for (let r of t) if (!L(e, r)) throw q(e, r);
                    if (e.M) {
                      var r;
                      let e = ((r = t), R(r).map(O));
                      for (let t = 1, r = e.length; t < r; t++)
                        if (d.has(e[t])) {
                          let i = t + 1;
                          for (let s; i < r && d.has((s = e[i])); i++)
                            for (let r = t; r < i; r++)
                              if (e[r] == s)
                                throw Error(
                                  `duplicate non-spacing marks: ${F(s)}`
                                );
                          if (i - t > 4)
                            throw Error(
                              `excessive non-spacing marks: ${$(
                                z(e.slice(t - 1, i))
                              )} (${i - t}/4)`
                            );
                          t = i;
                        }
                    }
                  })(s, t),
                    (function (e, t) {
                      let r;
                      let i = [];
                      for (let e of t) {
                        let t = g.get(e);
                        if (1 === t) return;
                        if (t) {
                          let i = t.M.get(e);
                          if (
                            !(r = r ? r.filter((e) => i.has(e)) : U(i)).length
                          )
                            return;
                        } else i.push(e);
                      }
                      if (r) {
                        for (let t of r)
                          if (i.every((e) => L(t, e)))
                            throw Error(
                              `whole-script confusable: ${e.N}/${t.N}`
                            );
                      }
                    })(s, r),
                    (e = s.N);
                } else e = "Emoji";
              }
              n.type = e;
            } catch (e) {
              n.error = e;
            }
            return n;
          });
        })(e, M, K))
          .map(({ input: e, error: r, output: i }) => {
            if (r) {
              let i = r.message;
              throw Error(
                1 == t.length ? i : `Invalid label ${$(z(e, 63))}: ${i}`
              );
            }
            return x(i);
          })
          .join(".");
      }
    },
    14105: (e, t) => {
      "use strict";
      function r(e) {
        let {
            widthInt: t,
            heightInt: r,
            blurWidth: i,
            blurHeight: s,
            blurDataURL: n,
            objectFit: a,
          } = e,
          o = i ? 40 * i : t,
          c = s ? 40 * s : r,
          l = o && c ? "viewBox='0 0 " + o + " " + c + "'" : "";
        return (
          "%3Csvg xmlns='http://www.w3.org/2000/svg' " +
          l +
          "%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='" +
          (l
            ? "none"
            : "contain" === a
            ? "xMidYMid"
            : "cover" === a
            ? "xMidYMid slice"
            : "none") +
          "' style='filter: url(%23b);' href='" +
          n +
          "'/%3E%3C/svg%3E"
        );
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "getImageBlurSvg", {
          enumerable: !0,
          get: function () {
            return r;
          },
        });
    },
    14537: (e) => {
      "use strict";
      e.exports = { rE: "6.6.1" };
    },
    14744: (e, t, r) => {
      "use strict";
      r.d(t, { $: () => c });
      var i = r(1220),
        s = r(72880),
        n = r(29936);
      let a = {
          eip155: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
          solana: "a1b58899-f671-4276-6a5e-56ca5bd59700",
          polkadot: "",
          bip122: "0b4838db-0161-4ffe-022d-532bf03dba00",
        },
        o = (0, i.BX)({ networkImagePromises: {} }),
        c = {
          async fetchWalletImage(e) {
            if (e)
              return await s.N._fetchWalletImage(e), this.getWalletImageById(e);
          },
          async fetchNetworkImage(e) {
            if (!e) return;
            let t = this.getNetworkImageById(e);
            return (
              t ||
              (o.networkImagePromises[e] ||
                (o.networkImagePromises[e] = s.N._fetchNetworkImage(e)),
              await o.networkImagePromises[e],
              this.getNetworkImageById(e))
            );
          },
          getWalletImageById(e) {
            if (e) return n.j.state.walletImages[e];
          },
          getWalletImage: (e) =>
            e?.image_url
              ? e?.image_url
              : e?.image_id
              ? n.j.state.walletImages[e.image_id]
              : void 0,
          getNetworkImage: (e) =>
            e?.assets?.imageUrl
              ? e?.assets?.imageUrl
              : e?.assets?.imageId
              ? n.j.state.networkImages[e.assets.imageId]
              : void 0,
          getNetworkImageById(e) {
            if (e) return n.j.state.networkImages[e];
          },
          getConnectorImage: (e) =>
            e?.imageUrl
              ? e.imageUrl
              : e?.imageId
              ? n.j.state.connectorImages[e.imageId]
              : void 0,
          getChainImage: (e) => n.j.state.networkImages[a[e]],
        };
    },
    15612: (e, t, r) => {
      "use strict";
      var i = r(20920),
        s = r(40709);
      function n() {
        if (!(this instanceof n)) return new n();
        s.call(this),
          (this.h = [
            0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31,
            0x68581511, 0x64f98fa7, 0xbefa4fa4,
          ]);
      }
      i.inherits(n, s),
        (e.exports = n),
        (n.blockSize = 512),
        (n.outSize = 224),
        (n.hmacStrength = 192),
        (n.padLength = 64),
        (n.prototype._digest = function (e) {
          return "hex" === e
            ? i.toHex32(this.h.slice(0, 7), "big")
            : i.split32(this.h.slice(0, 7), "big");
        });
    },
    16459: (e) => {
      "use strict";
      var t,
        r = "object" == typeof Reflect ? Reflect : null,
        i =
          r && "function" == typeof r.apply
            ? r.apply
            : function (e, t, r) {
                return Function.prototype.apply.call(e, t, r);
              };
      t =
        r && "function" == typeof r.ownKeys
          ? r.ownKeys
          : Object.getOwnPropertySymbols
          ? function (e) {
              return Object.getOwnPropertyNames(e).concat(
                Object.getOwnPropertySymbols(e)
              );
            }
          : function (e) {
              return Object.getOwnPropertyNames(e);
            };
      var s =
        Number.isNaN ||
        function (e) {
          return e != e;
        };
      function n() {
        n.init.call(this);
      }
      (e.exports = n),
        (e.exports.once = function (e, t) {
          return new Promise(function (r, i) {
            var s, n, a;
            function o(r) {
              e.removeListener(t, c), i(r);
            }
            function c() {
              "function" == typeof e.removeListener &&
                e.removeListener("error", o),
                r([].slice.call(arguments));
            }
            g(e, t, c, { once: !0 }),
              "error" !== t &&
                ((s = e),
                (n = o),
                (a = { once: !0 }),
                "function" == typeof s.on && g(s, "error", n, a));
          });
        }),
        (n.EventEmitter = n),
        (n.prototype._events = void 0),
        (n.prototype._eventsCount = 0),
        (n.prototype._maxListeners = void 0);
      var a = 10;
      function o(e) {
        if ("function" != typeof e)
          throw TypeError(
            'The "listener" argument must be of type Function. Received type ' +
              typeof e
          );
      }
      function c(e) {
        return void 0 === e._maxListeners
          ? n.defaultMaxListeners
          : e._maxListeners;
      }
      function l(e, t, r, i) {
        if (
          (o(r),
          void 0 === (n = e._events)
            ? ((n = e._events = Object.create(null)), (e._eventsCount = 0))
            : (void 0 !== n.newListener &&
                (e.emit("newListener", t, r.listener ? r.listener : r),
                (n = e._events)),
              (a = n[t])),
          void 0 === a)
        )
          (a = n[t] = r), ++e._eventsCount;
        else if (
          ("function" == typeof a
            ? (a = n[t] = i ? [r, a] : [a, r])
            : i
            ? a.unshift(r)
            : a.push(r),
          (s = c(e)) > 0 && a.length > s && !a.warned)
        ) {
          a.warned = !0;
          var s,
            n,
            a,
            l = Error(
              "Possible EventEmitter memory leak detected. " +
                a.length +
                " " +
                String(t) +
                " listeners added. Use emitter.setMaxListeners() to increase limit"
            );
          (l.name = "MaxListenersExceededWarning"),
            (l.emitter = e),
            (l.type = t),
            (l.count = a.length),
            console && console.warn && console.warn(l);
        }
        return e;
      }
      function d() {
        if (!this.fired)
          return (this.target.removeListener(this.type, this.wrapFn),
          (this.fired = !0),
          0 == arguments.length)
            ? this.listener.call(this.target)
            : this.listener.apply(this.target, arguments);
      }
      function u(e, t, r) {
        var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r },
          s = d.bind(i);
        return (s.listener = r), (i.wrapFn = s), s;
      }
      function h(e, t, r) {
        var i = e._events;
        if (void 0 === i) return [];
        var s = i[t];
        return void 0 === s
          ? []
          : "function" == typeof s
          ? r
            ? [s.listener || s]
            : [s]
          : r
          ? (function (e) {
              for (var t = Array(e.length), r = 0; r < t.length; ++r)
                t[r] = e[r].listener || e[r];
              return t;
            })(s)
          : p(s, s.length);
      }
      function f(e) {
        var t = this._events;
        if (void 0 !== t) {
          var r = t[e];
          if ("function" == typeof r) return 1;
          if (void 0 !== r) return r.length;
        }
        return 0;
      }
      function p(e, t) {
        for (var r = Array(t), i = 0; i < t; ++i) r[i] = e[i];
        return r;
      }
      function g(e, t, r, i) {
        if ("function" == typeof e.on) i.once ? e.once(t, r) : e.on(t, r);
        else if ("function" == typeof e.addEventListener)
          e.addEventListener(t, function s(n) {
            i.once && e.removeEventListener(t, s), r(n);
          });
        else
          throw TypeError(
            'The "emitter" argument must be of type EventEmitter. Received type ' +
              typeof e
          );
      }
      Object.defineProperty(n, "defaultMaxListeners", {
        enumerable: !0,
        get: function () {
          return a;
        },
        set: function (e) {
          if ("number" != typeof e || e < 0 || s(e))
            throw RangeError(
              'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                e +
                "."
            );
          a = e;
        },
      }),
        (n.init = function () {
          (void 0 === this._events ||
            this._events === Object.getPrototypeOf(this)._events) &&
            ((this._events = Object.create(null)), (this._eventsCount = 0)),
            (this._maxListeners = this._maxListeners || void 0);
        }),
        (n.prototype.setMaxListeners = function (e) {
          if ("number" != typeof e || e < 0 || s(e))
            throw RangeError(
              'The value of "n" is out of range. It must be a non-negative number. Received ' +
                e +
                "."
            );
          return (this._maxListeners = e), this;
        }),
        (n.prototype.getMaxListeners = function () {
          return c(this);
        }),
        (n.prototype.emit = function (e) {
          for (var t = [], r = 1; r < arguments.length; r++)
            t.push(arguments[r]);
          var s = "error" === e,
            n = this._events;
          if (void 0 !== n) s = s && void 0 === n.error;
          else if (!s) return !1;
          if (s) {
            if ((t.length > 0 && (a = t[0]), a instanceof Error)) throw a;
            var a,
              o = Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
            throw ((o.context = a), o);
          }
          var c = n[e];
          if (void 0 === c) return !1;
          if ("function" == typeof c) i(c, this, t);
          else
            for (var l = c.length, d = p(c, l), r = 0; r < l; ++r)
              i(d[r], this, t);
          return !0;
        }),
        (n.prototype.addListener = function (e, t) {
          return l(this, e, t, !1);
        }),
        (n.prototype.on = n.prototype.addListener),
        (n.prototype.prependListener = function (e, t) {
          return l(this, e, t, !0);
        }),
        (n.prototype.once = function (e, t) {
          return o(t), this.on(e, u(this, e, t)), this;
        }),
        (n.prototype.prependOnceListener = function (e, t) {
          return o(t), this.prependListener(e, u(this, e, t)), this;
        }),
        (n.prototype.removeListener = function (e, t) {
          var r, i, s, n, a;
          if ((o(t), void 0 === (i = this._events) || void 0 === (r = i[e])))
            return this;
          if (r === t || r.listener === t)
            0 == --this._eventsCount
              ? (this._events = Object.create(null))
              : (delete i[e],
                i.removeListener &&
                  this.emit("removeListener", e, r.listener || t));
          else if ("function" != typeof r) {
            for (s = -1, n = r.length - 1; n >= 0; n--)
              if (r[n] === t || r[n].listener === t) {
                (a = r[n].listener), (s = n);
                break;
              }
            if (s < 0) return this;
            0 === s
              ? r.shift()
              : (function (e, t) {
                  for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                  e.pop();
                })(r, s),
              1 === r.length && (i[e] = r[0]),
              void 0 !== i.removeListener &&
                this.emit("removeListener", e, a || t);
          }
          return this;
        }),
        (n.prototype.off = n.prototype.removeListener),
        (n.prototype.removeAllListeners = function (e) {
          var t, r, i;
          if (void 0 === (r = this._events)) return this;
          if (void 0 === r.removeListener)
            return (
              0 == arguments.length
                ? ((this._events = Object.create(null)),
                  (this._eventsCount = 0))
                : void 0 !== r[e] &&
                  (0 == --this._eventsCount
                    ? (this._events = Object.create(null))
                    : delete r[e]),
              this
            );
          if (0 == arguments.length) {
            var s,
              n = Object.keys(r);
            for (i = 0; i < n.length; ++i)
              "removeListener" !== (s = n[i]) && this.removeAllListeners(s);
            return (
              this.removeAllListeners("removeListener"),
              (this._events = Object.create(null)),
              (this._eventsCount = 0),
              this
            );
          }
          if ("function" == typeof (t = r[e])) this.removeListener(e, t);
          else if (void 0 !== t)
            for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
          return this;
        }),
        (n.prototype.listeners = function (e) {
          return h(this, e, !0);
        }),
        (n.prototype.rawListeners = function (e) {
          return h(this, e, !1);
        }),
        (n.listenerCount = function (e, t) {
          return "function" == typeof e.listenerCount
            ? e.listenerCount(t)
            : f.call(e, t);
        }),
        (n.prototype.listenerCount = f),
        (n.prototype.eventNames = function () {
          return this._eventsCount > 0 ? t(this._events) : [];
        });
    },
    16871: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => s });
      var i = r(60587);
      function s(e) {
        return (0, i.q)(e, { strict: !1 })
          ? Math.ceil((e.length - 2) / 2)
          : e.length;
      }
    },
    17389: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => a });
      let i = {
        transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u,
        signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u,
      };
      var s = r(73537),
        n = r(22669);
      let a = {
        checkIfAllowedToTriggerEmail() {
          let e = n.o.get(s.s1.LAST_EMAIL_LOGIN_TIME);
          if (e) {
            let t = Date.now() - Number(e);
            if (t < 3e4) {
              let e = Math.ceil((3e4 - t) / 1e3);
              throw Error(`Please try again after ${e} seconds`);
            }
          }
        },
        getTimeToNextEmailLogin() {
          let e = n.o.get(s.s1.LAST_EMAIL_LOGIN_TIME);
          if (e) {
            let t = Date.now() - Number(e);
            if (t < 3e4) return Math.ceil((3e4 - t) / 1e3);
          }
          return 0;
        },
        checkIfRequestExists: (e) =>
          s.Vl.NOT_SAFE_RPC_METHODS.includes(e.method) ||
          s.Vl.SAFE_RPC_METHODS.includes(e.method),
        getResponseType: (e) =>
          "string" == typeof e &&
          (e?.match(i.transactionHash) || e?.match(i.signedMessage))
            ? s.s1.RPC_RESPONSE_TYPE_TX
            : s.s1.RPC_RESPONSE_TYPE_OBJECT,
        checkIfRequestIsSafe: (e) => s.Vl.SAFE_RPC_METHODS.includes(e.method),
        isClient: "undefined" != typeof window,
      };
    },
    17852: (e, t, r) => {
      "use strict";
      r.d(t, { TQ: () => a, ol: () => o, r9: () => n });
      var i = r(88487),
        s = r(458);
      function n(e, t, r) {
        return (e & t) ^ (~e & r);
      }
      function a(e, t, r) {
        return (e & t) ^ (e & r) ^ (t & r);
      }
      class o extends s.Vw {
        constructor(e, t, r, i) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = (0, s.O8)(this.buffer));
        }
        update(e) {
          (0, i.CC)(this);
          let { view: t, buffer: r, blockLen: n } = this,
            a = (e = (0, s.ZJ)(e)).length;
          for (let i = 0; i < a; ) {
            let o = Math.min(n - this.pos, a - i);
            if (o === n) {
              let t = (0, s.O8)(e);
              for (; n <= a - i; i += n) this.process(t, i);
              continue;
            }
            r.set(e.subarray(i, i + o), this.pos),
              (this.pos += o),
              (i += o),
              this.pos === n && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          (0, i.CC)(this), (0, i.Ht)(e, this), (this.finished = !0);
          let { buffer: t, view: r, blockLen: n, isLE: a } = this,
            { pos: o } = this;
          (t[o++] = 128),
            this.buffer.subarray(o).fill(0),
            this.padOffset > n - o && (this.process(r, 0), (o = 0));
          for (let e = o; e < n; e++) t[e] = 0;
          !(function (e, t, r, i) {
            if ("function" == typeof e.setBigUint64)
              return e.setBigUint64(t, r, i);
            let s = BigInt(32),
              n = BigInt(0xffffffff),
              a = Number((r >> s) & n),
              o = Number(r & n),
              c = 4 * !!i,
              l = 4 * !i;
            e.setUint32(t + c, a, i), e.setUint32(t + l, o, i);
          })(r, n - 8, BigInt(8 * this.length), a),
            this.process(r, 0);
          let c = (0, s.O8)(e),
            l = this.outputLen;
          if (l % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
          let d = l / 4,
            u = this.get();
          if (d > u.length) throw Error("_sha2: outputLen bigger than state");
          for (let e = 0; e < d; e++) c.setUint32(4 * e, u[e], a);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: s,
            destroyed: n,
            pos: a,
          } = this;
          return (
            (e.length = i),
            (e.pos = a),
            (e.finished = s),
            (e.destroyed = n),
            i % t && e.buffer.set(r),
            e
          );
        }
      }
    },
    17891: (e, t, r) => {
      "use strict";
      var i = r(19670),
        s = r(95119),
        n = r(3285);
      function a(e) {
        if (!(this instanceof a)) return new a(e);
        (this.hash = e.hash),
          (this.predResist = !!e.predResist),
          (this.outLen = this.hash.outSize),
          (this.minEntropy = e.minEntropy || this.hash.hmacStrength),
          (this._reseed = null),
          (this.reseedInterval = null),
          (this.K = null),
          (this.V = null);
        var t = s.toArray(e.entropy, e.entropyEnc || "hex"),
          r = s.toArray(e.nonce, e.nonceEnc || "hex"),
          i = s.toArray(e.pers, e.persEnc || "hex");
        n(
          t.length >= this.minEntropy / 8,
          "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
        ),
          this._init(t, r, i);
      }
      (e.exports = a),
        (a.prototype._init = function (e, t, r) {
          var i = e.concat(t).concat(r);
          (this.K = Array(this.outLen / 8)), (this.V = Array(this.outLen / 8));
          for (var s = 0; s < this.V.length; s++)
            (this.K[s] = 0), (this.V[s] = 1);
          this._update(i),
            (this._reseed = 1),
            (this.reseedInterval = 0x1000000000000);
        }),
        (a.prototype._hmac = function () {
          return new i.hmac(this.hash, this.K);
        }),
        (a.prototype._update = function (e) {
          var t = this._hmac().update(this.V).update([0]);
          e && (t = t.update(e)),
            (this.K = t.digest()),
            (this.V = this._hmac().update(this.V).digest()),
            e &&
              ((this.K = this._hmac()
                .update(this.V)
                .update([1])
                .update(e)
                .digest()),
              (this.V = this._hmac().update(this.V).digest()));
        }),
        (a.prototype.reseed = function (e, t, r, i) {
          "string" != typeof t && ((i = r), (r = t), (t = null)),
            (e = s.toArray(e, t)),
            (r = s.toArray(r, i)),
            n(
              e.length >= this.minEntropy / 8,
              "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
            ),
            this._update(e.concat(r || [])),
            (this._reseed = 1);
        }),
        (a.prototype.generate = function (e, t, r, i) {
          if (this._reseed > this.reseedInterval)
            throw Error("Reseed is required");
          "string" != typeof t && ((i = r), (r = t), (t = null)),
            r && ((r = s.toArray(r, i || "hex")), this._update(r));
          for (var n = []; n.length < e; )
            (this.V = this._hmac().update(this.V).digest()),
              (n = n.concat(this.V));
          var a = n.slice(0, e);
          return this._update(r), this._reseed++, s.encode(a, t);
        });
    },
    18085: function (e) {
      e.exports = function (e, t, r) {
        r.updateLocale = function (e, t) {
          var i = r.Ls[e];
          if (i)
            return (
              (t ? Object.keys(t) : []).forEach(function (e) {
                i[e] = t[e];
              }),
              i
            );
        };
      };
    },
    18635: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => d });
      var i = r(55480),
        s = r(66254),
        n = r(58653),
        a = r(12319),
        o = r(72880),
        c = r(48981),
        l = r(91867);
      let d = {
        filterOutDuplicatesByRDNS(e) {
          let t = i.H.state.enableEIP6963 ? s.a.state.connectors : [],
            r = n.i.getRecentWallets(),
            o = t.map((e) => e.info?.rdns).filter(Boolean),
            c = r.map((e) => e.rdns).filter(Boolean),
            l = o.concat(c);
          if (l.includes("io.metamask.mobile") && a.w.isMobile()) {
            let e = l.indexOf("io.metamask.mobile");
            l[e] = "io.metamask";
          }
          return e.filter((e) => !l.includes(String(e?.rdns)));
        },
        filterOutDuplicatesByIds(e) {
          let t = s.a.state.connectors.filter(
              (e) => "ANNOUNCED" === e.type || "INJECTED" === e.type
            ),
            r = n.i.getRecentWallets(),
            i = t.map((e) => e.explorerId),
            a = r.map((e) => e.id),
            o = i.concat(a);
          return e.filter((e) => !o.includes(e?.id));
        },
        filterOutDuplicateWallets(e) {
          let t = this.filterOutDuplicatesByRDNS(e);
          return this.filterOutDuplicatesByIds(t);
        },
        markWalletsAsInstalled(e) {
          let { connectors: t } = s.a.state,
            r = t
              .filter((e) => "ANNOUNCED" === e.type)
              .reduce((e, t) => (t.info?.rdns && (e[t.info.rdns] = !0), e), {});
          return e
            .map((e) => ({ ...e, installed: !!e.rdns && !!r[e.rdns ?? ""] }))
            .sort((e, t) => Number(t.installed) - Number(e.installed));
        },
        getConnectOrderMethod(e, t) {
          let r =
              e?.connectMethodsOrder || i.H.state.features?.connectMethodsOrder,
            n = t || s.a.state.connectors;
          if (r) return r;
          let { injected: a, announced: d } = c.g.getConnectorsByType(
              n,
              o.N.state.recommended,
              o.N.state.featured
            ),
            u = a.filter(c.g.showConnector),
            h = d.filter(c.g.showConnector);
          return u.length || h.length
            ? ["wallet", "email", "social"]
            : l.o.DEFAULT_CONNECT_METHOD_ORDER;
        },
      };
    },
    19511: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.IWatch = void 0);
      class r {}
      t.IWatch = r;
    },
    19670: (e, t, r) => {
      (t.utils = r(20920)),
        (t.common = r(64874)),
        (t.sha = r(47887)),
        (t.ripemd = r(20036)),
        (t.hmac = r(46524)),
        (t.sha1 = t.sha.sha1),
        (t.sha256 = t.sha.sha256),
        (t.sha224 = t.sha.sha224),
        (t.sha384 = t.sha.sha384),
        (t.sha512 = t.sha.sha512),
        (t.ripemd160 = t.ripemd.ripemd160);
    },
    20034: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => s });
      var i = r(53473);
      function s(e, t = {}) {
        let {
          key: r = "custom",
          methods: n,
          name: a = "Custom Provider",
          retryDelay: o,
        } = t;
        return ({ retryCount: s }) =>
          (0, i.o)({
            key: r,
            methods: n,
            name: a,
            request: e.request.bind(e),
            retryCount: t.retryCount ?? s,
            retryDelay: o,
            type: "custom",
          });
      }
    },
    20036: (e, t, r) => {
      "use strict";
      var i = r(20920),
        s = r(64874),
        n = i.rotl32,
        a = i.sum32,
        o = i.sum32_3,
        c = i.sum32_4,
        l = s.BlockHash;
      function d() {
        if (!(this instanceof d)) return new d();
        l.call(this),
          (this.h = [
            0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,
          ]),
          (this.endian = "little");
      }
      function u(e, t, r, i) {
        return e <= 15
          ? t ^ r ^ i
          : e <= 31
          ? (t & r) | (~t & i)
          : e <= 47
          ? (t | ~r) ^ i
          : e <= 63
          ? (t & i) | (r & ~i)
          : t ^ (r | ~i);
      }
      i.inherits(d, l),
        (t.ripemd160 = d),
        (d.blockSize = 512),
        (d.outSize = 160),
        (d.hmacStrength = 192),
        (d.padLength = 64),
        (d.prototype._update = function (e, t) {
          for (
            var r = this.h[0],
              i = this.h[1],
              s = this.h[2],
              l = this.h[3],
              d = this.h[4],
              m = r,
              b = i,
              y = s,
              w = l,
              v = d,
              A = 0;
            A < 80;
            A++
          ) {
            var E,
              _,
              C = a(
                n(
                  c(
                    r,
                    u(A, i, s, l),
                    e[h[A] + t],
                    (E = A) <= 15
                      ? 0
                      : E <= 31
                      ? 0x5a827999
                      : E <= 47
                      ? 0x6ed9eba1
                      : E <= 63
                      ? 0x8f1bbcdc
                      : 0xa953fd4e
                  ),
                  p[A]
                ),
                d
              );
            (r = d),
              (d = l),
              (l = n(s, 10)),
              (s = i),
              (i = C),
              (C = a(
                n(
                  c(
                    m,
                    u(79 - A, b, y, w),
                    e[f[A] + t],
                    (_ = A) <= 15
                      ? 0x50a28be6
                      : _ <= 31
                      ? 0x5c4dd124
                      : _ <= 47
                      ? 0x6d703ef3
                      : 0x7a6d76e9 * !!(_ <= 63)
                  ),
                  g[A]
                ),
                v
              )),
              (m = v),
              (v = w),
              (w = n(y, 10)),
              (y = b),
              (b = C);
          }
          (C = o(this.h[1], s, w)),
            (this.h[1] = o(this.h[2], l, v)),
            (this.h[2] = o(this.h[3], d, m)),
            (this.h[3] = o(this.h[4], r, b)),
            (this.h[4] = o(this.h[0], i, y)),
            (this.h[0] = C);
        }),
        (d.prototype._digest = function (e) {
          return "hex" === e
            ? i.toHex32(this.h, "little")
            : i.split32(this.h, "little");
        });
      var h = [
          0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10,
          6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7,
          0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5,
          6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
        ],
        f = [
          5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0,
          13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8,
          12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10,
          14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
        ],
        p = [
          11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13,
          11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13,
          15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5,
          6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5,
          6,
        ],
        g = [
          8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7,
          12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14,
          12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9,
          12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,
        ];
    },
    20390: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => i });
      class i extends Map {
        constructor(e) {
          super(),
            Object.defineProperty(this, "maxSize", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.maxSize = e);
        }
        get(e) {
          let t = super.get(e);
          return (
            super.has(e) && void 0 !== t && (this.delete(e), super.set(e, t)), t
          );
        }
        set(e, t) {
          if ((super.set(e, t), this.maxSize && this.size > this.maxSize)) {
            let e = this.keys().next().value;
            e && this.delete(e);
          }
          return this;
        }
      }
    },
    20821: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        !(function (e, t) {
          for (var r in t)
            Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
        })(t, {
          VALID_LOADERS: function () {
            return r;
          },
          imageConfigDefault: function () {
            return i;
          },
        });
      let r = ["default", "imgix", "cloudinary", "akamai", "custom"],
        i = {
          deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
          imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
          path: "/_next/image",
          loader: "default",
          loaderFile: "",
          domains: [],
          disableStaticImages: !1,
          minimumCacheTTL: 60,
          formats: ["image/webp"],
          dangerouslyAllowSVG: !1,
          contentSecurityPolicy:
            "script-src 'none'; frame-src 'none'; sandbox;",
          contentDispositionType: "attachment",
          localPatterns: void 0,
          remotePatterns: [],
          qualities: void 0,
          unoptimized: !1,
        };
    },
    20852: (e, t, r) => {
      "use strict";
      r.d(t, { Cq: () => tx, FA: () => tT, TZ: () => tN, UF: () => tS });
      var i = r(5566),
        s = r(25042);
      function n(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function a(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      let o =
          "object" == typeof globalThis && "crypto" in globalThis
            ? globalThis.crypto
            : void 0,
        c = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
      function l(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e)
                throw Error("utf8ToBytes expected string, got " + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          n(e),
          e
        );
      }
      class d {
        clone() {
          return this._cloneInto();
        }
      }
      function u(e = 32) {
        if (o && "function" == typeof o.getRandomValues)
          return o.getRandomValues(new Uint8Array(e));
        if (o && "function" == typeof o.randomBytes) return o.randomBytes(e);
        throw Error("crypto.getRandomValues must be defined");
      }
      class h extends d {
        constructor(e, t, r, i) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = c(this.buffer));
        }
        update(e) {
          a(this);
          let { view: t, buffer: r, blockLen: i } = this,
            s = (e = l(e)).length;
          for (let n = 0; n < s; ) {
            let a = Math.min(i - this.pos, s - n);
            if (a === i) {
              let t = c(e);
              for (; i <= s - n; n += i) this.process(t, n);
              continue;
            }
            r.set(e.subarray(n, n + a), this.pos),
              (this.pos += a),
              (n += a),
              this.pos === i && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          a(this),
            (function (e, t) {
              n(e);
              let r = t.outputLen;
              if (e.length < r)
                throw Error(
                  "digestInto() expects output buffer of length at least " + r
                );
            })(e, this),
            (this.finished = !0);
          let { buffer: t, view: r, blockLen: i, isLE: s } = this,
            { pos: o } = this;
          (t[o++] = 128),
            this.buffer.subarray(o).fill(0),
            this.padOffset > i - o && (this.process(r, 0), (o = 0));
          for (let e = o; e < i; e++) t[e] = 0;
          (function (e, t, r, i) {
            if ("function" == typeof e.setBigUint64)
              return e.setBigUint64(t, r, i);
            let s = BigInt(32),
              n = BigInt(0xffffffff),
              a = Number((r >> s) & n),
              o = Number(r & n),
              c = 4 * !!i,
              l = 4 * !i;
            e.setUint32(t + c, a, i), e.setUint32(t + l, o, i);
          })(r, i - 8, BigInt(8 * this.length), s),
            this.process(r, 0);
          let l = c(e),
            d = this.outputLen;
          if (d % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
          let u = d / 4,
            h = this.get();
          if (u > h.length) throw Error("_sha2: outputLen bigger than state");
          for (let e = 0; e < u; e++) l.setUint32(4 * e, h[e], s);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: s,
            destroyed: n,
            pos: a,
          } = this;
          return (
            (e.length = i),
            (e.pos = a),
            (e.finished = s),
            (e.destroyed = n),
            i % t && e.buffer.set(r),
            e
          );
        }
      }
      let f = BigInt(0x100000000 - 1),
        p = BigInt(32),
        g = {
          split: function (e, t = !1) {
            let r = new Uint32Array(e.length),
              i = new Uint32Array(e.length);
            for (let s = 0; s < e.length; s++) {
              let { h: n, l: a } = (function (e, t = !1) {
                return t
                  ? { h: Number(e & f), l: Number((e >> p) & f) }
                  : { h: 0 | Number((e >> p) & f), l: 0 | Number(e & f) };
              })(e[s], t);
              [r[s], i[s]] = [n, a];
            }
            return [r, i];
          },
          shrSH: (e, t, r) => e >>> r,
          shrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
          rotrSH: (e, t, r) => (e >>> r) | (t << (32 - r)),
          rotrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
          rotrBH: (e, t, r) => (e << (64 - r)) | (t >>> (r - 32)),
          rotrBL: (e, t, r) => (e >>> (r - 32)) | (t << (64 - r)),
          add: function (e, t, r, i) {
            let s = (t >>> 0) + (i >>> 0);
            return { h: (e + r + ((s / 0x100000000) | 0)) | 0, l: 0 | s };
          },
          add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),
          add3H: (e, t, r, i) => (t + r + i + ((e / 0x100000000) | 0)) | 0,
          add4L: (e, t, r, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0),
          add4H: (e, t, r, i, s) =>
            (t + r + i + s + ((e / 0x100000000) | 0)) | 0,
          add5H: (e, t, r, i, s, n) =>
            (t + r + i + s + n + ((e / 0x100000000) | 0)) | 0,
          add5L: (e, t, r, i, s) =>
            (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0) + (s >>> 0),
        },
        [m, b] = g.split(
          [
            "0x428a2f98d728ae22",
            "0x7137449123ef65cd",
            "0xb5c0fbcfec4d3b2f",
            "0xe9b5dba58189dbbc",
            "0x3956c25bf348b538",
            "0x59f111f1b605d019",
            "0x923f82a4af194f9b",
            "0xab1c5ed5da6d8118",
            "0xd807aa98a3030242",
            "0x12835b0145706fbe",
            "0x243185be4ee4b28c",
            "0x550c7dc3d5ffb4e2",
            "0x72be5d74f27b896f",
            "0x80deb1fe3b1696b1",
            "0x9bdc06a725c71235",
            "0xc19bf174cf692694",
            "0xe49b69c19ef14ad2",
            "0xefbe4786384f25e3",
            "0x0fc19dc68b8cd5b5",
            "0x240ca1cc77ac9c65",
            "0x2de92c6f592b0275",
            "0x4a7484aa6ea6e483",
            "0x5cb0a9dcbd41fbd4",
            "0x76f988da831153b5",
            "0x983e5152ee66dfab",
            "0xa831c66d2db43210",
            "0xb00327c898fb213f",
            "0xbf597fc7beef0ee4",
            "0xc6e00bf33da88fc2",
            "0xd5a79147930aa725",
            "0x06ca6351e003826f",
            "0x142929670a0e6e70",
            "0x27b70a8546d22ffc",
            "0x2e1b21385c26c926",
            "0x4d2c6dfc5ac42aed",
            "0x53380d139d95b3df",
            "0x650a73548baf63de",
            "0x766a0abb3c77b2a8",
            "0x81c2c92e47edaee6",
            "0x92722c851482353b",
            "0xa2bfe8a14cf10364",
            "0xa81a664bbc423001",
            "0xc24b8b70d0f89791",
            "0xc76c51a30654be30",
            "0xd192e819d6ef5218",
            "0xd69906245565a910",
            "0xf40e35855771202a",
            "0x106aa07032bbd1b8",
            "0x19a4c116b8d2d0c8",
            "0x1e376c085141ab53",
            "0x2748774cdf8eeb99",
            "0x34b0bcb5e19b48a8",
            "0x391c0cb3c5c95a63",
            "0x4ed8aa4ae3418acb",
            "0x5b9cca4f7763e373",
            "0x682e6ff3d6b2b8a3",
            "0x748f82ee5defb2fc",
            "0x78a5636f43172f60",
            "0x84c87814a1f0ab72",
            "0x8cc702081a6439ec",
            "0x90befffa23631e28",
            "0xa4506cebde82bde9",
            "0xbef9a3f7b2c67915",
            "0xc67178f2e372532b",
            "0xca273eceea26619c",
            "0xd186b8c721c0c207",
            "0xeada7dd6cde0eb1e",
            "0xf57d4f7fee6ed178",
            "0x06f067aa72176fba",
            "0x0a637dc5a2c898a6",
            "0x113f9804bef90dae",
            "0x1b710b35131c471b",
            "0x28db77f523047d84",
            "0x32caab7b40c72493",
            "0x3c9ebe0a15c9bebc",
            "0x431d67c49c100d4c",
            "0x4cc5d4becb3e42b6",
            "0x597f299cfc657e2a",
            "0x5fcb6fab3ad6faec",
            "0x6c44198c4a475817",
          ].map((e) => BigInt(e))
        ),
        y = new Uint32Array(80),
        w = new Uint32Array(80);
      class v extends h {
        constructor() {
          super(128, 64, 16, !1),
            (this.Ah = 0x6a09e667),
            (this.Al = -0xc4336f8),
            (this.Bh = -0x4498517b),
            (this.Bl = -0x7b3558c5),
            (this.Ch = 0x3c6ef372),
            (this.Cl = -0x16b07d5),
            (this.Dh = -0x5ab00ac6),
            (this.Dl = 0x5f1d36f1),
            (this.Eh = 0x510e527f),
            (this.El = -0x52197d2f),
            (this.Fh = -0x64fa9774),
            (this.Fl = 0x2b3e6c1f),
            (this.Gh = 0x1f83d9ab),
            (this.Gl = -0x4be4295),
            (this.Hh = 0x5be0cd19),
            (this.Hl = 0x137e2179);
        }
        get() {
          let {
            Ah: e,
            Al: t,
            Bh: r,
            Bl: i,
            Ch: s,
            Cl: n,
            Dh: a,
            Dl: o,
            Eh: c,
            El: l,
            Fh: d,
            Fl: u,
            Gh: h,
            Gl: f,
            Hh: p,
            Hl: g,
          } = this;
          return [e, t, r, i, s, n, a, o, c, l, d, u, h, f, p, g];
        }
        set(e, t, r, i, s, n, a, o, c, l, d, u, h, f, p, g) {
          (this.Ah = 0 | e),
            (this.Al = 0 | t),
            (this.Bh = 0 | r),
            (this.Bl = 0 | i),
            (this.Ch = 0 | s),
            (this.Cl = 0 | n),
            (this.Dh = 0 | a),
            (this.Dl = 0 | o),
            (this.Eh = 0 | c),
            (this.El = 0 | l),
            (this.Fh = 0 | d),
            (this.Fl = 0 | u),
            (this.Gh = 0 | h),
            (this.Gl = 0 | f),
            (this.Hh = 0 | p),
            (this.Hl = 0 | g);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4)
            (y[r] = e.getUint32(t)), (w[r] = e.getUint32((t += 4)));
          for (let e = 16; e < 80; e++) {
            let t = 0 | y[e - 15],
              r = 0 | w[e - 15],
              i = g.rotrSH(t, r, 1) ^ g.rotrSH(t, r, 8) ^ g.shrSH(t, r, 7),
              s = g.rotrSL(t, r, 1) ^ g.rotrSL(t, r, 8) ^ g.shrSL(t, r, 7),
              n = 0 | y[e - 2],
              a = 0 | w[e - 2],
              o = g.rotrSH(n, a, 19) ^ g.rotrBH(n, a, 61) ^ g.shrSH(n, a, 6),
              c = g.rotrSL(n, a, 19) ^ g.rotrBL(n, a, 61) ^ g.shrSL(n, a, 6),
              l = g.add4L(s, c, w[e - 7], w[e - 16]),
              d = g.add4H(l, i, o, y[e - 7], y[e - 16]);
            (y[e] = 0 | d), (w[e] = 0 | l);
          }
          let {
            Ah: r,
            Al: i,
            Bh: s,
            Bl: n,
            Ch: a,
            Cl: o,
            Dh: c,
            Dl: l,
            Eh: d,
            El: u,
            Fh: h,
            Fl: f,
            Gh: p,
            Gl: v,
            Hh: A,
            Hl: E,
          } = this;
          for (let e = 0; e < 80; e++) {
            let t =
                g.rotrSH(d, u, 14) ^ g.rotrSH(d, u, 18) ^ g.rotrBH(d, u, 41),
              _ = g.rotrSL(d, u, 14) ^ g.rotrSL(d, u, 18) ^ g.rotrBL(d, u, 41),
              C = (d & h) ^ (~d & p),
              I = (u & f) ^ (~u & v),
              S = g.add5L(E, _, I, b[e], w[e]),
              x = g.add5H(S, A, t, C, m[e], y[e]),
              N = 0 | S,
              T = g.rotrSH(r, i, 28) ^ g.rotrBH(r, i, 34) ^ g.rotrBH(r, i, 39),
              P = g.rotrSL(r, i, 28) ^ g.rotrBL(r, i, 34) ^ g.rotrBL(r, i, 39),
              O = (r & s) ^ (r & a) ^ (s & a),
              k = (i & n) ^ (i & o) ^ (n & o);
            (A = 0 | p),
              (E = 0 | v),
              (p = 0 | h),
              (v = 0 | f),
              (h = 0 | d),
              (f = 0 | u),
              ({ h: d, l: u } = g.add(0 | c, 0 | l, 0 | x, 0 | N)),
              (c = 0 | a),
              (l = 0 | o),
              (a = 0 | s),
              (o = 0 | n),
              (s = 0 | r),
              (n = 0 | i);
            let R = g.add3L(N, P, k);
            (r = g.add3H(R, x, T, O)), (i = 0 | R);
          }
          ({ h: r, l: i } = g.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | i)),
            ({ h: s, l: n } = g.add(0 | this.Bh, 0 | this.Bl, 0 | s, 0 | n)),
            ({ h: a, l: o } = g.add(0 | this.Ch, 0 | this.Cl, 0 | a, 0 | o)),
            ({ h: c, l: l } = g.add(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l)),
            ({ h: d, l: u } = g.add(0 | this.Eh, 0 | this.El, 0 | d, 0 | u)),
            ({ h: h, l: f } = g.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | f)),
            ({ h: p, l: v } = g.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | v)),
            ({ h: A, l: E } = g.add(0 | this.Hh, 0 | this.Hl, 0 | A, 0 | E)),
            this.set(r, i, s, n, a, o, c, l, d, u, h, f, p, v, A, E);
        }
        roundClean() {
          y.fill(0), w.fill(0);
        }
        destroy() {
          this.buffer.fill(0),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
      let A = (function (e) {
          let t = (t) => e().update(l(t)).digest(),
            r = e();
          return (
            (t.outputLen = r.outputLen),
            (t.blockLen = r.blockLen),
            (t.create = () => e()),
            t
          );
        })(() => new v()),
        E = BigInt(0),
        _ = BigInt(1),
        C = BigInt(2);
      function I(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function S(e) {
        if (!I(e)) throw Error("Uint8Array expected");
      }
      function x(e, t) {
        if ("boolean" != typeof t)
          throw Error(e + " boolean expected, got " + t);
      }
      let N = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function T(e) {
        S(e);
        let t = "";
        for (let r = 0; r < e.length; r++) t += N[e[r]];
        return t;
      }
      function P(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        return "" === e ? E : BigInt("0x" + e);
      }
      let O = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function k(e) {
        return e >= O._0 && e <= O._9
          ? e - O._0
          : e >= O.A && e <= O.F
          ? e - (O.A - 10)
          : e >= O.a && e <= O.f
          ? e - (O.a - 10)
          : void 0;
      }
      function R(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        let t = e.length,
          r = t / 2;
        if (t % 2)
          throw Error("hex string expected, got unpadded hex of length " + t);
        let i = new Uint8Array(r);
        for (let t = 0, s = 0; t < r; t++, s += 2) {
          let r = k(e.charCodeAt(s)),
            n = k(e.charCodeAt(s + 1));
          if (void 0 === r || void 0 === n)
            throw Error(
              'hex string expected, got non-hex character "' +
                (e[s] + e[s + 1]) +
                '" at index ' +
                s
            );
          i[t] = 16 * r + n;
        }
        return i;
      }
      function D(e) {
        return S(e), P(T(Uint8Array.from(e).reverse()));
      }
      function M(e, t) {
        return R(e.toString(16).padStart(2 * t, "0"));
      }
      function U(e, t) {
        return M(e, t).reverse();
      }
      function L(e, t, r) {
        let i;
        if ("string" == typeof t)
          try {
            i = R(t);
          } catch (t) {
            throw Error(e + " must be hex string or Uint8Array, cause: " + t);
          }
        else if (I(t)) i = Uint8Array.from(t);
        else throw Error(e + " must be hex string or Uint8Array");
        let s = i.length;
        if ("number" == typeof r && s !== r)
          throw Error(e + " of length " + r + " expected, got " + s);
        return i;
      }
      function B(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
          let i = e[r];
          S(i), (t += i.length);
        }
        let r = new Uint8Array(t);
        for (let t = 0, i = 0; t < e.length; t++) {
          let s = e[t];
          r.set(s, i), (i += s.length);
        }
        return r;
      }
      let j = (e) => "bigint" == typeof e && E <= e;
      function F(e, t, r, i) {
        if (!(j(t) && j(r) && j(i)) || !(r <= t) || !(t < i))
          throw Error(
            "expected valid " + e + ": " + r + " <= n < " + i + ", got " + t
          );
      }
      let $ = (e) => (C << BigInt(e - 1)) - _,
        z = {
          bigint: (e) => "bigint" == typeof e,
          function: (e) => "function" == typeof e,
          boolean: (e) => "boolean" == typeof e,
          string: (e) => "string" == typeof e,
          stringOrUint8Array: (e) => "string" == typeof e || I(e),
          isSafeInteger: (e) => Number.isSafeInteger(e),
          array: (e) => Array.isArray(e),
          field: (e, t) => t.Fp.isValid(e),
          hash: (e) =>
            "function" == typeof e && Number.isSafeInteger(e.outputLen),
        };
      function W(e, t, r = {}) {
        let i = (t, r, i) => {
          let s = z[r];
          if ("function" != typeof s) throw Error("invalid validator function");
          let n = e[t];
          if (!(i && void 0 === n) && !s(n, e))
            throw Error(
              "param " + String(t) + " is invalid. Expected " + r + ", got " + n
            );
        };
        for (let [e, r] of Object.entries(t)) i(e, r, !1);
        for (let [e, t] of Object.entries(r)) i(e, t, !0);
        return e;
      }
      function H(e) {
        let t = new WeakMap();
        return (r, ...i) => {
          let s = t.get(r);
          if (void 0 !== s) return s;
          let n = e(r, ...i);
          return t.set(r, n), n;
        };
      }
      let q = BigInt(0),
        V = BigInt(1),
        K = BigInt(2),
        G = BigInt(3),
        Y = BigInt(4),
        Q = BigInt(5),
        Z = BigInt(8);
      function J(e, t) {
        let r = e % t;
        return r >= q ? r : t + r;
      }
      function X(e, t, r) {
        let i = e;
        for (; t-- > q; ) (i *= i), (i %= r);
        return i;
      }
      function ee(e, t) {
        if (e === q) throw Error("invert: expected non-zero number");
        if (t <= q) throw Error("invert: expected positive modulus, got " + t);
        let r = J(e, t),
          i = t,
          s = q,
          n = V;
        for (; r !== q; ) {
          let e = i / r,
            t = i % r,
            a = s - n * e;
          (i = r), (r = t), (s = n), (n = a);
        }
        if (i !== V) throw Error("invert: does not exist");
        return J(s, t);
      }
      let et = (e, t) => (J(e, t) & V) === V,
        er = [
          "create",
          "isValid",
          "is0",
          "neg",
          "inv",
          "sqrt",
          "sqr",
          "eql",
          "add",
          "sub",
          "mul",
          "pow",
          "div",
          "addN",
          "subN",
          "mulN",
          "sqrN",
        ];
      function ei(e, t) {
        let r = void 0 !== t ? t : e.toString(2).length,
          i = Math.ceil(r / 8);
        return { nBitLength: r, nByteLength: i };
      }
      function es(e, t, r = !1, i = {}) {
        let s;
        if (e <= q) throw Error("invalid field: expected ORDER > 0, got " + e);
        let { nBitLength: n, nByteLength: a } = ei(e, t);
        if (a > 2048)
          throw Error("invalid field: expected ORDER of <= 2048 bytes");
        let o = Object.freeze({
          ORDER: e,
          isLE: r,
          BITS: n,
          BYTES: a,
          MASK: $(n),
          ZERO: q,
          ONE: V,
          create: (t) => J(t, e),
          isValid: (t) => {
            if ("bigint" != typeof t)
              throw Error(
                "invalid field element: expected bigint, got " + typeof t
              );
            return q <= t && t < e;
          },
          is0: (e) => e === q,
          isOdd: (e) => (e & V) === V,
          neg: (t) => J(-t, e),
          eql: (e, t) => e === t,
          sqr: (t) => J(t * t, e),
          add: (t, r) => J(t + r, e),
          sub: (t, r) => J(t - r, e),
          mul: (t, r) => J(t * r, e),
          pow: (e, t) =>
            (function (e, t, r) {
              if (r < q) throw Error("invalid exponent, negatives unsupported");
              if (r === q) return e.ONE;
              if (r === V) return t;
              let i = e.ONE,
                s = t;
              for (; r > q; )
                r & V && (i = e.mul(i, s)), (s = e.sqr(s)), (r >>= V);
              return i;
            })(o, e, t),
          div: (t, r) => J(t * ee(r, e), e),
          sqrN: (e) => e * e,
          addN: (e, t) => e + t,
          subN: (e, t) => e - t,
          mulN: (e, t) => e * t,
          inv: (t) => ee(t, e),
          sqrt:
            i.sqrt ||
            ((t) => (
              s ||
                (s = (function (e) {
                  if (e % Y === G) {
                    let t = (e + V) / Y;
                    return function (e, r) {
                      let i = e.pow(r, t);
                      if (!e.eql(e.sqr(i), r))
                        throw Error("Cannot find square root");
                      return i;
                    };
                  }
                  if (e % Z === Q) {
                    let t = (e - Q) / Z;
                    return function (e, r) {
                      let i = e.mul(r, K),
                        s = e.pow(i, t),
                        n = e.mul(r, s),
                        a = e.mul(e.mul(n, K), s),
                        o = e.mul(n, e.sub(a, e.ONE));
                      if (!e.eql(e.sqr(o), r))
                        throw Error("Cannot find square root");
                      return o;
                    };
                  }
                  return (function (e) {
                    let t, r, i;
                    let s = (e - V) / K;
                    for (t = e - V, r = 0; t % K === q; t /= K, r++);
                    for (
                      i = K;
                      i < e &&
                      (function (e, t, r) {
                        if (t < q)
                          throw Error(
                            "invalid exponent, negatives unsupported"
                          );
                        if (r <= q) throw Error("invalid modulus");
                        if (r === V) return q;
                        let i = V;
                        for (; t > q; )
                          t & V && (i = (i * e) % r),
                            (e = (e * e) % r),
                            (t >>= V);
                        return i;
                      })(i, s, e) !==
                        e - V;
                      i++
                    )
                      if (i > 1e3)
                        throw Error(
                          "Cannot find square root: likely non-prime P"
                        );
                    if (1 === r) {
                      let t = (e + V) / Y;
                      return function (e, r) {
                        let i = e.pow(r, t);
                        if (!e.eql(e.sqr(i), r))
                          throw Error("Cannot find square root");
                        return i;
                      };
                    }
                    let n = (t + V) / K;
                    return function (e, a) {
                      if (e.pow(a, s) === e.neg(e.ONE))
                        throw Error("Cannot find square root");
                      let o = r,
                        c = e.pow(e.mul(e.ONE, i), t),
                        l = e.pow(a, n),
                        d = e.pow(a, t);
                      for (; !e.eql(d, e.ONE); ) {
                        if (e.eql(d, e.ZERO)) return e.ZERO;
                        let t = 1;
                        for (let r = e.sqr(d); t < o && !e.eql(r, e.ONE); t++)
                          r = e.sqr(r);
                        let r = e.pow(c, V << BigInt(o - t - 1));
                        (c = e.sqr(r)),
                          (l = e.mul(l, r)),
                          (d = e.mul(d, c)),
                          (o = t);
                      }
                      return l;
                    };
                  })(e);
                })(e)),
              s(o, t)
            )),
          invertBatch: (e) =>
            (function (e, t) {
              let r = Array(t.length),
                i = t.reduce(
                  (t, i, s) => (e.is0(i) ? t : ((r[s] = t), e.mul(t, i))),
                  e.ONE
                ),
                s = e.inv(i);
              return (
                t.reduceRight(
                  (t, i, s) =>
                    e.is0(i) ? t : ((r[s] = e.mul(t, r[s])), e.mul(t, i)),
                  s
                ),
                r
              );
            })(o, e),
          cmov: (e, t, r) => (r ? t : e),
          toBytes: (e) => (r ? U(e, a) : M(e, a)),
          fromBytes: (e) => {
            if (e.length !== a)
              throw Error(
                "Field.fromBytes: expected " + a + " bytes, got " + e.length
              );
            return r ? D(e) : P(T(e));
          },
        });
        return Object.freeze(o);
      }
      let en = BigInt(0),
        ea = BigInt(1);
      function eo(e, t) {
        let r = t.negate();
        return e ? r : t;
      }
      function ec(e, t) {
        if (!Number.isSafeInteger(e) || e <= 0 || e > t)
          throw Error(
            "invalid window size, expected [1.." + t + "], got W=" + e
          );
      }
      function el(e, t) {
        return (
          ec(e, t), { windows: Math.ceil(t / e) + 1, windowSize: 2 ** (e - 1) }
        );
      }
      let ed = new WeakMap(),
        eu = new WeakMap();
      function eh(e) {
        return eu.get(e) || 1;
      }
      let ef = BigInt(0),
        ep = BigInt(1),
        eg = BigInt(2),
        em = BigInt(8),
        eb = { zip215: !0 };
      BigInt(0), BigInt(1);
      let ey = BigInt(
          "57896044618658097711785492504343953926634992332820282019728792003956564819949"
        ),
        ew = BigInt(
          "19681161376707505956807079304988542015446066515923890162744021073123829784752"
        );
      BigInt(0);
      let ev = BigInt(1),
        eA = BigInt(2);
      BigInt(3);
      let eE = BigInt(5),
        e_ = BigInt(8),
        eC = es(ey, void 0, !0),
        eI = (function (e) {
          var t;
          let r = (function (e) {
              let t =
                (W(
                  e.Fp,
                  er.reduce((e, t) => ((e[t] = "function"), e), {
                    ORDER: "bigint",
                    MASK: "bigint",
                    BYTES: "isSafeInteger",
                    BITS: "isSafeInteger",
                  })
                ),
                W(
                  e,
                  { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
                  { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
                ),
                Object.freeze({
                  ...ei(e.n, e.nBitLength),
                  ...e,
                  p: e.Fp.ORDER,
                }));
              return (
                W(
                  e,
                  {
                    hash: "function",
                    a: "bigint",
                    d: "bigint",
                    randomBytes: "function",
                  },
                  {
                    adjustScalarBytes: "function",
                    domain: "function",
                    uvRatio: "function",
                    mapToCurve: "function",
                  }
                ),
                Object.freeze({ ...t })
              );
            })(e),
            {
              Fp: i,
              n: s,
              prehash: n,
              hash: a,
              randomBytes: o,
              nByteLength: c,
              h: l,
            } = r,
            d = eg << (BigInt(8 * c) - ep),
            u = i.create,
            h = es(r.n, r.nBitLength),
            f =
              r.uvRatio ||
              ((e, t) => {
                try {
                  return { isValid: !0, value: i.sqrt(e * i.inv(t)) };
                } catch {
                  return { isValid: !1, value: ef };
                }
              }),
            p = r.adjustScalarBytes || ((e) => e),
            g =
              r.domain ||
              ((e, t, r) => {
                if ((x("phflag", r), t.length || r))
                  throw Error("Contexts/pre-hash are not supported");
                return e;
              });
          function m(e, t) {
            F("coordinate " + e, t, ef, d);
          }
          function b(e) {
            if (!(e instanceof v)) throw Error("ExtendedPoint expected");
          }
          let y = H((e, t) => {
              let { ex: r, ey: s, ez: n } = e,
                a = e.is0();
              null == t && (t = a ? em : i.inv(n));
              let o = u(r * t),
                c = u(s * t),
                l = u(n * t);
              if (a) return { x: ef, y: ep };
              if (l !== ep) throw Error("invZ was invalid");
              return { x: o, y: c };
            }),
            w = H((e) => {
              let { a: t, d: i } = r;
              if (e.is0()) throw Error("bad point: ZERO");
              let { ex: s, ey: n, ez: a, et: o } = e,
                c = u(s * s),
                l = u(n * n),
                d = u(a * a),
                h = u(d * d),
                f = u(c * t);
              if (u(d * u(f + l)) !== u(h + u(i * u(c * l))))
                throw Error("bad point: equation left != right (1)");
              if (u(s * n) !== u(a * o))
                throw Error("bad point: equation left != right (2)");
              return !0;
            });
          class v {
            constructor(e, t, r, i) {
              (this.ex = e),
                (this.ey = t),
                (this.ez = r),
                (this.et = i),
                m("x", e),
                m("y", t),
                m("z", r),
                m("t", i),
                Object.freeze(this);
            }
            get x() {
              return this.toAffine().x;
            }
            get y() {
              return this.toAffine().y;
            }
            static fromAffine(e) {
              if (e instanceof v) throw Error("extended point not allowed");
              let { x: t, y: r } = e || {};
              return m("x", t), m("y", r), new v(t, r, ep, u(t * r));
            }
            static normalizeZ(e) {
              let t = i.invertBatch(e.map((e) => e.ez));
              return e.map((e, r) => e.toAffine(t[r])).map(v.fromAffine);
            }
            static msm(e, t) {
              return (function (e, t, r, i) {
                if (
                  ((function (e, t) {
                    if (!Array.isArray(e)) throw Error("array expected");
                    e.forEach((e, r) => {
                      if (!(e instanceof t))
                        throw Error("invalid point at index " + r);
                    });
                  })(r, e),
                  (function (e, t) {
                    if (!Array.isArray(e))
                      throw Error("array of scalars expected");
                    e.forEach((e, r) => {
                      if (!t.isValid(e))
                        throw Error("invalid scalar at index " + r);
                    });
                  })(i, t),
                  r.length !== i.length)
                )
                  throw Error(
                    "arrays of points and scalars must have equal length"
                  );
                let s = e.ZERO,
                  n = (function (e) {
                    let t;
                    for (t = 0; e > E; e >>= _, t += 1);
                    return t;
                  })(BigInt(r.length)),
                  a = n > 12 ? n - 3 : n > 4 ? n - 2 : n ? 2 : 1,
                  o = (1 << a) - 1,
                  c = Array(o + 1).fill(s),
                  l = Math.floor((t.BITS - 1) / a) * a,
                  d = s;
                for (let e = l; e >= 0; e -= a) {
                  c.fill(s);
                  for (let t = 0; t < i.length; t++) {
                    let s = Number((i[t] >> BigInt(e)) & BigInt(o));
                    c[s] = c[s].add(r[t]);
                  }
                  let t = s;
                  for (let e = c.length - 1, r = s; e > 0; e--)
                    (r = r.add(c[e])), (t = t.add(r));
                  if (((d = d.add(t)), 0 !== e))
                    for (let e = 0; e < a; e++) d = d.double();
                }
                return d;
              })(v, h, e, t);
            }
            _setWindowSize(e) {
              I.setWindowSize(this, e);
            }
            assertValidity() {
              w(this);
            }
            equals(e) {
              b(e);
              let { ex: t, ey: r, ez: i } = this,
                { ex: s, ey: n, ez: a } = e,
                o = u(t * a),
                c = u(s * i),
                l = u(r * a),
                d = u(n * i);
              return o === c && l === d;
            }
            is0() {
              return this.equals(v.ZERO);
            }
            negate() {
              return new v(u(-this.ex), this.ey, this.ez, u(-this.et));
            }
            double() {
              let { a: e } = r,
                { ex: t, ey: i, ez: s } = this,
                n = u(t * t),
                a = u(i * i),
                o = u(eg * u(s * s)),
                c = u(e * n),
                l = t + i,
                d = u(u(l * l) - n - a),
                h = c + a,
                f = h - o,
                p = c - a,
                g = u(d * f),
                m = u(h * p),
                b = u(d * p);
              return new v(g, m, u(f * h), b);
            }
            add(e) {
              b(e);
              let { a: t, d: i } = r,
                { ex: s, ey: n, ez: a, et: o } = this,
                { ex: c, ey: l, ez: d, et: h } = e;
              if (t === BigInt(-1)) {
                let e = u((n - s) * (l + c)),
                  t = u((n + s) * (l - c)),
                  r = u(t - e);
                if (r === ef) return this.double();
                let i = u(a * eg * h),
                  f = u(o * eg * d),
                  p = f + i,
                  g = t + e,
                  m = f - i,
                  b = u(p * r),
                  y = u(g * m),
                  w = u(p * m);
                return new v(b, y, u(r * g), w);
              }
              let f = u(s * c),
                p = u(n * l),
                g = u(o * i * h),
                m = u(a * d),
                y = u((s + n) * (c + l) - f - p),
                w = m - g,
                A = m + g,
                E = u(p - t * f),
                _ = u(y * w),
                C = u(A * E),
                I = u(y * E);
              return new v(_, C, u(w * A), I);
            }
            subtract(e) {
              return this.add(e.negate());
            }
            wNAF(e) {
              return I.wNAFCached(this, e, v.normalizeZ);
            }
            multiply(e) {
              F("scalar", e, ep, s);
              let { p: t, f: r } = this.wNAF(e);
              return v.normalizeZ([t, r])[0];
            }
            multiplyUnsafe(e, t = v.ZERO) {
              return (
                F("scalar", e, ef, s),
                e === ef
                  ? C
                  : this.is0() || e === ep
                  ? this
                  : I.wNAFCachedUnsafe(this, e, v.normalizeZ, t)
              );
            }
            isSmallOrder() {
              return this.multiplyUnsafe(l).is0();
            }
            isTorsionFree() {
              return I.unsafeLadder(this, s).is0();
            }
            toAffine(e) {
              return y(this, e);
            }
            clearCofactor() {
              let { h: e } = r;
              return e === ep ? this : this.multiplyUnsafe(e);
            }
            static fromHex(e, t = !1) {
              let { d: s, a: n } = r,
                a = i.BYTES;
              (e = L("pointHex", e, a)), x("zip215", t);
              let o = e.slice(),
                c = e[a - 1];
              o[a - 1] = -129 & c;
              let l = D(o);
              F("pointHex.y", l, ef, t ? d : i.ORDER);
              let h = u(l * l),
                { isValid: p, value: g } = f(u(h - ep), u(s * h - n));
              if (!p) throw Error("Point.fromHex: invalid y coordinate");
              let m = (g & ep) === ep,
                b = (128 & c) != 0;
              if (!t && g === ef && b)
                throw Error("Point.fromHex: x=0 and x_0=1");
              return b !== m && (g = u(-g)), v.fromAffine({ x: g, y: l });
            }
            static fromPrivateKey(e) {
              return S(e).point;
            }
            toRawBytes() {
              let { x: e, y: t } = this.toAffine(),
                r = U(t, i.BYTES);
              return (r[r.length - 1] |= e & ep ? 128 : 0), r;
            }
            toHex() {
              return T(this.toRawBytes());
            }
          }
          (v.BASE = new v(r.Gx, r.Gy, ep, u(r.Gx * r.Gy))),
            (v.ZERO = new v(ef, ep, ep, ef));
          let { BASE: A, ZERO: C } = v,
            I =
              ((t = 8 * c),
              {
                constTimeNegate: eo,
                hasPrecomputes: (e) => 1 !== eh(e),
                unsafeLadder(e, t, r = v.ZERO) {
                  let i = e;
                  for (; t > en; )
                    t & ea && (r = r.add(i)), (i = i.double()), (t >>= ea);
                  return r;
                },
                precomputeWindow(e, r) {
                  let { windows: i, windowSize: s } = el(r, t),
                    n = [],
                    a = e,
                    o = a;
                  for (let e = 0; e < i; e++) {
                    (o = a), n.push(o);
                    for (let e = 1; e < s; e++) (o = o.add(a)), n.push(o);
                    a = o.double();
                  }
                  return n;
                },
                wNAF(e, r, i) {
                  let { windows: s, windowSize: n } = el(e, t),
                    a = v.ZERO,
                    o = v.BASE,
                    c = BigInt(2 ** e - 1),
                    l = 2 ** e,
                    d = BigInt(e);
                  for (let e = 0; e < s; e++) {
                    let t = e * n,
                      s = Number(i & c);
                    (i >>= d), s > n && ((s -= l), (i += ea));
                    let u = t + Math.abs(s) - 1,
                      h = e % 2 != 0,
                      f = s < 0;
                    0 === s
                      ? (o = o.add(eo(h, r[t])))
                      : (a = a.add(eo(f, r[u])));
                  }
                  return { p: a, f: o };
                },
                wNAFUnsafe(e, r, i, s = v.ZERO) {
                  let { windows: n, windowSize: a } = el(e, t),
                    o = BigInt(2 ** e - 1),
                    c = 2 ** e,
                    l = BigInt(e);
                  for (let e = 0; e < n; e++) {
                    let t = e * a;
                    if (i === en) break;
                    let n = Number(i & o);
                    if (((i >>= l), n > a && ((n -= c), (i += ea)), 0 === n))
                      continue;
                    let d = r[t + Math.abs(n) - 1];
                    n < 0 && (d = d.negate()), (s = s.add(d));
                  }
                  return s;
                },
                getPrecomputes(e, t, r) {
                  let i = ed.get(t);
                  return (
                    i ||
                      ((i = this.precomputeWindow(t, e)),
                      1 !== e && ed.set(t, r(i))),
                    i
                  );
                },
                wNAFCached(e, t, r) {
                  let i = eh(e);
                  return this.wNAF(i, this.getPrecomputes(i, e, r), t);
                },
                wNAFCachedUnsafe(e, t, r, i) {
                  let s = eh(e);
                  return 1 === s
                    ? this.unsafeLadder(e, t, i)
                    : this.wNAFUnsafe(s, this.getPrecomputes(s, e, r), t, i);
                },
                setWindowSize(e, r) {
                  ec(r, t), eu.set(e, r), ed.delete(e);
                },
              });
          function S(e) {
            let t = i.BYTES;
            e = L("private key", e, t);
            let r = L("hashed private key", a(e), 2 * t),
              n = p(r.slice(0, t)),
              o = r.slice(t, 2 * t),
              c = J(D(n), s),
              l = A.multiply(c),
              d = l.toRawBytes();
            return { head: n, prefix: o, scalar: c, point: l, pointBytes: d };
          }
          function N(e = new Uint8Array(), ...t) {
            return J(D(a(g(B(...t), L("context", e), !!n))), s);
          }
          return (
            A._setWindowSize(8),
            {
              CURVE: r,
              getPublicKey: function (e) {
                return S(e).pointBytes;
              },
              sign: function (e, t, r = {}) {
                (e = L("message", e)), n && (e = n(e));
                let { prefix: a, scalar: o, pointBytes: c } = S(t),
                  l = N(r.context, a, e),
                  d = A.multiply(l).toRawBytes(),
                  u = J(l + N(r.context, d, c, e) * o, s);
                return (
                  F("signature.s", u, ef, s),
                  L("result", B(d, U(u, i.BYTES)), 2 * i.BYTES)
                );
              },
              verify: function (e, t, r, s = eb) {
                let a, o, c;
                let { context: l, zip215: d } = s,
                  u = i.BYTES;
                (e = L("signature", e, 2 * u)),
                  (t = L("message", t)),
                  (r = L("publicKey", r, u)),
                  void 0 !== d && x("zip215", d),
                  n && (t = n(t));
                let h = D(e.slice(u, 2 * u));
                try {
                  (a = v.fromHex(r, d)),
                    (o = v.fromHex(e.slice(0, u), d)),
                    (c = A.multiplyUnsafe(h));
                } catch {
                  return !1;
                }
                if (!d && a.isSmallOrder()) return !1;
                let f = N(l, o.toRawBytes(), a.toRawBytes(), t);
                return o
                  .add(a.multiplyUnsafe(f))
                  .subtract(c)
                  .clearCofactor()
                  .equals(v.ZERO);
              },
              ExtendedPoint: v,
              utils: {
                getExtendedPublicKey: S,
                randomPrivateKey: () => o(i.BYTES),
                precompute: (e = 8, t = v.BASE) => (
                  t._setWindowSize(e), t.multiply(BigInt(3)), t
                ),
              },
            }
          );
        })({
          a: BigInt(-1),
          d: BigInt(
            "37095705934669439343138083508754565189542113879843219016388785533085940283555"
          ),
          Fp: eC,
          n: BigInt(
            "7237005577332262213973186563042994240857116359379907606001950938285454250989"
          ),
          h: e_,
          Gx: BigInt(
            "15112221349535400772501151409588531511454012693041857206046113283949847762202"
          ),
          Gy: BigInt(
            "46316835694926478169428394003475163141307993866256225615783033603165251855960"
          ),
          hash: A,
          randomBytes: u,
          adjustScalarBytes: function (e) {
            return (e[0] &= 248), (e[31] &= 127), (e[31] |= 64), e;
          },
          uvRatio: function (e, t) {
            let r = J(t * t * t, ey),
              i = (function (e) {
                let t = BigInt(10),
                  r = BigInt(20),
                  i = BigInt(40),
                  s = BigInt(80),
                  n = (((e * e) % ey) * e) % ey,
                  a = (X(n, eA, ey) * n) % ey,
                  o = (X(a, ev, ey) * e) % ey,
                  c = (X(o, eE, ey) * o) % ey,
                  l = (X(c, t, ey) * c) % ey,
                  d = (X(l, r, ey) * l) % ey,
                  u = (X(d, i, ey) * d) % ey,
                  h = (X(u, s, ey) * u) % ey,
                  f = (X(h, s, ey) * u) % ey,
                  p = (X(f, t, ey) * c) % ey;
                return { pow_p_5_8: (X(p, eA, ey) * e) % ey, b2: n };
              })(e * J(r * r * t, ey)).pow_p_5_8,
              s = J(e * r * i, ey),
              n = J(t * s * s, ey),
              a = s,
              o = J(s * ew, ey),
              c = n === e,
              l = n === J(-e, ey),
              d = n === J(-e * ew, ey);
            return (
              c && (s = a),
              (l || d) && (s = o),
              et(s, ey) && (s = J(-s, ey)),
              { isValid: c || l, value: s }
            );
          },
        }),
        eS = "base64url",
        ex = "utf8",
        eN = "utf8",
        eT = "base58btc";
      function eP(e) {
        return null != globalThis.Buffer
          ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          : e;
      }
      function eO(e = 0) {
        return null != globalThis.Buffer &&
          null != globalThis.Buffer.allocUnsafe
          ? eP(globalThis.Buffer.allocUnsafe(e))
          : new Uint8Array(e);
      }
      function ek(e, t) {
        t || (t = e.reduce((e, t) => e + t.length, 0));
        let r = eO(t),
          i = 0;
        for (let t of e) r.set(t, i), (i += t.length);
        return eP(r);
      }
      var eR = function (e, t) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
        for (var s = 0; s < e.length; s++) {
          var n = e.charAt(s),
            a = n.charCodeAt(0);
          if (255 !== r[a]) throw TypeError(n + " is ambiguous");
          r[a] = s;
        }
        var o = e.length,
          c = e.charAt(0),
          l = Math.log(o) / Math.log(256),
          d = Math.log(256) / Math.log(o);
        function u(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[0]) {
            for (var i = 0, s = 0; e[t] === c; ) i++, t++;
            for (
              var n = ((e.length - t) * l + 1) >>> 0, a = new Uint8Array(n);
              e[t];

            ) {
              var d = r[e.charCodeAt(t)];
              if (255 === d) return;
              for (
                var u = 0, h = n - 1;
                (0 !== d || u < s) && -1 !== h;
                h--, u++
              )
                (d += (o * a[h]) >>> 0),
                  (a[h] = d % 256 >>> 0),
                  (d = (d / 256) >>> 0);
              if (0 !== d) throw Error("Non-zero carry");
              (s = u), t++;
            }
            if (" " !== e[t]) {
              for (var f = n - s; f !== n && 0 === a[f]; ) f++;
              for (var p = new Uint8Array(i + (n - f)), g = i; f !== n; )
                p[g++] = a[f++];
              return p;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            for (var r = 0, i = 0, s = 0, n = t.length; s !== n && 0 === t[s]; )
              s++, r++;
            for (
              var a = ((n - s) * d + 1) >>> 0, l = new Uint8Array(a);
              s !== n;

            ) {
              for (
                var u = t[s], h = 0, f = a - 1;
                (0 !== u || h < i) && -1 !== f;
                f--, h++
              )
                (u += (256 * l[f]) >>> 0),
                  (l[f] = u % o >>> 0),
                  (u = (u / o) >>> 0);
              if (0 !== u) throw Error("Non-zero carry");
              (i = h), s++;
            }
            for (var p = a - i; p !== a && 0 === l[p]; ) p++;
            for (var g = c.repeat(r); p < a; ++p) g += e.charAt(l[p]);
            return g;
          },
          decodeUnsafe: u,
          decode: function (e) {
            var r = u(e);
            if (r) return r;
            throw Error(`Non-${t} character`);
          },
        };
      };
      let eD = (e) => {
          if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
            return e;
          if (e instanceof ArrayBuffer) return new Uint8Array(e);
          if (ArrayBuffer.isView(e))
            return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw Error("Unknown type, must be binary type");
        },
        eM = (e) => new TextEncoder().encode(e),
        eU = (e) => new TextDecoder().decode(e);
      class eL {
        constructor(e, t, r) {
          (this.name = e), (this.prefix = t), (this.baseEncode = r);
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class eB {
        constructor(e, t, r) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error("Invalid prefix character");
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
        }
        decode(e) {
          if ("string" == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${
                  this.name
                } decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error("Can only multibase decode strings");
        }
        or(e) {
          return eF(this, e);
        }
      }
      class ej {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return eF(this, e);
        }
        decode(e) {
          let t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(
              e
            )}, only inputs prefixed with ${Object.keys(
              this.decoders
            )} are supported`
          );
        }
      }
      let eF = (e, t) =>
        new ej({
          ...(e.decoders || { [e.prefix]: e }),
          ...(t.decoders || { [t.prefix]: t }),
        });
      class e$ {
        constructor(e, t, r, i) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = r),
            (this.baseDecode = i),
            (this.encoder = new eL(e, t, r)),
            (this.decoder = new eB(e, t, i));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let ez = ({ name: e, prefix: t, encode: r, decode: i }) =>
          new e$(e, t, r, i),
        eW = ({ prefix: e, name: t, alphabet: r }) => {
          let { encode: i, decode: s } = eR(r, t);
          return ez({ prefix: e, name: t, encode: i, decode: (e) => eD(s(e)) });
        },
        eH = (e, t, r, i) => {
          let s = {};
          for (let e = 0; e < t.length; ++e) s[t[e]] = e;
          let n = e.length;
          for (; "=" === e[n - 1]; ) --n;
          let a = new Uint8Array(((n * r) / 8) | 0),
            o = 0,
            c = 0,
            l = 0;
          for (let t = 0; t < n; ++t) {
            let n = s[e[t]];
            if (void 0 === n) throw SyntaxError(`Non-${i} character`);
            (c = (c << r) | n),
              (o += r) >= 8 && ((o -= 8), (a[l++] = 255 & (c >> o)));
          }
          if (o >= r || 255 & (c << (8 - o)))
            throw SyntaxError("Unexpected end of data");
          return a;
        },
        eq = (e, t, r) => {
          let i = "=" === t[t.length - 1],
            s = (1 << r) - 1,
            n = "",
            a = 0,
            o = 0;
          for (let i = 0; i < e.length; ++i)
            for (o = (o << 8) | e[i], a += 8; a > r; )
              (a -= r), (n += t[s & (o >> a)]);
          if ((a && (n += t[s & (o << (r - a))]), i))
            for (; (n.length * r) & 7; ) n += "=";
          return n;
        },
        eV = ({ name: e, prefix: t, bitsPerChar: r, alphabet: i }) =>
          ez({
            prefix: t,
            name: e,
            encode: (e) => eq(e, i, r),
            decode: (t) => eH(t, i, r, e),
          });
      var eK = Object.freeze({
          __proto__: null,
          identity: ez({
            prefix: "\0",
            name: "identity",
            encode: (e) => eU(e),
            decode: (e) => eM(e),
          }),
        }),
        eG = Object.freeze({
          __proto__: null,
          base2: eV({
            prefix: "0",
            name: "base2",
            alphabet: "01",
            bitsPerChar: 1,
          }),
        }),
        eY = Object.freeze({
          __proto__: null,
          base8: eV({
            prefix: "7",
            name: "base8",
            alphabet: "01234567",
            bitsPerChar: 3,
          }),
        }),
        eQ = Object.freeze({
          __proto__: null,
          base10: eW({ prefix: "9", name: "base10", alphabet: "0123456789" }),
        }),
        eZ = Object.freeze({
          __proto__: null,
          base16: eV({
            prefix: "f",
            name: "base16",
            alphabet: "0123456789abcdef",
            bitsPerChar: 4,
          }),
          base16upper: eV({
            prefix: "F",
            name: "base16upper",
            alphabet: "0123456789ABCDEF",
            bitsPerChar: 4,
          }),
        });
      let eJ = eV({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5,
        }),
        eX = eV({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5,
        }),
        e0 = eV({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5,
        }),
        e1 = eV({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5,
        }),
        e2 = eV({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5,
        }),
        e3 = eV({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5,
        }),
        e5 = eV({
          prefix: "t",
          name: "base32hexpad",
          alphabet: "0123456789abcdefghijklmnopqrstuv=",
          bitsPerChar: 5,
        });
      var e8 = Object.freeze({
          __proto__: null,
          base32: eJ,
          base32upper: eX,
          base32pad: e0,
          base32padupper: e1,
          base32hex: e2,
          base32hexupper: e3,
          base32hexpad: e5,
          base32hexpadupper: eV({
            prefix: "T",
            name: "base32hexpadupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
            bitsPerChar: 5,
          }),
          base32z: eV({
            prefix: "h",
            name: "base32z",
            alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
            bitsPerChar: 5,
          }),
        }),
        e6 = Object.freeze({
          __proto__: null,
          base36: eW({
            prefix: "k",
            name: "base36",
            alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
          }),
          base36upper: eW({
            prefix: "K",
            name: "base36upper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          }),
        }),
        e4 = Object.freeze({
          __proto__: null,
          base58btc: eW({
            name: "base58btc",
            prefix: "z",
            alphabet:
              "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
          }),
          base58flickr: eW({
            name: "base58flickr",
            prefix: "Z",
            alphabet:
              "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
          }),
        });
      let e9 = eV({
          prefix: "m",
          name: "base64",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          bitsPerChar: 6,
        }),
        e7 = eV({
          prefix: "M",
          name: "base64pad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6,
        });
      var te = Object.freeze({
        __proto__: null,
        base64: e9,
        base64pad: e7,
        base64url: eV({
          prefix: "u",
          name: "base64url",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6,
        }),
        base64urlpad: eV({
          prefix: "U",
          name: "base64urlpad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6,
        }),
      });
      let tt = Array.from(
          "\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"
        ),
        tr = tt.reduce((e, t, r) => ((e[r] = t), e), []),
        ti = tt.reduce((e, t, r) => ((e[t.codePointAt(0)] = r), e), []);
      var ts = Object.freeze({
        __proto__: null,
        base256emoji: ez({
          prefix: "\uD83D\uDE80",
          name: "base256emoji",
          encode: function (e) {
            return e.reduce((e, t) => (e += tr[t]), "");
          },
          decode: function (e) {
            let t = [];
            for (let r of e) {
              let e = ti[r.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${r}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        }),
      });
      function tn(e, t, r) {
        (t = t || []), (r = r || 0);
        for (var i = r; e >= 0x80000000; )
          (t[r++] = (255 & e) | 128), (e /= 128);
        for (; -128 & e; ) (t[r++] = (255 & e) | 128), (e >>>= 7);
        return (t[r] = 0 | e), (tn.bytes = r - i + 1), t;
      }
      function ta(e, t) {
        var r,
          i = 0,
          t = t || 0,
          s = 0,
          n = t,
          a = e.length;
        do {
          if (n >= a)
            throw ((ta.bytes = 0), RangeError("Could not decode varint"));
          (r = e[n++]),
            (i += s < 28 ? (127 & r) << s : (127 & r) * Math.pow(2, s)),
            (s += 7);
        } while (r >= 128);
        return (ta.bytes = n - t), i;
      }
      var to = {
        encode: tn,
        encodingLength: function (e) {
          return e < 128
            ? 1
            : e < 16384
            ? 2
            : e < 2097152
            ? 3
            : e < 0x10000000
            ? 4
            : e < 0x800000000
            ? 5
            : e < 0x40000000000
            ? 6
            : e < 0x2000000000000
            ? 7
            : e < 0x100000000000000
            ? 8
            : e < 0x8000000000000000
            ? 9
            : 10;
        },
      };
      let tc = (e, t, r = 0) => (to.encode(e, t, r), t),
        tl = (e) => to.encodingLength(e),
        td = (e, t) => {
          let r = t.byteLength,
            i = tl(e),
            s = i + tl(r),
            n = new Uint8Array(s + r);
          return tc(e, n, 0), tc(r, n, i), n.set(t, s), new tu(e, r, t, n);
        };
      class tu {
        constructor(e, t, r, i) {
          (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
        }
      }
      let th = ({ name: e, code: t, encode: r }) => new tf(e, t, r);
      class tf {
        constructor(e, t, r) {
          (this.name = e), (this.code = t), (this.encode = r);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array
              ? td(this.code, t)
              : t.then((e) => td(this.code, e));
          }
          throw Error("Unknown type, must be binary type");
        }
      }
      let tp = (e) => async (t) =>
        new Uint8Array(await crypto.subtle.digest(e, t));
      var tg = Object.freeze({
          __proto__: null,
          sha256: th({ name: "sha2-256", code: 18, encode: tp("SHA-256") }),
          sha512: th({ name: "sha2-512", code: 19, encode: tp("SHA-512") }),
        }),
        tm = Object.freeze({
          __proto__: null,
          identity: {
            code: 0,
            name: "identity",
            encode: eD,
            digest: (e) => td(0, eD(e)),
          },
        });
      new TextEncoder(), new TextDecoder();
      let tb = {
        ...eK,
        ...eG,
        ...eY,
        ...eQ,
        ...eZ,
        ...e8,
        ...e6,
        ...e4,
        ...te,
        ...ts,
      };
      function ty(e, t, r, i) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: r },
          decoder: { decode: i },
        };
      }
      ({ ...tg, ...tm });
      let tw = ty(
          "utf8",
          "u",
          (e) => "u" + new TextDecoder("utf8").decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        tv = ty(
          "ascii",
          "a",
          (e) => {
            let t = "a";
            for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
            return t;
          },
          (e) => {
            let t = eO((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
            return t;
          }
        ),
        tA = {
          utf8: tw,
          "utf-8": tw,
          hex: tb.base16,
          latin1: tv,
          ascii: tv,
          binary: tv,
          ...tb,
        };
      function tE(e, t = "utf8") {
        let r = tA[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(
              e.buffer,
              e.byteOffset,
              e.byteLength
            ).toString("utf8")
          : r.encoder.encode(e).substring(1);
      }
      function t_(e, t = "utf8") {
        let r = tA[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? eP(globalThis.Buffer.from(e, "utf-8"))
          : r.decoder.decode(`${r.prefix}${e}`);
      }
      function tC(e) {
        return (0, s.j)(tE(t_(e, eS), ex));
      }
      function tI(e) {
        return tE(t_((0, s.h)(e), ex), eS);
      }
      function tS(e) {
        return ["did", "key", "z" + tE(ek([t_("K36", eT), e]), eT)].join(":");
      }
      function tx(e) {
        let t = e.split("."),
          r = tC(t[0]),
          i = tC(t[1]);
        return {
          header: r,
          payload: i,
          signature: t_(t[2], eS),
          data: t_(t.slice(0, 2).join("."), eN),
        };
      }
      function tN(e = u(32)) {
        let t = eI.getPublicKey(e);
        return { secretKey: ek([e, t]), publicKey: t };
      }
      async function tT(e, t, r, s, n = (0, i.fromMiliseconds)(Date.now())) {
        var a, o;
        let c = { alg: "EdDSA", typ: "JWT" },
          l = { iss: tS(s.publicKey), sub: e, aud: t, iat: n, exp: n + r },
          d = t_(
            [tI((a = { header: c, payload: l }).header), tI(a.payload)].join(
              "."
            ),
            eN
          );
        return [
          tI(
            (o = {
              header: c,
              payload: l,
              signature: eI.sign(d, s.secretKey.slice(0, 32)),
            }).header
          ),
          tI(o.payload),
          tE(o.signature, eS),
        ].join(".");
      }
    },
    20920: (e, t, r) => {
      "use strict";
      var i = r(3285);
      function s(e) {
        return (
          ((e >>> 24) |
            ((e >>> 8) & 65280) |
            ((e << 8) & 0xff0000) |
            ((255 & e) << 24)) >>>
          0
        );
      }
      function n(e) {
        return 1 === e.length ? "0" + e : e;
      }
      function a(e) {
        if (7 === e.length) return "0" + e;
        if (6 === e.length) return "00" + e;
        if (5 === e.length) return "000" + e;
        if (4 === e.length) return "0000" + e;
        if (3 === e.length) return "00000" + e;
        else if (2 === e.length) return "000000" + e;
        else if (1 === e.length) return "0000000" + e;
        else return e;
      }
      (t.inherits = r(43770)),
        (t.toArray = function (e, t) {
          if (Array.isArray(e)) return e.slice();
          if (!e) return [];
          var r = [];
          if ("string" == typeof e) {
            if (t) {
              if ("hex" === t)
                for (
                  (e = e.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 &&
                    (e = "0" + e),
                    s = 0;
                  s < e.length;
                  s += 2
                )
                  r.push(parseInt(e[s] + e[s + 1], 16));
            } else
              for (var i = 0, s = 0; s < e.length; s++) {
                var n,
                  a,
                  o = e.charCodeAt(s);
                o < 128
                  ? (r[i++] = o)
                  : (o < 2048
                      ? (r[i++] = (o >> 6) | 192)
                      : (((n = e),
                        (a = s),
                        (64512 & n.charCodeAt(a)) != 55296 ||
                        a < 0 ||
                        a + 1 >= n.length
                          ? 1
                          : (64512 & n.charCodeAt(a + 1)) != 56320)
                          ? (r[i++] = (o >> 12) | 224)
                          : ((o =
                              65536 +
                              ((1023 & o) << 10) +
                              (1023 & e.charCodeAt(++s))),
                            (r[i++] = (o >> 18) | 240),
                            (r[i++] = ((o >> 12) & 63) | 128)),
                        (r[i++] = ((o >> 6) & 63) | 128)),
                    (r[i++] = (63 & o) | 128));
              }
          } else for (s = 0; s < e.length; s++) r[s] = 0 | e[s];
          return r;
        }),
        (t.toHex = function (e) {
          for (var t = "", r = 0; r < e.length; r++) t += n(e[r].toString(16));
          return t;
        }),
        (t.htonl = s),
        (t.toHex32 = function (e, t) {
          for (var r = "", i = 0; i < e.length; i++) {
            var n = e[i];
            "little" === t && (n = s(n)), (r += a(n.toString(16)));
          }
          return r;
        }),
        (t.zero2 = n),
        (t.zero8 = a),
        (t.join32 = function (e, t, r, s) {
          var n,
            a = r - t;
          i(a % 4 == 0);
          for (var o = Array(a / 4), c = 0, l = t; c < o.length; c++, l += 4)
            (n =
              "big" === s
                ? (e[l] << 24) | (e[l + 1] << 16) | (e[l + 2] << 8) | e[l + 3]
                : (e[l + 3] << 24) | (e[l + 2] << 16) | (e[l + 1] << 8) | e[l]),
              (o[c] = n >>> 0);
          return o;
        }),
        (t.split32 = function (e, t) {
          for (
            var r = Array(4 * e.length), i = 0, s = 0;
            i < e.length;
            i++, s += 4
          ) {
            var n = e[i];
            "big" === t
              ? ((r[s] = n >>> 24),
                (r[s + 1] = (n >>> 16) & 255),
                (r[s + 2] = (n >>> 8) & 255),
                (r[s + 3] = 255 & n))
              : ((r[s + 3] = n >>> 24),
                (r[s + 2] = (n >>> 16) & 255),
                (r[s + 1] = (n >>> 8) & 255),
                (r[s] = 255 & n));
          }
          return r;
        }),
        (t.rotr32 = function (e, t) {
          return (e >>> t) | (e << (32 - t));
        }),
        (t.rotl32 = function (e, t) {
          return (e << t) | (e >>> (32 - t));
        }),
        (t.sum32 = function (e, t) {
          return (e + t) >>> 0;
        }),
        (t.sum32_3 = function (e, t, r) {
          return (e + t + r) >>> 0;
        }),
        (t.sum32_4 = function (e, t, r, i) {
          return (e + t + r + i) >>> 0;
        }),
        (t.sum32_5 = function (e, t, r, i, s) {
          return (e + t + r + i + s) >>> 0;
        }),
        (t.sum64 = function (e, t, r, i) {
          var s = e[t],
            n = (i + e[t + 1]) >>> 0;
          (e[t] = (+(n < i) + r + s) >>> 0), (e[t + 1] = n);
        }),
        (t.sum64_hi = function (e, t, r, i) {
          return (+((t + i) >>> 0 < t) + e + r) >>> 0;
        }),
        (t.sum64_lo = function (e, t, r, i) {
          return (t + i) >>> 0;
        }),
        (t.sum64_4_hi = function (e, t, r, i, s, n, a, o) {
          var c,
            l = t;
          return (
            (e +
              r +
              s +
              a +
              (c =
                0 +
                +((l = (l + i) >>> 0) < t) +
                +((l = (l + n) >>> 0) < n) +
                +((l = (l + o) >>> 0) < o))) >>>
            0
          );
        }),
        (t.sum64_4_lo = function (e, t, r, i, s, n, a, o) {
          return (t + i + n + o) >>> 0;
        }),
        (t.sum64_5_hi = function (e, t, r, i, s, n, a, o, c, l) {
          var d,
            u = t;
          return (
            (e +
              r +
              s +
              a +
              c +
              (d =
                0 +
                +((u = (u + i) >>> 0) < t) +
                +((u = (u + n) >>> 0) < n) +
                +((u = (u + o) >>> 0) < o) +
                +((u = (u + l) >>> 0) < l))) >>>
            0
          );
        }),
        (t.sum64_5_lo = function (e, t, r, i, s, n, a, o, c, l) {
          return (t + i + n + o + l) >>> 0;
        }),
        (t.rotr64_hi = function (e, t, r) {
          return ((t << (32 - r)) | (e >>> r)) >>> 0;
        }),
        (t.rotr64_lo = function (e, t, r) {
          return ((e << (32 - r)) | (t >>> r)) >>> 0;
        }),
        (t.shr64_hi = function (e, t, r) {
          return e >>> r;
        }),
        (t.shr64_lo = function (e, t, r) {
          return ((e << (32 - r)) | (t >>> r)) >>> 0;
        });
    },
    22633: (e, t, r) => {
      "use strict";
      var i = r(20920),
        s = r(31e3);
      function n() {
        if (!(this instanceof n)) return new n();
        s.call(this),
          (this.h = [
            0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a,
            0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31,
            0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d,
            0xbefa4fa4,
          ]);
      }
      i.inherits(n, s),
        (e.exports = n),
        (n.blockSize = 1024),
        (n.outSize = 384),
        (n.hmacStrength = 192),
        (n.padLength = 128),
        (n.prototype._digest = function (e) {
          return "hex" === e
            ? i.toHex32(this.h.slice(0, 12), "big")
            : i.split32(this.h.slice(0, 12), "big");
        });
    },
    22669: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => n });
      var i = r(73537),
        s = r(17389);
      let n = {
        set(e, t) {
          s.Q.isClient && localStorage.setItem(`${i.s1.STORAGE_KEY}${e}`, t);
        },
        get: (e) =>
          s.Q.isClient ? localStorage.getItem(`${i.s1.STORAGE_KEY}${e}`) : null,
        delete(e, t) {
          s.Q.isClient &&
            (t
              ? localStorage.removeItem(e)
              : localStorage.removeItem(`${i.s1.STORAGE_KEY}${e}`));
        },
      };
    },
    23749: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { R: () => eh });
      let s = (e, t, r) =>
          JSON.stringify(
            e,
            (e, r) => {
              let i = "bigint" == typeof r ? r.toString() : r;
              return "function" == typeof t ? t(e, i) : i;
            },
            r
          ),
        n = "2.23.15",
        a = {
          getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: r }) =>
            t ? `${e ?? "https://viem.sh"}${t}${r ? `#${r}` : ""}` : void 0,
          version: `viem@${n}`,
        };
      class o extends Error {
        constructor(e, t = {}) {
          let r =
              t.cause instanceof o
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            i = (t.cause instanceof o && t.cause.docsPath) || t.docsPath,
            s = a.getDocsUrl?.({ ...t, docsPath: i });
          super(
            [
              e || "An error occurred.",
              "",
              ...(t.metaMessages ? [...t.metaMessages, ""] : []),
              ...(s ? [`Docs: ${s}`] : []),
              ...(r ? [`Details: ${r}`] : []),
              ...(a.version ? [`Version: ${a.version}`] : []),
            ].join("\n"),
            t.cause ? { cause: t.cause } : void 0
          ),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "version", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "BaseError",
            }),
            (this.details = r),
            (this.docsPath = i),
            (this.metaMessages = t.metaMessages),
            (this.name = t.name ?? this.name),
            (this.shortMessage = e),
            (this.version = n);
        }
        walk(e) {
          return (function e(t, r) {
            return r?.(t)
              ? t
              : t && "object" == typeof t && "cause" in t && void 0 !== t.cause
              ? e(t.cause, r)
              : r
              ? null
              : t;
          })(this, e);
        }
      }
      let c = (e) => e;
      class l extends o {
        constructor({
          body: e,
          cause: t,
          details: r,
          headers: i,
          status: n,
          url: a,
        }) {
          super("HTTP request failed.", {
            cause: t,
            details: r,
            metaMessages: [
              n && `Status: ${n}`,
              `URL: ${c(a)}`,
              e && `Request body: ${s(e)}`,
            ].filter(Boolean),
            name: "HttpRequestError",
          }),
            Object.defineProperty(this, "body", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "headers", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "status", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "url", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.body = e),
            (this.headers = i),
            (this.status = n),
            (this.url = a);
        }
      }
      class d extends o {
        constructor({ body: e, error: t, url: r }) {
          super("RPC Request failed.", {
            cause: t,
            details: t.message,
            metaMessages: [`URL: ${c(r)}`, `Request body: ${s(e)}`],
            name: "RpcRequestError",
          }),
            Object.defineProperty(this, "code", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "data", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.code = t.code),
            (this.data = t.data);
        }
      }
      class u extends o {
        constructor({ body: e, url: t }) {
          super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [`URL: ${c(t)}`, `Request body: ${s(e)}`],
            name: "TimeoutError",
          });
        }
      }
      class h extends o {
        constructor() {
          super(
            "No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",
            { docsPath: "/docs/clients/intro", name: "UrlRequiredError" }
          );
        }
      }
      let f = new Map(),
        p = {
          current: 0,
          take() {
            return this.current++;
          },
          reset() {
            this.current = 0;
          },
        };
      class g extends o {
        constructor(
          e,
          { code: t, docsPath: r, metaMessages: i, name: s, shortMessage: n }
        ) {
          super(n, {
            cause: e,
            docsPath: r,
            metaMessages: i || e?.metaMessages,
            name: s || "RpcError",
          }),
            Object.defineProperty(this, "code", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.name = s || e.name),
            (this.code = e instanceof d ? e.code : t ?? -1);
        }
      }
      class m extends g {
        constructor(e, t) {
          super(e, t),
            Object.defineProperty(this, "data", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.data = t.data);
        }
      }
      class b extends g {
        constructor(e) {
          super(e, {
            code: b.code,
            name: "ParseRpcError",
            shortMessage:
              "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",
          });
        }
      }
      Object.defineProperty(b, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32700,
      });
      class y extends g {
        constructor(e) {
          super(e, {
            code: y.code,
            name: "InvalidRequestRpcError",
            shortMessage: "JSON is not a valid request object.",
          });
        }
      }
      Object.defineProperty(y, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32600,
      });
      class w extends g {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: w.code,
            name: "MethodNotFoundRpcError",
            shortMessage: `The method${
              t ? ` "${t}"` : ""
            } does not exist / is not available.`,
          });
        }
      }
      Object.defineProperty(w, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32601,
      });
      class v extends g {
        constructor(e) {
          super(e, {
            code: v.code,
            name: "InvalidParamsRpcError",
            shortMessage:
              "Invalid parameters were provided to the RPC method.\nDouble check you have provided the correct parameters.",
          });
        }
      }
      Object.defineProperty(v, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32602,
      });
      class A extends g {
        constructor(e) {
          super(e, {
            code: A.code,
            name: "InternalRpcError",
            shortMessage: "An internal error was received.",
          });
        }
      }
      Object.defineProperty(A, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32603,
      });
      class E extends g {
        constructor(e) {
          super(e, {
            code: E.code,
            name: "InvalidInputRpcError",
            shortMessage:
              "Missing or invalid parameters.\nDouble check you have provided the correct parameters.",
          });
        }
      }
      Object.defineProperty(E, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32e3,
      });
      class _ extends g {
        constructor(e) {
          super(e, {
            code: _.code,
            name: "ResourceNotFoundRpcError",
            shortMessage: "Requested resource not found.",
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ResourceNotFoundRpcError",
            });
        }
      }
      Object.defineProperty(_, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32001,
      });
      class C extends g {
        constructor(e) {
          super(e, {
            code: C.code,
            name: "ResourceUnavailableRpcError",
            shortMessage: "Requested resource not available.",
          });
        }
      }
      Object.defineProperty(C, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32002,
      });
      class I extends g {
        constructor(e) {
          super(e, {
            code: I.code,
            name: "TransactionRejectedRpcError",
            shortMessage: "Transaction creation failed.",
          });
        }
      }
      Object.defineProperty(I, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32003,
      });
      class S extends g {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: S.code,
            name: "MethodNotSupportedRpcError",
            shortMessage: `Method${t ? ` "${t}"` : ""} is not supported.`,
          });
        }
      }
      Object.defineProperty(S, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32004,
      });
      class x extends g {
        constructor(e) {
          super(e, {
            code: x.code,
            name: "LimitExceededRpcError",
            shortMessage: "Request exceeds defined limit.",
          });
        }
      }
      Object.defineProperty(x, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32005,
      });
      class N extends g {
        constructor(e) {
          super(e, {
            code: N.code,
            name: "JsonRpcVersionUnsupportedError",
            shortMessage: "Version of JSON-RPC protocol is not supported.",
          });
        }
      }
      Object.defineProperty(N, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32006,
      });
      class T extends m {
        constructor(e) {
          super(e, {
            code: T.code,
            name: "UserRejectedRequestError",
            shortMessage: "User rejected the request.",
          });
        }
      }
      Object.defineProperty(T, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4001,
      });
      class P extends m {
        constructor(e) {
          super(e, {
            code: P.code,
            name: "UnauthorizedProviderError",
            shortMessage:
              "The requested method and/or account has not been authorized by the user.",
          });
        }
      }
      Object.defineProperty(P, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4100,
      });
      class O extends m {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: O.code,
            name: "UnsupportedProviderMethodError",
            shortMessage: `The Provider does not support the requested method${
              t ? ` " ${t}"` : ""
            }.`,
          });
        }
      }
      Object.defineProperty(O, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4200,
      });
      class k extends m {
        constructor(e) {
          super(e, {
            code: k.code,
            name: "ProviderDisconnectedError",
            shortMessage: "The Provider is disconnected from all chains.",
          });
        }
      }
      Object.defineProperty(k, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4900,
      });
      class R extends m {
        constructor(e) {
          super(e, {
            code: R.code,
            name: "ChainDisconnectedError",
            shortMessage:
              "The Provider is not connected to the requested chain.",
          });
        }
      }
      Object.defineProperty(R, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4901,
      });
      class D extends m {
        constructor(e) {
          super(e, {
            code: D.code,
            name: "SwitchChainError",
            shortMessage: "An error occurred when attempting to switch chain.",
          });
        }
      }
      Object.defineProperty(D, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4902,
      });
      class M extends g {
        constructor(e) {
          super(e, {
            name: "UnknownRpcError",
            shortMessage: "An unknown RPC error occurred.",
          });
        }
      }
      class U extends o {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} size (${e}) exceeds padding size (${t}).`,
            { name: "SizeExceedsPaddingSizeError" }
          );
        }
      }
      class L extends o {
        constructor({ givenSize: e, maxSize: t }) {
          super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
            name: "SizeOverflowError",
          });
        }
      }
      function B(e) {
        return !(function (e, { strict: t = !0 } = {}) {
          return (
            !!e &&
            "string" == typeof e &&
            (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x"))
          );
        })(e, { strict: !1 })
          ? e.length
          : Math.ceil((e.length - 2) / 2);
      }
      function j(e, { size: t }) {
        if (B(e) > t) throw new L({ givenSize: B(e), maxSize: t });
      }
      let F = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0")
        ),
        $ = new TextEncoder();
      class z extends Map {
        constructor(e) {
          super(),
            Object.defineProperty(this, "maxSize", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.maxSize = e);
        }
        get(e) {
          let t = super.get(e);
          return (
            super.has(e) && void 0 !== t && (this.delete(e), super.set(e, t)), t
          );
        }
        set(e, t) {
          if ((super.set(e, t), this.maxSize && this.size > this.maxSize)) {
            let e = this.keys().next().value;
            e && this.delete(e);
          }
          return this;
        }
      }
      let W = new z(8192);
      async function H(e) {
        return new Promise((t) => setTimeout(t, e));
      }
      let q = 256;
      function V(
        {
          key: e,
          methods: t,
          name: r,
          request: n,
          retryCount: a = 3,
          retryDelay: c = 150,
          timeout: d,
          type: u,
        },
        h
      ) {
        return {
          config: {
            key: e,
            methods: t,
            name: r,
            request: n,
            retryCount: a,
            retryDelay: c,
            timeout: d,
            type: u,
          },
          request: (function (e, t = {}) {
            return async (r, i = {}) => {
              let {
                  dedupe: n = !1,
                  methods: a,
                  retryDelay: c = 150,
                  retryCount: d = 3,
                  uid: u,
                } = { ...t, ...i },
                { method: h } = r;
              if (
                a?.exclude?.includes(h) ||
                (a?.include && !a.include.includes(h))
              )
                throw new S(Error("method not supported"), { method: h });
              let f = n
                ? (function (e, t = {}) {
                    return (function (e, t = {}) {
                      let r = "";
                      for (let t = 0; t < e.length; t++) r += F[e[t]];
                      let i = `0x${r}`;
                      return "number" == typeof t.size
                        ? (j(i, { size: t.size }),
                          (function (e, { dir: t, size: r = 32 } = {}) {
                            return "string" == typeof e
                              ? (function (e, { dir: t, size: r = 32 } = {}) {
                                  if (null === r) return e;
                                  let i = e.replace("0x", "");
                                  if (i.length > 2 * r)
                                    throw new U({
                                      size: Math.ceil(i.length / 2),
                                      targetSize: r,
                                      type: "hex",
                                    });
                                  return `0x${i[
                                    "right" === t ? "padEnd" : "padStart"
                                  ](2 * r, "0")}`;
                                })(e, { dir: t, size: r })
                              : (function (e, { dir: t, size: r = 32 } = {}) {
                                  if (null === r) return e;
                                  if (e.length > r)
                                    throw new U({
                                      size: e.length,
                                      targetSize: r,
                                      type: "bytes",
                                    });
                                  let i = new Uint8Array(r);
                                  for (let s = 0; s < r; s++) {
                                    let n = "right" === t;
                                    i[n ? s : r - s - 1] =
                                      e[n ? s : e.length - s - 1];
                                  }
                                  return i;
                                })(e, { dir: t, size: r });
                          })(i, { dir: "right", size: t.size }))
                        : i;
                    })($.encode(e), t);
                  })(`${u}.${s(r)}`)
                : void 0;
              return (function (e, { enabled: t = !0, id: r }) {
                if (!t || !r) return e();
                if (W.get(r)) return W.get(r);
                let i = e().finally(() => W.delete(r));
                return W.set(r, i), i;
              })(
                () =>
                  (function (
                    e,
                    {
                      delay: t = 100,
                      retryCount: r = 2,
                      shouldRetry: i = () => !0,
                    } = {}
                  ) {
                    return new Promise((s, n) => {
                      let a = async ({ count: o = 0 } = {}) => {
                        let c = async ({ error: e }) => {
                          let r =
                            "function" == typeof t
                              ? t({ count: o, error: e })
                              : t;
                          r && (await H(r)), a({ count: o + 1 });
                        };
                        try {
                          let t = await e();
                          s(t);
                        } catch (e) {
                          if (o < r && (await i({ count: o, error: e })))
                            return c({ error: e });
                          n(e);
                        }
                      };
                      a();
                    });
                  })(
                    async () => {
                      try {
                        return await e(r);
                      } catch (e) {
                        switch (e.code) {
                          case b.code:
                            throw new b(e);
                          case y.code:
                            throw new y(e);
                          case w.code:
                            throw new w(e, { method: r.method });
                          case v.code:
                            throw new v(e);
                          case A.code:
                            throw new A(e);
                          case E.code:
                            throw new E(e);
                          case _.code:
                            throw new _(e);
                          case C.code:
                            throw new C(e);
                          case I.code:
                            throw new I(e);
                          case S.code:
                            throw new S(e, { method: r.method });
                          case x.code:
                            throw new x(e);
                          case N.code:
                            throw new N(e);
                          case T.code:
                            throw new T(e);
                          case P.code:
                            throw new P(e);
                          case O.code:
                            throw new O(e);
                          case k.code:
                            throw new k(e);
                          case R.code:
                            throw new R(e);
                          case D.code:
                            throw new D(e);
                          case 5e3:
                            throw new T(e);
                          default:
                            if (e instanceof o) throw e;
                            throw new M(e);
                        }
                      }
                    },
                    {
                      delay: ({ count: e, error: t }) => {
                        if (t && t instanceof l) {
                          let e = t?.headers?.get("Retry-After");
                          if (e?.match(/\d/)) return 1e3 * Number.parseInt(e);
                        }
                        return ~~(1 << e) * c;
                      },
                      retryCount: d,
                      shouldRetry: ({ error: e }) => {
                        var t;
                        return "code" in (t = e) && "number" == typeof t.code
                          ? -1 === t.code ||
                              t.code === x.code ||
                              t.code === A.code
                          : !(t instanceof l) ||
                              !t.status ||
                              403 === t.status ||
                              408 === t.status ||
                              413 === t.status ||
                              429 === t.status ||
                              500 === t.status ||
                              502 === t.status ||
                              503 === t.status ||
                              504 === t.status ||
                              !1;
                      },
                    }
                  ),
                { enabled: n, id: f }
              );
            };
          })(n, {
            methods: t,
            retryCount: a,
            retryDelay: c,
            uid: (function (e = 11) {
              if (!i || q + e > 512) {
                (i = ""), (q = 0);
                for (let e = 0; e < 256; e++)
                  i += ((256 + 256 * Math.random()) | 0)
                    .toString(16)
                    .substring(1);
              }
              return i.substring(q, q++ + e);
            })(),
          }),
          value: h,
        };
      }
      function K(e, t = {}) {
        let {
          batch: r,
          fetchOptions: i,
          key: n = "http",
          methods: a,
          name: o = "HTTP JSON-RPC",
          onFetchRequest: c,
          onFetchResponse: g,
          retryDelay: m,
          raw: b,
        } = t;
        return ({ chain: y, retryCount: w, timeout: v }) => {
          let { batchSize: A = 1e3, wait: E = 0 } =
              "object" == typeof r ? r : {},
            _ = t.retryCount ?? w,
            C = v ?? t.timeout ?? 1e4,
            I = e || y?.rpcUrls.default.http[0];
          if (!I) throw new h();
          let S = (function (e, t = {}) {
            return {
              async request(r) {
                let {
                    body: i,
                    onRequest: n = t.onRequest,
                    onResponse: a = t.onResponse,
                    timeout: o = t.timeout ?? 1e4,
                  } = r,
                  c = { ...(t.fetchOptions ?? {}), ...(r.fetchOptions ?? {}) },
                  { headers: d, method: h, signal: f } = c;
                try {
                  let t;
                  let r = await (function (
                    e,
                    {
                      errorInstance: t = Error("timed out"),
                      timeout: r,
                      signal: i,
                    }
                  ) {
                    return new Promise((s, n) => {
                      (async () => {
                        let a;
                        try {
                          let o = new AbortController();
                          r > 0 &&
                            (a = setTimeout(() => {
                              i ? o.abort() : n(t);
                            }, r)),
                            s(await e({ signal: o?.signal || null }));
                        } catch (e) {
                          e?.name === "AbortError" && n(t), n(e);
                        } finally {
                          clearTimeout(a);
                        }
                      })();
                    });
                  })(
                    async ({ signal: t }) => {
                      let r = {
                          ...c,
                          body: Array.isArray(i)
                            ? s(
                                i.map((e) => ({
                                  jsonrpc: "2.0",
                                  id: e.id ?? p.take(),
                                  ...e,
                                }))
                              )
                            : s({ jsonrpc: "2.0", id: i.id ?? p.take(), ...i }),
                          headers: { "Content-Type": "application/json", ...d },
                          method: h || "POST",
                          signal: f || (o > 0 ? t : null),
                        },
                        a = new Request(e, r),
                        l = (await n?.(a, r)) ?? { ...r, url: e };
                      return await fetch(l.url ?? e, l);
                    },
                    {
                      errorInstance: new u({ body: i, url: e }),
                      timeout: o,
                      signal: !0,
                    }
                  );
                  if (
                    (a && (await a(r)),
                    r.headers
                      .get("Content-Type")
                      ?.startsWith("application/json"))
                  )
                    t = await r.json();
                  else {
                    t = await r.text();
                    try {
                      t = JSON.parse(t || "{}");
                    } catch (e) {
                      if (r.ok) throw e;
                      t = { error: t };
                    }
                  }
                  if (!r.ok)
                    throw new l({
                      body: i,
                      details: s(t.error) || r.statusText,
                      headers: r.headers,
                      status: r.status,
                      url: e,
                    });
                  return t;
                } catch (t) {
                  if (t instanceof l || t instanceof u) throw t;
                  throw new l({ body: i, cause: t, url: e });
                }
              },
            };
          })(I, { fetchOptions: i, onRequest: c, onResponse: g, timeout: C });
          return V(
            {
              key: n,
              methods: a,
              name: o,
              async request({ method: e, params: t }) {
                let i = { method: e, params: t },
                  { schedule: s } = (function ({
                    fn: e,
                    id: t,
                    shouldSplitBatch: r,
                    wait: i = 0,
                    sort: s,
                  }) {
                    let n = async () => {
                        let t = c();
                        a();
                        let r = t.map(({ args: e }) => e);
                        0 !== r.length &&
                          e(r)
                            .then((e) => {
                              s && Array.isArray(e) && e.sort(s);
                              for (let r = 0; r < t.length; r++) {
                                let { resolve: i } = t[r];
                                i?.([e[r], e]);
                              }
                            })
                            .catch((e) => {
                              for (let r = 0; r < t.length; r++) {
                                let { reject: i } = t[r];
                                i?.(e);
                              }
                            });
                      },
                      a = () => f.delete(t),
                      o = () => c().map(({ args: e }) => e),
                      c = () => f.get(t) || [],
                      l = (e) => f.set(t, [...c(), e]);
                    return {
                      flush: a,
                      async schedule(e) {
                        let t, s;
                        let {
                          promise: a,
                          resolve: d,
                          reject: u,
                        } = ((t = () => void 0),
                        (s = () => void 0),
                        {
                          promise: new Promise((e, r) => {
                            (t = e), (s = r);
                          }),
                          resolve: t,
                          reject: s,
                        });
                        return (
                          (r?.([...o(), e]) && n(), c().length > 0)
                            ? l({ args: e, resolve: d, reject: u })
                            : (l({ args: e, resolve: d, reject: u }),
                              setTimeout(n, i)),
                          a
                        );
                      },
                    };
                  })({
                    id: I,
                    wait: E,
                    shouldSplitBatch: (e) => e.length > A,
                    fn: (e) => S.request({ body: e }),
                    sort: (e, t) => e.id - t.id,
                  }),
                  n = async (e) => (r ? s(e) : [await S.request({ body: e })]),
                  [{ error: a, result: o }] = await n(i);
                if (b) return { error: a, result: o };
                if (a) throw new d({ body: i, error: a, url: I });
                return o;
              },
              retryCount: _,
              retryDelay: m,
              timeout: C,
              type: "http",
            },
            { fetchOptions: i, url: I }
          );
        };
      }
      let G = { ether: -9, wei: 9 };
      function Y(e, t = "wei") {
        return (function (e, t) {
          let r = e.toString(),
            i = r.startsWith("-");
          i && (r = r.slice(1));
          let [s, n] = [
            (r = r.padStart(t, "0")).slice(0, r.length - t),
            r.slice(r.length - t),
          ];
          return (
            (n = n.replace(/(0+)$/, "")),
            `${i ? "-" : ""}${s || "0"}${n ? `.${n}` : ""}`
          );
        })(e, G[t]);
      }
      class Q extends o {
        constructor({ cause: e, message: t } = {}) {
          let r = t
            ?.replace("execution reverted: ", "")
            ?.replace("execution reverted", "");
          super(
            `Execution reverted ${
              r ? `with reason: ${r}` : "for an unknown reason"
            }.`,
            { cause: e, name: "ExecutionRevertedError" }
          );
        }
      }
      Object.defineProperty(Q, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 3,
      }),
        Object.defineProperty(Q, "nodeMessage", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: /execution reverted/,
        });
      class Z extends o {
        constructor({ cause: e, maxFeePerGas: t } = {}) {
          super(
            `The fee cap (\`maxFeePerGas\`${
              t ? ` = ${Y(t)} gwei` : ""
            }) cannot be higher than the maximum allowed value (2^256-1).`,
            { cause: e, name: "FeeCapTooHighError" }
          );
        }
      }
      Object.defineProperty(Z, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value:
          /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/,
      });
      class J extends o {
        constructor({ cause: e, maxFeePerGas: t } = {}) {
          super(
            `The fee cap (\`maxFeePerGas\`${
              t ? ` = ${Y(t)}` : ""
            } gwei) cannot be lower than the block base fee.`,
            { cause: e, name: "FeeCapTooLowError" }
          );
        }
      }
      Object.defineProperty(J, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value:
          /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/,
      });
      class X extends o {
        constructor({ cause: e, nonce: t } = {}) {
          super(
            `Nonce provided for the transaction ${
              t ? `(${t}) ` : ""
            }is higher than the next one expected.`,
            { cause: e, name: "NonceTooHighError" }
          );
        }
      }
      Object.defineProperty(X, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /nonce too high/,
      });
      class ee extends o {
        constructor({ cause: e, nonce: t } = {}) {
          super(
            `Nonce provided for the transaction ${
              t ? `(${t}) ` : ""
            }is lower than the current nonce of the account.
Try increasing the nonce or find the latest nonce with \`getTransactionCount\`.`,
            { cause: e, name: "NonceTooLowError" }
          );
        }
      }
      Object.defineProperty(ee, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /nonce too low|transaction already imported|already known/,
      });
      class et extends o {
        constructor({ cause: e, nonce: t } = {}) {
          super(
            `Nonce provided for the transaction ${
              t ? `(${t}) ` : ""
            }exceeds the maximum allowed nonce.`,
            { cause: e, name: "NonceMaxValueError" }
          );
        }
      }
      Object.defineProperty(et, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /nonce has max value/,
      });
      class er extends o {
        constructor({ cause: e } = {}) {
          super(
            "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.",
            {
              cause: e,
              metaMessages: [
                "This error could arise when the account does not have enough funds to:",
                " - pay for the total gas fee,",
                " - pay for the value to send.",
                " ",
                "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
                " - `gas` is the amount of gas needed for transaction to execute,",
                " - `gas fee` is the gas fee,",
                " - `value` is the amount of ether to send to the recipient.",
              ],
              name: "InsufficientFundsError",
            }
          );
        }
      }
      Object.defineProperty(er, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /insufficient funds|exceeds transaction sender account balance/,
      });
      class ei extends o {
        constructor({ cause: e, gas: t } = {}) {
          super(
            `The amount of gas ${
              t ? `(${t}) ` : ""
            }provided for the transaction exceeds the limit allowed for the block.`,
            { cause: e, name: "IntrinsicGasTooHighError" }
          );
        }
      }
      Object.defineProperty(ei, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /intrinsic gas too high|gas limit reached/,
      });
      class es extends o {
        constructor({ cause: e, gas: t } = {}) {
          super(
            `The amount of gas ${
              t ? `(${t}) ` : ""
            }provided for the transaction is too low.`,
            { cause: e, name: "IntrinsicGasTooLowError" }
          );
        }
      }
      Object.defineProperty(es, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /intrinsic gas too low/,
      });
      class en extends o {
        constructor({ cause: e }) {
          super("The transaction type is not supported for this chain.", {
            cause: e,
            name: "TransactionTypeNotSupportedError",
          });
        }
      }
      Object.defineProperty(en, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /transaction type not valid/,
      });
      class ea extends o {
        constructor({
          cause: e,
          maxPriorityFeePerGas: t,
          maxFeePerGas: r,
        } = {}) {
          super(
            `The provided tip (\`maxPriorityFeePerGas\`${
              t ? ` = ${Y(t)} gwei` : ""
            }) cannot be higher than the fee cap (\`maxFeePerGas\`${
              r ? ` = ${Y(r)} gwei` : ""
            }).`,
            { cause: e, name: "TipAboveFeeCapError" }
          );
        }
      }
      function eo(e, t = {}) {
        let {
          key: r = "fallback",
          name: i = "Fallback",
          rank: s = !1,
          shouldThrow: n = ec,
          retryCount: a,
          retryDelay: o,
        } = t;
        return ({ chain: t, pollingInterval: c = 4e3, timeout: l, ...d }) => {
          let u = e,
            h = () => {},
            f = V(
              {
                key: r,
                name: i,
                async request({ method: e, params: r }) {
                  let i;
                  let s = async (a = 0) => {
                    let o = u[a]({ ...d, chain: t, retryCount: 0, timeout: l });
                    try {
                      let t = await o.request({ method: e, params: r });
                      return (
                        h({
                          method: e,
                          params: r,
                          response: t,
                          transport: o,
                          status: "success",
                        }),
                        t
                      );
                    } catch (c) {
                      if (
                        (h({
                          error: c,
                          method: e,
                          params: r,
                          transport: o,
                          status: "error",
                        }),
                        n(c) ||
                          a === u.length - 1 ||
                          !(i ??= u.slice(a + 1).some((r) => {
                            let { include: i, exclude: s } =
                              r({ chain: t }).config.methods || {};
                            return i ? i.includes(e) : !s || !s.includes(e);
                          })))
                      )
                        throw c;
                      return s(a + 1);
                    }
                  };
                  return s();
                },
                retryCount: a,
                retryDelay: o,
                type: "fallback",
              },
              {
                onResponse: (e) => (h = e),
                transports: u.map((e) => e({ chain: t, retryCount: 0 })),
              }
            );
          if (s) {
            let e = "object" == typeof s ? s : {};
            !(function ({
              chain: e,
              interval: t = 4e3,
              onTransports: r,
              ping: i,
              sampleCount: s = 10,
              timeout: n = 1e3,
              transports: a,
              weights: o = {},
            }) {
              let { stability: c = 0.7, latency: l = 0.3 } = o,
                d = [],
                u = async () => {
                  let o = await Promise.all(
                    a.map(async (t) => {
                      let r, s;
                      let a = t({ chain: e, retryCount: 0, timeout: n }),
                        o = Date.now();
                      try {
                        await (i
                          ? i({ transport: a })
                          : a.request({ method: "net_listening" })),
                          (s = 1);
                      } catch {
                        s = 0;
                      } finally {
                        r = Date.now();
                      }
                      return { latency: r - o, success: s };
                    })
                  );
                  d.push(o), d.length > s && d.shift();
                  let h = Math.max(
                    ...d.map((e) => Math.max(...e.map(({ latency: e }) => e)))
                  );
                  r(
                    a
                      .map((e, t) => {
                        let r = d.map((e) => e[t].latency),
                          i = r.reduce((e, t) => e + t, 0) / r.length,
                          s = d.map((e) => e[t].success),
                          n = s.reduce((e, t) => e + t, 0) / s.length;
                        return 0 === n ? [0, t] : [l * (1 - i / h) + c * n, t];
                      })
                      .sort((e, t) => t[0] - e[0])
                      .map(([, e]) => a[e])
                  ),
                    await H(t),
                    u();
                };
              u();
            })({
              chain: t,
              interval: e.interval ?? c,
              onTransports: (e) => (u = e),
              ping: e.ping,
              sampleCount: e.sampleCount,
              timeout: e.timeout,
              transports: u,
              weights: e.weights,
            });
          }
          return f;
        };
      }
      function ec(e) {
        return !!(
          "code" in e &&
          "number" == typeof e.code &&
          (e.code === I.code ||
            e.code === T.code ||
            Q.nodeMessage.test(e.message) ||
            5e3 === e.code)
        );
      }
      Object.defineProperty(ea, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value:
          /max priority fee per gas higher than max fee per gas|tip higher than fee cap/,
      });
      var el = r(45553),
        ed = r(75578);
      let eu = [
          "near:mainnet",
          "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
          "eip155:1101",
          "eip155:56",
          "eip155:42161",
          "eip155:7777777",
          "eip155:59144",
          "eip155:324",
          "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
          "eip155:5000",
          "solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
          "eip155:80084",
          "eip155:5003",
          "eip155:100",
          "eip155:8453",
          "eip155:42220",
          "eip155:1313161555",
          "eip155:17000",
          "eip155:1",
          "eip155:300",
          "eip155:1313161554",
          "eip155:1329",
          "eip155:84532",
          "eip155:421614",
          "eip155:11155111",
          "eip155:8217",
          "eip155:43114",
          "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
          "eip155:999999999",
          "eip155:11155420",
          "eip155:80002",
          "eip155:97",
          "eip155:43113",
          "eip155:137",
          "eip155:10",
          "eip155:1301",
          "bip122:000000000019d6689c085ae165831e93",
          "bip122:000000000933ea01ad0ee984209779ba",
        ],
        eh = {
          extendRpcUrlWithProjectId(e, t) {
            let r = !1;
            try {
              r = "rpc.walletconnect.org" === new URL(e).host;
            } catch (e) {
              r = !1;
            }
            if (r) {
              let r = new URL(e);
              return (
                r.searchParams.has("projectId") ||
                  r.searchParams.set("projectId", t),
                r.toString()
              );
            }
            return e;
          },
          isCaipNetwork: (e) => "chainNamespace" in e && "caipNetworkId" in e,
          getChainNamespace(e) {
            return this.isCaipNetwork(e) ? e.chainNamespace : el.o.CHAIN.EVM;
          },
          getCaipNetworkId(e) {
            return this.isCaipNetwork(e)
              ? e.caipNetworkId
              : `${el.o.CHAIN.EVM}:${e.id}`;
          },
          getDefaultRpcUrl(e, t, r) {
            let i = e.rpcUrls?.default?.http?.[0];
            return eu.includes(t)
              ? (function (e, t) {
                  let r = new URL("https://rpc.walletconnect.org/v1/");
                  return (
                    r.searchParams.set("chainId", e),
                    r.searchParams.set("projectId", t),
                    r.toString()
                  );
                })(t, r)
              : i || "";
          },
          extendCaipNetwork(
            e,
            { customNetworkImageUrls: t, projectId: r, customRpcUrls: i }
          ) {
            let s = this.getChainNamespace(e),
              n = this.getCaipNetworkId(e),
              a = e.rpcUrls.default.http?.[0],
              o = this.getDefaultRpcUrl(e, n, r),
              c = e?.rpcUrls?.chainDefault?.http?.[0] || a,
              l = i?.[n]?.map((e) => e.url) || [],
              d = [...l, o],
              u = [...l];
            return (
              c && !u.includes(c) && u.push(c),
              {
                ...e,
                chainNamespace: s,
                caipNetworkId: n,
                assets: {
                  imageId: ed.L.NetworkImageIds[e.id],
                  imageUrl: t?.[e.id],
                },
                rpcUrls: {
                  ...e.rpcUrls,
                  default: { http: d },
                  chainDefault: { http: u },
                },
              }
            );
          },
          extendCaipNetworks: (
            e,
            { customNetworkImageUrls: t, projectId: r, customRpcUrls: i }
          ) =>
            e.map((e) =>
              eh.extendCaipNetwork(e, {
                customNetworkImageUrls: t,
                customRpcUrls: i,
                projectId: r,
              })
            ),
          getViemTransport(e, t, r) {
            let i = [];
            if (
              (r?.forEach((e) => {
                i.push(K(e.url, e.config));
              }),
              eu.includes(e.caipNetworkId))
            ) {
              let r = this.getDefaultRpcUrl(e, e.caipNetworkId, t);
              i.push(
                K(r, {
                  fetchOptions: { headers: { "Content-Type": "text/plain" } },
                })
              );
            }
            return eo(i);
          },
          extendWagmiTransports(e, t, r) {
            return eu.includes(e.caipNetworkId)
              ? eo([r, K(this.getDefaultRpcUrl(e, e.caipNetworkId, t))])
              : r;
          },
        };
    },
    23750: (e, t, r) => {
      "use strict";
      (t.base = r(92963)),
        (t.short = r(70064)),
        (t.mont = r(83176)),
        (t.edwards = r(85574));
    },
    24250: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => s, R: () => i });
      let i = (e) => e,
        s = (e) => e;
    },
    24369: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => h });
      var i = r(1220),
        s = r(73537),
        n = r(58051),
        a = r(44826),
        o = r(73442),
        c = r(70417),
        l = r(55480),
        d = r(65374);
      let u = (0, i.BX)({
          transactions: [],
          coinbaseTransactions: {},
          transactionsByYear: {},
          lastNetworkInView: void 0,
          loading: !1,
          empty: !1,
          next: void 0,
        }),
        h = {
          state: u,
          subscribe: (e) => (0, i.B1)(u, () => e(u)),
          setLastNetworkInView(e) {
            u.lastNetworkInView = e;
          },
          async fetchTransactions(e, t) {
            if (!e)
              throw Error(
                "Transactions can't be fetched without an accountAddress"
              );
            u.loading = !0;
            try {
              let r = await a.T.fetchTransactions({
                  account: e,
                  cursor: u.next,
                  onramp: t,
                  cache: "coinbase" === t ? "no-cache" : void 0,
                  chainId: o.W.state.activeCaipNetwork?.caipNetworkId,
                }),
                i = this.filterSpamTransactions(r.data),
                s = this.filterByConnectedChain(i),
                n = [...u.transactions, ...s];
              (u.loading = !1),
                "coinbase" === t
                  ? (u.coinbaseTransactions =
                      this.groupTransactionsByYearAndMonth(
                        u.coinbaseTransactions,
                        r.data
                      ))
                  : ((u.transactions = n),
                    (u.transactionsByYear =
                      this.groupTransactionsByYearAndMonth(
                        u.transactionsByYear,
                        s
                      ))),
                (u.empty = 0 === n.length),
                (u.next = r.next ? r.next : void 0);
            } catch (t) {
              c.E.sendEvent({
                type: "track",
                event: "ERROR_FETCH_TRANSACTIONS",
                properties: {
                  address: e,
                  projectId: l.H.state.projectId,
                  cursor: u.next,
                  isSmartAccount:
                    n.U.state.preferredAccountType ===
                    s.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                },
              }),
                d.P.showError("Failed to fetch transactions"),
                (u.loading = !1),
                (u.empty = !0),
                (u.next = void 0);
            }
          },
          groupTransactionsByYearAndMonth: (e = {}, t = []) => (
            t.forEach((t) => {
              let r = new Date(t.metadata.minedAt).getFullYear(),
                i = new Date(t.metadata.minedAt).getMonth(),
                s = e[r] ?? {},
                n = (s[i] ?? []).filter((e) => e.id !== t.id);
              e[r] = {
                ...s,
                [i]: [...n, t].sort(
                  (e, t) =>
                    new Date(t.metadata.minedAt).getTime() -
                    new Date(e.metadata.minedAt).getTime()
                ),
              };
            }),
            e
          ),
          filterSpamTransactions: (e) =>
            e.filter(
              (e) => !e.transfers.every((e) => e.nft_info?.flags.is_spam === !0)
            ),
          filterByConnectedChain(e) {
            let t = o.W.state.activeCaipNetwork?.caipNetworkId;
            return e.filter((e) => e.metadata.chain === t);
          },
          clearCursor() {
            u.next = void 0;
          },
          resetTransactions() {
            (u.transactions = []),
              (u.transactionsByYear = {}),
              (u.lastNetworkInView = void 0),
              (u.loading = !1),
              (u.empty = !1),
              (u.next = void 0);
          },
        };
    },
    24755: (e, t, r) => {
      "use strict";
      r.d(t, { sc: () => l });
      var i = r(17852),
        s = r(458);
      let n = new Uint32Array([
          0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
          0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
          0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
          0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f,
          0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d,
          0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x6ca6351, 0x14292967,
          0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354,
          0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
          0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585,
          0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
          0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee,
          0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb,
          0xbef9a3f7, 0xc67178f2,
        ]),
        a = new Uint32Array([
          0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f,
          0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
        ]),
        o = new Uint32Array(64);
      class c extends i.ol {
        constructor() {
          super(64, 32, 8, !1),
            (this.A = 0 | a[0]),
            (this.B = 0 | a[1]),
            (this.C = 0 | a[2]),
            (this.D = 0 | a[3]),
            (this.E = 0 | a[4]),
            (this.F = 0 | a[5]),
            (this.G = 0 | a[6]),
            (this.H = 0 | a[7]);
        }
        get() {
          let { A: e, B: t, C: r, D: i, E: s, F: n, G: a, H: o } = this;
          return [e, t, r, i, s, n, a, o];
        }
        set(e, t, r, i, s, n, a, o) {
          (this.A = 0 | e),
            (this.B = 0 | t),
            (this.C = 0 | r),
            (this.D = 0 | i),
            (this.E = 0 | s),
            (this.F = 0 | n),
            (this.G = 0 | a),
            (this.H = 0 | o);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4) o[r] = e.getUint32(t, !1);
          for (let e = 16; e < 64; e++) {
            let t = o[e - 15],
              r = o[e - 2],
              i = (0, s.Ow)(t, 7) ^ (0, s.Ow)(t, 18) ^ (t >>> 3),
              n = (0, s.Ow)(r, 17) ^ (0, s.Ow)(r, 19) ^ (r >>> 10);
            o[e] = (n + o[e - 7] + i + o[e - 16]) | 0;
          }
          let { A: r, B: a, C: c, D: l, E: d, F: u, G: h, H: f } = this;
          for (let e = 0; e < 64; e++) {
            let t =
                (f +
                  ((0, s.Ow)(d, 6) ^ (0, s.Ow)(d, 11) ^ (0, s.Ow)(d, 25)) +
                  (0, i.r9)(d, u, h) +
                  n[e] +
                  o[e]) |
                0,
              p =
                (((0, s.Ow)(r, 2) ^ (0, s.Ow)(r, 13) ^ (0, s.Ow)(r, 22)) +
                  (0, i.TQ)(r, a, c)) |
                0;
            (f = h),
              (h = u),
              (u = d),
              (d = (l + t) | 0),
              (l = c),
              (c = a),
              (a = r),
              (r = (t + p) | 0);
          }
          (r = (r + this.A) | 0),
            (a = (a + this.B) | 0),
            (c = (c + this.C) | 0),
            (l = (l + this.D) | 0),
            (d = (d + this.E) | 0),
            (u = (u + this.F) | 0),
            (h = (h + this.G) | 0),
            (f = (f + this.H) | 0),
            this.set(r, a, c, l, d, u, h, f);
        }
        roundClean() {
          o.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
        }
      }
      let l = (0, s.ld)(() => new c());
    },
    24784: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => o });
      var i = r(20390),
        s = r(77608);
      let n = /^0x[a-fA-F0-9]{40}$/,
        a = new i.A(8192);
      function o(e, t) {
        let { strict: r = !0 } = t ?? {},
          i = `${e}.${r}`;
        if (a.has(i)) return a.get(i);
        let o =
          !!n.test(e) && (e.toLowerCase() === e || !r || (0, s.o)(e) === e);
        return a.set(i, o), o;
      }
    },
    24836: (e, t, r) => {
      "use strict";
      r.d(t, { GN: () => _ });
      var i = r(1220),
        s = r(98866),
        n = r(12182),
        a = r(45553),
        o = r(73537),
        c = r(28977),
        l = r(12319),
        d = r(83941);
      let u = {
        getGasPriceInEther: (e, t) => Number(t * e) / 1e18,
        getGasPriceInUSD(e, t, r) {
          let i = u.getGasPriceInEther(t, r);
          return n.S.bigNumber(e).times(i).toNumber();
        },
        getPriceImpact({
          sourceTokenAmount: e,
          sourceTokenPriceInUSD: t,
          toTokenPriceInUSD: r,
          toTokenAmount: i,
        }) {
          let s = n.S.bigNumber(e).times(t),
            a = n.S.bigNumber(i).times(r);
          return s.minus(a).div(s).times(100).toNumber();
        },
        getMaxSlippage(e, t) {
          let r = n.S.bigNumber(e).div(100);
          return n.S.multiply(t, r).toNumber();
        },
        getProviderFee: (e, t = 0.0085) => n.S.bigNumber(e).times(t).toString(),
        isInsufficientNetworkTokenForGas: (e, t) =>
          !!n.S.bigNumber(e).eq(0) ||
          n.S.bigNumber(n.S.bigNumber(t || "0")).gt(e),
        isInsufficientSourceTokenForSwap(e, t, r) {
          let i = r?.find((e) => e.address === t)?.quantity?.numeric;
          return n.S.bigNumber(i || "0").lt(e);
        },
        getToTokenAmount({
          sourceToken: e,
          toToken: t,
          sourceTokenPrice: r,
          toTokenPrice: i,
          sourceTokenAmount: s,
        }) {
          if ("0" === s || !e || !t) return "0";
          let a = e.decimals,
            o = t.decimals;
          if (i <= 0) return "0";
          let c = n.S.bigNumber(s).times(0.0085),
            l = n.S.bigNumber(s).minus(c).times(n.S.bigNumber(10).pow(a)),
            d = n.S.bigNumber(r).div(i),
            u = a - o;
          return l
            .times(d)
            .div(n.S.bigNumber(10).pow(u))
            .div(n.S.bigNumber(10).pow(o))
            .toFixed(o)
            .toString();
        },
      };
      var h = r(58051),
        f = r(52502),
        p = r(44826),
        g = r(73442),
        m = r(3824),
        b = r(66254),
        y = r(70417),
        w = r(67869),
        v = r(65374);
      let A = {
          initializing: !1,
          initialized: !1,
          loadingPrices: !1,
          loadingQuote: !1,
          loadingApprovalTransaction: !1,
          loadingBuildTransaction: !1,
          loadingTransaction: !1,
          fetchError: !1,
          approvalTransaction: void 0,
          swapTransaction: void 0,
          transactionError: void 0,
          sourceToken: void 0,
          sourceTokenAmount: "",
          sourceTokenPriceInUSD: 0,
          toToken: void 0,
          toTokenAmount: "",
          toTokenPriceInUSD: 0,
          networkPrice: "0",
          networkBalanceInUSD: "0",
          networkTokenSymbol: "",
          inputError: void 0,
          slippage: c.oU.CONVERT_SLIPPAGE_TOLERANCE,
          tokens: void 0,
          popularTokens: void 0,
          suggestedTokens: void 0,
          foundTokens: void 0,
          myTokensWithBalance: void 0,
          tokensPriceMap: {},
          gasFee: "0",
          gasPriceInUSD: 0,
          priceImpact: void 0,
          maxSlippage: void 0,
          providerFee: void 0,
        },
        E = (0, i.BX)(A),
        _ = {
          state: E,
          subscribe: (e) => (0, i.B1)(E, () => e(E)),
          subscribeKey: (e, t) => (0, s.u$)(E, e, t),
          getParams() {
            let e = g.W.state.activeCaipAddress,
              t = g.W.state.activeChain,
              r = l.w.getPlainAddress(e),
              i = g.W.getActiveNetworkTokenAddress(),
              s = b.a.getConnectorId(t);
            if (!r) throw Error("No address found to swap the tokens from.");
            let o = !E.toToken?.address || !E.toToken?.decimals,
              c =
                !E.sourceToken?.address ||
                !E.sourceToken?.decimals ||
                !n.S.bigNumber(E.sourceTokenAmount).gt(0),
              d = !E.sourceTokenAmount;
            return {
              networkAddress: i,
              fromAddress: r,
              fromCaipAddress: e,
              sourceTokenAddress: E.sourceToken?.address,
              toTokenAddress: E.toToken?.address,
              toTokenAmount: E.toTokenAmount,
              toTokenDecimals: E.toToken?.decimals,
              sourceTokenAmount: E.sourceTokenAmount,
              sourceTokenDecimals: E.sourceToken?.decimals,
              invalidToToken: o,
              invalidSourceToken: c,
              invalidSourceTokenAmount: d,
              availableToSwap: e && !o && !c && !d,
              isAuthConnector: s === a.o.CONNECTOR_ID.AUTH,
            };
          },
          setSourceToken(e) {
            if (!e) {
              (E.sourceToken = e),
                (E.sourceTokenAmount = ""),
                (E.sourceTokenPriceInUSD = 0);
              return;
            }
            (E.sourceToken = e), this.setTokenPrice(e.address, "sourceToken");
          },
          setSourceTokenAmount(e) {
            E.sourceTokenAmount = e;
          },
          setToToken(e) {
            if (!e) {
              (E.toToken = e),
                (E.toTokenAmount = ""),
                (E.toTokenPriceInUSD = 0);
              return;
            }
            (E.toToken = e), this.setTokenPrice(e.address, "toToken");
          },
          setToTokenAmount(e) {
            E.toTokenAmount = e ? n.S.formatNumberToLocalString(e, 6) : "";
          },
          async setTokenPrice(e, t) {
            let r = E.tokensPriceMap[e] || 0;
            r || ((E.loadingPrices = !0), (r = await this.getAddressPrice(e))),
              "sourceToken" === t
                ? (E.sourceTokenPriceInUSD = r)
                : "toToken" === t && (E.toTokenPriceInUSD = r),
              E.loadingPrices && (E.loadingPrices = !1),
              this.getParams().availableToSwap && this.swapTokens();
          },
          switchTokens() {
            if (E.initializing || !E.initialized) return;
            let e = E.toToken ? { ...E.toToken } : void 0,
              t = E.sourceToken ? { ...E.sourceToken } : void 0,
              r = e && "" === E.toTokenAmount ? "1" : E.toTokenAmount;
            this.setSourceToken(e),
              this.setToToken(t),
              this.setSourceTokenAmount(r),
              this.setToTokenAmount(""),
              this.swapTokens();
          },
          resetState() {
            (E.myTokensWithBalance = A.myTokensWithBalance),
              (E.tokensPriceMap = A.tokensPriceMap),
              (E.initialized = A.initialized),
              (E.sourceToken = A.sourceToken),
              (E.sourceTokenAmount = A.sourceTokenAmount),
              (E.sourceTokenPriceInUSD = A.sourceTokenPriceInUSD),
              (E.toToken = A.toToken),
              (E.toTokenAmount = A.toTokenAmount),
              (E.toTokenPriceInUSD = A.toTokenPriceInUSD),
              (E.networkPrice = A.networkPrice),
              (E.networkTokenSymbol = A.networkTokenSymbol),
              (E.networkBalanceInUSD = A.networkBalanceInUSD),
              (E.inputError = A.inputError);
          },
          resetValues() {
            let { networkAddress: e } = this.getParams(),
              t = E.tokens?.find((t) => t.address === e);
            this.setSourceToken(t), this.setToToken(void 0);
          },
          getApprovalLoadingState: () => E.loadingApprovalTransaction,
          clearError() {
            E.transactionError = void 0;
          },
          async initializeState() {
            if (!E.initializing) {
              if (((E.initializing = !0), !E.initialized))
                try {
                  await this.fetchTokens(), (E.initialized = !0);
                } catch (e) {
                  (E.initialized = !1),
                    v.P.showError("Failed to initialize swap"),
                    w.I.goBack();
                }
              E.initializing = !1;
            }
          },
          async fetchTokens() {
            let { networkAddress: e } = this.getParams();
            await this.getTokenList(),
              await this.getNetworkTokenPrice(),
              await this.getMyTokensWithBalance();
            let t = E.tokens?.find((t) => t.address === e);
            t &&
              ((E.networkTokenSymbol = t.symbol),
              this.setSourceToken(t),
              this.setSourceTokenAmount("1"));
          },
          async getTokenList() {
            let e = await d.s.getTokenList();
            (E.tokens = e),
              (E.popularTokens = e.sort((e, t) =>
                e.symbol < t.symbol ? -1 : +(e.symbol > t.symbol)
              )),
              (E.suggestedTokens = e.filter(
                (e) => !!c.oU.SWAP_SUGGESTED_TOKENS.includes(e.symbol),
                {}
              ));
          },
          async getAddressPrice(e) {
            let t = E.tokensPriceMap[e];
            if (t) return t;
            let r = await p.T.fetchTokenPrice({ addresses: [e] }),
              i = r?.fungibles || [],
              s = [...(E.tokens || []), ...(E.myTokensWithBalance || [])],
              n = s?.find((t) => t.address === e)?.symbol,
              a = parseFloat(
                (
                  i.find((e) => e.symbol.toLowerCase() === n?.toLowerCase())
                    ?.price || 0
                ).toString()
              );
            return (E.tokensPriceMap[e] = a), a;
          },
          async getNetworkTokenPrice() {
            let { networkAddress: e } = this.getParams(),
              t = await p.T.fetchTokenPrice({ addresses: [e] }).catch(
                () => (
                  v.P.showError("Failed to fetch network token price"),
                  { fungibles: [] }
                )
              ),
              r = t.fungibles?.[0],
              i = r?.price.toString() || "0";
            (E.tokensPriceMap[e] = parseFloat(i)),
              (E.networkTokenSymbol = r?.symbol || ""),
              (E.networkPrice = i);
          },
          async getMyTokensWithBalance(e) {
            let t = await d.s.getMyTokensWithBalance(e);
            t && (await this.getInitialGasPrice(), this.setBalances(t));
          },
          setBalances(e) {
            let { networkAddress: t } = this.getParams(),
              r = g.W.state.activeCaipNetwork;
            if (!r) return;
            let i = e.find((e) => e.address === t);
            e.forEach((e) => {
              E.tokensPriceMap[e.address] = e.price || 0;
            }),
              (E.myTokensWithBalance = e.filter((e) =>
                e.address.startsWith(r.caipNetworkId)
              )),
              (E.networkBalanceInUSD = i
                ? n.S.multiply(i.quantity.numeric, i.price).toString()
                : "0");
          },
          async getInitialGasPrice() {
            let e = await d.s.fetchGasPrice();
            if (!e) return { gasPrice: null, gasPriceInUSD: null };
            if (g.W.state?.activeCaipNetwork?.chainNamespace === "solana")
              return (
                (E.gasFee = e.standard ?? "0"),
                (E.gasPriceInUSD = n.S.multiply(e.standard, E.networkPrice)
                  .div(1e9)
                  .toNumber()),
                {
                  gasPrice: BigInt(E.gasFee),
                  gasPriceInUSD: Number(E.gasPriceInUSD),
                }
              );
            {
              let t = e.standard ?? "0",
                r = BigInt(t),
                i = BigInt(15e4),
                s = u.getGasPriceInUSD(E.networkPrice, i, r);
              return (
                (E.gasFee = t),
                (E.gasPriceInUSD = s),
                { gasPrice: r, gasPriceInUSD: s }
              );
            }
          },
          async swapTokens() {
            let e = h.U.state.address,
              t = E.sourceToken,
              r = E.toToken,
              i = n.S.bigNumber(E.sourceTokenAmount).gt(0);
            if (
              (i || this.setToTokenAmount(""),
              !r || !t || E.loadingPrices || !i)
            )
              return;
            E.loadingQuote = !0;
            let s = n.S.bigNumber(E.sourceTokenAmount)
              .times(10 ** t.decimals)
              .round(0);
            try {
              let i = await p.T.fetchSwapQuote({
                userAddress: e,
                from: t.address,
                to: r.address,
                gasPrice: E.gasFee,
                amount: s.toString(),
              });
              E.loadingQuote = !1;
              let a = i?.quotes?.[0]?.toAmount;
              if (!a) {
                f.h.open(
                  {
                    shortMessage: "Incorrect amount",
                    longMessage: "Please enter a valid amount",
                  },
                  "error"
                );
                return;
              }
              let o = n.S.bigNumber(a)
                .div(10 ** r.decimals)
                .toString();
              this.setToTokenAmount(o),
                this.hasInsufficientToken(E.sourceTokenAmount, t.address)
                  ? (E.inputError = "Insufficient balance")
                  : ((E.inputError = void 0), this.setTransactionDetails());
            } catch (e) {
              (E.loadingQuote = !1), (E.inputError = "Insufficient balance");
            }
          },
          async getTransaction() {
            let { fromCaipAddress: e, availableToSwap: t } = this.getParams(),
              r = E.sourceToken,
              i = E.toToken;
            if (e && t && r && i && !E.loadingQuote)
              try {
                let t;
                return (
                  (E.loadingBuildTransaction = !0),
                  (t = (await d.s.fetchSwapAllowance({
                    userAddress: e,
                    tokenAddress: r.address,
                    sourceTokenAmount: E.sourceTokenAmount,
                    sourceTokenDecimals: r.decimals,
                  }))
                    ? await this.createSwapTransaction()
                    : await this.createAllowanceTransaction()),
                  (E.loadingBuildTransaction = !1),
                  (E.fetchError = !1),
                  t
                );
              } catch (e) {
                w.I.goBack(),
                  v.P.showError("Failed to check allowance"),
                  (E.loadingBuildTransaction = !1),
                  (E.approvalTransaction = void 0),
                  (E.swapTransaction = void 0),
                  (E.fetchError = !0);
                return;
              }
          },
          async createAllowanceTransaction() {
            let {
              fromCaipAddress: e,
              fromAddress: t,
              sourceTokenAddress: r,
              toTokenAddress: i,
            } = this.getParams();
            if (e && i) {
              if (!r)
                throw Error(
                  "createAllowanceTransaction - No source token address found."
                );
              try {
                let s = await p.T.generateApproveCalldata({
                    from: r,
                    to: i,
                    userAddress: e,
                  }),
                  n = await m.x.estimateGas({
                    chainNamespace: a.o.CHAIN.EVM,
                    address: t,
                    to: l.w.getPlainAddress(s.tx.to),
                    data: s.tx.data,
                  }),
                  o = {
                    data: s.tx.data,
                    to: l.w.getPlainAddress(s.tx.from),
                    gas: n,
                    gasPrice: BigInt(s.tx.eip155.gasPrice),
                    value: BigInt(s.tx.value),
                    toAmount: E.toTokenAmount,
                  };
                return (
                  (E.swapTransaction = void 0),
                  (E.approvalTransaction = {
                    data: o.data,
                    to: o.to,
                    gas: o.gas ?? BigInt(0),
                    gasPrice: o.gasPrice,
                    value: o.value,
                    toAmount: o.toAmount,
                  }),
                  {
                    data: o.data,
                    to: o.to,
                    gas: o.gas ?? BigInt(0),
                    gasPrice: o.gasPrice,
                    value: o.value,
                    toAmount: o.toAmount,
                  }
                );
              } catch (e) {
                w.I.goBack(),
                  v.P.showError("Failed to create approval transaction"),
                  (E.approvalTransaction = void 0),
                  (E.swapTransaction = void 0),
                  (E.fetchError = !0);
                return;
              }
            }
          },
          async createSwapTransaction() {
            let {
                networkAddress: e,
                fromCaipAddress: t,
                sourceTokenAmount: r,
              } = this.getParams(),
              i = E.sourceToken,
              s = E.toToken;
            if (!t || !r || !i || !s) return;
            let n = m.x.parseUnits(r, i.decimals)?.toString();
            try {
              let r = await p.T.generateSwapCalldata({
                  userAddress: t,
                  from: i.address,
                  to: s.address,
                  amount: n,
                }),
                a = i.address === e,
                o = BigInt(r.tx.eip155.gas),
                c = BigInt(r.tx.eip155.gasPrice),
                d = {
                  data: r.tx.data,
                  to: l.w.getPlainAddress(r.tx.to),
                  gas: o,
                  gasPrice: c,
                  value: a ? BigInt(n ?? "0") : BigInt("0"),
                  toAmount: E.toTokenAmount,
                };
              return (
                (E.gasPriceInUSD = u.getGasPriceInUSD(E.networkPrice, o, c)),
                (E.approvalTransaction = void 0),
                (E.swapTransaction = d),
                d
              );
            } catch (e) {
              w.I.goBack(),
                v.P.showError("Failed to create transaction"),
                (E.approvalTransaction = void 0),
                (E.swapTransaction = void 0),
                (E.fetchError = !0);
              return;
            }
          },
          async sendTransactionForApproval(e) {
            let { fromAddress: t, isAuthConnector: r } = this.getParams();
            E.loadingApprovalTransaction = !0;
            let i = "Approve limit increase in your wallet";
            r
              ? w.I.pushTransactionStack({
                  view: null,
                  goBack: !0,
                  onSuccess() {
                    v.P.showLoading(i);
                  },
                })
              : v.P.showLoading(i);
            try {
              await m.x.sendTransaction({
                address: t,
                to: e.to,
                data: e.data,
                gas: e.gas,
                gasPrice: BigInt(e.gasPrice),
                value: e.value,
                chainNamespace: "eip155",
              }),
                await this.swapTokens(),
                await this.getTransaction(),
                (E.approvalTransaction = void 0),
                (E.loadingApprovalTransaction = !1);
            } catch (e) {
              (E.transactionError = e?.shortMessage),
                (E.loadingApprovalTransaction = !1),
                v.P.showError(e?.shortMessage || "Transaction error"),
                y.E.sendEvent({
                  type: "track",
                  event: "SWAP_APPROVAL_ERROR",
                  properties: {
                    message: e?.shortMessage || e?.message || "Unknown",
                    network: g.W.state.activeCaipNetwork?.caipNetworkId || "",
                    swapFromToken: this.state.sourceToken?.symbol || "",
                    swapToToken: this.state.toToken?.symbol || "",
                    swapFromAmount: this.state.sourceTokenAmount || "",
                    swapToAmount: this.state.toTokenAmount || "",
                    isSmartAccount:
                      h.U.state.preferredAccountType ===
                      o.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                  },
                });
            }
          },
          async sendTransactionForSwap(e) {
            if (!e) return;
            let {
              fromAddress: t,
              toTokenAmount: r,
              isAuthConnector: i,
            } = this.getParams();
            E.loadingTransaction = !0;
            let s = `Swapping ${
                E.sourceToken?.symbol
              } to ${n.S.formatNumberToLocalString(r, 3)} ${E.toToken?.symbol}`,
              a = `Swapped ${
                E.sourceToken?.symbol
              } to ${n.S.formatNumberToLocalString(r, 3)} ${E.toToken?.symbol}`;
            i
              ? w.I.pushTransactionStack({
                  view: "Account",
                  goBack: !1,
                  onSuccess() {
                    v.P.showLoading(s), _.resetState();
                  },
                })
              : v.P.showLoading("Confirm transaction in your wallet");
            try {
              let r = [E.sourceToken?.address, E.toToken?.address].join(","),
                s = await m.x.sendTransaction({
                  address: t,
                  to: e.to,
                  data: e.data,
                  gas: e.gas,
                  gasPrice: BigInt(e.gasPrice),
                  value: e.value,
                  chainNamespace: "eip155",
                });
              return (
                (E.loadingTransaction = !1),
                v.P.showSuccess(a),
                y.E.sendEvent({
                  type: "track",
                  event: "SWAP_SUCCESS",
                  properties: {
                    network: g.W.state.activeCaipNetwork?.caipNetworkId || "",
                    swapFromToken: this.state.sourceToken?.symbol || "",
                    swapToToken: this.state.toToken?.symbol || "",
                    swapFromAmount: this.state.sourceTokenAmount || "",
                    swapToAmount: this.state.toTokenAmount || "",
                    isSmartAccount:
                      h.U.state.preferredAccountType ===
                      o.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                  },
                }),
                _.resetState(),
                i || w.I.replace("Account"),
                _.getMyTokensWithBalance(r),
                s
              );
            } catch (e) {
              (E.transactionError = e?.shortMessage),
                (E.loadingTransaction = !1),
                v.P.showError(e?.shortMessage || "Transaction error"),
                y.E.sendEvent({
                  type: "track",
                  event: "SWAP_ERROR",
                  properties: {
                    message: e?.shortMessage || e?.message || "Unknown",
                    network: g.W.state.activeCaipNetwork?.caipNetworkId || "",
                    swapFromToken: this.state.sourceToken?.symbol || "",
                    swapToToken: this.state.toToken?.symbol || "",
                    swapFromAmount: this.state.sourceTokenAmount || "",
                    swapToAmount: this.state.toTokenAmount || "",
                    isSmartAccount:
                      h.U.state.preferredAccountType ===
                      o.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                  },
                });
              return;
            }
          },
          hasInsufficientToken(e, t) {
            let r = u.isInsufficientSourceTokenForSwap(
                e,
                t,
                E.myTokensWithBalance
              ),
              i = !0;
            return (
              (h.U.state.preferredAccountType !==
                o.Vl.ACCOUNT_TYPES.SMART_ACCOUNT &&
                u.isInsufficientNetworkTokenForGas(
                  E.networkBalanceInUSD,
                  E.gasPriceInUSD
                )) ||
              r
            );
          },
          setTransactionDetails() {
            let { toTokenAddress: e, toTokenDecimals: t } = this.getParams();
            e &&
              t &&
              ((E.gasPriceInUSD = u.getGasPriceInUSD(
                E.networkPrice,
                BigInt(E.gasFee),
                BigInt(15e4)
              )),
              (E.priceImpact = u.getPriceImpact({
                sourceTokenAmount: E.sourceTokenAmount,
                sourceTokenPriceInUSD: E.sourceTokenPriceInUSD,
                toTokenPriceInUSD: E.toTokenPriceInUSD,
                toTokenAmount: E.toTokenAmount,
              })),
              (E.maxSlippage = u.getMaxSlippage(E.slippage, E.toTokenAmount)),
              (E.providerFee = u.getProviderFee(E.sourceTokenAmount)));
          },
        };
    },
    25042: (e, t, r) => {
      "use strict";
      r.d(t, { h: () => a, j: () => n });
      let i = (e) =>
          JSON.stringify(e, (e, t) =>
            "bigint" == typeof t ? t.toString() + "n" : t
          ),
        s = (e) =>
          JSON.parse(
            e.replace(
              /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
              '$1"$2n"$3'
            ),
            (e, t) =>
              "string" == typeof t && t.match(/^\d+n$/)
                ? BigInt(t.substring(0, t.length - 1))
                : t
          );
      function n(e) {
        if ("string" != typeof e)
          throw Error(`Cannot safe json parse value of type ${typeof e}`);
        try {
          return s(e);
        } catch (t) {
          return e;
        }
      }
      function a(e) {
        return "string" == typeof e ? e : i(e) || "";
      }
    },
    25648: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(12590);
      i.__exportStar(r(81452), t), i.__exportStar(r(80361), t);
    },
    25939: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.fromMiliseconds = t.toMiliseconds = void 0);
      let i = r(25648);
      (t.toMiliseconds = function (e) {
        return e * i.ONE_THOUSAND;
      }),
        (t.fromMiliseconds = function (e) {
          return Math.floor(e / i.ONE_THOUSAND);
        });
    },
    26662: (e, t) => {
      "use strict";
      function r(e) {
        let t;
        return (
          "undefined" != typeof window &&
            void 0 !== window[e] &&
            (t = window[e]),
          t
        );
      }
      function i(e) {
        let t = r(e);
        if (!t) throw Error(`${e} is not defined in Window`);
        return t;
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.getLocalStorage =
          t.getLocalStorageOrThrow =
          t.getCrypto =
          t.getCryptoOrThrow =
          t.getLocation =
          t.getLocationOrThrow =
          t.getNavigator =
          t.getNavigatorOrThrow =
          t.getDocument =
          t.getDocumentOrThrow =
          t.getFromWindowOrThrow =
          t.getFromWindow =
            void 0),
        (t.getFromWindow = r),
        (t.getFromWindowOrThrow = i),
        (t.getDocumentOrThrow = function () {
          return i("document");
        }),
        (t.getDocument = function () {
          return r("document");
        }),
        (t.getNavigatorOrThrow = function () {
          return i("navigator");
        }),
        (t.getNavigator = function () {
          return r("navigator");
        }),
        (t.getLocationOrThrow = function () {
          return i("location");
        }),
        (t.getLocation = function () {
          return r("location");
        }),
        (t.getCryptoOrThrow = function () {
          return i("crypto");
        }),
        (t.getCrypto = function () {
          return r("crypto");
        }),
        (t.getLocalStorageOrThrow = function () {
          return i("localStorage");
        }),
        (t.getLocalStorage = function () {
          return r("localStorage");
        });
    },
    28245: (e, t, r) => {
      "use strict";
      r.d(t, { c: () => n });
      var i = r(62023),
        s = r(30598);
      function n(e, t = "wei") {
        return (0, s.J)(e, i.eL[t]);
      }
    },
    28698: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => c });
      var i,
        s,
        n = r(46465);
      let a = () => `@wagmi/core@${n.r}`;
      var o = function (e, t, r, i) {
        if ("a" === r && !i)
          throw TypeError("Private accessor was defined without a getter");
        if ("function" == typeof t ? e !== t || !i : !t.has(e))
          throw TypeError(
            "Cannot read private member from an object whose class did not declare it"
          );
        return "m" === r ? i : "a" === r ? i.call(e) : i ? i.value : t.get(e);
      };
      class c extends Error {
        get docsBaseUrl() {
          return "https://wagmi.sh/core";
        }
        get version() {
          return a();
        }
        constructor(e, t = {}) {
          super(),
            i.add(this),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "WagmiCoreError",
            });
          let r =
              t.cause instanceof c
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            s = (t.cause instanceof c && t.cause.docsPath) || t.docsPath;
          (this.message = [
            e || "An error occurred.",
            "",
            ...(t.metaMessages ? [...t.metaMessages, ""] : []),
            ...(s
              ? [
                  `Docs: ${this.docsBaseUrl}${s}.html${
                    t.docsSlug ? `#${t.docsSlug}` : ""
                  }`,
                ]
              : []),
            ...(r ? [`Details: ${r}`] : []),
            `Version: ${this.version}`,
          ].join("\n")),
            t.cause && (this.cause = t.cause),
            (this.details = r),
            (this.docsPath = s),
            (this.metaMessages = t.metaMessages),
            (this.shortMessage = e);
        }
        walk(e) {
          return o(this, i, "m", s).call(this, this, e);
        }
      }
      (i = new WeakSet()),
        (s = function e(t, r) {
          return r?.(t)
            ? t
            : t.cause
            ? o(this, i, "m", e).call(this, t.cause, r)
            : t;
        });
    },
    28977: (e, t, r) => {
      "use strict";
      r.d(t, { Db: () => a, oU: () => o, tM: () => n });
      var i = r(87358);
      let s =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN
            : void 0) || "https://secure.walletconnect.org",
        n = [
          {
            label: "Coinbase",
            name: "coinbase",
            feeRange: "1-2%",
            url: "",
            supportedChains: ["eip155"],
          },
          {
            label: "Meld.io",
            name: "meld",
            feeRange: "1-2%",
            url: "https://meldcrypto.com",
            supportedChains: ["eip155", "solana"],
          },
        ],
        a = "WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU",
        o = {
          FOUR_MINUTES_MS: 24e4,
          TEN_SEC_MS: 1e4,
          FIVE_SEC_MS: 5e3,
          THREE_SEC_MS: 3e3,
          ONE_SEC_MS: 1e3,
          SECURE_SITE: s,
          SECURE_SITE_DASHBOARD: `${s}/dashboard`,
          SECURE_SITE_FAVICON: `${s}/images/favicon.png`,
          RESTRICTED_TIMEZONES: [
            "ASIA/SHANGHAI",
            "ASIA/URUMQI",
            "ASIA/CHONGQING",
            "ASIA/HARBIN",
            "ASIA/KASHGAR",
            "ASIA/MACAU",
            "ASIA/HONG_KONG",
            "ASIA/MACAO",
            "ASIA/BEIJING",
            "ASIA/HARBIN",
          ],
          WC_COINBASE_PAY_SDK_CHAINS: [
            "ethereum",
            "arbitrum",
            "polygon",
            "berachain",
            "avalanche-c-chain",
            "optimism",
            "celo",
            "base",
          ],
          WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
          WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
            Ethereum: "ethereum",
            "Arbitrum One": "arbitrum",
            Polygon: "polygon",
            Berachain: "berachain",
            Avalanche: "avalanche-c-chain",
            "OP Mainnet": "optimism",
            Celo: "celo",
            Base: "base",
          },
          WC_COINBASE_ONRAMP_APP_ID: "bf18c88d-495a-463b-b249-0b9d3656cf5e",
          SWAP_SUGGESTED_TOKENS: [
            "ETH",
            "UNI",
            "1INCH",
            "AAVE",
            "SOL",
            "ADA",
            "AVAX",
            "DOT",
            "LINK",
            "NITRO",
            "GAIA",
            "MILK",
            "TRX",
            "NEAR",
            "GNO",
            "WBTC",
            "DAI",
            "WETH",
            "USDC",
            "USDT",
            "ARB",
            "BAL",
            "BICO",
            "CRV",
            "ENS",
            "MATIC",
            "OP",
          ],
          SWAP_POPULAR_TOKENS: [
            "ETH",
            "UNI",
            "1INCH",
            "AAVE",
            "SOL",
            "ADA",
            "AVAX",
            "DOT",
            "LINK",
            "NITRO",
            "GAIA",
            "MILK",
            "TRX",
            "NEAR",
            "GNO",
            "WBTC",
            "DAI",
            "WETH",
            "USDC",
            "USDT",
            "ARB",
            "BAL",
            "BICO",
            "CRV",
            "ENS",
            "MATIC",
            "OP",
            "METAL",
            "DAI",
            "CHAMP",
            "WOLF",
            "SALE",
            "BAL",
            "BUSD",
            "MUST",
            "BTCpx",
            "ROUTE",
            "HEX",
            "WELT",
            "amDAI",
            "VSQ",
            "VISION",
            "AURUM",
            "pSP",
            "SNX",
            "VC",
            "LINK",
            "CHP",
            "amUSDT",
            "SPHERE",
            "FOX",
            "GIDDY",
            "GFC",
            "OMEN",
            "OX_OLD",
            "DE",
            "WNT",
          ],
          BALANCE_SUPPORTED_CHAINS: ["eip155", "solana"],
          SWAP_SUPPORTED_NETWORKS: [
            "eip155:1",
            "eip155:42161",
            "eip155:10",
            "eip155:324",
            "eip155:8453",
            "eip155:56",
            "eip155:137",
            "eip155:100",
            "eip155:43114",
            "eip155:250",
            "eip155:8217",
            "eip155:1313161554",
          ],
          NAMES_SUPPORTED_CHAIN_NAMESPACES: ["eip155"],
          ONRAMP_SUPPORTED_CHAIN_NAMESPACES: ["eip155", "solana"],
          ACTIVITY_ENABLED_CHAIN_NAMESPACES: ["eip155", "solana"],
          NATIVE_TOKEN_ADDRESS: {
            eip155: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
            solana: "So11111111111111111111111111111111111111111",
            polkadot: "0x",
            bip122: "0x",
          },
          CONVERT_SLIPPAGE_TOLERANCE: 1,
          CONNECT_LABELS: { MOBILE: "Open and continue in a new browser tab" },
          DEFAULT_FEATURES: {
            swaps: !0,
            onramp: !0,
            receive: !0,
            send: !0,
            email: !0,
            emailShowWallets: !0,
            socials: [
              "google",
              "x",
              "discord",
              "farcaster",
              "github",
              "apple",
              "facebook",
            ],
            connectorTypeOrder: [
              "walletConnect",
              "recent",
              "injected",
              "featured",
              "custom",
              "external",
              "recommended",
            ],
            history: !0,
            analytics: !0,
            allWallets: !0,
            legalCheckbox: !1,
            smartSessions: !1,
            collapseWallets: !1,
            walletFeaturesOrder: ["onramp", "swaps", "receive", "send"],
            connectMethodsOrder: void 0,
          },
          DEFAULT_ACCOUNT_TYPES: {
            bip122: "payment",
            eip155: "smartAccount",
            polkadot: "eoa",
            solana: "eoa",
          },
          ADAPTER_TYPES: {
            UNIVERSAL: "universal",
            SOLANA: "solana",
            WAGMI: "wagmi",
            ETHERS: "ethers",
            ETHERS5: "ethers5",
            BITCOIN: "bitcoin",
          },
        };
    },
    29143: (e, t, r) => {
      "use strict";
      r.d(t, { lY: () => v });
      var i = r(88487),
        s = r(78710),
        n = r(458);
      let a = [],
        o = [],
        c = [],
        l = BigInt(0),
        d = BigInt(1),
        u = BigInt(2),
        h = BigInt(7),
        f = BigInt(256),
        p = BigInt(113);
      for (let e = 0, t = d, r = 1, i = 0; e < 24; e++) {
        ([r, i] = [i, (2 * r + 3 * i) % 5]),
          a.push(2 * (5 * i + r)),
          o.push((((e + 1) * (e + 2)) / 2) % 64);
        let s = l;
        for (let e = 0; e < 7; e++)
          (t = ((t << d) ^ ((t >> h) * p)) % f) & u &&
            (s ^= d << ((d << BigInt(e)) - d));
        c.push(s);
      }
      let [g, m] = (0, s.lD)(c, !0),
        b = (e, t, r) => (r > 32 ? (0, s.WM)(e, t, r) : (0, s.P5)(e, t, r)),
        y = (e, t, r) => (r > 32 ? (0, s.im)(e, t, r) : (0, s.B4)(e, t, r));
      class w extends n.Vw {
        constructor(e, t, r, s = !1, a = 24) {
          if (
            (super(),
            (this.blockLen = e),
            (this.suffix = t),
            (this.outputLen = r),
            (this.enableXOF = s),
            (this.rounds = a),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            (0, i.Fe)(r),
            0 >= this.blockLen || this.blockLen >= 200)
          )
            throw Error("Sha3 supports only keccak-f1600 function");
          (this.state = new Uint8Array(200)),
            (this.state32 = (0, n.DH)(this.state));
        }
        keccak() {
          n.qv || (0, n.Fc)(this.state32),
            (function (e, t = 24) {
              let r = new Uint32Array(10);
              for (let i = 24 - t; i < 24; i++) {
                for (let t = 0; t < 10; t++)
                  r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
                for (let t = 0; t < 10; t += 2) {
                  let i = (t + 8) % 10,
                    s = (t + 2) % 10,
                    n = r[s],
                    a = r[s + 1],
                    o = b(n, a, 1) ^ r[i],
                    c = y(n, a, 1) ^ r[i + 1];
                  for (let r = 0; r < 50; r += 10)
                    (e[t + r] ^= o), (e[t + r + 1] ^= c);
                }
                let t = e[2],
                  s = e[3];
                for (let r = 0; r < 24; r++) {
                  let i = o[r],
                    n = b(t, s, i),
                    c = y(t, s, i),
                    l = a[r];
                  (t = e[l]), (s = e[l + 1]), (e[l] = n), (e[l + 1] = c);
                }
                for (let t = 0; t < 50; t += 10) {
                  for (let i = 0; i < 10; i++) r[i] = e[t + i];
                  for (let i = 0; i < 10; i++)
                    e[t + i] ^= ~r[(i + 2) % 10] & r[(i + 4) % 10];
                }
                (e[0] ^= g[i]), (e[1] ^= m[i]);
              }
              r.fill(0);
            })(this.state32, this.rounds),
            n.qv || (0, n.Fc)(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(e) {
          (0, i.CC)(this);
          let { blockLen: t, state: r } = this,
            s = (e = (0, n.ZJ)(e)).length;
          for (let i = 0; i < s; ) {
            let n = Math.min(t - this.pos, s - i);
            for (let t = 0; t < n; t++) r[this.pos++] ^= e[i++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: e, suffix: t, pos: r, blockLen: i } = this;
          (e[r] ^= t),
            (128 & t) != 0 && r === i - 1 && this.keccak(),
            (e[i - 1] ^= 128),
            this.keccak();
        }
        writeInto(e) {
          (0, i.CC)(this, !1), (0, i.DO)(e), this.finish();
          let t = this.state,
            { blockLen: r } = this;
          for (let i = 0, s = e.length; i < s; ) {
            this.posOut >= r && this.keccak();
            let n = Math.min(r - this.posOut, s - i);
            e.set(t.subarray(this.posOut, this.posOut + n), i),
              (this.posOut += n),
              (i += n);
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF)
            throw Error("XOF is not possible for this instance");
          return this.writeInto(e);
        }
        xof(e) {
          return (0, i.Fe)(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if (((0, i.Ht)(e, this), this.finished))
            throw Error("digest() was already called");
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), this.state.fill(0);
        }
        _cloneInto(e) {
          let {
            blockLen: t,
            suffix: r,
            outputLen: i,
            rounds: s,
            enableXOF: n,
          } = this;
          return (
            e || (e = new w(t, r, i, n, s)),
            e.state32.set(this.state32),
            (e.pos = this.pos),
            (e.posOut = this.posOut),
            (e.finished = this.finished),
            (e.rounds = s),
            (e.suffix = r),
            (e.outputLen = i),
            (e.enableXOF = n),
            (e.destroyed = this.destroyed),
            e
          );
        }
      }
      let v = (0, n.ld)(() => new w(136, 1, 32));
    },
    29461: (e, t, r) => {
      "use strict";
      r.d(t, {
        Ai: () => p,
        Hq: () => f,
        JR: () => m,
        OC: () => g,
        tz: () => h,
      });
      let i = Symbol(),
        s = Symbol(),
        n = (e, t) => new Proxy(e, t),
        a = Object.getPrototypeOf,
        o = new WeakMap(),
        c = (e) =>
          e &&
          (o.has(e)
            ? o.get(e)
            : a(e) === Object.prototype || a(e) === Array.prototype),
        l = (e) => "object" == typeof e && null !== e,
        d = (e) => {
          if (Array.isArray(e)) return Array.from(e);
          let t = Object.getOwnPropertyDescriptors(e);
          return (
            Object.values(t).forEach((e) => {
              e.configurable = !0;
            }),
            Object.create(a(e), t)
          );
        },
        u = (e) => e[s] || e,
        h = (e, t, r, a) => {
          if (!c(e)) return e;
          let o = a && a.get(e);
          if (!o) {
            let t = u(e);
            (o = Object.values(Object.getOwnPropertyDescriptors(t)).some(
              (e) => !e.configurable && !e.writable
            )
              ? [t, d(t)]
              : [t]),
              null == a || a.set(e, o);
          }
          let [l, f] = o,
            p = r && r.get(l);
          return (
            (p && !!f === p[1].f) ||
              (((p = ((e, t) => {
                let r = { f: t },
                  n = !1,
                  a = (t, i) => {
                    if (!n) {
                      let s = r.a.get(e);
                      if ((s || ((s = {}), r.a.set(e, s)), "w" === t)) s.w = !0;
                      else {
                        let e = s[t];
                        e || ((e = new Set()), (s[t] = e)), e.add(i);
                      }
                    }
                  },
                  o = {
                    get: (t, i) =>
                      i === s
                        ? e
                        : (a("k", i), h(Reflect.get(t, i), r.a, r.c, r.t)),
                    has: (t, s) =>
                      s === i
                        ? ((n = !0), r.a.delete(e), !0)
                        : (a("h", s), Reflect.has(t, s)),
                    getOwnPropertyDescriptor: (e, t) => (
                      a("o", t), Reflect.getOwnPropertyDescriptor(e, t)
                    ),
                    ownKeys: (e) => (a("w"), Reflect.ownKeys(e)),
                  };
                return t && (o.set = o.deleteProperty = () => !1), [o, r];
              })(l, !!f))[1].p = n(f || l, p[0])),
              r && r.set(l, p)),
            (p[1].a = t),
            (p[1].c = r),
            (p[1].t = a),
            p[1].p
          );
        },
        f = (e, t, r, i, s = Object.is) => {
          if (s(e, t)) return !1;
          if (!l(e) || !l(t)) return !0;
          let n = r.get(u(e));
          if (!n) return !0;
          if (i) {
            let r = i.get(e);
            if (r && r.n === t) return r.g;
            i.set(e, { n: t, g: !1 });
          }
          let a = null;
          try {
            for (let r of n.h || [])
              if ((a = Reflect.has(e, r) !== Reflect.has(t, r))) return a;
            if (!0 === n.w) {
              if (
                (a = ((e, t) => {
                  let r = Reflect.ownKeys(e),
                    i = Reflect.ownKeys(t);
                  return r.length !== i.length || r.some((e, t) => e !== i[t]);
                })(e, t))
              )
                return a;
            } else
              for (let r of n.o || [])
                if (
                  (a =
                    !!Reflect.getOwnPropertyDescriptor(e, r) !=
                    !!Reflect.getOwnPropertyDescriptor(t, r))
                )
                  return a;
            for (let o of n.k || []) if ((a = f(e[o], t[o], r, i, s))) return a;
            return null === a && (a = !0), a;
          } finally {
            i && i.set(e, { n: t, g: a });
          }
        },
        p = (e) => (c(e) && e[s]) || null,
        g = (e, t = !0) => {
          o.set(e, t);
        },
        m = (e, t, r) => {
          let i = [],
            s = new WeakSet(),
            n = (e, a) => {
              if (s.has(e)) return;
              l(e) && s.add(e);
              let o = l(e) && t.get(u(e));
              if (o) {
                var c, d, h;
                if (
                  (null == (c = o.h) ||
                    c.forEach((e) => {
                      let t = `:has(${String(e)})`;
                      i.push(a ? [...a, t] : [t]);
                    }),
                  !0 === o.w)
                ) {
                  let e = ":ownKeys";
                  i.push(a ? [...a, e] : [e]);
                } else
                  null == (h = o.o) ||
                    h.forEach((e) => {
                      let t = `:hasOwn(${String(e)})`;
                      i.push(a ? [...a, t] : [t]);
                    });
                null == (d = o.k) ||
                  d.forEach((t) => {
                    (!r ||
                      "value" in
                        (Object.getOwnPropertyDescriptor(e, t) || {})) &&
                      n(e[t], a ? [...a, t] : [t]);
                  });
              } else a && i.push(a);
            };
          return n(e), i;
        };
    },
    29936: (e, t, r) => {
      "use strict";
      r.d(t, { j: () => a });
      var i = r(1220),
        s = r(98866);
      let n = (0, i.BX)({
          walletImages: {},
          networkImages: {},
          chainImages: {},
          connectorImages: {},
          tokenImages: {},
          currencyImages: {},
        }),
        a = {
          state: n,
          subscribeNetworkImages: (e) =>
            (0, i.B1)(n.networkImages, () => e(n.networkImages)),
          subscribeKey: (e, t) => (0, s.u$)(n, e, t),
          subscribe: (e) => (0, i.B1)(n, () => e(n)),
          setWalletImage(e, t) {
            n.walletImages[e] = t;
          },
          setNetworkImage(e, t) {
            n.networkImages[e] = t;
          },
          setChainImage(e, t) {
            n.chainImages[e] = t;
          },
          setConnectorImage(e, t) {
            n.connectorImages = { ...n.connectorImages, [e]: t };
          },
          setTokenImage(e, t) {
            n.tokenImages[e] = t;
          },
          setCurrencyImage(e, t) {
            n.currencyImages[e] = t;
          },
        };
    },
    30598: (e, t, r) => {
      "use strict";
      function i(e, t) {
        let r = e.toString(),
          i = r.startsWith("-");
        i && (r = r.slice(1));
        let [s, n] = [
          (r = r.padStart(t, "0")).slice(0, r.length - t),
          r.slice(r.length - t),
        ];
        return (
          (n = n.replace(/(0+)$/, "")),
          `${i ? "-" : ""}${s || "0"}${n ? `.${n}` : ""}`
        );
      }
      r.d(t, { J: () => i });
    },
    30948: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => i });
      let i = {
        METMASK_CONNECTOR_NAME: "MetaMask",
        TRUST_CONNECTOR_NAME: "Trust Wallet",
        SOLFLARE_CONNECTOR_NAME: "Solflare",
        PHANTOM_CONNECTOR_NAME: "Phantom",
        COIN98_CONNECTOR_NAME: "Coin98",
        MAGIC_EDEN_CONNECTOR_NAME: "Magic Eden",
        BACKPACK_CONNECTOR_NAME: "Backpack",
        BITGET_CONNECTOR_NAME: "Bitget Wallet",
        FRONTIER_CONNECTOR_NAME: "Frontier",
        XVERSE_CONNECTOR_NAME: "Xverse Wallet",
        LEATHER_CONNECTOR_NAME: "Leather",
        EIP155: "eip155",
        ADD_CHAIN_METHOD: "wallet_addEthereumChain",
        EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
        EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
        CONNECTOR_RDNS_MAP: {
          coinbaseWallet: "com.coinbase.wallet",
          coinbaseWalletSDK: "com.coinbase.wallet",
        },
        CONNECTOR_TYPE_EXTERNAL: "EXTERNAL",
        CONNECTOR_TYPE_WALLET_CONNECT: "WALLET_CONNECT",
        CONNECTOR_TYPE_INJECTED: "INJECTED",
        CONNECTOR_TYPE_ANNOUNCED: "ANNOUNCED",
        CONNECTOR_TYPE_AUTH: "AUTH",
        CONNECTOR_TYPE_MULTI_CHAIN: "MULTI_CHAIN",
        CONNECTOR_TYPE_W3M_AUTH: "ID_AUTH",
      };
    },
    31e3: (e, t, r) => {
      "use strict";
      var i = r(20920),
        s = r(64874),
        n = r(3285),
        a = i.rotr64_hi,
        o = i.rotr64_lo,
        c = i.shr64_hi,
        l = i.shr64_lo,
        d = i.sum64,
        u = i.sum64_hi,
        h = i.sum64_lo,
        f = i.sum64_4_hi,
        p = i.sum64_4_lo,
        g = i.sum64_5_hi,
        m = i.sum64_5_lo,
        b = s.BlockHash,
        y = [
          0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf,
          0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538,
          0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5,
          0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
          0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74,
          0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235,
          0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786,
          0x384f25e3, 0xfc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f,
          0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4,
          0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d,
          0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
          0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x6ca6351, 0xe003826f,
          0x14292967, 0xa0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
          0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354,
          0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6,
          0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b,
          0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x654be30, 0xd192e819,
          0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a,
          0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08,
          0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
          0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f,
          0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc,
          0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208,
          0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
          0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece,
          0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e,
          0xf57d4f7f, 0xee6ed178, 0x6f067aa, 0x72176fba, 0xa637dc5, 0xa2c898a6,
          0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5,
          0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc,
          0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c,
          0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817,
        ];
      function w() {
        if (!(this instanceof w)) return new w();
        b.call(this),
          (this.h = [
            0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372,
            0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1,
            0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19,
            0x137e2179,
          ]),
          (this.k = y),
          (this.W = Array(160));
      }
      i.inherits(w, b),
        (e.exports = w),
        (w.blockSize = 1024),
        (w.outSize = 512),
        (w.hmacStrength = 192),
        (w.padLength = 128),
        (w.prototype._prepareBlock = function (e, t) {
          for (var r = this.W, i = 0; i < 32; i++) r[i] = e[t + i];
          for (; i < r.length; i += 2) {
            var s = (function (e, t) {
                var r = a(e, t, 19) ^ a(t, e, 29) ^ c(e, t, 6);
                return r < 0 && (r += 0x100000000), r;
              })(r[i - 4], r[i - 3]),
              n = (function (e, t) {
                var r = o(e, t, 19) ^ o(t, e, 29) ^ l(e, t, 6);
                return r < 0 && (r += 0x100000000), r;
              })(r[i - 4], r[i - 3]),
              d = r[i - 14],
              u = r[i - 13],
              h = (function (e, t) {
                var r = a(e, t, 1) ^ a(e, t, 8) ^ c(e, t, 7);
                return r < 0 && (r += 0x100000000), r;
              })(r[i - 30], r[i - 29]),
              g = (function (e, t) {
                var r = o(e, t, 1) ^ o(e, t, 8) ^ l(e, t, 7);
                return r < 0 && (r += 0x100000000), r;
              })(r[i - 30], r[i - 29]),
              m = r[i - 32],
              b = r[i - 31];
            (r[i] = f(s, n, d, u, h, g, m, b)),
              (r[i + 1] = p(s, n, d, u, h, g, m, b));
          }
        }),
        (w.prototype._update = function (e, t) {
          this._prepareBlock(e, t);
          var r = this.W,
            i = this.h[0],
            s = this.h[1],
            c = this.h[2],
            l = this.h[3],
            f = this.h[4],
            p = this.h[5],
            b = this.h[6],
            y = this.h[7],
            w = this.h[8],
            v = this.h[9],
            A = this.h[10],
            E = this.h[11],
            _ = this.h[12],
            C = this.h[13],
            I = this.h[14],
            S = this.h[15];
          n(this.k.length === r.length);
          for (var x = 0; x < r.length; x += 2) {
            var N = I,
              T = S,
              P = (function (e, t) {
                var r = a(e, t, 14) ^ a(e, t, 18) ^ a(t, e, 9);
                return r < 0 && (r += 0x100000000), r;
              })(w, v),
              O = (function (e, t) {
                var r = o(e, t, 14) ^ o(e, t, 18) ^ o(t, e, 9);
                return r < 0 && (r += 0x100000000), r;
              })(w, v),
              k = (function (e, t, r, i, s) {
                var n = (e & r) ^ (~e & s);
                return n < 0 && (n += 0x100000000), n;
              })(w, 0, A, 0, _, C),
              R = (function (e, t, r, i, s, n) {
                var a = (t & i) ^ (~t & n);
                return a < 0 && (a += 0x100000000), a;
              })(0, v, 0, E, 0, C),
              D = this.k[x],
              M = this.k[x + 1],
              U = r[x],
              L = r[x + 1],
              B = g(N, T, P, O, k, R, D, M, U, L),
              j = m(N, T, P, O, k, R, D, M, U, L);
            (N = (function (e, t) {
              var r = a(e, t, 28) ^ a(t, e, 2) ^ a(t, e, 7);
              return r < 0 && (r += 0x100000000), r;
            })(i, s)),
              (T = (function (e, t) {
                var r = o(e, t, 28) ^ o(t, e, 2) ^ o(t, e, 7);
                return r < 0 && (r += 0x100000000), r;
              })(i, s));
            var F = u(
                N,
                T,
                (P = (function (e, t, r, i, s) {
                  var n = (e & r) ^ (e & s) ^ (r & s);
                  return n < 0 && (n += 0x100000000), n;
                })(i, 0, c, 0, f, p)),
                (O = (function (e, t, r, i, s, n) {
                  var a = (t & i) ^ (t & n) ^ (i & n);
                  return a < 0 && (a += 0x100000000), a;
                })(0, s, 0, l, 0, p))
              ),
              $ = h(N, T, P, O);
            (I = _),
              (S = C),
              (_ = A),
              (C = E),
              (A = w),
              (E = v),
              (w = u(b, y, B, j)),
              (v = h(y, y, B, j)),
              (b = f),
              (y = p),
              (f = c),
              (p = l),
              (c = i),
              (l = s),
              (i = u(B, j, F, $)),
              (s = h(B, j, F, $));
          }
          d(this.h, 0, i, s),
            d(this.h, 2, c, l),
            d(this.h, 4, f, p),
            d(this.h, 6, b, y),
            d(this.h, 8, w, v),
            d(this.h, 10, A, E),
            d(this.h, 12, _, C),
            d(this.h, 14, I, S);
        }),
        (w.prototype._digest = function (e) {
          return "hex" === e
            ? i.toHex32(this.h, "big")
            : i.split32(this.h, "big");
        });
    },
    31622: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => n, x: () => a });
      var i = r(12115),
        s = r(7208);
      let n = (0, i.createContext)(void 0);
      function a(e) {
        let { children: t, config: r } = e;
        return (0, i.createElement)(
          s.C,
          e,
          (0, i.createElement)(n.Provider, { value: r }, t)
        );
      }
    },
    32464: (e, t, r) => {
      "use strict";
      async function i(...e) {
        let t = await fetch(...e);
        if (!t.ok) throw Error(`HTTP status code: ${t.status}`, { cause: t });
        return t;
      }
      r.d(t, { Z: () => s });
      class s {
        constructor({ baseUrl: e, clientId: t }) {
          (this.baseUrl = e), (this.clientId = t);
        }
        async get({ headers: e, signal: t, cache: r, ...s }) {
          let n = this.createUrl(s);
          return (
            await i(n, { method: "GET", headers: e, signal: t, cache: r })
          ).json();
        }
        async getBlob({ headers: e, signal: t, ...r }) {
          let s = this.createUrl(r);
          return (await i(s, { method: "GET", headers: e, signal: t })).blob();
        }
        async post({ body: e, headers: t, signal: r, ...s }) {
          let n = this.createUrl(s);
          return (
            await i(n, {
              method: "POST",
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: r,
            })
          ).json();
        }
        async put({ body: e, headers: t, signal: r, ...s }) {
          let n = this.createUrl(s);
          return (
            await i(n, {
              method: "PUT",
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: r,
            })
          ).json();
        }
        async delete({ body: e, headers: t, signal: r, ...s }) {
          let n = this.createUrl(s);
          return (
            await i(n, {
              method: "DELETE",
              headers: t,
              body: e ? JSON.stringify(e) : void 0,
              signal: r,
            })
          ).json();
        }
        createUrl({ path: e, params: t }) {
          let r = new URL(e, this.baseUrl);
          return (
            t &&
              Object.entries(t).forEach(([e, t]) => {
                t && r.searchParams.append(e, t);
              }),
            this.clientId && r.searchParams.append("clientId", this.clientId),
            r
          );
        }
      }
    },
    33372: (e, t, r) => {
      "use strict";
      var i = r(98392),
        s = r(78239),
        n = s.assert,
        a = s.cachedProperty,
        o = s.parseBytes;
      function c(e, t) {
        (this.eddsa = e),
          "object" != typeof t && (t = o(t)),
          Array.isArray(t) &&
            (n(t.length === 2 * e.encodingLength, "Signature has invalid size"),
            (t = {
              R: t.slice(0, e.encodingLength),
              S: t.slice(e.encodingLength),
            })),
          n(t.R && t.S, "Signature without R or S"),
          e.isPoint(t.R) && (this._R = t.R),
          t.S instanceof i && (this._S = t.S),
          (this._Rencoded = Array.isArray(t.R) ? t.R : t.Rencoded),
          (this._Sencoded = Array.isArray(t.S) ? t.S : t.Sencoded);
      }
      a(c, "S", function () {
        return this.eddsa.decodeInt(this.Sencoded());
      }),
        a(c, "R", function () {
          return this.eddsa.decodePoint(this.Rencoded());
        }),
        a(c, "Rencoded", function () {
          return this.eddsa.encodePoint(this.R());
        }),
        a(c, "Sencoded", function () {
          return this.eddsa.encodeInt(this.S());
        }),
        (c.prototype.toBytes = function () {
          return this.Rencoded().concat(this.Sencoded());
        }),
        (c.prototype.toHex = function () {
          return s.encode(this.toBytes(), "hex").toUpperCase();
        }),
        (e.exports = c);
    },
    33455: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "ImageConfigContext", {
          enumerable: !0,
          get: function () {
            return n;
          },
        });
      let i = r(28140)._(r(12115)),
        s = r(20821),
        n = i.default.createContext(s.imageConfigDefault);
    },
    33869: (e, t, r) => {
      "use strict";
      var i = r(78239),
        s = i.assert,
        n = i.parseBytes,
        a = i.cachedProperty;
      function o(e, t) {
        (this.eddsa = e),
          (this._secret = n(t.secret)),
          e.isPoint(t.pub) ? (this._pub = t.pub) : (this._pubBytes = n(t.pub));
      }
      (o.fromPublic = function (e, t) {
        return t instanceof o ? t : new o(e, { pub: t });
      }),
        (o.fromSecret = function (e, t) {
          return t instanceof o ? t : new o(e, { secret: t });
        }),
        (o.prototype.secret = function () {
          return this._secret;
        }),
        a(o, "pubBytes", function () {
          return this.eddsa.encodePoint(this.pub());
        }),
        a(o, "pub", function () {
          return this._pubBytes
            ? this.eddsa.decodePoint(this._pubBytes)
            : this.eddsa.g.mul(this.priv());
        }),
        a(o, "privBytes", function () {
          var e = this.eddsa,
            t = this.hash(),
            r = e.encodingLength - 1,
            i = t.slice(0, e.encodingLength);
          return (i[0] &= 248), (i[r] &= 127), (i[r] |= 64), i;
        }),
        a(o, "priv", function () {
          return this.eddsa.decodeInt(this.privBytes());
        }),
        a(o, "hash", function () {
          return this.eddsa.hash().update(this.secret()).digest();
        }),
        a(o, "messagePrefix", function () {
          return this.hash().slice(this.eddsa.encodingLength);
        }),
        (o.prototype.sign = function (e) {
          return (
            s(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this)
          );
        }),
        (o.prototype.verify = function (e, t) {
          return this.eddsa.verify(e, t, this);
        }),
        (o.prototype.getSecret = function (e) {
          return (
            s(this._secret, "KeyPair is public only"),
            i.encode(this.secret(), e)
          );
        }),
        (o.prototype.getPublic = function (e) {
          return i.encode(this.pubBytes(), e);
        }),
        (e.exports = o);
    },
    34430: function (e) {
      e.exports = {
        name: "en",
        weekdays:
          "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months:
          "January_February_March_April_May_June_July_August_September_October_November_December".split(
            "_"
          ),
        ordinal: function (e) {
          var t = ["th", "st", "nd", "rd"],
            r = e % 100;
          return "[" + e + (t[(r - 20) % 10] || t[r] || "th") + "]";
        },
      };
    },
    34561: (e, t, r) => {
      "use strict";
      r.d(t, {
        $P: () => c,
        My: () => l,
        cK: () => d,
        i3: () => h,
        nj: () => o,
      });
      var i = r(35276),
        s = r(72427),
        n = r(11914);
      let a = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function o(e, t = {}) {
        return "number" == typeof e || "bigint" == typeof e
          ? d(e, t)
          : "string" == typeof e
          ? h(e, t)
          : "boolean" == typeof e
          ? c(e, t)
          : l(e, t);
      }
      function c(e, t = {}) {
        let r = `0x${Number(e)}`;
        return "number" == typeof t.size
          ? ((0, n.Sl)(r, { size: t.size }), (0, s.eV)(r, { size: t.size }))
          : r;
      }
      function l(e, t = {}) {
        let r = "";
        for (let t = 0; t < e.length; t++) r += a[e[t]];
        let i = `0x${r}`;
        return "number" == typeof t.size
          ? ((0, n.Sl)(i, { size: t.size }),
            (0, s.eV)(i, { dir: "right", size: t.size }))
          : i;
      }
      function d(e, t = {}) {
        let r;
        let { signed: n, size: a } = t,
          o = BigInt(e);
        a
          ? (r = n
              ? (1n << (8n * BigInt(a) - 1n)) - 1n
              : 2n ** (8n * BigInt(a)) - 1n)
          : "number" == typeof e && (r = BigInt(Number.MAX_SAFE_INTEGER));
        let c = "bigint" == typeof r && n ? -r - 1n : 0;
        if ((r && o > r) || o < c) {
          let t = "bigint" == typeof e ? "n" : "";
          throw new i.Ty({
            max: r ? `${r}${t}` : void 0,
            min: `${c}${t}`,
            signed: n,
            size: a,
            value: `${e}${t}`,
          });
        }
        let l = `0x${(n && o < 0
          ? (1n << BigInt(8 * a)) + BigInt(o)
          : o
        ).toString(16)}`;
        return a ? (0, s.eV)(l, { size: a }) : l;
      }
      let u = new TextEncoder();
      function h(e, t = {}) {
        return l(u.encode(e), t);
      }
    },
    35276: (e, t, r) => {
      "use strict";
      r.d(t, { H2: () => a, Ty: () => s, u: () => o, xO: () => n });
      var i = r(13933);
      class s extends i.C {
        constructor({ max: e, min: t, signed: r, size: i, value: s }) {
          super(
            `Number "${s}" is not in safe ${
              i ? `${8 * i}-bit ${r ? "signed" : "unsigned"} ` : ""
            }integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`,
            { name: "IntegerOutOfRangeError" }
          );
        }
      }
      class n extends i.C {
        constructor(e) {
          super(
            `Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,
            { name: "InvalidBytesBooleanError" }
          );
        }
      }
      class a extends i.C {
        constructor(e) {
          super(
            `Hex value "${e}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`,
            { name: "InvalidHexBooleanError" }
          );
        }
      }
      i.C;
      class o extends i.C {
        constructor({ givenSize: e, maxSize: t }) {
          super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
            name: "SizeOverflowError",
          });
        }
      }
    },
    36117: function (e) {
      var t, r, i, s, n, a, o, c, l, d, u, h, f, p, g, m, b, y, w, v, A, E;
      (t = "millisecond"),
        (r = "second"),
        (i = "minute"),
        (s = "hour"),
        (n = "week"),
        (a = "month"),
        (o = "quarter"),
        (c = "year"),
        (l = "date"),
        (d = "Invalid Date"),
        (u =
          /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/),
        (h =
          /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g),
        (f = function (e, t, r) {
          var i = String(e);
          return !i || i.length >= t
            ? e
            : "" + Array(t + 1 - i.length).join(r) + e;
        }),
        ((g = {})[(p = "en")] = {
          name: "en",
          weekdays:
            "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
              "_"
            ),
          months:
            "January_February_March_April_May_June_July_August_September_October_November_December".split(
              "_"
            ),
          ordinal: function (e) {
            var t = ["th", "st", "nd", "rd"],
              r = e % 100;
            return "[" + e + (t[(r - 20) % 10] || t[r] || "th") + "]";
          },
        }),
        (m = "$isDayjsObject"),
        (b = function (e) {
          return e instanceof A || !(!e || !e[m]);
        }),
        (y = function e(t, r, i) {
          var s;
          if (!t) return p;
          if ("string" == typeof t) {
            var n = t.toLowerCase();
            g[n] && (s = n), r && ((g[n] = r), (s = n));
            var a = t.split("-");
            if (!s && a.length > 1) return e(a[0]);
          } else {
            var o = t.name;
            (g[o] = t), (s = o);
          }
          return !i && s && (p = s), s || (!i && p);
        }),
        (w = function (e, t) {
          if (b(e)) return e.clone();
          var r = "object" == typeof t ? t : {};
          return (r.date = e), (r.args = arguments), new A(r);
        }),
        ((v = {
          s: f,
          z: function (e) {
            var t = -e.utcOffset(),
              r = Math.abs(t);
            return (
              (t <= 0 ? "+" : "-") +
              f(Math.floor(r / 60), 2, "0") +
              ":" +
              f(r % 60, 2, "0")
            );
          },
          m: function e(t, r) {
            if (t.date() < r.date()) return -e(r, t);
            var i = 12 * (r.year() - t.year()) + (r.month() - t.month()),
              s = t.clone().add(i, a),
              n = r - s < 0,
              o = t.clone().add(i + (n ? -1 : 1), a);
            return +(-(i + (r - s) / (n ? s - o : o - s)) || 0);
          },
          a: function (e) {
            return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
          },
          p: function (e) {
            return (
              {
                M: a,
                y: c,
                w: n,
                d: "day",
                D: l,
                h: s,
                m: i,
                s: r,
                ms: t,
                Q: o,
              }[e] ||
              String(e || "")
                .toLowerCase()
                .replace(/s$/, "")
            );
          },
          u: function (e) {
            return void 0 === e;
          },
        }).l = y),
        (v.i = b),
        (v.w = function (e, t) {
          return w(e, { locale: t.$L, utc: t.$u, x: t.$x, $offset: t.$offset });
        }),
        (E = (A = (function () {
          function e(e) {
            (this.$L = y(e.locale, null, !0)),
              this.parse(e),
              (this.$x = this.$x || e.x || {}),
              (this[m] = !0);
          }
          var f = e.prototype;
          return (
            (f.parse = function (e) {
              (this.$d = (function (e) {
                var t = e.date,
                  r = e.utc;
                if (null === t) return new Date(NaN);
                if (v.u(t)) return new Date();
                if (t instanceof Date) return new Date(t);
                if ("string" == typeof t && !/Z$/i.test(t)) {
                  var i = t.match(u);
                  if (i) {
                    var s = i[2] - 1 || 0,
                      n = (i[7] || "0").substring(0, 3);
                    return r
                      ? new Date(
                          Date.UTC(
                            i[1],
                            s,
                            i[3] || 1,
                            i[4] || 0,
                            i[5] || 0,
                            i[6] || 0,
                            n
                          )
                        )
                      : new Date(
                          i[1],
                          s,
                          i[3] || 1,
                          i[4] || 0,
                          i[5] || 0,
                          i[6] || 0,
                          n
                        );
                  }
                }
                return new Date(t);
              })(e)),
                this.init();
            }),
            (f.init = function () {
              var e = this.$d;
              (this.$y = e.getFullYear()),
                (this.$M = e.getMonth()),
                (this.$D = e.getDate()),
                (this.$W = e.getDay()),
                (this.$H = e.getHours()),
                (this.$m = e.getMinutes()),
                (this.$s = e.getSeconds()),
                (this.$ms = e.getMilliseconds());
            }),
            (f.$utils = function () {
              return v;
            }),
            (f.isValid = function () {
              return this.$d.toString() !== d;
            }),
            (f.isSame = function (e, t) {
              var r = w(e);
              return this.startOf(t) <= r && r <= this.endOf(t);
            }),
            (f.isAfter = function (e, t) {
              return w(e) < this.startOf(t);
            }),
            (f.isBefore = function (e, t) {
              return this.endOf(t) < w(e);
            }),
            (f.$g = function (e, t, r) {
              return v.u(e) ? this[t] : this.set(r, e);
            }),
            (f.unix = function () {
              return Math.floor(this.valueOf() / 1e3);
            }),
            (f.valueOf = function () {
              return this.$d.getTime();
            }),
            (f.startOf = function (e, t) {
              var o = this,
                d = !!v.u(t) || t,
                u = v.p(e),
                h = function (e, t) {
                  var r = v.w(
                    o.$u ? Date.UTC(o.$y, t, e) : new Date(o.$y, t, e),
                    o
                  );
                  return d ? r : r.endOf("day");
                },
                f = function (e, t) {
                  return v.w(
                    o
                      .toDate()
                      [e].apply(
                        o.toDate("s"),
                        (d ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)
                      ),
                    o
                  );
                },
                p = this.$W,
                g = this.$M,
                m = this.$D,
                b = "set" + (this.$u ? "UTC" : "");
              switch (u) {
                case c:
                  return d ? h(1, 0) : h(31, 11);
                case a:
                  return d ? h(1, g) : h(0, g + 1);
                case n:
                  var y = this.$locale().weekStart || 0,
                    w = (p < y ? p + 7 : p) - y;
                  return h(d ? m - w : m + (6 - w), g);
                case "day":
                case l:
                  return f(b + "Hours", 0);
                case s:
                  return f(b + "Minutes", 1);
                case i:
                  return f(b + "Seconds", 2);
                case r:
                  return f(b + "Milliseconds", 3);
                default:
                  return this.clone();
              }
            }),
            (f.endOf = function (e) {
              return this.startOf(e, !1);
            }),
            (f.$set = function (e, n) {
              var o,
                d = v.p(e),
                u = "set" + (this.$u ? "UTC" : ""),
                h = (((o = {}).day = u + "Date"),
                (o[l] = u + "Date"),
                (o[a] = u + "Month"),
                (o[c] = u + "FullYear"),
                (o[s] = u + "Hours"),
                (o[i] = u + "Minutes"),
                (o[r] = u + "Seconds"),
                (o[t] = u + "Milliseconds"),
                o)[d],
                f = "day" === d ? this.$D + (n - this.$W) : n;
              if (d === a || d === c) {
                var p = this.clone().set(l, 1);
                p.$d[h](f),
                  p.init(),
                  (this.$d = p.set(l, Math.min(this.$D, p.daysInMonth())).$d);
              } else h && this.$d[h](f);
              return this.init(), this;
            }),
            (f.set = function (e, t) {
              return this.clone().$set(e, t);
            }),
            (f.get = function (e) {
              return this[v.p(e)]();
            }),
            (f.add = function (e, t) {
              var o,
                l = this;
              e = Number(e);
              var d = v.p(t),
                u = function (t) {
                  var r = w(l);
                  return v.w(r.date(r.date() + Math.round(t * e)), l);
                };
              if (d === a) return this.set(a, this.$M + e);
              if (d === c) return this.set(c, this.$y + e);
              if ("day" === d) return u(1);
              if (d === n) return u(7);
              var h =
                  (((o = {})[i] = 6e4), (o[s] = 36e5), (o[r] = 1e3), o)[d] || 1,
                f = this.$d.getTime() + e * h;
              return v.w(f, this);
            }),
            (f.subtract = function (e, t) {
              return this.add(-1 * e, t);
            }),
            (f.format = function (e) {
              var t = this,
                r = this.$locale();
              if (!this.isValid()) return r.invalidDate || d;
              var i = e || "YYYY-MM-DDTHH:mm:ssZ",
                s = v.z(this),
                n = this.$H,
                a = this.$m,
                o = this.$M,
                c = r.weekdays,
                l = r.months,
                u = r.meridiem,
                f = function (e, r, s, n) {
                  return (e && (e[r] || e(t, i))) || s[r].slice(0, n);
                },
                p = function (e) {
                  return v.s(n % 12 || 12, e, "0");
                },
                g =
                  u ||
                  function (e, t, r) {
                    var i = e < 12 ? "AM" : "PM";
                    return r ? i.toLowerCase() : i;
                  };
              return i.replace(h, function (e, i) {
                return (
                  i ||
                  (function (e) {
                    switch (e) {
                      case "YY":
                        return String(t.$y).slice(-2);
                      case "YYYY":
                        return v.s(t.$y, 4, "0");
                      case "M":
                        return o + 1;
                      case "MM":
                        return v.s(o + 1, 2, "0");
                      case "MMM":
                        return f(r.monthsShort, o, l, 3);
                      case "MMMM":
                        return f(l, o);
                      case "D":
                        return t.$D;
                      case "DD":
                        return v.s(t.$D, 2, "0");
                      case "d":
                        return String(t.$W);
                      case "dd":
                        return f(r.weekdaysMin, t.$W, c, 2);
                      case "ddd":
                        return f(r.weekdaysShort, t.$W, c, 3);
                      case "dddd":
                        return c[t.$W];
                      case "H":
                        return String(n);
                      case "HH":
                        return v.s(n, 2, "0");
                      case "h":
                        return p(1);
                      case "hh":
                        return p(2);
                      case "a":
                        return g(n, a, !0);
                      case "A":
                        return g(n, a, !1);
                      case "m":
                        return String(a);
                      case "mm":
                        return v.s(a, 2, "0");
                      case "s":
                        return String(t.$s);
                      case "ss":
                        return v.s(t.$s, 2, "0");
                      case "SSS":
                        return v.s(t.$ms, 3, "0");
                      case "Z":
                        return s;
                    }
                    return null;
                  })(e) ||
                  s.replace(":", "")
                );
              });
            }),
            (f.utcOffset = function () {
              return -(15 * Math.round(this.$d.getTimezoneOffset() / 15));
            }),
            (f.diff = function (e, t, l) {
              var d,
                u = this,
                h = v.p(t),
                f = w(e),
                p = (f.utcOffset() - this.utcOffset()) * 6e4,
                g = this - f,
                m = function () {
                  return v.m(u, f);
                };
              switch (h) {
                case c:
                  d = m() / 12;
                  break;
                case a:
                  d = m();
                  break;
                case o:
                  d = m() / 3;
                  break;
                case n:
                  d = (g - p) / 6048e5;
                  break;
                case "day":
                  d = (g - p) / 864e5;
                  break;
                case s:
                  d = g / 36e5;
                  break;
                case i:
                  d = g / 6e4;
                  break;
                case r:
                  d = g / 1e3;
                  break;
                default:
                  d = g;
              }
              return l ? d : v.a(d);
            }),
            (f.daysInMonth = function () {
              return this.endOf(a).$D;
            }),
            (f.$locale = function () {
              return g[this.$L];
            }),
            (f.locale = function (e, t) {
              if (!e) return this.$L;
              var r = this.clone(),
                i = y(e, t, !0);
              return i && (r.$L = i), r;
            }),
            (f.clone = function () {
              return v.w(this.$d, this);
            }),
            (f.toDate = function () {
              return new Date(this.valueOf());
            }),
            (f.toJSON = function () {
              return this.isValid() ? this.toISOString() : null;
            }),
            (f.toISOString = function () {
              return this.$d.toISOString();
            }),
            (f.toString = function () {
              return this.$d.toUTCString();
            }),
            e
          );
        })()).prototype),
        (w.prototype = E),
        [
          ["$ms", t],
          ["$s", r],
          ["$m", i],
          ["$H", s],
          ["$W", "day"],
          ["$M", a],
          ["$y", c],
          ["$D", l],
        ].forEach(function (e) {
          E[e[1]] = function (t) {
            return this.$g(t, e[0], e[1]);
          };
        }),
        (w.extend = function (e, t) {
          return e.$i || (e(t, A, w), (e.$i = !0)), w;
        }),
        (w.locale = y),
        (w.isDayjs = b),
        (w.unix = function (e) {
          return w(1e3 * e);
        }),
        (w.en = g[p]),
        (w.Ls = g),
        (w.p = {}),
        (e.exports = w);
    },
    36211: (e, t, r) => {
      "use strict";
      r.d(t, {
        z8: () => i,
        tt: () => l,
        Zv: () => n.Z,
        EM: () => d.E,
        RF: () => s.RF,
        JX: () => s.JX,
        ds: () => s.ds,
      });
      let i = {
        interpolate(e, t, r) {
          if (2 !== e.length || 2 !== t.length)
            throw Error(
              "inputRange and outputRange must be an array of length 2"
            );
          let i = e[0] || 0,
            s = e[1] || 0,
            n = t[0] || 0,
            a = t[1] || 0;
          return r < i ? n : r > s ? a : ((a - n) / (s - i)) * (r - i) + n;
        },
      };
      var s = r(71084),
        n = r(8821),
        a = r(12232);
      let o = ["receive", "deposit", "borrow", "claim"],
        c = ["withdraw", "repay", "burn"],
        l = {
          getTransactionGroupTitle(e, t) {
            let r = a.r.getYear(),
              i = a.r.getMonthNameByIndex(t);
            return e === r ? i : `${i} ${e}`;
          },
          getTransactionImages(e) {
            let [t, r] = e,
              i = !!t && e?.every((e) => !!e.nft_info),
              s = e?.length > 1;
            return e?.length !== 2 || i
              ? s
                ? e.map((e) => this.getTransactionImage(e))
                : [this.getTransactionImage(t)]
              : [this.getTransactionImage(t), this.getTransactionImage(r)];
          },
          getTransactionImage: (e) => ({
            type: l.getTransactionTransferTokenType(e),
            url: l.getTransactionImageURL(e),
          }),
          getTransactionImageURL(e) {
            let t;
            let r = !!e?.nft_info,
              i = !!e?.fungible_info;
            return (
              e && r
                ? (t = e?.nft_info?.content?.preview?.url)
                : e && i && (t = e?.fungible_info?.icon?.url),
              t
            );
          },
          getTransactionTransferTokenType: (e) =>
            e?.fungible_info ? "FUNGIBLE" : e?.nft_info ? "NFT" : void 0,
          getTransactionDescriptions(e) {
            let t = e?.metadata?.operationType,
              r = e?.transfers,
              i = e?.transfers?.length > 0,
              s = e?.transfers?.length > 1,
              a = i && r?.every((e) => !!e?.fungible_info),
              [l, d] = r,
              u = this.getTransferDescription(l),
              h = this.getTransferDescription(d);
            if (!i)
              return ("send" === t || "receive" === t) && a
                ? [
                    (u = n.Z.getTruncateString({
                      string: e?.metadata.sentFrom,
                      charsStart: 4,
                      charsEnd: 6,
                      truncate: "middle",
                    })),
                    n.Z.getTruncateString({
                      string: e?.metadata.sentTo,
                      charsStart: 4,
                      charsEnd: 6,
                      truncate: "middle",
                    }),
                  ]
                : [e.metadata.status];
            if (s) return r.map((e) => this.getTransferDescription(e));
            let f = "";
            return (
              o.includes(t) ? (f = "+") : c.includes(t) && (f = "-"),
              [(u = f.concat(u))]
            );
          },
          getTransferDescription(e) {
            let t = "";
            return (
              e &&
                (e?.nft_info
                  ? (t = e?.nft_info?.name || "-")
                  : e?.fungible_info &&
                    (t = this.getFungibleTransferDescription(e) || "-")),
              t
            );
          },
          getFungibleTransferDescription(e) {
            return e
              ? [
                  this.getQuantityFixedValue(e?.quantity.numeric),
                  e?.fungible_info?.symbol,
                ]
                  .join(" ")
                  .trim()
              : null;
          },
          getQuantityFixedValue: (e) => (e ? parseFloat(e).toFixed(3) : null),
        };
      var d = r(47327);
    },
    37370: (e, t, r) => {
      var i =
          ("undefined" != typeof globalThis && globalThis) ||
          ("undefined" != typeof self && self) ||
          (void 0 !== r.g && r.g),
        s = (function () {
          function e() {
            (this.fetch = !1), (this.DOMException = i.DOMException);
          }
          return (e.prototype = i), new e();
        })();
      !(function (e) {
        !(function (t) {
          var i =
              (void 0 !== e && e) ||
              ("undefined" != typeof self && self) ||
              (void 0 !== r.g && r.g) ||
              {},
            s = {
              searchParams: "URLSearchParams" in i,
              iterable: "Symbol" in i && "iterator" in Symbol,
              blob:
                "FileReader" in i &&
                "Blob" in i &&
                (function () {
                  try {
                    return new Blob(), !0;
                  } catch (e) {
                    return !1;
                  }
                })(),
              formData: "FormData" in i,
              arrayBuffer: "ArrayBuffer" in i,
            };
          if (s.arrayBuffer)
            var n = [
                "[object Int8Array]",
                "[object Uint8Array]",
                "[object Uint8ClampedArray]",
                "[object Int16Array]",
                "[object Uint16Array]",
                "[object Int32Array]",
                "[object Uint32Array]",
                "[object Float32Array]",
                "[object Float64Array]",
              ],
              a =
                ArrayBuffer.isView ||
                function (e) {
                  return e && n.indexOf(Object.prototype.toString.call(e)) > -1;
                };
          function o(e) {
            if (
              ("string" != typeof e && (e = String(e)),
              /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || "" === e)
            )
              throw TypeError(
                'Invalid character in header field name: "' + e + '"'
              );
            return e.toLowerCase();
          }
          function c(e) {
            return "string" != typeof e && (e = String(e)), e;
          }
          function l(e) {
            var t = {
              next: function () {
                var t = e.shift();
                return { done: void 0 === t, value: t };
              },
            };
            return (
              s.iterable &&
                (t[Symbol.iterator] = function () {
                  return t;
                }),
              t
            );
          }
          function d(e) {
            (this.map = {}),
              e instanceof d
                ? e.forEach(function (e, t) {
                    this.append(t, e);
                  }, this)
                : Array.isArray(e)
                ? e.forEach(function (e) {
                    if (2 != e.length)
                      throw TypeError(
                        "Headers constructor: expected name/value pair to be length 2, found" +
                          e.length
                      );
                    this.append(e[0], e[1]);
                  }, this)
                : e &&
                  Object.getOwnPropertyNames(e).forEach(function (t) {
                    this.append(t, e[t]);
                  }, this);
          }
          function u(e) {
            if (!e._noBody) {
              if (e.bodyUsed) return Promise.reject(TypeError("Already read"));
              e.bodyUsed = !0;
            }
          }
          function h(e) {
            return new Promise(function (t, r) {
              (e.onload = function () {
                t(e.result);
              }),
                (e.onerror = function () {
                  r(e.error);
                });
            });
          }
          function f(e) {
            var t = new FileReader(),
              r = h(t);
            return t.readAsArrayBuffer(e), r;
          }
          function p(e) {
            if (e.slice) return e.slice(0);
            var t = new Uint8Array(e.byteLength);
            return t.set(new Uint8Array(e)), t.buffer;
          }
          function g() {
            return (
              (this.bodyUsed = !1),
              (this._initBody = function (e) {
                if (
                  ((this.bodyUsed = this.bodyUsed), (this._bodyInit = e), e)
                ) {
                  if ("string" == typeof e) this._bodyText = e;
                  else if (s.blob && Blob.prototype.isPrototypeOf(e))
                    this._bodyBlob = e;
                  else if (s.formData && FormData.prototype.isPrototypeOf(e))
                    this._bodyFormData = e;
                  else if (
                    s.searchParams &&
                    URLSearchParams.prototype.isPrototypeOf(e)
                  )
                    this._bodyText = e.toString();
                  else {
                    var t;
                    s.arrayBuffer &&
                    s.blob &&
                    (t = e) &&
                    DataView.prototype.isPrototypeOf(t)
                      ? ((this._bodyArrayBuffer = p(e.buffer)),
                        (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                      : s.arrayBuffer &&
                        (ArrayBuffer.prototype.isPrototypeOf(e) || a(e))
                      ? (this._bodyArrayBuffer = p(e))
                      : (this._bodyText = e =
                          Object.prototype.toString.call(e));
                  }
                } else (this._noBody = !0), (this._bodyText = "");
                !this.headers.get("content-type") &&
                  ("string" == typeof e
                    ? this.headers.set(
                        "content-type",
                        "text/plain;charset=UTF-8"
                      )
                    : this._bodyBlob && this._bodyBlob.type
                    ? this.headers.set("content-type", this._bodyBlob.type)
                    : s.searchParams &&
                      URLSearchParams.prototype.isPrototypeOf(e) &&
                      this.headers.set(
                        "content-type",
                        "application/x-www-form-urlencoded;charset=UTF-8"
                      ));
              }),
              s.blob &&
                (this.blob = function () {
                  var e = u(this);
                  if (e) return e;
                  if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                  if (this._bodyArrayBuffer)
                    return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                  if (!this._bodyFormData)
                    return Promise.resolve(new Blob([this._bodyText]));
                  throw Error("could not read FormData body as blob");
                }),
              (this.arrayBuffer = function () {
                if (this._bodyArrayBuffer) {
                  var e = u(this);
                  return (
                    e ||
                    (ArrayBuffer.isView(this._bodyArrayBuffer)
                      ? Promise.resolve(
                          this._bodyArrayBuffer.buffer.slice(
                            this._bodyArrayBuffer.byteOffset,
                            this._bodyArrayBuffer.byteOffset +
                              this._bodyArrayBuffer.byteLength
                          )
                        )
                      : Promise.resolve(this._bodyArrayBuffer))
                  );
                }
                if (s.blob) return this.blob().then(f);
                throw Error("could not read as ArrayBuffer");
              }),
              (this.text = function () {
                var e,
                  t,
                  r,
                  i,
                  s,
                  n = u(this);
                if (n) return n;
                if (this._bodyBlob)
                  return (
                    (e = this._bodyBlob),
                    (r = h((t = new FileReader()))),
                    (s = (i = /charset=([A-Za-z0-9_-]+)/.exec(e.type))
                      ? i[1]
                      : "utf-8"),
                    t.readAsText(e, s),
                    r
                  );
                if (this._bodyArrayBuffer)
                  return Promise.resolve(
                    (function (e) {
                      for (
                        var t = new Uint8Array(e), r = Array(t.length), i = 0;
                        i < t.length;
                        i++
                      )
                        r[i] = String.fromCharCode(t[i]);
                      return r.join("");
                    })(this._bodyArrayBuffer)
                  );
                if (!this._bodyFormData) return Promise.resolve(this._bodyText);
                throw Error("could not read FormData body as text");
              }),
              s.formData &&
                (this.formData = function () {
                  return this.text().then(y);
                }),
              (this.json = function () {
                return this.text().then(JSON.parse);
              }),
              this
            );
          }
          (d.prototype.append = function (e, t) {
            (e = o(e)), (t = c(t));
            var r = this.map[e];
            this.map[e] = r ? r + ", " + t : t;
          }),
            (d.prototype.delete = function (e) {
              delete this.map[o(e)];
            }),
            (d.prototype.get = function (e) {
              return (e = o(e)), this.has(e) ? this.map[e] : null;
            }),
            (d.prototype.has = function (e) {
              return this.map.hasOwnProperty(o(e));
            }),
            (d.prototype.set = function (e, t) {
              this.map[o(e)] = c(t);
            }),
            (d.prototype.forEach = function (e, t) {
              for (var r in this.map)
                this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this);
            }),
            (d.prototype.keys = function () {
              var e = [];
              return (
                this.forEach(function (t, r) {
                  e.push(r);
                }),
                l(e)
              );
            }),
            (d.prototype.values = function () {
              var e = [];
              return (
                this.forEach(function (t) {
                  e.push(t);
                }),
                l(e)
              );
            }),
            (d.prototype.entries = function () {
              var e = [];
              return (
                this.forEach(function (t, r) {
                  e.push([r, t]);
                }),
                l(e)
              );
            }),
            s.iterable && (d.prototype[Symbol.iterator] = d.prototype.entries);
          var m = [
            "CONNECT",
            "DELETE",
            "GET",
            "HEAD",
            "OPTIONS",
            "PATCH",
            "POST",
            "PUT",
            "TRACE",
          ];
          function b(e, t) {
            if (!(this instanceof b))
              throw TypeError(
                'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
              );
            var r,
              s,
              n = (t = t || {}).body;
            if (e instanceof b) {
              if (e.bodyUsed) throw TypeError("Already read");
              (this.url = e.url),
                (this.credentials = e.credentials),
                t.headers || (this.headers = new d(e.headers)),
                (this.method = e.method),
                (this.mode = e.mode),
                (this.signal = e.signal),
                n ||
                  null == e._bodyInit ||
                  ((n = e._bodyInit), (e.bodyUsed = !0));
            } else this.url = String(e);
            if (
              ((this.credentials =
                t.credentials || this.credentials || "same-origin"),
              (t.headers || !this.headers) && (this.headers = new d(t.headers)),
              (this.method =
                ((s = (r = t.method || this.method || "GET").toUpperCase()),
                m.indexOf(s) > -1 ? s : r)),
              (this.mode = t.mode || this.mode || null),
              (this.signal =
                t.signal ||
                this.signal ||
                (function () {
                  if ("AbortController" in i)
                    return new AbortController().signal;
                })()),
              (this.referrer = null),
              ("GET" === this.method || "HEAD" === this.method) && n)
            )
              throw TypeError("Body not allowed for GET or HEAD requests");
            if (
              (this._initBody(n),
              ("GET" === this.method || "HEAD" === this.method) &&
                ("no-store" === t.cache || "no-cache" === t.cache))
            ) {
              var a = /([?&])_=[^&]*/;
              a.test(this.url)
                ? (this.url = this.url.replace(
                    a,
                    "$1_=" + new Date().getTime()
                  ))
                : (this.url +=
                    (/\?/.test(this.url) ? "&" : "?") +
                    "_=" +
                    new Date().getTime());
            }
          }
          function y(e) {
            var t = new FormData();
            return (
              e
                .trim()
                .split("&")
                .forEach(function (e) {
                  if (e) {
                    var r = e.split("="),
                      i = r.shift().replace(/\+/g, " "),
                      s = r.join("=").replace(/\+/g, " ");
                    t.append(decodeURIComponent(i), decodeURIComponent(s));
                  }
                }),
              t
            );
          }
          function w(e, t) {
            if (!(this instanceof w))
              throw TypeError(
                'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
              );
            if (
              (t || (t = {}),
              (this.type = "default"),
              (this.status = void 0 === t.status ? 200 : t.status),
              this.status < 200 || this.status > 599)
            )
              throw RangeError(
                "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
              );
            (this.ok = this.status >= 200 && this.status < 300),
              (this.statusText =
                void 0 === t.statusText ? "" : "" + t.statusText),
              (this.headers = new d(t.headers)),
              (this.url = t.url || ""),
              this._initBody(e);
          }
          (b.prototype.clone = function () {
            return new b(this, { body: this._bodyInit });
          }),
            g.call(b.prototype),
            g.call(w.prototype),
            (w.prototype.clone = function () {
              return new w(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new d(this.headers),
                url: this.url,
              });
            }),
            (w.error = function () {
              var e = new w(null, { status: 200, statusText: "" });
              return (e.ok = !1), (e.status = 0), (e.type = "error"), e;
            });
          var v = [301, 302, 303, 307, 308];
          (w.redirect = function (e, t) {
            if (-1 === v.indexOf(t)) throw RangeError("Invalid status code");
            return new w(null, { status: t, headers: { location: e } });
          }),
            (t.DOMException = i.DOMException);
          try {
            new t.DOMException();
          } catch (e) {
            (t.DOMException = function (e, t) {
              (this.message = e), (this.name = t);
              var r = Error(e);
              this.stack = r.stack;
            }),
              (t.DOMException.prototype = Object.create(Error.prototype)),
              (t.DOMException.prototype.constructor = t.DOMException);
          }
          function A(e, r) {
            return new Promise(function (n, a) {
              var l = new b(e, r);
              if (l.signal && l.signal.aborted)
                return a(new t.DOMException("Aborted", "AbortError"));
              var u = new XMLHttpRequest();
              function h() {
                u.abort();
              }
              if (
                ((u.onload = function () {
                  var e,
                    t,
                    r = {
                      statusText: u.statusText,
                      headers:
                        ((e = u.getAllResponseHeaders() || ""),
                        (t = new d()),
                        e
                          .replace(/\r?\n[\t ]+/g, " ")
                          .split("\r")
                          .map(function (e) {
                            return 0 === e.indexOf("\n")
                              ? e.substr(1, e.length)
                              : e;
                          })
                          .forEach(function (e) {
                            var r = e.split(":"),
                              i = r.shift().trim();
                            if (i) {
                              var s = r.join(":").trim();
                              try {
                                t.append(i, s);
                              } catch (e) {
                                console.warn("Response " + e.message);
                              }
                            }
                          }),
                        t),
                    };
                  0 === l.url.indexOf("file://") &&
                  (u.status < 200 || u.status > 599)
                    ? (r.status = 200)
                    : (r.status = u.status),
                    (r.url =
                      "responseURL" in u
                        ? u.responseURL
                        : r.headers.get("X-Request-URL"));
                  var i = "response" in u ? u.response : u.responseText;
                  setTimeout(function () {
                    n(new w(i, r));
                  }, 0);
                }),
                (u.onerror = function () {
                  setTimeout(function () {
                    a(TypeError("Network request failed"));
                  }, 0);
                }),
                (u.ontimeout = function () {
                  setTimeout(function () {
                    a(TypeError("Network request timed out"));
                  }, 0);
                }),
                (u.onabort = function () {
                  setTimeout(function () {
                    a(new t.DOMException("Aborted", "AbortError"));
                  }, 0);
                }),
                u.open(
                  l.method,
                  (function (e) {
                    try {
                      return "" === e && i.location.href ? i.location.href : e;
                    } catch (t) {
                      return e;
                    }
                  })(l.url),
                  !0
                ),
                "include" === l.credentials
                  ? (u.withCredentials = !0)
                  : "omit" === l.credentials && (u.withCredentials = !1),
                "responseType" in u &&
                  (s.blob
                    ? (u.responseType = "blob")
                    : s.arrayBuffer && (u.responseType = "arraybuffer")),
                r &&
                  "object" == typeof r.headers &&
                  !(
                    r.headers instanceof d ||
                    (i.Headers && r.headers instanceof i.Headers)
                  ))
              ) {
                var f = [];
                Object.getOwnPropertyNames(r.headers).forEach(function (e) {
                  f.push(o(e)), u.setRequestHeader(e, c(r.headers[e]));
                }),
                  l.headers.forEach(function (e, t) {
                    -1 === f.indexOf(t) && u.setRequestHeader(t, e);
                  });
              } else
                l.headers.forEach(function (e, t) {
                  u.setRequestHeader(t, e);
                });
              l.signal &&
                (l.signal.addEventListener("abort", h),
                (u.onreadystatechange = function () {
                  4 === u.readyState &&
                    l.signal.removeEventListener("abort", h);
                })),
                u.send(void 0 === l._bodyInit ? null : l._bodyInit);
            });
          }
          (A.polyfill = !0),
            i.fetch ||
              ((i.fetch = A),
              (i.Headers = d),
              (i.Request = b),
              (i.Response = w)),
            (t.Headers = d),
            (t.Request = b),
            (t.Response = w),
            (t.fetch = A),
            Object.defineProperty(t, "__esModule", { value: !0 });
        })({});
      })(s),
        (s.fetch.ponyfill = !0),
        delete s.fetch.polyfill;
      var n = i.fetch ? i : s;
      ((t = n.fetch).default = n.fetch),
        (t.fetch = n.fetch),
        (t.Headers = n.Headers),
        (t.Request = n.Request),
        (t.Response = n.Response),
        (e.exports = t);
    },
    37407: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => s });
      var i = r(78140);
      function s(
        e,
        { delay: t = 100, retryCount: r = 2, shouldRetry: n = () => !0 } = {}
      ) {
        return new Promise((s, a) => {
          let o = async ({ count: c = 0 } = {}) => {
            let l = async ({ error: e }) => {
              let r = "function" == typeof t ? t({ count: c, error: e }) : t;
              r && (await (0, i.u)(r)), o({ count: c + 1 });
            };
            try {
              let t = await e();
              s(t);
            } catch (e) {
              if (c < r && (await n({ count: c, error: e })))
                return l({ error: e });
              a(e);
            }
          };
          o();
        });
      }
    },
    38053: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }), (t.Watch = void 0);
      class r {
        constructor() {
          this.timestamps = new Map();
        }
        start(e) {
          if (this.timestamps.has(e))
            throw Error(`Watch already started for label: ${e}`);
          this.timestamps.set(e, { started: Date.now() });
        }
        stop(e) {
          let t = this.get(e);
          if (void 0 !== t.elapsed)
            throw Error(`Watch already stopped for label: ${e}`);
          let r = Date.now() - t.started;
          this.timestamps.set(e, { started: t.started, elapsed: r });
        }
        get(e) {
          let t = this.timestamps.get(e);
          if (void 0 === t) throw Error(`No timestamp found for label: ${e}`);
          return t;
        }
        elapsed(e) {
          let t = this.get(e);
          return t.elapsed || Date.now() - t.started;
        }
      }
      (t.Watch = r), (t.default = r);
    },
    38547: (e, t, r) => {
      "use strict";
      function i() {
        let e = new Set(),
          t = [],
          r = () =>
            (function (e) {
              if ("undefined" == typeof window) return;
              let t = (t) => e(t.detail);
              return (
                window.addEventListener("eip6963:announceProvider", t),
                window.dispatchEvent(
                  new CustomEvent("eip6963:requestProvider")
                ),
                () => window.removeEventListener("eip6963:announceProvider", t)
              );
            })((r) => {
              t.some(({ info: e }) => e.uuid === r.info.uuid) ||
                ((t = [...t, r]), e.forEach((e) => e(t, { added: [r] })));
            }),
          i = r();
        return {
          _listeners: () => e,
          clear() {
            e.forEach((e) => e([], { removed: [...t] })), (t = []);
          },
          destroy() {
            this.clear(), e.clear(), i?.();
          },
          findProvider: ({ rdns: e }) => t.find((t) => t.info.rdns === e),
          getProviders: () => t,
          reset() {
            this.clear(), i?.(), (i = r());
          },
          subscribe: (r, { emitImmediately: i } = {}) => (
            e.add(r), i && r(t, { added: t }), () => e.delete(r)
          ),
        };
      }
      r.d(t, { y: () => i });
    },
    39382: (e, t, r) => {
      "use strict";
      r.d(t, { _o: () => b, Pj: () => g, uT: () => u, NV: () => m });
      var i = r(89709),
        s = r(98782),
        n = r(91136),
        a = r(54029),
        o = r(63542);
      class c extends o.C {
        constructor({ current: e, depth: t }) {
          super("Unbalanced parentheses.", {
            metaMessages: [
              `"${e.trim()}" has too many ${
                t > 0 ? "opening" : "closing"
              } parentheses.`,
            ],
            details: `Depth "${t}"`,
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "InvalidParenthesisError",
            });
        }
      }
      let l = new Map([
        ["address", { type: "address" }],
        ["bool", { type: "bool" }],
        ["bytes", { type: "bytes" }],
        ["bytes32", { type: "bytes32" }],
        ["int", { type: "int256" }],
        ["int256", { type: "int256" }],
        ["string", { type: "string" }],
        ["uint", { type: "uint256" }],
        ["uint8", { type: "uint8" }],
        ["uint16", { type: "uint16" }],
        ["uint24", { type: "uint24" }],
        ["uint32", { type: "uint32" }],
        ["uint64", { type: "uint64" }],
        ["uint96", { type: "uint96" }],
        ["uint112", { type: "uint112" }],
        ["uint160", { type: "uint160" }],
        ["uint192", { type: "uint192" }],
        ["uint256", { type: "uint256" }],
        ["address owner", { type: "address", name: "owner" }],
        ["address to", { type: "address", name: "to" }],
        ["bool approved", { type: "bool", name: "approved" }],
        ["bytes _data", { type: "bytes", name: "_data" }],
        ["bytes data", { type: "bytes", name: "data" }],
        ["bytes signature", { type: "bytes", name: "signature" }],
        ["bytes32 hash", { type: "bytes32", name: "hash" }],
        ["bytes32 r", { type: "bytes32", name: "r" }],
        ["bytes32 root", { type: "bytes32", name: "root" }],
        ["bytes32 s", { type: "bytes32", name: "s" }],
        ["string name", { type: "string", name: "name" }],
        ["string symbol", { type: "string", name: "symbol" }],
        ["string tokenURI", { type: "string", name: "tokenURI" }],
        ["uint tokenId", { type: "uint256", name: "tokenId" }],
        ["uint8 v", { type: "uint8", name: "v" }],
        ["uint256 balance", { type: "uint256", name: "balance" }],
        ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
        ["uint256 value", { type: "uint256", name: "value" }],
        [
          "event:address indexed from",
          { type: "address", name: "from", indexed: !0 },
        ],
        [
          "event:address indexed to",
          { type: "address", name: "to", indexed: !0 },
        ],
        [
          "event:uint indexed tokenId",
          { type: "uint256", name: "tokenId", indexed: !0 },
        ],
        [
          "event:uint256 indexed tokenId",
          { type: "uint256", name: "tokenId", indexed: !0 },
        ],
      ]);
      var d = r(98957);
      function u(e, t = {}) {
        if ((0, d.Ji)(e))
          return (function (e, t = {}) {
            let r = (0, d.ej)(e);
            if (!r) throw new a.s7({ signature: e, type: "function" });
            let i = m(r.parameters),
              s = [],
              n = i.length;
            for (let e = 0; e < n; e++)
              s.push(
                g(i[e], { modifiers: d.v7, structs: t, type: "function" })
              );
            let o = [];
            if (r.returns) {
              let e = m(r.returns),
                i = e.length;
              for (let r = 0; r < i; r++)
                o.push(
                  g(e[r], { modifiers: d.v7, structs: t, type: "function" })
                );
            }
            return {
              name: r.name,
              type: "function",
              stateMutability: r.stateMutability ?? "nonpayable",
              inputs: s,
              outputs: o,
            };
          })(e, t);
        if ((0, d.Rv)(e))
          return (function (e, t = {}) {
            let r = (0, d.iB)(e);
            if (!r) throw new a.s7({ signature: e, type: "event" });
            let i = m(r.parameters),
              s = [],
              n = i.length;
            for (let e = 0; e < n; e++)
              s.push(g(i[e], { modifiers: d.fC, structs: t, type: "event" }));
            return { name: r.name, type: "event", inputs: s };
          })(e, t);
        if ((0, d.pc)(e))
          return (function (e, t = {}) {
            let r = (0, d.kz)(e);
            if (!r) throw new a.s7({ signature: e, type: "error" });
            let i = m(r.parameters),
              s = [],
              n = i.length;
            for (let e = 0; e < n; e++)
              s.push(g(i[e], { structs: t, type: "error" }));
            return { name: r.name, type: "error", inputs: s };
          })(e, t);
        if ((0, d.l9)(e))
          return (function (e, t = {}) {
            let r = (0, d.Yo)(e);
            if (!r) throw new a.s7({ signature: e, type: "constructor" });
            let i = m(r.parameters),
              s = [],
              n = i.length;
            for (let e = 0; e < n; e++)
              s.push(g(i[e], { structs: t, type: "constructor" }));
            return {
              type: "constructor",
              stateMutability: r.stateMutability ?? "nonpayable",
              inputs: s,
            };
          })(e, t);
        if ((0, d.v8)(e))
          return (function (e) {
            let t = (0, d.If)(e);
            if (!t) throw new a.s7({ signature: e, type: "fallback" });
            return {
              type: "fallback",
              stateMutability: t.stateMutability ?? "nonpayable",
            };
          })(e);
        if ((0, d.sP)(e))
          return { type: "receive", stateMutability: "payable" };
        throw new a.x8({ signature: e });
      }
      let h =
          /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
        f =
          /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
        p = /^u?int$/;
      function g(e, t) {
        var r, a;
        let o;
        let c = (function (e, t, r) {
          let i = "";
          if (r)
            for (let e of Object.entries(r)) {
              if (!e) continue;
              let t = "";
              for (let r of e[1])
                t += `[${r.type}${r.name ? `:${r.name}` : ""}]`;
              i += `(${e[0]}{${t}})`;
            }
          return t ? `${t}:${e}${i}` : e;
        })(e, t?.type, t?.structs);
        if (l.has(c)) return l.get(c);
        let u = i.wj.test(e),
          w = (0, i.Yv)(u ? f : h, e);
        if (!w) throw new n.dV({ param: e });
        if (
          w.name &&
          ("address" === (r = w.name) ||
            "bool" === r ||
            "function" === r ||
            "string" === r ||
            "tuple" === r ||
            i.BD.test(r) ||
            i.Ge.test(r) ||
            y.test(r))
        )
          throw new n.zd({ param: e, name: w.name });
        let v = w.name ? { name: w.name } : {},
          A = "indexed" === w.modifier ? { indexed: !0 } : {},
          E = t?.structs ?? {},
          _ = {};
        if (u) {
          o = "tuple";
          let e = m(w.type),
            t = [],
            r = e.length;
          for (let i = 0; i < r; i++) t.push(g(e[i], { structs: E }));
          _ = { components: t };
        } else if (w.type in E) (o = "tuple"), (_ = { components: E[w.type] });
        else if (p.test(w.type)) o = `${w.type}256`;
        else if (((o = w.type), t?.type !== "struct" && !b(o)))
          throw new s.UG({ type: o });
        if (w.modifier) {
          if (!t?.modifiers?.has?.(w.modifier))
            throw new n.NO({ param: e, type: t?.type, modifier: w.modifier });
          if (
            d.v7.has(w.modifier) &&
            ((a = o),
            !w.array && "bytes" !== a && "string" !== a && "tuple" !== a)
          )
            throw new n.Pj({ param: e, type: t?.type, modifier: w.modifier });
        }
        let C = { type: `${o}${w.array ?? ""}`, ...v, ...A, ..._ };
        return l.set(c, C), C;
      }
      function m(e, t = [], r = "", i = 0) {
        let s = e.trim().length;
        for (let n = 0; n < s; n++) {
          let s = e[n],
            a = e.slice(n + 1);
          switch (s) {
            case ",":
              return 0 === i ? m(a, [...t, r.trim()]) : m(a, t, `${r}${s}`, i);
            case "(":
              return m(a, t, `${r}${s}`, i + 1);
            case ")":
              return m(a, t, `${r}${s}`, i - 1);
            default:
              return m(a, t, `${r}${s}`, i);
          }
        }
        if ("" === r) return t;
        if (0 !== i) throw new c({ current: r, depth: i });
        return t.push(r.trim()), t;
      }
      function b(e) {
        return (
          "address" === e ||
          "bool" === e ||
          "function" === e ||
          "string" === e ||
          i.BD.test(e) ||
          i.Ge.test(e)
        );
      }
      let y =
        /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
    },
    40709: (e, t, r) => {
      "use strict";
      var i = r(20920),
        s = r(64874),
        n = r(4117),
        a = r(3285),
        o = i.sum32,
        c = i.sum32_4,
        l = i.sum32_5,
        d = n.ch32,
        u = n.maj32,
        h = n.s0_256,
        f = n.s1_256,
        p = n.g0_256,
        g = n.g1_256,
        m = s.BlockHash,
        b = [
          0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
          0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
          0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
          0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f,
          0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d,
          0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x6ca6351, 0x14292967,
          0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354,
          0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
          0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585,
          0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
          0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee,
          0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb,
          0xbef9a3f7, 0xc67178f2,
        ];
      function y() {
        if (!(this instanceof y)) return new y();
        m.call(this),
          (this.h = [
            0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f,
            0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
          ]),
          (this.k = b),
          (this.W = Array(64));
      }
      i.inherits(y, m),
        (e.exports = y),
        (y.blockSize = 512),
        (y.outSize = 256),
        (y.hmacStrength = 192),
        (y.padLength = 64),
        (y.prototype._update = function (e, t) {
          for (var r = this.W, i = 0; i < 16; i++) r[i] = e[t + i];
          for (; i < r.length; i++)
            r[i] = c(g(r[i - 2]), r[i - 7], p(r[i - 15]), r[i - 16]);
          var s = this.h[0],
            n = this.h[1],
            m = this.h[2],
            b = this.h[3],
            y = this.h[4],
            w = this.h[5],
            v = this.h[6],
            A = this.h[7];
          for (a(this.k.length === r.length), i = 0; i < r.length; i++) {
            var E = l(A, f(y), d(y, w, v), this.k[i], r[i]),
              _ = o(h(s), u(s, n, m));
            (A = v),
              (v = w),
              (w = y),
              (y = o(b, E)),
              (b = m),
              (m = n),
              (n = s),
              (s = o(E, _));
          }
          (this.h[0] = o(this.h[0], s)),
            (this.h[1] = o(this.h[1], n)),
            (this.h[2] = o(this.h[2], m)),
            (this.h[3] = o(this.h[3], b)),
            (this.h[4] = o(this.h[4], y)),
            (this.h[5] = o(this.h[5], w)),
            (this.h[6] = o(this.h[6], v)),
            (this.h[7] = o(this.h[7], A));
        }),
        (y.prototype._digest = function (e) {
          return "hex" === e
            ? i.toHex32(this.h, "big")
            : i.split32(this.h, "big");
        });
    },
    42438: (e, t, r) => {
      "use strict";
      function i(e, { dir: t = "left" } = {}) {
        let r = "string" == typeof e ? e.replace("0x", "") : e,
          s = 0;
        for (
          let e = 0;
          e < r.length - 1 &&
          "0" === r["left" === t ? e : r.length - e - 1].toString();
          e++
        )
          s++;
        return ((r = "left" === t ? r.slice(s) : r.slice(0, r.length - s)),
        "string" == typeof e)
          ? (1 === r.length && "right" === t && (r = `${r}0`),
            `0x${r.length % 2 == 1 ? `0${r}` : r}`)
          : r;
      }
      r.d(t, { B: () => i });
    },
    42503: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => n });
      var i = r(62023),
        s = r(30598);
      function n(e, t = "wei") {
        return (0, s.J)(e, i.sz[t]);
      }
    },
    43159: (e, t, r) => {
      "use strict";
      r.d(t, {
        HF: () => l,
        aj: () => o,
        gC: () => a,
        nM: () => n,
        nk: () => s,
        xU: () => c,
      });
      var i = r(28698);
      class s extends i.C {
        constructor() {
          super("Chain not configured."),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ChainNotConfiguredError",
            });
        }
      }
      class n extends i.C {
        constructor() {
          super("Connector already connected."),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ConnectorAlreadyConnectedError",
            });
        }
      }
      class a extends i.C {
        constructor() {
          super("Connector not connected."),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ConnectorNotConnectedError",
            });
        }
      }
      i.C;
      class o extends i.C {
        constructor({ address: e, connector: t }) {
          super(`Account "${e}" not found for connector "${t.name}".`),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ConnectorAccountNotFoundError",
            });
        }
      }
      class c extends i.C {
        constructor({ connectionChainId: e, connectorChainId: t }) {
          super(
            `The current chain of the connector (id: ${t}) does not match the connection's chain (id: ${e}).`,
            {
              metaMessages: [
                `Current Chain ID:  ${t}`,
                `Expected Chain ID: ${e}`,
              ],
            }
          ),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ConnectorChainMismatchError",
            });
        }
      }
      class l extends i.C {
        constructor({ connector: e }) {
          super(`Connector "${e.name}" unavailable while reconnecting.`, {
            details:
              "During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`. All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored. This error commonly occurs for connectors that asynchronously inject after reconnection has already started.",
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ConnectorUnavailableReconnectingError",
            });
        }
      }
    },
    43238: (e, t, r) => {
      "use strict";
      r.d(t, { _: () => ed });
      var i = r(45553),
        s = r(52617),
        n = r(66254),
        a = r(3824),
        o = r(70417),
        c = r(28977),
        l = r(72880),
        d = r(58051),
        u = r(73442),
        h = r(55480),
        f = r(12319),
        p = r(45069),
        g = r(58653),
        m = r(52502),
        b = r(79355),
        y = r(30948),
        w = r(89600),
        v = r(1220),
        A = r(98866);
      let E = {
          eip155: void 0,
          solana: void 0,
          polkadot: void 0,
          bip122: void 0,
        },
        _ = (0, v.BX)({ providers: { ...E }, providerIds: { ...E } }),
        C = {
          state: _,
          subscribeKey: (e, t) => (0, A.u$)(_, e, t),
          subscribeProviders: (e) =>
            (0, v.B1)(_.providers, () => e(_.providers)),
          setProvider(e, t) {
            t && (_.providers[e] = (0, v.KR)(t));
          },
          getProvider: (e) => _.providers[e],
          setProviderId(e, t) {
            t && (_.providerIds[e] = t);
          },
          getProviderId(e) {
            if (e) return _.providerIds[e];
          },
          reset() {
            (_.providers = { ...E }), (_.providerIds = { ...E });
          },
          resetChain(e) {
            (_.providers[e] = void 0), (_.providerIds[e] = void 0);
          },
        };
      var I = r(17389),
        S = r(73537),
        x = r(83881),
        N = r(77931),
        T = r(65103),
        P = r(76190),
        O = r(44826),
        k = r(81701),
        R = r(62609),
        D = r(14744),
        M = r(6578),
        U = r(65374),
        L = r(67869);
      r(48981), r(91867);
      var B = r(18635),
        j = r(36211),
        F = r(23749),
        $ = r(71018);
      let z = {
        createLogger(e, t = "error") {
          let r = (0, $.iP)({ level: t }),
            { logger: i } = (0, $.D5)({ opts: r });
          return (
            (i.error = (...t) => {
              for (let r of t)
                if (r instanceof Error) {
                  e(r, ...t);
                  return;
                }
              e(void 0, ...t);
            }),
            i
          );
        },
      };
      var W = r(54685);
      let H = "2.23.15",
        q = {
          getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: r }) =>
            t ? `${e ?? "https://viem.sh"}${t}${r ? `#${r}` : ""}` : void 0,
          version: `viem@${H}`,
        };
      class V extends Error {
        constructor(e, t = {}) {
          let r =
              t.cause instanceof V
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            i = (t.cause instanceof V && t.cause.docsPath) || t.docsPath,
            s = q.getDocsUrl?.({ ...t, docsPath: i });
          super(
            [
              e || "An error occurred.",
              "",
              ...(t.metaMessages ? [...t.metaMessages, ""] : []),
              ...(s ? [`Docs: ${s}`] : []),
              ...(r ? [`Details: ${r}`] : []),
              ...(q.version ? [`Version: ${q.version}`] : []),
            ].join("\n"),
            t.cause ? { cause: t.cause } : void 0
          ),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "version", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "BaseError",
            }),
            (this.details = r),
            (this.docsPath = i),
            (this.metaMessages = t.metaMessages),
            (this.name = t.name ?? this.name),
            (this.shortMessage = e),
            (this.version = H);
        }
        walk(e) {
          return (function e(t, r) {
            return r?.(t)
              ? t
              : t && "object" == typeof t && "cause" in t && void 0 !== t.cause
              ? e(t.cause, r)
              : r
              ? null
              : t;
          })(this, e);
        }
      }
      class K extends V {
        constructor({ max: e, min: t, signed: r, size: i, value: s }) {
          super(
            `Number "${s}" is not in safe ${
              i ? `${8 * i}-bit ${r ? "signed" : "unsigned"} ` : ""
            }integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`,
            { name: "IntegerOutOfRangeError" }
          );
        }
      }
      class G extends V {
        constructor({ givenSize: e, maxSize: t }) {
          super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
            name: "SizeOverflowError",
          });
        }
      }
      class Y extends V {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} size (${e}) exceeds padding size (${t}).`,
            { name: "SizeExceedsPaddingSizeError" }
          );
        }
      }
      function Q(e, { dir: t, size: r = 32 } = {}) {
        return "string" == typeof e
          ? (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              let i = e.replace("0x", "");
              if (i.length > 2 * r)
                throw new Y({
                  size: Math.ceil(i.length / 2),
                  targetSize: r,
                  type: "hex",
                });
              return `0x${i["right" === t ? "padEnd" : "padStart"](
                2 * r,
                "0"
              )}`;
            })(e, { dir: t, size: r })
          : (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              if (e.length > r)
                throw new Y({ size: e.length, targetSize: r, type: "bytes" });
              let i = new Uint8Array(r);
              for (let s = 0; s < r; s++) {
                let n = "right" === t;
                i[n ? s : r - s - 1] = e[n ? s : e.length - s - 1];
              }
              return i;
            })(e, { dir: t, size: r });
      }
      function Z(e) {
        return !(function (e, { strict: t = !0 } = {}) {
          return (
            !!e &&
            "string" == typeof e &&
            (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x"))
          );
        })(e, { strict: !1 })
          ? e.length
          : Math.ceil((e.length - 2) / 2);
      }
      function J(e, { size: t }) {
        if (Z(e) > t) throw new G({ givenSize: Z(e), maxSize: t });
      }
      let X = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function ee(e, t = {}) {
        return "number" == typeof e || "bigint" == typeof e
          ? (function (e, t = {}) {
              let r;
              let { signed: i, size: s } = t,
                n = BigInt(e);
              s
                ? (r = i
                    ? (1n << (8n * BigInt(s) - 1n)) - 1n
                    : 2n ** (8n * BigInt(s)) - 1n)
                : "number" == typeof e && (r = BigInt(Number.MAX_SAFE_INTEGER));
              let a = "bigint" == typeof r && i ? -r - 1n : 0;
              if ((r && n > r) || n < a) {
                let t = "bigint" == typeof e ? "n" : "";
                throw new K({
                  max: r ? `${r}${t}` : void 0,
                  min: `${a}${t}`,
                  signed: i,
                  size: s,
                  value: `${e}${t}`,
                });
              }
              let o = `0x${(i && n < 0
                ? (1n << BigInt(8 * s)) + BigInt(n)
                : n
              ).toString(16)}`;
              return s ? Q(o, { size: s }) : o;
            })(e, t)
          : "string" == typeof e
          ? (function (e, t = {}) {
              return et(er.encode(e), t);
            })(e, t)
          : "boolean" == typeof e
          ? (function (e, t = {}) {
              let r = `0x${Number(e)}`;
              return "number" == typeof t.size
                ? (J(r, { size: t.size }), Q(r, { size: t.size }))
                : r;
            })(e, t)
          : et(e, t);
      }
      function et(e, t = {}) {
        let r = "";
        for (let t = 0; t < e.length; t++) r += X[e[t]];
        let i = `0x${r}`;
        return "number" == typeof t.size
          ? (J(i, { size: t.size }), Q(i, { dir: "right", size: t.size }))
          : i;
      }
      let er = new TextEncoder();
      var ei = r(92302),
        es = r(10763),
        en = r(72557);
      class ea extends ei.X {
        setUniversalProvider(e) {
          this.addConnector(
            new es.F({
              provider: e,
              caipNetworks: this.caipNetworks || [],
              namespace: this.namespace,
            })
          );
        }
        async connect(e) {
          return Promise.resolve({
            id: "WALLET_CONNECT",
            type: "WALLET_CONNECT",
            chainId: Number(e.chainId),
            provider: this.provider,
            address: "",
          });
        }
        async disconnect() {
          try {
            let e = this.getWalletConnectConnector();
            await e.disconnect();
          } catch (e) {
            console.warn("UniversalAdapter:disconnect - error", e);
          }
        }
        async getAccounts({ namespace: e }) {
          let t = this.provider;
          return Promise.resolve({
            accounts: (
              t?.session?.namespaces?.[e]?.accounts
                ?.map((e) => {
                  let [, , t] = e.split(":");
                  return t;
                })
                .filter((e, t, r) => r.indexOf(e) === t) || []
            ).map((t) =>
              f.w.createAccount(e, t, "bip122" === e ? "payment" : "eoa")
            ),
          });
        }
        async syncConnectors() {
          return Promise.resolve();
        }
        async getBalance(e) {
          if (
            !(
              e.caipNetwork &&
              c.oU.BALANCE_SUPPORTED_CHAINS.includes(
                e.caipNetwork?.chainNamespace
              )
            ) ||
            e.caipNetwork?.testnet
          )
            return {
              balance: "0.00",
              symbol: e.caipNetwork?.nativeCurrency.symbol || "",
            };
          if (
            d.U.state.balanceLoading &&
            e.chainId === u.W.state.activeCaipNetwork?.id
          )
            return {
              balance: d.U.state.balance || "0.00",
              symbol: d.U.state.balanceSymbol || "",
            };
          let t = (await d.U.fetchTokenBalance()).find(
            (t) =>
              t.chainId === `${e.caipNetwork?.chainNamespace}:${e.chainId}` &&
              t.symbol === e.caipNetwork?.nativeCurrency.symbol
          );
          return {
            balance: t?.quantity.numeric || "0.00",
            symbol: t?.symbol || e.caipNetwork?.nativeCurrency.symbol || "",
          };
        }
        async signMessage(e) {
          let { provider: t, message: r, address: s } = e;
          if (!t)
            throw Error("UniversalAdapter:signMessage - provider is undefined");
          let n = "";
          return {
            signature:
              u.W.state.activeCaipNetwork?.chainNamespace === i.o.CHAIN.SOLANA
                ? (
                    await t.request(
                      {
                        method: "solana_signMessage",
                        params: {
                          message: W.A.encode(new TextEncoder().encode(r)),
                          pubkey: s,
                        },
                      },
                      u.W.state.activeCaipNetwork?.caipNetworkId
                    )
                  ).signature
                : await t.request(
                    { method: "personal_sign", params: [r, s] },
                    u.W.state.activeCaipNetwork?.caipNetworkId
                  ),
          };
        }
        async estimateGas() {
          return Promise.resolve({ gas: BigInt(0) });
        }
        async getProfile() {
          return Promise.resolve({ profileImage: "", profileName: "" });
        }
        async sendTransaction() {
          return Promise.resolve({ hash: "" });
        }
        walletGetAssets(e) {
          return Promise.resolve({});
        }
        async writeContract() {
          return Promise.resolve({ hash: "" });
        }
        async getEnsAddress() {
          return Promise.resolve({ address: !1 });
        }
        parseUnits() {
          return 0n;
        }
        formatUnits() {
          return "0";
        }
        async getCapabilities() {
          return Promise.resolve({});
        }
        async grantPermissions() {
          return Promise.resolve({});
        }
        async revokePermissions() {
          return Promise.resolve("0x");
        }
        async syncConnection() {
          return Promise.resolve({
            id: "WALLET_CONNECT",
            type: "WALLET_CONNECT",
            chainId: 1,
            provider: this.provider,
            address: "",
          });
        }
        async switchNetwork(e) {
          let { caipNetwork: t } = e,
            r = this.getWalletConnectConnector();
          if (t.chainNamespace === i.o.CHAIN.EVM)
            try {
              await r.provider?.request({
                method: "wallet_switchEthereumChain",
                params: [{ chainId: ee(t.id) }],
              });
            } catch (e) {
              if (
                e.code === en.E.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
                e.code === en.E.ERROR_INVALID_CHAIN_ID ||
                e.code === en.E.ERROR_CODE_DEFAULT ||
                e?.data?.originalError?.code ===
                  en.E.ERROR_CODE_UNRECOGNIZED_CHAIN_ID
              )
                try {
                  await r.provider?.request({
                    method: "wallet_addEthereumChain",
                    params: [
                      {
                        chainId: ee(t.id),
                        rpcUrls: [t?.rpcUrls.chainDefault?.http],
                        chainName: t.name,
                        nativeCurrency: t.nativeCurrency,
                        blockExplorerUrls: [t.blockExplorers?.default.url],
                      },
                    ],
                  });
                } catch (e) {
                  throw Error("Chain is not supported");
                }
            }
          r.provider.setDefaultChain(t.caipNetworkId);
        }
        getWalletConnectProvider() {
          let e = this.connectors.find((e) => "WALLET_CONNECT" === e.type);
          return e?.provider;
        }
      }
      var eo = r(94842);
      class ec {
        constructor(e) {
          (this.chainNamespaces = []),
            (this.reportedAlertErrors = {}),
            (this.getCaipNetwork = (e) => {
              if (e) {
                let t = u.W.getNetworkData(e)?.caipNetwork;
                return (
                  t ||
                  u.W.getRequestedCaipNetworks(e).filter(
                    (t) => t.chainNamespace === e
                  )?.[0]
                );
              }
              return u.W.state.activeCaipNetwork || this.defaultCaipNetwork;
            }),
            (this.getCaipNetworkId = () => {
              let e = this.getCaipNetwork();
              if (e) return e.id;
            }),
            (this.getCaipNetworks = (e) => u.W.getRequestedCaipNetworks(e)),
            (this.getActiveChainNamespace = () => u.W.state.activeChain),
            (this.setRequestedCaipNetworks = (e, t) => {
              u.W.setRequestedCaipNetworks(e, t);
            }),
            (this.getApprovedCaipNetworkIds = () =>
              u.W.getAllApprovedCaipNetworkIds()),
            (this.getCaipAddress = (e) =>
              u.W.state.activeChain !== e && e
                ? u.W.getAccountProp("caipAddress", e)
                : u.W.state.activeCaipAddress),
            (this.setClientId = (e) => {
              O.T.setClientId(e);
            }),
            (this.getProvider = (e) => C.getProvider(e)),
            (this.getProviderType = (e) => C.getProviderId(e)),
            (this.getPreferredAccountType = () =>
              d.U.state.preferredAccountType),
            (this.setCaipAddress = (e, t) => {
              d.U.setCaipAddress(e, t);
            }),
            (this.setBalance = (e, t, r) => {
              d.U.setBalance(e, t, r);
            }),
            (this.setProfileName = (e, t) => {
              d.U.setProfileName(e, t);
            }),
            (this.setProfileImage = (e, t) => {
              d.U.setProfileImage(e, t);
            }),
            (this.setUser = (e, t) => {
              d.U.setUser(e, t), h.H.state.enableEmbedded && k.W.close();
            }),
            (this.resetAccount = (e) => {
              d.U.resetAccount(e);
            }),
            (this.setCaipNetwork = (e) => {
              u.W.setActiveCaipNetwork(e);
            }),
            (this.setCaipNetworkOfNamespace = (e, t) => {
              u.W.setChainNetworkData(t, { caipNetwork: e });
            }),
            (this.setAllAccounts = (e, t) => {
              d.U.setAllAccounts(e, t),
                h.H.setHasMultipleAddresses(e?.length > 1);
            }),
            (this.setStatus = (e, t) => {
              d.U.setStatus(e, t),
                n.a.isConnected()
                  ? g.i.setConnectionStatus("connected")
                  : g.i.setConnectionStatus("disconnected");
            }),
            (this.getAddressByChainNamespace = (e) =>
              u.W.getAccountProp("address", e)),
            (this.setConnectors = (e) => {
              let t = [...n.a.getConnectors(), ...e];
              n.a.setConnectors(t);
            }),
            (this.fetchIdentity = (e) => O.T.fetchIdentity(e)),
            (this.getReownName = (e) => R.f.getNamesForAddress(e)),
            (this.getConnectors = () => n.a.getConnectors()),
            (this.getConnectorImage = (e) => D.$.getConnectorImage(e)),
            (this.setConnectedWalletInfo = (e, t) => {
              let r = C.getProviderId(t),
                i = e ? { ...e, type: r } : void 0;
              d.U.setConnectedWalletInfo(i, t);
            }),
            (this.getIsConnectedState = () => !!u.W.state.activeCaipAddress),
            (this.addAddressLabel = (e, t, r) => {
              d.U.addAddressLabel(e, t, r);
            }),
            (this.removeAddressLabel = (e, t) => {
              d.U.removeAddressLabel(e, t);
            }),
            (this.getAddress = (e) =>
              u.W.state.activeChain !== e && e
                ? u.W.getAccountProp("address", e)
                : d.U.state.address),
            (this.setApprovedCaipNetworksData = (e) =>
              u.W.setApprovedCaipNetworksData(e)),
            (this.resetNetwork = (e) => {
              u.W.resetNetwork(e);
            }),
            (this.addConnector = (e) => {
              n.a.addConnector(e);
            }),
            (this.resetWcConnection = () => {
              a.x.resetWcConnection();
            }),
            (this.setAddressExplorerUrl = (e, t) => {
              d.U.setAddressExplorerUrl(e, t);
            }),
            (this.setSmartAccountDeployed = (e, t) => {
              d.U.setSmartAccountDeployed(e, t);
            }),
            (this.setSmartAccountEnabledNetworks = (e, t) => {
              u.W.setSmartAccountEnabledNetworks(e, t);
            }),
            (this.setPreferredAccountType = (e, t) => {
              d.U.setPreferredAccountType(e, t);
            }),
            (this.setEIP6963Enabled = (e) => {
              h.H.setEIP6963Enabled(e);
            }),
            (this.handleUnsafeRPCRequest = () => {
              this.isOpen()
                ? !this.isTransactionStackEmpty() &&
                  this.redirect("ApproveTransaction")
                : this.open({ view: "ApproveTransaction" });
            }),
            (this.options = e),
            (this.version = e.sdkVersion),
            (this.caipNetworks = this.extendCaipNetworks(e)),
            (this.chainNamespaces = [
              ...new Set(this.caipNetworks?.map((e) => e.chainNamespace)),
            ]),
            (this.defaultCaipNetwork = this.extendDefaultCaipNetwork(e)),
            (this.chainAdapters = this.createAdapters(e.adapters)),
            this.initialize(e),
            this.sendInitializeEvent(e);
        }
        async initialize(e) {
          this.initControllers(e),
            await this.initChainAdapters(),
            await this.injectModalUi(),
            await this.syncExistingConnection(),
            M.z.set({ initialized: !0 });
        }
        sendInitializeEvent(e) {
          let { ...t } = e;
          delete t.adapters,
            o.E.sendEvent({
              type: "track",
              event: "INITIALIZE",
              properties: {
                ...t,
                networks: e.networks.map((e) => e.id),
                siweConfig: { options: e.siweConfig?.options || {} },
              },
            });
        }
        initControllers(e) {
          this.initializeOptionsController(e),
            this.initializeChainController(e),
            this.initializeThemeController(e),
            this.initializeConnectionController(e),
            this.initializeConnectorController();
        }
        initializeThemeController(e) {
          e.themeMode && p.W.setThemeMode(e.themeMode),
            e.themeVariables && p.W.setThemeVariables(e.themeVariables);
        }
        initializeChainController(e) {
          if (!this.connectionControllerClient || !this.networkControllerClient)
            throw Error(
              "ConnectionControllerClient and NetworkControllerClient must be set"
            );
          u.W.initialize(e.adapters ?? [], this.caipNetworks, {
            connectionControllerClient: this.connectionControllerClient,
            networkControllerClient: this.networkControllerClient,
          });
          let t = this.getDefaultNetwork();
          t && u.W.setActiveCaipNetwork(t);
        }
        initializeConnectionController(e) {
          a.x.setWcBasic(e.basic ?? !1);
        }
        initializeConnectorController() {
          n.a.initialize(this.chainNamespaces);
        }
        initializeOptionsController(e) {
          h.H.setDebug(!1 !== e.debug),
            h.H.setEnableWalletConnect(!1 !== e.enableWalletConnect),
            h.H.setEnableWalletGuide(!1 !== e.enableWalletGuide),
            h.H.setEnableWallets(!1 !== e.enableWallets),
            h.H.setEIP6963Enabled(!1 !== e.enableEIP6963),
            h.H.setEnableAuthLogger(!1 !== e.enableAuthLogger),
            h.H.setCustomRpcUrls(e.customRpcUrls),
            h.H.setSdkVersion(e.sdkVersion),
            h.H.setProjectId(e.projectId),
            h.H.setEnableEmbedded(e.enableEmbedded),
            h.H.setAllWallets(e.allWallets),
            h.H.setIncludeWalletIds(e.includeWalletIds),
            h.H.setExcludeWalletIds(e.excludeWalletIds),
            h.H.setFeaturedWalletIds(e.featuredWalletIds),
            h.H.setTokens(e.tokens),
            h.H.setTermsConditionsUrl(e.termsConditionsUrl),
            h.H.setPrivacyPolicyUrl(e.privacyPolicyUrl),
            h.H.setCustomWallets(e.customWallets),
            h.H.setFeatures(e.features),
            h.H.setAllowUnsupportedChain(e.allowUnsupportedChain),
            h.H.setDefaultAccountTypes(e.defaultAccountTypes);
          let t = this.getDefaultMetaData();
          if (
            (!e.metadata && t && (e.metadata = t),
            h.H.setMetadata(e.metadata),
            h.H.setDisableAppend(e.disableAppend),
            h.H.setEnableEmbedded(e.enableEmbedded),
            h.H.setSIWX(e.siwx),
            !e.projectId)
          ) {
            m.h.open(w.R.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
            return;
          }
          if (
            e.adapters?.find((e) => e.namespace === i.o.CHAIN.EVM) &&
            e.siweConfig
          ) {
            if (e.siwx)
              throw Error("Cannot set both `siweConfig` and `siwx` options");
            h.H.setSIWX(e.siweConfig.mapToSIWX());
          }
        }
        getDefaultMetaData() {
          return "undefined" != typeof window && "undefined" != typeof document
            ? {
                name:
                  document.getElementsByTagName("title")?.[0]?.textContent ||
                  "",
                description:
                  document.querySelector('meta[property="og:description"]')
                    ?.content || "",
                url: window.location.origin,
                icons: [
                  document.querySelector('link[rel~="icon"]')?.href || "",
                ],
              }
            : null;
        }
        getUnsupportedNetwork(e) {
          return {
            id: e.split(":")[1],
            caipNetworkId: e,
            name: i.o.UNSUPPORTED_NETWORK_NAME,
            chainNamespace: e.split(":")[0],
            nativeCurrency: { name: "", decimals: 0, symbol: "" },
            rpcUrls: { default: { http: [] } },
          };
        }
        setUnsupportedNetwork(e) {
          let t = this.getActiveChainNamespace();
          if (t) {
            let r = this.getUnsupportedNetwork(`${t}:${e}`);
            u.W.setActiveCaipNetwork(r);
          }
        }
        getDefaultNetwork() {
          let e = g.i.getActiveCaipNetworkId();
          if (e) {
            let t = this.caipNetworks?.find((t) => t.caipNetworkId === e);
            return (
              t ||
              (this.defaultCaipNetwork
                ? this.defaultCaipNetwork
                : this.getUnsupportedNetwork(e))
            );
          }
          return this.defaultCaipNetwork
            ? this.defaultCaipNetwork
            : this.caipNetworks?.[0];
        }
        extendCaipNetwork(e, t) {
          return F.R.extendCaipNetwork(e, {
            customNetworkImageUrls: t.chainImages,
            projectId: t.projectId,
          });
        }
        extendCaipNetworks(e) {
          return F.R.extendCaipNetworks(e.networks, {
            customNetworkImageUrls: e.chainImages,
            customRpcUrls: e.customRpcUrls,
            projectId: e.projectId,
          });
        }
        extendDefaultCaipNetwork(e) {
          let t = e.networks.find((t) => t.id === e.defaultNetwork?.id);
          return t
            ? F.R.extendCaipNetwork(t, {
                customNetworkImageUrls: e.chainImages,
                customRpcUrls: e.customRpcUrls,
                projectId: e.projectId,
              })
            : void 0;
        }
        createClients() {
          (this.connectionControllerClient = {
            connectWalletConnect: async () => {
              let e = u.W.state.activeChain,
                t = this.getAdapter(e),
                r = this.getCaipNetwork(e)?.id;
              if (!t) throw Error("Adapter not found");
              let i = await t.connectWalletConnect(r);
              this.close(),
                this.setClientId(i?.clientId || null),
                g.i.setConnectedNamespaces([...u.W.state.chains.keys()]),
                this.chainNamespaces.forEach((e) => {
                  n.a.setConnectorId(y.o.CONNECTOR_TYPE_WALLET_CONNECT, e);
                }),
                await this.syncWalletConnectAccount();
            },
            connectExternal: async ({
              id: e,
              info: t,
              type: r,
              provider: i,
              chain: s,
              caipNetwork: n,
            }) => {
              let a = u.W.state.activeChain,
                o = s || a,
                c = this.getAdapter(o);
              if (s && s !== a && !n) {
                let e = this.caipNetworks?.find((e) => e.chainNamespace === s);
                e && this.setCaipNetwork(e);
              }
              if (!c) throw Error("Adapter not found");
              let l = this.getCaipNetwork(o),
                d = await c.connect({
                  id: e,
                  info: t,
                  type: r,
                  provider: i,
                  chainId: n?.id || l?.id,
                  rpcUrl:
                    n?.rpcUrls?.default?.http?.[0] ||
                    l?.rpcUrls?.default?.http?.[0],
                });
              if (!d) return;
              g.i.addConnectedNamespace(o),
                this.syncProvider({ ...d, chainNamespace: o }),
                await this.syncAccount({ ...d, chainNamespace: o });
              let { accounts: h } = await c.getAccounts({
                namespace: o,
                id: e,
              });
              this.setAllAccounts(h, o);
            },
            reconnectExternal: async ({
              id: e,
              info: t,
              type: r,
              provider: i,
            }) => {
              let s = u.W.state.activeChain,
                n = this.getAdapter(s);
              n?.reconnect &&
                (await n?.reconnect({
                  id: e,
                  info: t,
                  type: r,
                  provider: i,
                  chainId: this.getCaipNetwork()?.id,
                }),
                g.i.addConnectedNamespace(s));
            },
            disconnect: async (e) => {
              let t = e || u.W.state.activeChain,
                r = this.getAdapter(t),
                i = C.getProvider(t),
                s = C.getProviderId(t);
              await r?.disconnect({ provider: i, providerType: s }),
                g.i.removeConnectedNamespace(t),
                C.resetChain(t),
                this.setUser(void 0, t),
                this.setStatus("disconnected", t);
            },
            checkInstalled: (e) =>
              e
                ? e.some((e) => !!window.ethereum?.[String(e)])
                : !!window.ethereum,
            signMessage: async (e) => {
              let t = this.getAdapter(u.W.state.activeChain),
                r = await t?.signMessage({
                  message: e,
                  address: d.U.state.address,
                  provider: C.getProvider(u.W.state.activeChain),
                });
              return r?.signature || "";
            },
            sendTransaction: async (e) => {
              if (e.chainNamespace === i.o.CHAIN.EVM) {
                let t = this.getAdapter(u.W.state.activeChain),
                  r = C.getProvider(u.W.state.activeChain),
                  i = await t?.sendTransaction({ ...e, provider: r });
                return i?.hash || "";
              }
              return "";
            },
            estimateGas: async (e) => {
              if (e.chainNamespace === i.o.CHAIN.EVM) {
                let t = this.getAdapter(u.W.state.activeChain),
                  r = C.getProvider(u.W.state.activeChain),
                  i = this.getCaipNetwork();
                if (!i) throw Error("CaipNetwork is undefined");
                let s = await t?.estimateGas({
                  ...e,
                  provider: r,
                  caipNetwork: i,
                });
                return s?.gas || 0n;
              }
              return 0n;
            },
            getEnsAvatar: async () => {
              let e = this.getAdapter(u.W.state.activeChain),
                t = await e?.getProfile({
                  address: d.U.state.address,
                  chainId: Number(this.getCaipNetwork()?.id),
                });
              return t?.profileImage || !1;
            },
            getEnsAddress: async (e) => {
              let t = this.getAdapter(u.W.state.activeChain),
                r = this.getCaipNetwork();
              if (!r) return !1;
              let i = await t?.getEnsAddress({ name: e, caipNetwork: r });
              return i?.address || !1;
            },
            writeContract: async (e) => {
              let t = this.getAdapter(u.W.state.activeChain),
                r = this.getCaipNetwork(),
                i = this.getCaipAddress(),
                s = C.getProvider(u.W.state.activeChain);
              if (!r || !i)
                throw Error("CaipNetwork or CaipAddress is undefined");
              let n = await t?.writeContract({
                ...e,
                caipNetwork: r,
                provider: s,
                caipAddress: i,
              });
              return n?.hash;
            },
            parseUnits: (e, t) => {
              let r = this.getAdapter(u.W.state.activeChain);
              return r?.parseUnits({ value: e, decimals: t }) ?? 0n;
            },
            formatUnits: (e, t) => {
              let r = this.getAdapter(u.W.state.activeChain);
              return r?.formatUnits({ value: e, decimals: t }) ?? "0";
            },
            getCapabilities: async (e) => {
              let t = this.getAdapter(u.W.state.activeChain);
              return await t?.getCapabilities(e);
            },
            grantPermissions: async (e) => {
              let t = this.getAdapter(u.W.state.activeChain);
              return await t?.grantPermissions(e);
            },
            revokePermissions: async (e) => {
              let t = this.getAdapter(u.W.state.activeChain);
              return t?.revokePermissions ? await t.revokePermissions(e) : "0x";
            },
            walletGetAssets: async (e) => {
              let t = this.getAdapter(u.W.state.activeChain);
              return (await t?.walletGetAssets(e)) ?? {};
            },
          }),
            (this.networkControllerClient = {
              switchCaipNetwork: async (e) => await this.switchCaipNetwork(e),
              getApprovedCaipNetworksData: async () =>
                this.getApprovedCaipNetworksData(),
            }),
            a.x.setClient(this.connectionControllerClient);
        }
        getApprovedCaipNetworksData() {
          if (
            C.getProviderId(u.W.state.activeChain) ===
            y.o.CONNECTOR_TYPE_WALLET_CONNECT
          ) {
            let e = this.universalProvider?.session?.namespaces;
            return {
              supportsAllNetworks:
                this.universalProvider?.session?.peer?.metadata.name ===
                "MetaMask Wallet",
              approvedCaipNetworkIds: this.getChainsFromNamespaces(e),
            };
          }
          return { supportsAllNetworks: !0, approvedCaipNetworkIds: [] };
        }
        async switchCaipNetwork(e) {
          if (!e) return;
          let t = e.chainNamespace;
          if (this.getAddressByChainNamespace(e.chainNamespace)) {
            let r = C.getProvider(t),
              i = C.getProviderId(t);
            if (e.chainNamespace === u.W.state.activeChain) {
              let s = this.getAdapter(t);
              await s?.switchNetwork({
                caipNetwork: e,
                provider: r,
                providerType: i,
              });
            } else if (
              (this.setCaipNetwork(e), i === y.o.CONNECTOR_TYPE_WALLET_CONNECT)
            )
              this.syncWalletConnectAccount();
            else {
              let r = this.getAddressByChainNamespace(t);
              r &&
                this.syncAccount({
                  address: r,
                  chainId: e.id,
                  chainNamespace: t,
                });
            }
          } else this.setCaipNetwork(e);
        }
        getChainsFromNamespaces(e = {}) {
          return Object.values(e).flatMap((e) =>
            Array.from(
              new Set([
                ...(e.chains || []),
                ...e.accounts.map((e) => {
                  let { chainId: t, chainNamespace: r } =
                    T.C.parseCaipAddress(e);
                  return `${r}:${t}`;
                }),
              ])
            )
          );
        }
        createAdapters(e) {
          return (
            this.createClients(),
            this.chainNamespaces.reduce((t, r) => {
              let i = e?.find((e) => e.namespace === r);
              return (
                i
                  ? ((t[r] = i),
                    (t[r].namespace = r),
                    t[r].construct({
                      namespace: r,
                      projectId: this.options?.projectId,
                      networks: this.caipNetworks,
                    }))
                  : (t[r] = new ea({
                      namespace: r,
                      networks: this.caipNetworks,
                    })),
                t
              );
            }, {})
          );
        }
        async initChainAdapter(e) {
          this.onConnectors(e),
            this.listenAdapter(e),
            this.chainAdapters?.[e].syncConnectors(this.options, this),
            await this.createUniversalProviderForAdapter(e);
        }
        async initChainAdapters() {
          await Promise.all(
            this.chainNamespaces.map(async (e) => {
              await this.initChainAdapter(e);
            })
          );
        }
        onConnectors(e) {
          let t = this.getAdapter(e);
          t?.on("connectors", this.setConnectors.bind(this));
        }
        listenAdapter(e) {
          let t = this.getAdapter(e);
          if (!t) return;
          let r = g.i.getConnectionStatus();
          "connected" === r
            ? this.setStatus("connecting", e)
            : ("disconnected" === r && g.i.clearAddressCache(),
              this.setStatus(r, e)),
            t.on("switchNetwork", ({ address: t, chainId: r }) => {
              let i = this.caipNetworks?.find(
                  (e) => e.id === r || e.caipNetworkId === r
                ),
                s = u.W.state.activeChain === e,
                n = u.W.getAccountProp("address", e);
              if (i) {
                let i = s && t ? t : n;
                i &&
                  this.syncAccount({
                    address: i,
                    chainId: r,
                    chainNamespace: e,
                  });
              } else this.setUnsupportedNetwork(r);
            }),
            t.on("disconnect", this.disconnect.bind(this, e)),
            t.on("pendingTransactions", () => {
              let e = d.U.state.address,
                t = u.W.state.activeCaipNetwork;
              e && t?.id && this.updateNativeBalance(e, t.id, t.chainNamespace);
            }),
            t.on("accountChanged", ({ address: t, chainId: r }) => {
              let i = u.W.state.activeChain === e;
              i && r
                ? this.syncAccount({
                    address: t,
                    chainId: r,
                    chainNamespace: e,
                  })
                : i && u.W.state.activeCaipNetwork?.id
                ? this.syncAccount({
                    address: t,
                    chainId: u.W.state.activeCaipNetwork?.id,
                    chainNamespace: e,
                  })
                : this.syncAccountInfo(t, r, e);
            });
        }
        async createUniversalProviderForAdapter(e) {
          await this.getUniversalProvider(),
            this.universalProvider &&
              this.chainAdapters?.[e]?.setUniversalProvider?.(
                this.universalProvider
              );
        }
        async syncExistingConnection() {
          await Promise.allSettled(
            this.chainNamespaces.map((e) => this.syncNamespaceConnection(e))
          );
        }
        async syncNamespaceConnection(e) {
          try {
            let t = n.a.getConnectorId(e);
            switch ((this.setStatus("connecting", e), t)) {
              case i.o.CONNECTOR_ID.WALLET_CONNECT:
                await this.syncWalletConnectAccount();
                break;
              case i.o.CONNECTOR_ID.AUTH:
                break;
              default:
                await this.syncAdapterConnection(e);
            }
          } catch (t) {
            console.warn("AppKit couldn't sync existing connection", t),
              this.setStatus("disconnected", e);
          }
        }
        async syncAdapterConnection(e) {
          let t = this.getAdapter(e),
            r = n.a.getConnectorId(e),
            i = this.getCaipNetwork(e),
            s = n.a.getConnectors(e).find((e) => e.id === r);
          try {
            if (!t || !s)
              throw Error(`Adapter or connector not found for namespace ${e}`);
            if (!i?.id) throw Error("CaipNetwork not found");
            let r = await t?.syncConnection({
              namespace: e,
              id: s.id,
              chainId: i.id,
              rpcUrl: i?.rpcUrls?.default?.http?.[0],
            });
            if (r) {
              let i = await t?.getAccounts({ namespace: e, id: s.id });
              i && i.accounts.length > 0
                ? this.setAllAccounts(i.accounts, e)
                : this.setAllAccounts(
                    [f.w.createAccount(e, r.address, "eoa")],
                    e
                  ),
                this.syncProvider({ ...r, chainNamespace: e }),
                await this.syncAccount({ ...r, chainNamespace: e }),
                this.setStatus("connected", e);
            } else this.setStatus("disconnected", e);
          } catch (t) {
            this.setStatus("disconnected", e);
          }
        }
        async syncWalletConnectAccount() {
          let e = this.chainNamespaces.map(async (e) => {
            let t = this.getAdapter(e),
              r =
                this.universalProvider?.session?.namespaces?.[e]?.accounts ||
                [],
              s = u.W.state.activeCaipNetwork?.id,
              a =
                r.find((e) => {
                  let { chainId: t } = T.C.parseCaipAddress(e);
                  return t === s?.toString();
                }) || r[0];
            if (a) {
              let r = T.C.validateCaipAddress(a),
                { chainId: s, address: o } = T.C.parseCaipAddress(r);
              if (
                (C.setProviderId(e, y.o.CONNECTOR_TYPE_WALLET_CONNECT),
                this.caipNetworks &&
                  u.W.state.activeCaipNetwork &&
                  t?.namespace !== i.o.CHAIN.EVM)
              ) {
                let r = t?.getWalletConnectProvider({
                  caipNetworks: this.caipNetworks,
                  provider: this.universalProvider,
                  activeCaipNetwork: u.W.state.activeCaipNetwork,
                });
                C.setProvider(e, r);
              } else C.setProvider(e, this.universalProvider);
              n.a.setConnectorId(i.o.CONNECTOR_ID.WALLET_CONNECT, e),
                g.i.addConnectedNamespace(e),
                this.syncWalletConnectAccounts(e),
                await this.syncAccount({
                  address: o,
                  chainId: s,
                  chainNamespace: e,
                });
            } else this.setStatus("disconnected", e);
            await u.W.setApprovedCaipNetworksData(e);
          });
          await Promise.all(e);
        }
        syncWalletConnectAccounts(e) {
          let t = this.universalProvider?.session?.namespaces?.[e]?.accounts
            ?.map((e) => {
              let { address: t } = T.C.parseCaipAddress(e);
              return t;
            })
            .filter((e, t, r) => r.indexOf(e) === t);
          t &&
            this.setAllAccounts(
              t.map((t) =>
                f.w.createAccount(e, t, "bip122" === e ? "payment" : "eoa")
              ),
              e
            );
        }
        syncProvider({ type: e, provider: t, id: r, chainNamespace: i }) {
          C.setProviderId(i, e), C.setProvider(i, t), n.a.setConnectorId(r, i);
        }
        async syncAccount(e) {
          let t = e.chainNamespace === u.W.state.activeChain,
            r = u.W.getCaipNetworkByNamespace(e.chainNamespace, e.chainId),
            { address: s, chainId: n, chainNamespace: a } = e,
            { chainId: o } = g.i.getActiveNetworkProps(),
            c = n || o,
            l =
              u.W.state.activeCaipNetwork?.name ===
              i.o.UNSUPPORTED_NETWORK_NAME,
            f = u.W.getNetworkProp("supportsAllNetworks", a);
          if ((this.setStatus("connected", a), (!l || f) && c)) {
            let e = this.caipNetworks?.find(
                (e) => e.id.toString() === c.toString()
              ),
              n = this.caipNetworks?.find((e) => e.chainNamespace === a);
            if (!f && !e && !n) {
              let t = this.getApprovedCaipNetworkIds() || [],
                r = t.find(
                  (e) => T.C.parseCaipNetworkId(e)?.chainId === c.toString()
                ),
                i = t.find(
                  (e) => T.C.parseCaipNetworkId(e)?.chainNamespace === a
                );
              (e = this.caipNetworks?.find((e) => e.caipNetworkId === r)),
                (n = this.caipNetworks?.find(
                  (e) =>
                    e.caipNetworkId === i ||
                    ("deprecatedCaipNetworkId" in e &&
                      e.deprecatedCaipNetworkId === i)
                ));
            }
            let o = e || n;
            o?.chainNamespace === u.W.state.activeChain
              ? h.H.state.allowUnsupportedChain ||
                u.W.state.activeCaipNetwork?.name !==
                  i.o.UNSUPPORTED_NETWORK_NAME
                ? this.setCaipNetwork(o)
                : u.W.showUnsupportedChainUI()
              : !t && r && this.setCaipNetworkOfNamespace(r, a),
              this.syncConnectedWalletInfo(a),
              b.y.isLowerCaseMatch(s, d.U.state.address) ||
                this.syncAccountInfo(s, o?.id, a),
              t
                ? await this.syncBalance({
                    address: s,
                    chainId: o?.id,
                    chainNamespace: a,
                  })
                : await this.syncBalance({
                    address: s,
                    chainId: r?.id,
                    chainNamespace: a,
                  });
          }
        }
        async syncAccountInfo(e, t, r) {
          let i = this.getCaipAddress(r),
            s = t || i?.split(":")[1];
          if (!s) return;
          let n = `${r}:${s}:${e}`;
          this.setCaipAddress(n, r),
            await this.syncIdentity({
              address: e,
              chainId: s,
              chainNamespace: r,
            });
        }
        async syncReownName(e, t) {
          try {
            let r = await this.getReownName(e);
            if (r[0]) {
              let e = r[0];
              this.setProfileName(e.name, t);
            } else this.setProfileName(null, t);
          } catch {
            this.setProfileName(null, t);
          }
        }
        syncConnectedWalletInfo(e) {
          let t = n.a.getConnectorId(e),
            r = C.getProviderId(e);
          if (
            r === y.o.CONNECTOR_TYPE_ANNOUNCED ||
            r === y.o.CONNECTOR_TYPE_INJECTED
          ) {
            if (t) {
              let r = this.getConnectors().find((e) => e.id === t);
              if (r) {
                let { info: t, name: i, imageUrl: s } = r,
                  n = s || this.getConnectorImage(r);
                this.setConnectedWalletInfo({ name: i, icon: n, ...t }, e);
              }
            }
          } else if (r === y.o.CONNECTOR_TYPE_WALLET_CONNECT) {
            let t = C.getProvider(e);
            t?.session &&
              this.setConnectedWalletInfo(
                {
                  ...t.session.peer.metadata,
                  name: t.session.peer.metadata.name,
                  icon: t.session.peer.metadata.icons?.[0],
                },
                e
              );
          } else if (t) {
            if (t === i.o.CONNECTOR_ID.COINBASE) {
              let t = this.getConnectors().find(
                (e) => e.id === i.o.CONNECTOR_ID.COINBASE
              );
              this.setConnectedWalletInfo(
                { name: "Coinbase Wallet", icon: this.getConnectorImage(t) },
                e
              );
            } else this.setConnectedWalletInfo({ name: t }, e);
          }
        }
        async syncBalance(e) {
          P.L.getNetworksByNamespace(this.caipNetworks, e.chainNamespace).find(
            (t) => t.id.toString() === e.chainId?.toString()
          ) &&
            e.chainId &&
            (await this.updateNativeBalance(
              e.address,
              e.chainId,
              e.chainNamespace
            ));
        }
        async updateNativeBalance(e, t, r) {
          let i = this.getAdapter(r);
          if (i) {
            let s = await i.getBalance({
              address: e,
              chainId: t,
              caipNetwork: this.getCaipNetwork(r),
              tokens: this.options.tokens,
            });
            this.setBalance(s.balance, s.symbol, r);
          }
        }
        async initializeUniversalAdapter() {
          let e = z.createLogger((e, ...t) => {
              e && this.handleAlertError(e), console.error(...t);
            }),
            t = {
              projectId: this.options?.projectId,
              metadata: {
                name: this.options?.metadata ? this.options?.metadata.name : "",
                description: this.options?.metadata
                  ? this.options?.metadata.description
                  : "",
                url: this.options?.metadata ? this.options?.metadata.url : "",
                icons: this.options?.metadata
                  ? this.options?.metadata.icons
                  : [""],
              },
              logger: e,
            };
          h.H.setManualWCControl(!!this.options?.manualWCControl),
            (this.universalProvider =
              this.options.universalProvider ?? (await N.A.init(t))),
            this.listenWalletConnect();
        }
        listenWalletConnect() {
          this.universalProvider &&
            (this.universalProvider.on("display_uri", (e) => {
              a.x.setUri(e);
            }),
            this.universalProvider.on("connect", a.x.finalizeWcConnection),
            this.universalProvider.on("disconnect", () => {
              this.chainNamespaces.forEach((e) => {
                this.resetAccount(e);
              }),
                a.x.resetWcConnection();
            }),
            this.universalProvider.on("chainChanged", (e) => {
              let t = this.caipNetworks?.find((t) => t.id == e),
                r = this.getCaipNetwork();
              if (!t) {
                this.setUnsupportedNetwork(e);
                return;
              }
              r?.id !== t?.id && this.setCaipNetwork(t);
            }),
            this.universalProvider.on("session_event", (e) => {
              if (eo.k.isSessionEventData(e)) {
                let { name: t, data: r } = e.params.event;
                "accountsChanged" === t &&
                  Array.isArray(r) &&
                  f.w.isCaipAddress(r[0]) &&
                  this.syncAccount(T.C.parseCaipAddress(r[0]));
              }
            }));
        }
        createUniversalProvider() {
          return (
            !this.universalProviderInitPromise &&
              f.w.isClient() &&
              this.options?.projectId &&
              (this.universalProviderInitPromise =
                this.initializeUniversalAdapter()),
            this.universalProviderInitPromise
          );
        }
        async getUniversalProvider() {
          if (!this.universalProvider)
            try {
              await this.createUniversalProvider();
            } catch (e) {
              throw Error(
                "AppKit:getUniversalProvider - Cannot create provider"
              );
            }
          return this.universalProvider;
        }
        handleAlertError(e) {
          let [t, r] =
              Object.entries(w.R.UniversalProviderErrors).find(
                ([, { message: t }]) => e.message.includes(t)
              ) ?? [],
            { message: i, alertErrorKey: s } = r ?? {};
          if (t && i && !this.reportedAlertErrors[t]) {
            let e = w.R.ALERT_ERRORS[s];
            e && (m.h.open(e, "error"), (this.reportedAlertErrors[t] = !0));
          }
        }
        getAdapter(e) {
          if (e) return this.chainAdapters?.[e];
        }
        createAdapter(e) {
          if (!e) return;
          let t = e.namespace;
          t &&
            (this.createClients(),
            (e.namespace = t),
            e.construct({
              namespace: t,
              projectId: this.options?.projectId,
              networks: this.caipNetworks,
            }),
            this.chainNamespaces.includes(t) || this.chainNamespaces.push(t),
            this.chainAdapters && (this.chainAdapters[t] = e));
        }
        async open(e) {
          await this.injectModalUi(),
            e?.uri && a.x.setUri(e.uri),
            await k.W.open(e);
        }
        async close() {
          await this.injectModalUi(), k.W.close();
        }
        setLoading(e, t) {
          k.W.setLoading(e, t);
        }
        async disconnect(e) {
          await a.x.disconnect(e);
        }
        getError() {
          return "";
        }
        getChainId() {
          return u.W.state.activeCaipNetwork?.id;
        }
        async switchNetwork(e) {
          let t = this.caipNetworks?.find((t) => t.id === e.id);
          if (!t) {
            m.h.open(w.R.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
            return;
          }
          await u.W.switchActiveNetwork(t);
        }
        getWalletProvider() {
          return u.W.state.activeChain
            ? C.state.providers[u.W.state.activeChain]
            : null;
        }
        getWalletProviderType() {
          return C.getProviderId(u.W.state.activeChain);
        }
        subscribeProviders(e) {
          return C.subscribeProviders(e);
        }
        getThemeMode() {
          return p.W.state.themeMode;
        }
        getThemeVariables() {
          return p.W.state.themeVariables;
        }
        setThemeMode(e) {
          p.W.setThemeMode(e), (0, j.JX)(p.W.state.themeMode);
        }
        setTermsConditionsUrl(e) {
          h.H.setTermsConditionsUrl(e);
        }
        setPrivacyPolicyUrl(e) {
          h.H.setPrivacyPolicyUrl(e);
        }
        setThemeVariables(e) {
          p.W.setThemeVariables(e), (0, j.ds)(p.W.state.themeVariables);
        }
        subscribeTheme(e) {
          return p.W.subscribe(e);
        }
        getWalletInfo() {
          return d.U.state.connectedWalletInfo;
        }
        getAccount(e) {
          let t = n.a.getAuthConnector(e),
            r = u.W.getAccountData(e);
          if (r)
            return {
              allAccounts: r.allAccounts,
              caipAddress: r.caipAddress,
              address: f.w.getPlainAddress(r.caipAddress),
              isConnected: !!r.caipAddress,
              status: r.status,
              embeddedWalletInfo: t
                ? {
                    user: r.user,
                    authProvider: r.socialProvider || "email",
                    accountType: r.preferredAccountType,
                    isSmartAccountDeployed: !!r.smartAccountDeployed,
                  }
                : void 0,
            };
        }
        subscribeAccount(e, t) {
          let r = () => {
            let r = this.getAccount(t);
            r && e(r);
          };
          t ? u.W.subscribeChainProp("accountState", r, t) : u.W.subscribe(r),
            n.a.subscribe(r);
        }
        subscribeNetwork(e) {
          return u.W.subscribe(({ activeCaipNetwork: t }) => {
            e({
              caipNetwork: t,
              chainId: t?.id,
              caipNetworkId: t?.caipNetworkId,
            });
          });
        }
        subscribeWalletInfo(e) {
          return d.U.subscribeKey("connectedWalletInfo", e);
        }
        subscribeShouldUpdateToAddress(e) {
          d.U.subscribeKey("shouldUpdateToAddress", e);
        }
        subscribeCaipNetworkChange(e) {
          u.W.subscribeKey("activeCaipNetwork", e);
        }
        getState() {
          return M.z.state;
        }
        subscribeState(e) {
          return M.z.subscribe(e);
        }
        showErrorMessage(e) {
          U.P.showError(e);
        }
        showSuccessMessage(e) {
          U.P.showSuccess(e);
        }
        getEvent() {
          return { ...o.E.state };
        }
        subscribeEvents(e) {
          return o.E.subscribe(e);
        }
        replace(e) {
          L.I.replace(e);
        }
        redirect(e) {
          L.I.push(e);
        }
        popTransactionStack(e) {
          L.I.popTransactionStack(e);
        }
        isOpen() {
          return k.W.state.open;
        }
        isTransactionStackEmpty() {
          return 0 === L.I.state.transactionStack.length;
        }
        isTransactionShouldReplaceView() {
          return L.I.state.transactionStack[
            L.I.state.transactionStack.length - 1
          ]?.replace;
        }
        static getInstance() {
          return this.instance;
        }
        updateFeatures(e) {
          h.H.setFeatures(e);
        }
        updateOptions(e) {
          let t = { ...(h.H.state || {}), ...e };
          h.H.setOptions(t);
        }
        setConnectMethodsOrder(e) {
          h.H.setConnectMethodsOrder(e);
        }
        setWalletFeaturesOrder(e) {
          h.H.setWalletFeaturesOrder(e);
        }
        setCollapseWallets(e) {
          h.H.setCollapseWallets(e);
        }
        setSocialsOrder(e) {
          h.H.setSocialsOrder(e);
        }
        getConnectMethodsOrder() {
          return B.A.getConnectOrderMethod(
            h.H.state.features,
            n.a.getConnectors()
          );
        }
        removeAdapter(e) {
          let t = this.getIsConnectedState(),
            r = this.getAdapter(e);
          if (!r || !this.chainAdapters || t) return;
          let i = this.caipNetworks?.filter((t) => t.chainNamespace !== e);
          u.W.removeAdapter(e),
            n.a.removeAdapter(e),
            (this.chainNamespaces = this.chainNamespaces.filter(
              (t) => t !== e
            )),
            (this.caipNetworks = i),
            r.removeAllEventListeners(),
            Reflect.deleteProperty(this.chainAdapters, e);
        }
        addAdapter(e, t) {
          let r = e.namespace;
          if (
            !this.connectionControllerClient ||
            !this.networkControllerClient ||
            !this.chainAdapters ||
            !r
          )
            return;
          let i = this.extendCaipNetworks({ ...this.options, networks: t });
          (this.caipNetworks = [...(this.caipNetworks || []), ...i]),
            this.createAdapter(e),
            this.initChainAdapter(r),
            u.W.addAdapter(
              e,
              {
                connectionControllerClient: this.connectionControllerClient,
                networkControllerClient: this.networkControllerClient,
              },
              i
            );
        }
        addNetwork(e, t) {
          if (this.chainAdapters && !this.chainAdapters[e])
            throw Error(`Adapter for namespace ${e} doesn't exist`);
          let r = this.extendCaipNetwork(t, this.options);
          u.W.addNetwork(r),
            this.caipNetworks &&
              !this.caipNetworks?.find((e) => e.id === r.id) &&
              this.caipNetworks.push(r);
        }
        removeNetwork(e, t) {
          if (this.chainAdapters && !this.chainAdapters[e])
            throw Error(`Adapter for namespace ${e} doesn't exist`);
          if (!this.caipNetworks?.find((e) => e.id === t))
            throw Error(`Network with ID ${t} not found`);
          if (!this.caipNetworks) return;
          let r = this.caipNetworks.filter(
            (r) => r.chainNamespace === e && r.id !== t
          );
          if (!r?.length)
            throw Error("Cannot remove last network for a namespace");
          u.W.removeNetwork(e, t), (this.caipNetworks = [...r]);
        }
      }
      let el = !1;
      class ed extends ec {
        setupAuthConnectorListeners(e) {
          e.onRpcRequest((t) => {
            I.Q.checkIfRequestExists(t)
              ? I.Q.checkIfRequestIsSafe(t) || this.handleUnsafeRPCRequest()
              : (this.open(),
                console.error(S.Vl.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
                  method: t.method,
                }),
                setTimeout(() => {
                  this.showErrorMessage(S.Vl.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
                }, 300),
                e.rejectRpcRequests());
          }),
            e.onRpcError(() => {
              this.isOpen() &&
                (this.isTransactionStackEmpty()
                  ? this.close()
                  : this.popTransactionStack(!0));
            }),
            e.onRpcSuccess((e, t) => {
              let r = I.Q.checkIfRequestIsSafe(t),
                i = d.U.state.address,
                s = u.W.state.activeCaipNetwork;
              !r &&
                (this.isTransactionStackEmpty()
                  ? this.close()
                  : this.popTransactionStack(),
                i &&
                  s?.id &&
                  this.updateNativeBalance(i, s.id, s.chainNamespace));
            }),
            e.onNotConnected(() => {
              let e = u.W.state.activeChain;
              n.a.getConnectorId(e) === i.o.CONNECTOR_ID.AUTH &&
                (this.setCaipAddress(void 0, e), this.setLoading(!1, e));
            }),
            e.onConnect(async (t) => {
              let r = u.W.state.activeChain,
                s =
                  r === i.o.CHAIN.EVM
                    ? `eip155:${t.chainId}:${t.address}`
                    : `${t.chainId}:${t.address}`;
              this.setSmartAccountDeployed(!!t.smartAccountDeployed, r),
                b.y.isLowerCaseMatch(t.address, d.U.state.address) ||
                  this.syncIdentity({
                    address: t.address,
                    chainId: t.chainId,
                    chainNamespace: r,
                  }),
                this.setCaipAddress(s, r),
                this.setUser({ ...(d.U.state.user || {}), email: t.email }, r);
              let n =
                t.preferredAccountType || h.H.state.defaultAccountTypes[r];
              this.setPreferredAccountType(n, r);
              let a = t.accounts?.map((e) =>
                f.w.createAccount(
                  r,
                  e.address,
                  e.type || h.H.state.defaultAccountTypes[r]
                )
              );
              this.setAllAccounts(a || [f.w.createAccount(r, t.address, n)], r),
                await e.getSmartAccountEnabledNetworks(),
                this.setLoading(!1, r);
            }),
            e.onSocialConnected(({ userName: e }) => {
              this.setUser(
                { ...(d.U.state.user || {}), username: e },
                u.W.state.activeChain
              );
            }),
            e.onGetSmartAccountEnabledNetworks((e) => {
              this.setSmartAccountEnabledNetworks(e, u.W.state.activeChain);
            }),
            e.onSetPreferredAccount(({ address: e, type: t }) => {
              e && this.setPreferredAccountType(t, u.W.state.activeChain);
            });
        }
        async syncAuthConnector(e, t) {
          let r = i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(t);
          if (!r) return;
          this.setLoading(!0, t);
          let a = e.getLoginEmailUsed();
          this.setLoading(a, t), a && this.setStatus("connecting", t);
          let o = e.getEmail(),
            c = e.getUsername();
          this.setUser(
            { ...(d.U.state?.user || {}), username: c, email: o },
            u.W.state.activeChain
          ),
            this.setupAuthConnectorListeners(e);
          let { isConnected: l } = await e.isConnected(),
            f = p.W.getSnapshot(),
            m = h.H.getSnapshot();
          e.syncDappData({
            metadata: m.metadata,
            sdkVersion: m.sdkVersion,
            projectId: m.projectId,
            sdkType: m.sdkType,
          }),
            e.syncTheme({
              themeMode: f.themeMode,
              themeVariables: f.themeVariables,
              w3mThemeVariables: (0, s.o)(f.themeVariables, f.themeMode),
            }),
            t &&
              r &&
              (l && this.connectionControllerClient?.connectExternal
                ? (await this.connectionControllerClient?.connectExternal({
                    id: i.o.CONNECTOR_ID.AUTH,
                    info: { name: i.o.CONNECTOR_ID.AUTH },
                    type: y.o.CONNECTOR_TYPE_AUTH,
                    provider: e,
                    chainId: u.W.state.activeCaipNetwork?.id,
                    chain: t,
                  }),
                  this.setStatus("connected", t))
                : n.a.getConnectorId(t) === i.o.CONNECTOR_ID.AUTH &&
                  (this.setStatus("disconnected", t),
                  g.i.removeConnectedNamespace(t))),
            this.setLoading(!1, t);
        }
        async checkExistingTelegramSocialConnection(e) {
          try {
            if (!f.w.isTelegram()) return;
            let t = g.i.getTelegramSocialProvider();
            if (
              !t ||
              "undefined" == typeof window ||
              "undefined" == typeof document
            )
              return;
            let r = new URL(window.location.href).searchParams.get(
              "result_uri"
            );
            if (!r) return;
            d.U.setSocialProvider(t, e), await this.authProvider?.init();
            let i = n.a.getAuthConnector();
            t &&
              i &&
              (this.setLoading(!0, e),
              await i.provider.connectSocial(r),
              await a.x.connectExternal(i, i.chain),
              g.i.setConnectedSocialProvider(t),
              g.i.removeTelegramSocialProvider(),
              o.E.sendEvent({
                type: "track",
                event: "SOCIAL_LOGIN_SUCCESS",
                properties: { provider: t },
              }));
          } catch (t) {
            this.setLoading(!1, e),
              console.error("checkExistingSTelegramocialConnection error", t);
          }
          try {
            let e = new URL(window.location.href);
            e.searchParams.delete("result_uri"),
              window.history.replaceState({}, document.title, e.toString());
          } catch (e) {
            console.error("tma social login failed", e);
          }
        }
        createAuthProvider(e) {
          if (!i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(e)) return;
          let t =
              this.options?.features?.email === void 0
                ? c.oU.DEFAULT_FEATURES.email
                : this.options?.features?.email,
            r = this.options?.features?.socials
              ? this.options?.features?.socials?.length > 0
              : c.oU.DEFAULT_FEATURES.socials;
          !this.authProvider &&
            this.options?.projectId &&
            (t || r) &&
            ((this.authProvider = x.v.getInstance({
              projectId: this.options.projectId,
              enableLogger: this.options.enableAuthLogger,
              chainId: this.getCaipNetwork(e)?.caipNetworkId,
              onTimeout: () => {
                m.h.open(w.R.ALERT_ERRORS.SOCIALS_TIMEOUT, "error");
              },
            })),
            this.subscribeState((e) => {
              e.open || this.authProvider?.rejectRpcRequests();
            }),
            this.syncAuthConnector(this.authProvider, e),
            this.checkExistingTelegramSocialConnection(e));
        }
        createAuthProviderForAdapter(e) {
          this.createAuthProvider(e),
            this.authProvider &&
              this.chainAdapters?.[e]?.setAuthProvider?.(this.authProvider);
        }
        initControllers(e) {
          super.initControllers(e),
            this.options.excludeWalletIds &&
              l.N.initializeExcludedWalletRdns({
                ids: this.options.excludeWalletIds,
              });
        }
        async switchCaipNetwork(e) {
          if (!e) return;
          let t = u.W.state.activeChain,
            r = e.chainNamespace,
            s = this.getAddressByChainNamespace(e.chainNamespace);
          if (e.chainNamespace === u.W.state.activeChain && s) {
            let t = this.getAdapter(r),
              i = C.getProvider(r),
              s = C.getProviderId(r);
            await t?.switchNetwork({
              caipNetwork: e,
              provider: i,
              providerType: s,
            }),
              this.setCaipNetwork(e);
          } else {
            let n = C.getProviderId(t) === y.o.CONNECTOR_TYPE_AUTH,
              a = C.getProviderId(r),
              o = a === y.o.CONNECTOR_TYPE_AUTH,
              c = i.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(r);
            if ((n || o) && c)
              try {
                (u.W.state.activeChain = e.chainNamespace),
                  await this.connectionControllerClient?.connectExternal?.({
                    id: i.o.CONNECTOR_ID.AUTH,
                    provider: this.authProvider,
                    chain: r,
                    chainId: e.id,
                    type: y.o.CONNECTOR_TYPE_AUTH,
                    caipNetwork: e,
                  }),
                  this.setCaipNetwork(e);
              } catch (i) {
                let t = this.getAdapter(r);
                await t?.switchNetwork({
                  caipNetwork: e,
                  provider: this.authProvider,
                  providerType: a,
                });
              }
            else
              a === y.o.CONNECTOR_TYPE_WALLET_CONNECT
                ? (this.setCaipNetwork(e), this.syncWalletConnectAccount())
                : (this.setCaipNetwork(e),
                  s &&
                    this.syncAccount({
                      address: s,
                      chainId: e.id,
                      chainNamespace: r,
                    }));
          }
        }
        async initChainAdapter(e) {
          await super.initChainAdapter(e), this.createAuthProviderForAdapter(e);
        }
        async syncIdentity({ address: e, chainId: t, chainNamespace: r }) {
          let s = `${r}:${t}`,
            n = this.caipNetworks?.find((e) => e.caipNetworkId === s);
          if (r !== i.o.CHAIN.EVM || n?.testnet) {
            this.setProfileName(null, r), this.setProfileImage(null, r);
            return;
          }
          try {
            let { name: i, avatar: n } = await this.fetchIdentity({
              address: e,
              caipNetworkId: s,
            });
            if ((this.setProfileName(i, r), this.setProfileImage(n, r), !i)) {
              let i = this.getAdapter(r),
                s = await i?.getProfile({ address: e, chainId: Number(t) });
              s?.profileName
                ? (this.setProfileName(s.profileName, r),
                  s.profileImage && this.setProfileImage(s.profileImage, r))
                : (await this.syncReownName(e, r),
                  this.setProfileImage(null, r));
            }
          } catch {
            await this.syncReownName(e, r),
              1 !== t && this.setProfileImage(null, r);
          }
        }
        syncConnectedWalletInfo(e) {
          let t = C.getProviderId(e);
          if (t === y.o.CONNECTOR_TYPE_AUTH) {
            let r = this.authProvider;
            if (r) {
              let i = g.i.getConnectedSocialProvider() ?? "email",
                s = r.getEmail() ?? r.getUsername();
              this.setConnectedWalletInfo(
                { name: t, identifier: s, social: i },
                e
              );
            }
          } else super.syncConnectedWalletInfo(e);
        }
        async injectModalUi() {
          if (!el && f.w.isClient()) {
            let e = { ...c.oU.DEFAULT_FEATURES, ...this.options.features },
              t = [];
            if (
              (e &&
                ((e.email || (e.socials && e.socials.length)) &&
                  t.push(
                    Promise.all([r.e(3776), r.e(8380), r.e(7389)]).then(
                      r.bind(r, 47389)
                    )
                  ),
                e.email &&
                  t.push(
                    Promise.all([r.e(3776), r.e(8380), r.e(7352)]).then(
                      r.bind(r, 74971)
                    )
                  ),
                e.socials &&
                  t.push(
                    Promise.all([
                      r.e(3776),
                      r.e(8380),
                      r.e(2769),
                      r.e(7723),
                      r.e(1925),
                      r.e(2170),
                    ]).then(r.bind(r, 92170))
                  ),
                e.swaps &&
                  t.push(
                    Promise.all([r.e(3776), r.e(8380), r.e(9246)]).then(
                      r.bind(r, 79246)
                    )
                  ),
                e.send &&
                  t.push(
                    Promise.all([r.e(3776), r.e(8380), r.e(9902)]).then(
                      r.bind(r, 39902)
                    )
                  ),
                e.receive &&
                  t.push(
                    Promise.all([r.e(3776), r.e(2769), r.e(2435)]).then(
                      r.bind(r, 20026)
                    )
                  ),
                e.onramp &&
                  t.push(
                    Promise.all([
                      r.e(3776),
                      r.e(8380),
                      r.e(7723),
                      r.e(3290),
                      r.e(8504),
                    ]).then(r.bind(r, 88504))
                  ),
                e.history &&
                  t.push(
                    Promise.all([r.e(3776), r.e(4790), r.e(5565)]).then(
                      r.bind(r, 20840)
                    )
                  )),
              await Promise.all([
                ...t,
                Promise.all([
                  r.e(3776),
                  r.e(8380),
                  r.e(2769),
                  r.e(7723),
                  r.e(3290),
                  r.e(4790),
                  r.e(1925),
                  r.e(4204),
                  r.e(2158),
                ]).then(r.bind(r, 52158)),
                Promise.all([r.e(3776), r.e(4204), r.e(1613)]).then(
                  r.bind(r, 92169)
                ),
              ]),
              !document.querySelector("w3m-modal"))
            ) {
              let e = document.createElement("w3m-modal");
              h.H.state.disableAppend ||
                h.H.state.enableEmbedded ||
                document.body.insertAdjacentElement("beforeend", e);
            }
            el = !0;
          }
        }
      }
    },
    43757: (e, t, r) => {
      "use strict";
      (t.version = r(14537).rE),
        (t.utils = r(78239)),
        (t.rand = r(66725)),
        (t.curve = r(23750)),
        (t.curves = r(13798)),
        (t.ec = r(82965)),
        (t.eddsa = r(10562));
    },
    43770: (e) => {
      "function" == typeof Object.create
        ? (e.exports = function (e, t) {
            t &&
              ((e.super_ = t),
              (e.prototype = Object.create(t.prototype, {
                constructor: {
                  value: e,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })));
          })
        : (e.exports = function (e, t) {
            if (t) {
              e.super_ = t;
              var r = function () {};
              (r.prototype = t.prototype),
                (e.prototype = new r()),
                (e.prototype.constructor = e);
            }
          });
    },
    43997: (e, t, r) => {
      "use strict";
      r.d(t, {
        AH: () => i.AH,
        JW: () => s.JW,
        WF: () => n,
        iz: () => i.iz,
        qy: () => s.qy,
      });
      var i = r(98502),
        s = r(52321);
      class n extends i.mN {
        constructor() {
          super(...arguments),
            (this.renderOptions = { host: this }),
            (this._$Do = void 0);
        }
        createRenderRoot() {
          let e = super.createRenderRoot();
          return (this.renderOptions.renderBefore ??= e.firstChild), e;
        }
        update(e) {
          let t = this.render();
          this.hasUpdated ||
            (this.renderOptions.isConnected = this.isConnected),
            super.update(e),
            (this._$Do = (0, s.XX)(t, this.renderRoot, this.renderOptions));
        }
        connectedCallback() {
          super.connectedCallback(), this._$Do?.setConnected(!0);
        }
        disconnectedCallback() {
          super.disconnectedCallback(), this._$Do?.setConnected(!1);
        }
        render() {
          return s.c0;
        }
      }
      (n._$litElement$ = !0),
        (n.finalized = !0),
        globalThis.litElementHydrateSupport?.({ LitElement: n });
      let a = globalThis.litElementPolyfillSupport;
      a?.({ LitElement: n }),
        (globalThis.litElementVersions ??= []).push("4.1.1");
    },
    44826: (e, t, r) => {
      "use strict";
      r.d(t, { T: () => g });
      var i = r(1220),
        s = r(28977),
        n = r(12319),
        a = r(32464),
        o = r(58653),
        c = r(58051),
        l = r(73442),
        d = r(55480),
        u = r(65374);
      let h = {
          purchaseCurrencies: [
            {
              id: "2b92315d-eab7-5bef-84fa-089a131333f5",
              name: "USD Coin",
              symbol: "USDC",
              networks: [
                {
                  name: "ethereum-mainnet",
                  display_name: "Ethereum",
                  chain_id: "1",
                  contract_address:
                    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
                },
                {
                  name: "polygon-mainnet",
                  display_name: "Polygon",
                  chain_id: "137",
                  contract_address:
                    "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
                },
              ],
            },
            {
              id: "2b92315d-eab7-5bef-84fa-089a131333f5",
              name: "Ether",
              symbol: "ETH",
              networks: [
                {
                  name: "ethereum-mainnet",
                  display_name: "Ethereum",
                  chain_id: "1",
                  contract_address:
                    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
                },
                {
                  name: "polygon-mainnet",
                  display_name: "Polygon",
                  chain_id: "137",
                  contract_address:
                    "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
                },
              ],
            },
          ],
          paymentCurrencies: [
            {
              id: "USD",
              payment_method_limits: [
                { id: "card", min: "10.00", max: "7500.00" },
                { id: "ach_bank_account", min: "10.00", max: "25000.00" },
              ],
            },
            {
              id: "EUR",
              payment_method_limits: [
                { id: "card", min: "10.00", max: "7500.00" },
                { id: "ach_bank_account", min: "10.00", max: "25000.00" },
              ],
            },
          ],
        },
        f = n.w.getBlockchainApiUrl(),
        p = (0, i.BX)({
          clientId: null,
          api: new a.Z({ baseUrl: f, clientId: null }),
          supportedChains: { http: [], ws: [] },
        }),
        g = {
          state: p,
          async get(e) {
            let { st: t, sv: r } = g.getSdkProperties(),
              i = d.H.state.projectId,
              s = { ...(e.params || {}), st: t, sv: r, projectId: i };
            return p.api.get({ ...e, params: s });
          },
          getSdkProperties() {
            let { sdkType: e, sdkVersion: t } = d.H.state;
            return { st: e || "unknown", sv: t || "unknown" };
          },
          async isNetworkSupported(e) {
            if (!e) return !1;
            try {
              p.supportedChains.http.length || (await g.getSupportedNetworks());
            } catch (e) {
              return !1;
            }
            return p.supportedChains.http.includes(e);
          },
          async getSupportedNetworks() {
            let e = await g.get({ path: "v1/supported-chains" });
            return (p.supportedChains = e), e;
          },
          async fetchIdentity({ address: e, caipNetworkId: t }) {
            if (!(await g.isNetworkSupported(t)))
              return { avatar: "", name: "" };
            let r = o.i.getIdentityFromCacheForAddress(e);
            if (r) return r;
            let i = await g.get({
              path: `/v1/identity/${e}`,
              params: {
                sender: l.W.state.activeCaipAddress
                  ? n.w.getPlainAddress(l.W.state.activeCaipAddress)
                  : void 0,
              },
            });
            return (
              o.i.updateIdentityCache({
                address: e,
                identity: i,
                timestamp: Date.now(),
              }),
              i
            );
          },
          fetchTransactions: async ({
            account: e,
            cursor: t,
            onramp: r,
            signal: i,
            cache: s,
            chainId: n,
          }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: `/v1/account/${e}/history`,
                  params: { cursor: t, onramp: r, chainId: n },
                  signal: i,
                  cache: s,
                })
              : { data: [], next: void 0 },
          fetchSwapQuote: async ({
            amount: e,
            userAddress: t,
            from: r,
            to: i,
            gasPrice: s,
          }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: "/v1/convert/quotes",
                  headers: { "Content-Type": "application/json" },
                  params: {
                    amount: e,
                    userAddress: t,
                    from: r,
                    to: i,
                    gasPrice: s,
                  },
                })
              : { quotes: [] },
          fetchSwapTokens: async ({ chainId: e }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({ path: "/v1/convert/tokens", params: { chainId: e } })
              : { tokens: [] },
          fetchTokenPrice: async ({ addresses: e }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? p.api.post({
                  path: "/v1/fungible/price",
                  body: {
                    currency: "usd",
                    addresses: e,
                    projectId: d.H.state.projectId,
                  },
                  headers: { "Content-Type": "application/json" },
                })
              : { fungibles: [] },
          fetchSwapAllowance: async ({ tokenAddress: e, userAddress: t }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: "/v1/convert/allowance",
                  params: { tokenAddress: e, userAddress: t },
                  headers: { "Content-Type": "application/json" },
                })
              : { allowance: "0" },
          async fetchGasPrice({ chainId: e }) {
            let { st: t, sv: r } = g.getSdkProperties();
            if (
              !(await g.isNetworkSupported(
                l.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              throw Error("Network not supported for Gas Price");
            return g.get({
              path: "/v1/convert/gas-price",
              headers: { "Content-Type": "application/json" },
              params: { chainId: e, st: t, sv: r },
            });
          },
          async generateSwapCalldata({
            amount: e,
            from: t,
            to: r,
            userAddress: i,
          }) {
            if (
              !(await g.isNetworkSupported(
                l.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              throw Error("Network not supported for Swaps");
            return p.api.post({
              path: "/v1/convert/build-transaction",
              headers: { "Content-Type": "application/json" },
              body: {
                amount: e,
                eip155: { slippage: s.oU.CONVERT_SLIPPAGE_TOLERANCE },
                projectId: d.H.state.projectId,
                from: t,
                to: r,
                userAddress: i,
              },
            });
          },
          async generateApproveCalldata({ from: e, to: t, userAddress: r }) {
            let { st: i, sv: s } = g.getSdkProperties();
            if (
              !(await g.isNetworkSupported(
                l.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              throw Error("Network not supported for Swaps");
            return g.get({
              path: "/v1/convert/build-approve",
              headers: { "Content-Type": "application/json" },
              params: { userAddress: r, from: e, to: t, st: i, sv: s },
            });
          },
          async getBalance(e, t, r) {
            let { st: i, sv: s } = g.getSdkProperties();
            if (
              !(await g.isNetworkSupported(
                l.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              return (
                u.P.showError("Token Balance Unavailable"), { balances: [] }
              );
            let n = `${t}:${e}`,
              a = o.i.getBalanceCacheForCaipAddress(n);
            if (a) return a;
            let c = await g.get({
              path: `/v1/account/${e}/balance`,
              params: {
                currency: "usd",
                chainId: t,
                forceUpdate: r,
                st: i,
                sv: s,
              },
            });
            return (
              o.i.updateBalanceCache({
                caipAddress: n,
                balance: c,
                timestamp: Date.now(),
              }),
              c
            );
          },
          lookupEnsName: async (e) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: `/v1/profile/account/${e}`,
                  params: { apiVersion: "2" },
                })
              : { addresses: {}, attributes: [] },
          reverseLookupEnsName: async ({ address: e }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: `/v1/profile/reverse/${e}`,
                  params: { sender: c.U.state.address, apiVersion: "2" },
                })
              : [],
          getEnsNameSuggestions: async (e) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({
                  path: `/v1/profile/suggestions/${e}`,
                  params: { zone: "reown.id" },
                })
              : { suggestions: [] },
          registerEnsName: async ({
            coinType: e,
            address: t,
            message: r,
            signature: i,
          }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? p.api.post({
                  path: "/v1/profile/account",
                  body: { coin_type: e, address: t, message: r, signature: i },
                  headers: { "Content-Type": "application/json" },
                })
              : { success: !1 },
          generateOnRampURL: async ({
            destinationWallets: e,
            partnerUserId: t,
            defaultNetwork: r,
            purchaseAmount: i,
            paymentAmount: s,
          }) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? (
                  await p.api.post({
                    path: "/v1/generators/onrampurl",
                    params: { projectId: d.H.state.projectId },
                    body: {
                      destinationWallets: e,
                      defaultNetwork: r,
                      partnerUserId: t,
                      defaultExperience: "buy",
                      presetCryptoAmount: i,
                      presetFiatAmount: s,
                    },
                  })
                ).url
              : "",
          async getOnrampOptions() {
            if (
              !(await g.isNetworkSupported(
                l.W.state.activeCaipNetwork?.caipNetworkId
              ))
            )
              return { paymentCurrencies: [], purchaseCurrencies: [] };
            try {
              return await g.get({ path: "/v1/onramp/options" });
            } catch (e) {
              return h;
            }
          },
          async getOnrampQuote({
            purchaseCurrency: e,
            paymentCurrency: t,
            amount: r,
            network: i,
          }) {
            try {
              if (
                !(await g.isNetworkSupported(
                  l.W.state.activeCaipNetwork?.caipNetworkId
                ))
              )
                return null;
              return await p.api.post({
                path: "/v1/onramp/quote",
                params: { projectId: d.H.state.projectId },
                body: {
                  purchaseCurrency: e,
                  paymentCurrency: t,
                  amount: r,
                  network: i,
                },
              });
            } catch (e) {
              return {
                coinbaseFee: { amount: r, currency: t.id },
                networkFee: { amount: r, currency: t.id },
                paymentSubtotal: { amount: r, currency: t.id },
                paymentTotal: { amount: r, currency: t.id },
                purchaseAmount: { amount: r, currency: t.id },
                quoteId: "mocked-quote-id",
              };
            }
          },
          getSmartSessions: async (e) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? g.get({ path: `/v1/sessions/${e}` })
              : [],
          revokeSmartSession: async (e, t, r) =>
            (await g.isNetworkSupported(
              l.W.state.activeCaipNetwork?.caipNetworkId
            ))
              ? p.api.post({
                  path: `/v1/sessions/${e}/revoke`,
                  params: { projectId: d.H.state.projectId },
                  body: { pci: t, signature: r },
                })
              : { success: !1 },
          setClientId(e) {
            (p.clientId = e), (p.api = new a.Z({ baseUrl: f, clientId: e }));
          },
        };
    },
    44839: function (e) {
      e.exports = function (e, t, r) {
        e = e || {};
        var i = t.prototype,
          s = {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years",
          };
        function n(e, t, r, s) {
          return i.fromToBase(e, t, r, s);
        }
        (r.en.relativeTime = s),
          (i.fromToBase = function (t, i, n, a, o) {
            for (
              var c,
                l,
                d,
                u = n.$locale().relativeTime || s,
                h = e.thresholds || [
                  { l: "s", r: 44, d: "second" },
                  { l: "m", r: 89 },
                  { l: "mm", r: 44, d: "minute" },
                  { l: "h", r: 89 },
                  { l: "hh", r: 21, d: "hour" },
                  { l: "d", r: 35 },
                  { l: "dd", r: 25, d: "day" },
                  { l: "M", r: 45 },
                  { l: "MM", r: 10, d: "month" },
                  { l: "y", r: 17 },
                  { l: "yy", d: "year" },
                ],
                f = h.length,
                p = 0;
              p < f;
              p += 1
            ) {
              var g = h[p];
              g.d && (c = a ? r(t).diff(n, g.d, !0) : n.diff(t, g.d, !0));
              var m = (e.rounding || Math.round)(Math.abs(c));
              if (((d = c > 0), m <= g.r || !g.r)) {
                m <= 1 && p > 0 && (g = h[p - 1]);
                var b = u[g.l];
                o && (m = o("" + m)),
                  (l =
                    "string" == typeof b
                      ? b.replace("%d", m)
                      : b(m, i, g.l, d));
                break;
              }
            }
            if (i) return l;
            var y = d ? u.future : u.past;
            return "function" == typeof y ? y(l) : y.replace("%s", l);
          }),
          (i.to = function (e, t) {
            return n(e, t, this, !0);
          }),
          (i.from = function (e, t) {
            return n(e, t, this);
          });
        var a = function (e) {
          return e.$u ? r.utc() : r();
        };
        (i.toNow = function (e) {
          return this.to(a(this), e);
        }),
          (i.fromNow = function (e) {
            return this.from(a(this), e);
          });
      };
    },
    45069: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => o });
      var i = r(1220),
        s = r(52617),
        n = r(66254);
      let a = (0, i.BX)({
          themeMode: "dark",
          themeVariables: {},
          w3mThemeVariables: void 0,
        }),
        o = {
          state: a,
          subscribe: (e) => (0, i.B1)(a, () => e(a)),
          setThemeMode(e) {
            a.themeMode = e;
            try {
              let t = n.a.getAuthConnector();
              if (t) {
                let r = o.getSnapshot().themeVariables;
                t.provider.syncTheme({
                  themeMode: e,
                  themeVariables: r,
                  w3mThemeVariables: (0, s.o)(r, e),
                });
              }
            } catch {
              console.info("Unable to sync theme to auth connector");
            }
          },
          setThemeVariables(e) {
            a.themeVariables = { ...a.themeVariables, ...e };
            try {
              let e = n.a.getAuthConnector();
              if (e) {
                let t = o.getSnapshot().themeVariables;
                e.provider.syncTheme({
                  themeVariables: t,
                  w3mThemeVariables: (0, s.o)(a.themeVariables, a.themeMode),
                });
              }
            } catch {
              console.info("Unable to sync theme to auth connector");
            }
          },
          getSnapshot: () => (0, i.P9)(a),
        };
    },
    45553: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => i });
      let i = {
        WC_NAME_SUFFIX: ".reown.id",
        WC_NAME_SUFFIX_LEGACY: ".wcn.id",
        BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
        PULSE_API_URL: "https://pulse.walletconnect.org",
        W3M_API_URL: "https://api.web3modal.org",
        CONNECTOR_ID: {
          WALLET_CONNECT: "walletConnect",
          INJECTED: "injected",
          WALLET_STANDARD: "announced",
          COINBASE: "coinbaseWallet",
          COINBASE_SDK: "coinbaseWalletSDK",
          SAFE: "safe",
          LEDGER: "ledger",
          OKX: "okx",
          EIP6963: "eip6963",
          AUTH: "ID_AUTH",
        },
        CONNECTOR_NAMES: { AUTH: "Auth" },
        AUTH_CONNECTOR_SUPPORTED_CHAINS: ["eip155", "solana"],
        LIMITS: { PENDING_TRANSACTIONS: 99 },
        CHAIN: {
          EVM: "eip155",
          SOLANA: "solana",
          POLKADOT: "polkadot",
          BITCOIN: "bip122",
        },
        CHAIN_NAME_MAP: {
          eip155: "EVM Networks",
          solana: "Solana",
          polkadot: "Polkadot",
          bip122: "Bitcoin",
        },
        USDT_CONTRACT_ADDRESSES: [
          "0xdac17f958d2ee523a2206206994597c13d831ec7",
          "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
          "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
          "0x919C1c267BC06a7039e03fcc2eF738525769109c",
          "0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e",
          "0x55d398326f99059fF775485246999027B3197955",
          "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
        ],
        HTTP_STATUS_CODES: { SERVICE_UNAVAILABLE: 503, FORBIDDEN: 403 },
        UNSUPPORTED_NETWORK_NAME: "Unknown Network",
      };
    },
    46465: (e, t, r) => {
      "use strict";
      r.d(t, { r: () => i });
      let i = "2.16.5";
    },
    46524: (e, t, r) => {
      "use strict";
      var i = r(20920),
        s = r(3285);
      function n(e, t, r) {
        if (!(this instanceof n)) return new n(e, t, r);
        (this.Hash = e),
          (this.blockSize = e.blockSize / 8),
          (this.outSize = e.outSize / 8),
          (this.inner = null),
          (this.outer = null),
          this._init(i.toArray(t, r));
      }
      (e.exports = n),
        (n.prototype._init = function (e) {
          e.length > this.blockSize && (e = new this.Hash().update(e).digest()),
            s(e.length <= this.blockSize);
          for (var t = e.length; t < this.blockSize; t++) e.push(0);
          for (t = 0; t < e.length; t++) e[t] ^= 54;
          for (t = 0, this.inner = new this.Hash().update(e); t < e.length; t++)
            e[t] ^= 106;
          this.outer = new this.Hash().update(e);
        }),
        (n.prototype.update = function (e, t) {
          return this.inner.update(e, t), this;
        }),
        (n.prototype.digest = function (e) {
          return this.outer.update(this.inner.digest()), this.outer.digest(e);
        });
    },
    47327: (e, t, r) => {
      "use strict";
      function i(e) {
        return function (t) {
          return "function" == typeof t
            ? (customElements.get(e) || customElements.define(e, t), t)
            : (function (e, t) {
                let { kind: r, elements: i } = t;
                return {
                  kind: r,
                  elements: i,
                  finisher(t) {
                    customElements.get(e) || customElements.define(e, t);
                  },
                };
              })(e, t);
        };
      }
      r.d(t, { E: () => i });
    },
    47887: (e, t, r) => {
      "use strict";
      (t.sha1 = r(48247)),
        (t.sha224 = r(15612)),
        (t.sha256 = r(40709)),
        (t.sha384 = r(22633)),
        (t.sha512 = r(31e3));
    },
    48247: (e, t, r) => {
      "use strict";
      var i = r(20920),
        s = r(64874),
        n = r(4117),
        a = i.rotl32,
        o = i.sum32,
        c = i.sum32_5,
        l = n.ft_1,
        d = s.BlockHash,
        u = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
      function h() {
        if (!(this instanceof h)) return new h();
        d.call(this),
          (this.h = [
            0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,
          ]),
          (this.W = Array(80));
      }
      i.inherits(h, d),
        (e.exports = h),
        (h.blockSize = 512),
        (h.outSize = 160),
        (h.hmacStrength = 80),
        (h.padLength = 64),
        (h.prototype._update = function (e, t) {
          for (var r = this.W, i = 0; i < 16; i++) r[i] = e[t + i];
          for (; i < r.length; i++)
            r[i] = a(r[i - 3] ^ r[i - 8] ^ r[i - 14] ^ r[i - 16], 1);
          var s = this.h[0],
            n = this.h[1],
            d = this.h[2],
            h = this.h[3],
            f = this.h[4];
          for (i = 0; i < r.length; i++) {
            var p = ~~(i / 20),
              g = c(a(s, 5), l(p, n, d, h), f, r[i], u[p]);
            (f = h), (h = d), (d = a(n, 30)), (n = s), (s = g);
          }
          (this.h[0] = o(this.h[0], s)),
            (this.h[1] = o(this.h[1], n)),
            (this.h[2] = o(this.h[2], d)),
            (this.h[3] = o(this.h[3], h)),
            (this.h[4] = o(this.h[4], f));
        }),
        (h.prototype._digest = function (e) {
          return "hex" === e
            ? i.toHex32(this.h, "big")
            : i.split32(this.h, "big");
        });
    },
    48543: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.delay = void 0),
        (t.delay = function (e) {
          return new Promise((t) => {
            setTimeout(() => {
              t(!0);
            }, e);
          });
        });
    },
    48981: (e, t, r) => {
      "use strict";
      r.d(t, { g: () => h });
      var i = r(45553),
        s = r(55480),
        n = r(58653),
        a = r(12319),
        o = r(3824),
        c = r(72880),
        l = r(73442),
        d = r(66254),
        u = r(18635);
      let h = {
        getConnectorsByType(e, t, r) {
          let { customWallets: i } = s.H.state,
            a = n.i.getRecentWallets(),
            o = u.A.filterOutDuplicateWallets(t),
            c = u.A.filterOutDuplicateWallets(r),
            l = e.filter((e) => "MULTI_CHAIN" === e.type),
            d = e.filter((e) => "ANNOUNCED" === e.type),
            h = e.filter((e) => "INJECTED" === e.type);
          return {
            custom: i,
            recent: a,
            external: e.filter((e) => "EXTERNAL" === e.type),
            multiChain: l,
            announced: d,
            injected: h,
            recommended: o,
            featured: c,
          };
        },
        showConnector(e) {
          if ("INJECTED" === e.type) {
            if (!a.w.isMobile() && "Browser Wallet" === e.name) return !1;
            let t = e.info?.rdns;
            if (
              (!t && !o.x.checkInstalled()) ||
              (t &&
                c.N.state.excludedRDNS &&
                c.N.state.excludedRDNS.includes(t))
            )
              return !1;
          }
          if ("ANNOUNCED" === e.type) {
            let t = e.info?.rdns;
            if (t && c.N.state.excludedRDNS.includes(t)) return !1;
          }
          return !0;
        },
        getIsConnectedWithWC: () =>
          Array.from(l.W.state.chains.values()).some(
            (e) =>
              d.a.getConnectorId(e.namespace) ===
              i.o.CONNECTOR_ID.WALLET_CONNECT
          ),
        getConnectorTypeOrder({
          recommended: e,
          featured: t,
          custom: r,
          recent: i,
          announced: n,
          injected: a,
          multiChain: o,
          external: c,
          overriddenConnectors: l = s.H.state.features?.connectorTypeOrder ??
            [],
        }) {
          let d = h.getIsConnectedWithWC(),
            u = [
              {
                type: "walletConnect",
                isEnabled: s.H.state.enableWalletConnect && !d,
              },
              { type: "recent", isEnabled: i.length > 0 },
              { type: "injected", isEnabled: [...a, ...n, ...o].length > 0 },
              { type: "featured", isEnabled: t.length > 0 },
              { type: "custom", isEnabled: r && r.length > 0 },
              { type: "external", isEnabled: c.length > 0 },
              { type: "recommended", isEnabled: e.length > 0 },
            ].filter((e) => e.isEnabled),
            f = new Set(u.map((e) => e.type)),
            p = l
              .filter((e) => f.has(e))
              .map((e) => ({ type: e, isEnabled: !0 })),
            g = u.filter(({ type: e }) => !p.some(({ type: t }) => t === e));
          return Array.from(new Set([...p, ...g].map(({ type: e }) => e)));
        },
      };
    },
    49068: (e, t, r) => {
      "use strict";
      r.d(t, {
        bEt: () => rM,
        EWt: () => rU,
        Pa8: () => rL,
        nyL: () => iJ,
        Lp_: () => rj,
        EHS: () => rF,
        Van: () => ip,
        Xw0: () => e_,
        Wx8: () => eb,
        e8_: () => tN,
        K3g: () => ey,
        x0t: () => rK,
        F$L: () => rZ,
        YcA: () => rY,
        ovp: () => rW,
        iui: () => rX,
        Tw2: () => rQ,
        wa2: () => rG,
        hEn: () => eI,
        PAk: () => tl,
        gOF: () => eA,
        hwK: () => tC,
        jUZ: () => ef,
        ADD: () => ev,
        ojD: () => eh,
        QJh: () => r9,
        TZl: () => r$,
        two: () => rz,
        Zz7: () => et,
        R7U: () => ed,
        lFF: () => eu,
        WWN: () => tO,
        jTh: () => eN,
        q_h: () => tE,
        GuA: () => ib,
        $Bq: () => r7,
        sc_: () => tP,
        xkc: () => tA,
        VBM: () => tk,
        aa1: () => r6,
        n6V: () => r8,
        Hjj: () => iy,
        $hI: () => eT,
        n3s: () => ex,
        EN$: () => rH,
        ALl: () => rq,
        m01: () => ea,
        BdH: () => ec,
        nWe: () => iu,
        XqR: () => iq,
        _dF: () => eC,
        aRZ: () => eo,
        Lln: () => es,
        sc7: () => iG,
        CTo: () => ix,
        lVv: () => en,
        HNf: () => iC,
        mr0: () => iN,
        w8K: () => eO,
        V7m: () => r2,
        ps1: () => r3,
        b07: () => iA,
        OP1: () => iw,
        tk0: () => iT,
        X3c: () => iB,
        FR8: () => i$,
        Alu: () => iU,
        FiO: () => iR,
        tLy: () => iz,
        z2N: () => iH,
        oKp: () => iW,
        aF0: () => iv,
        TeY: () => iL,
        kuU: () => iD,
        V9G: () => iM,
        iV1: () => ij,
        Hbs: () => iK,
        esh: () => ik,
        M8n: () => iF,
        Qhg: () => iE,
        AYU: () => iS,
        h0Y: () => eg,
        TRk: () => eS,
        hVC: () => tT,
        PUk: () => em,
        _Yb: () => X,
        c82: () => eE,
        kob: () => ih,
        wYp: () => r4,
        yy4: () => eR,
        uym: () => iQ,
        gZm: () => eP,
        C5G: () => r0,
        AwN: () => r1,
        IjX: () => t_,
        U0i: () => r5,
      });
      var i = r(87358),
        s = function (e, t, r) {
          if (r || 2 == arguments.length)
            for (var i, s = 0, n = t.length; s < n; s++)
              (!i && s in t) ||
                (i || (i = Array.prototype.slice.call(t, 0, s)), (i[s] = t[s]));
          return e.concat(i || Array.prototype.slice.call(t));
        },
        n = function (e, t, r) {
          (this.name = e),
            (this.version = t),
            (this.os = r),
            (this.type = "browser");
        },
        a = function (e) {
          (this.version = e),
            (this.type = "node"),
            (this.name = "node"),
            (this.os = i.platform);
        },
        o = function (e, t, r, i) {
          (this.name = e),
            (this.version = t),
            (this.os = r),
            (this.bot = i),
            (this.type = "bot-device");
        },
        c = function () {
          (this.type = "bot"),
            (this.bot = !0),
            (this.name = "bot"),
            (this.version = null),
            (this.os = null);
        },
        l = function () {
          (this.type = "react-native"),
            (this.name = "react-native"),
            (this.version = null),
            (this.os = null);
        },
        d =
          /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
        u = [
          ["aol", /AOLShield\/([0-9\._]+)/],
          ["edge", /Edge\/([0-9\._]+)/],
          ["edge-ios", /EdgiOS\/([0-9\._]+)/],
          ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
          ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
          ["samsung", /SamsungBrowser\/([0-9\.]+)/],
          ["silk", /\bSilk\/([0-9._-]+)\b/],
          ["miui", /MiuiBrowser\/([0-9\.]+)$/],
          ["beaker", /BeakerBrowser\/([0-9\.]+)/],
          ["edge-chromium", /EdgA?\/([0-9\.]+)/],
          [
            "chromium-webview",
            /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
          ],
          ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
          ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
          ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
          ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
          ["fxios", /FxiOS\/([0-9\.]+)/],
          ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
          ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
          ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
          ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
          [
            "pie",
            /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/,
          ],
          ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
          ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
          ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
          ["ie", /MSIE\s(7\.0)/],
          ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
          ["android", /Android\s([0-9\.]+)/],
          ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
          ["safari", /Version\/([0-9\._]+).*Safari/],
          ["facebook", /FB[AS]V\/([0-9\.]+)/],
          ["instagram", /Instagram\s([0-9\.]+)/],
          ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
          ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
          ["curl", /^curl\/([0-9\.]+)$/],
          [
            "searchbot",
            /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
          ],
        ],
        h = [
          ["iOS", /iP(hone|od|ad)/],
          ["Android OS", /Android/],
          ["BlackBerry OS", /BlackBerry|BB10/],
          ["Windows Mobile", /IEMobile/],
          ["Amazon OS", /Kindle/],
          ["Windows 3.11", /Win16/],
          ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
          ["Windows 98", /(Windows 98)|(Win98)/],
          ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
          ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
          ["Windows Server 2003", /(Windows NT 5.2)/],
          ["Windows Vista", /(Windows NT 6.0)/],
          ["Windows 7", /(Windows NT 6.1)/],
          ["Windows 8", /(Windows NT 6.2)/],
          ["Windows 8.1", /(Windows NT 6.3)/],
          ["Windows 10", /(Windows NT 10.0)/],
          ["Windows ME", /Windows ME/],
          ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
          ["Open BSD", /OpenBSD/],
          ["Sun OS", /SunOS/],
          ["Chrome OS", /CrOS/],
          ["Linux", /(Linux)|(X11)/],
          ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
          ["QNX", /QNX/],
          ["BeOS", /BeOS/],
          ["OS/2", /OS\/2/],
        ],
        f = r(5566),
        p = r(26662),
        g = r(88955);
      let m = "2.23.2",
        b = {
          getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: r }) =>
            t ? `${e ?? "https://viem.sh"}${t}${r ? `#${r}` : ""}` : void 0,
          version: `viem@${m}`,
        };
      class y extends Error {
        constructor(e, t = {}) {
          let r =
              t.cause instanceof y
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            i = (t.cause instanceof y && t.cause.docsPath) || t.docsPath,
            s = b.getDocsUrl?.({ ...t, docsPath: i });
          super(
            [
              e || "An error occurred.",
              "",
              ...(t.metaMessages ? [...t.metaMessages, ""] : []),
              ...(s ? [`Docs: ${s}`] : []),
              ...(r ? [`Details: ${r}`] : []),
              ...(b.version ? [`Version: ${b.version}`] : []),
            ].join("\n"),
            t.cause ? { cause: t.cause } : void 0
          ),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "version", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "BaseError",
            }),
            (this.details = r),
            (this.docsPath = i),
            (this.metaMessages = t.metaMessages),
            (this.name = t.name ?? this.name),
            (this.shortMessage = e),
            (this.version = m);
        }
        walk(e) {
          return (function e(t, r) {
            return r?.(t)
              ? t
              : t && "object" == typeof t && "cause" in t && void 0 !== t.cause
              ? e(t.cause, r)
              : r
              ? null
              : t;
          })(this, e);
        }
      }
      function w(e, { strict: t = !0 } = {}) {
        return (
          !!e &&
          "string" == typeof e &&
          (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x"))
        );
      }
      class v extends y {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} size (${e}) exceeds padding size (${t}).`,
            { name: "SizeExceedsPaddingSizeError" }
          );
        }
      }
      function A(e, { dir: t, size: r = 32 } = {}) {
        return "string" == typeof e
          ? (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              let i = e.replace("0x", "");
              if (i.length > 2 * r)
                throw new v({
                  size: Math.ceil(i.length / 2),
                  targetSize: r,
                  type: "hex",
                });
              return `0x${i["right" === t ? "padEnd" : "padStart"](
                2 * r,
                "0"
              )}`;
            })(e, { dir: t, size: r })
          : (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              if (e.length > r)
                throw new v({ size: e.length, targetSize: r, type: "bytes" });
              let i = new Uint8Array(r);
              for (let s = 0; s < r; s++) {
                let n = "right" === t;
                i[n ? s : r - s - 1] = e[n ? s : e.length - s - 1];
              }
              return i;
            })(e, { dir: t, size: r });
      }
      class E extends y {
        constructor({ max: e, min: t, signed: r, size: i, value: s }) {
          super(
            `Number "${s}" is not in safe ${
              i ? `${8 * i}-bit ${r ? "signed" : "unsigned"} ` : ""
            }integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`,
            { name: "IntegerOutOfRangeError" }
          );
        }
      }
      class _ extends y {
        constructor({ givenSize: e, maxSize: t }) {
          super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
            name: "SizeOverflowError",
          });
        }
      }
      function C(e) {
        return w(e, { strict: !1 }) ? Math.ceil((e.length - 2) / 2) : e.length;
      }
      function I(e, { size: t }) {
        if (C(e) > t) throw new _({ givenSize: C(e), maxSize: t });
      }
      function S(e, t = {}) {
        let { signed: r } = t;
        t.size && I(e, { size: t.size });
        let i = BigInt(e);
        if (!r) return i;
        let s = (e.length - 2) / 2;
        return i <= (1n << (8n * BigInt(s) - 1n)) - 1n
          ? i
          : i - BigInt(`0x${"f".padStart(2 * s, "f")}`) - 1n;
      }
      let x = Array.from({ length: 256 }, (e, t) =>
        t.toString(16).padStart(2, "0")
      );
      function N(e, t = {}) {
        return "number" == typeof e || "bigint" == typeof e
          ? P(e, t)
          : "string" == typeof e
          ? (function (e, t = {}) {
              return T(O.encode(e), t);
            })(e, t)
          : "boolean" == typeof e
          ? (function (e, t = {}) {
              let r = `0x${Number(e)}`;
              return "number" == typeof t.size
                ? (I(r, { size: t.size }), A(r, { size: t.size }))
                : r;
            })(e, t)
          : T(e, t);
      }
      function T(e, t = {}) {
        let r = "";
        for (let t = 0; t < e.length; t++) r += x[e[t]];
        let i = `0x${r}`;
        return "number" == typeof t.size
          ? (I(i, { size: t.size }), A(i, { dir: "right", size: t.size }))
          : i;
      }
      function P(e, t = {}) {
        let r;
        let { signed: i, size: s } = t,
          n = BigInt(e);
        s
          ? (r = i
              ? (1n << (8n * BigInt(s) - 1n)) - 1n
              : 2n ** (8n * BigInt(s)) - 1n)
          : "number" == typeof e && (r = BigInt(Number.MAX_SAFE_INTEGER));
        let a = "bigint" == typeof r && i ? -r - 1n : 0;
        if ((r && n > r) || n < a) {
          let t = "bigint" == typeof e ? "n" : "";
          throw new E({
            max: r ? `${r}${t}` : void 0,
            min: `${a}${t}`,
            signed: i,
            size: s,
            value: `${e}${t}`,
          });
        }
        let o = `0x${(i && n < 0
          ? (1n << BigInt(8 * s)) + BigInt(n)
          : n
        ).toString(16)}`;
        return s ? A(o, { size: s }) : o;
      }
      let O = new TextEncoder(),
        k = new TextEncoder(),
        R = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
      function D(e) {
        return e >= R.zero && e <= R.nine
          ? e - R.zero
          : e >= R.A && e <= R.F
          ? e - (R.A - 10)
          : e >= R.a && e <= R.f
          ? e - (R.a - 10)
          : void 0;
      }
      function M(e, t = {}) {
        let r = e;
        t.size &&
          (I(r, { size: t.size }), (r = A(r, { dir: "right", size: t.size })));
        let i = r.slice(2);
        i.length % 2 && (i = `0${i}`);
        let s = i.length / 2,
          n = new Uint8Array(s);
        for (let e = 0, t = 0; e < s; e++) {
          let r = D(i.charCodeAt(t++)),
            s = D(i.charCodeAt(t++));
          if (void 0 === r || void 0 === s)
            throw new y(
              `Invalid byte sequence ("${i[t - 2]}${i[t - 1]}" in "${i}").`
            );
          n[e] = 16 * r + s;
        }
        return n;
      }
      function U(e, t = {}) {
        let r = k.encode(e);
        return "number" == typeof t.size
          ? (I(r, { size: t.size }), A(r, { dir: "right", size: t.size }))
          : r;
      }
      var L = r(29143);
      function B(e, t) {
        let r = (0, L.lY)(
          w(e, { strict: !1 })
            ? (function (e, t = {}) {
                return "number" == typeof e || "bigint" == typeof e
                  ? M(P(e, t))
                  : "boolean" == typeof e
                  ? (function (e, t = {}) {
                      let r = new Uint8Array(1);
                      return ((r[0] = Number(e)), "number" == typeof t.size)
                        ? (I(r, { size: t.size }), A(r, { size: t.size }))
                        : r;
                    })(e, t)
                  : w(e)
                  ? M(e, t)
                  : U(e, t);
              })(e)
            : e
        );
        return "bytes" === (t || "hex") ? r : N(r);
      }
      class j extends Map {
        constructor(e) {
          super(),
            Object.defineProperty(this, "maxSize", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.maxSize = e);
        }
        get(e) {
          let t = super.get(e);
          return (
            super.has(e) && void 0 !== t && (this.delete(e), super.set(e, t)), t
          );
        }
        set(e, t) {
          if ((super.set(e, t), this.maxSize && this.size > this.maxSize)) {
            let e = this.keys().next().value;
            e && this.delete(e);
          }
          return this;
        }
      }
      let F = new j(8192);
      async function $({ hash: e, signature: t }) {
        let i = w(e) ? e : N(e),
          { secp256k1: s } = await r.e(5009).then(r.bind(r, 75009)),
          n = (() => {
            if ("object" == typeof t && "r" in t && "s" in t) {
              let { r: e, s: r, v: i, yParity: n } = t,
                a = z(Number(n ?? i));
              return new s.Signature(S(e), S(r)).addRecoveryBit(a);
            }
            let e = w(t) ? t : N(t),
              r = z(
                (function (e, t = {}) {
                  return Number(S(e, t));
                })(`0x${e.slice(130)}`)
              );
            return s.Signature.fromCompact(e.substring(2, 130)).addRecoveryBit(
              r
            );
          })()
            .recoverPublicKey(i.substring(2))
            .toHex(!1);
        return `0x${n}`;
      }
      function z(e) {
        if (0 === e || 1 === e) return e;
        if (27 === e) return 0;
        if (28 === e) return 1;
        throw Error("Invalid yParityOrV value");
      }
      async function W({ hash: e, signature: t }) {
        return (function (e) {
          let t = B(`0x${e.substring(4)}`).substring(26);
          return (function (e, t) {
            if (F.has(`${e}.${void 0}`)) return F.get(`${e}.${t}`);
            let r = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase(),
              i = B(U(r), "bytes"),
              s = (t ? r.substring(`${t}0x`.length) : r).split("");
            for (let e = 0; e < 40; e += 2)
              i[e >> 1] >> 4 >= 8 && s[e] && (s[e] = s[e].toUpperCase()),
                (15 & i[e >> 1]) >= 8 &&
                  s[e + 1] &&
                  (s[e + 1] = s[e + 1].toUpperCase());
            let n = `0x${s.join("")}`;
            return F.set(`${e}.${t}`, n), n;
          })(`0x${t}`);
        })(await $({ hash: e, signature: t }));
      }
      var H = r(54685),
        q = r(20852),
        V = r(58222),
        K = r(43757);
      function G(e, t, r) {
        var i, s;
        let n;
        return (
          (r.length
            ? ((i = t.length),
              Array.isArray(e) ? e.length >= i : Object.keys(e).length >= i)
            : ((s = t.length),
              Array.isArray(e)
                ? e.length === s
                : Object.keys(e).length === s)) &&
          ((n = !0),
          t.forEach((t) => {
            t in e || (n = !1);
          }),
          n)
        );
      }
      function Y(e, t, r = "_") {
        let i = e.split(r);
        return i[i.length - 1].trim().toLowerCase() === t.trim().toLowerCase();
      }
      let Q = {
        waku: {
          publish: "waku_publish",
          batchPublish: "waku_batchPublish",
          subscribe: "waku_subscribe",
          batchSubscribe: "waku_batchSubscribe",
          subscription: "waku_subscription",
          unsubscribe: "waku_unsubscribe",
          batchUnsubscribe: "waku_batchUnsubscribe",
          batchFetchMessages: "waku_batchFetchMessages",
        },
        irn: {
          publish: "irn_publish",
          batchPublish: "irn_batchPublish",
          subscribe: "irn_subscribe",
          batchSubscribe: "irn_batchSubscribe",
          subscription: "irn_subscription",
          unsubscribe: "irn_unsubscribe",
          batchUnsubscribe: "irn_batchUnsubscribe",
          batchFetchMessages: "irn_batchFetchMessages",
        },
        iridium: {
          publish: "iridium_publish",
          batchPublish: "iridium_batchPublish",
          subscribe: "iridium_subscribe",
          batchSubscribe: "iridium_batchSubscribe",
          subscription: "iridium_subscription",
          unsubscribe: "iridium_unsubscribe",
          batchUnsubscribe: "iridium_batchUnsubscribe",
          batchFetchMessages: "iridium_batchFetchMessages",
        },
      };
      var Z = r(87358),
        J = r(81029).Buffer;
      function X(e) {
        let [t, r] = e.split(":");
        return { namespace: t, reference: r };
      }
      function ee(e) {
        let [t, r, i] = e.split(":");
        return { namespace: t, reference: r, address: i };
      }
      function et(e, t = []) {
        let r = [];
        return (
          Object.keys(e).forEach((i) => {
            if (t.length && !t.includes(i)) return;
            let s = e[i];
            r.push(...s.accounts);
          }),
          r
        );
      }
      function er(e, t) {
        return e.includes(":") ? [e] : t.chains || [];
      }
      let ei = {
        reactNative: "react-native",
        node: "node",
        browser: "browser",
        unknown: "unknown",
      };
      function es() {
        return (
          "u" > typeof Z &&
          "u" > typeof Z.versions &&
          "u" > typeof Z.versions.node
        );
      }
      function en() {
        return (
          !(0, p.getDocument)() &&
          !!(0, p.getNavigator)() &&
          "ReactNative" === navigator.product
        );
      }
      function ea() {
        return (
          en() &&
          "u" > typeof r.g &&
          "u" > typeof (null == r.g ? void 0 : r.g.Platform) &&
          (null == r.g ? void 0 : r.g.Platform.OS) === "android"
        );
      }
      function eo() {
        return (
          en() &&
          "u" > typeof r.g &&
          "u" > typeof (null == r.g ? void 0 : r.g.Platform) &&
          (null == r.g ? void 0 : r.g.Platform.OS) === "ios"
        );
      }
      function ec() {
        return !es() && !!(0, p.getNavigator)() && !!(0, p.getDocument)();
      }
      function el() {
        return en()
          ? ei.reactNative
          : es()
          ? ei.node
          : ec()
          ? ei.browser
          : ei.unknown;
      }
      function ed() {
        var e;
        try {
          return en() &&
            "u" > typeof r.g &&
            "u" > typeof (null == r.g ? void 0 : r.g.Application)
            ? null == (e = r.g.Application)
              ? void 0
              : e.applicationId
            : void 0;
        } catch {
          return;
        }
      }
      function eu() {
        return (
          (0, g.g)() || { name: "", description: "", url: "", icons: [""] }
        );
      }
      function eh(e, t, f) {
        let g = (function () {
            if (
              el() === ei.reactNative &&
              "u" > typeof r.g &&
              "u" > typeof (null == r.g ? void 0 : r.g.Platform)
            ) {
              let { OS: e, Version: t } = r.g.Platform;
              return [e, t].join("-");
            }
            let e =
              "undefined" == typeof document &&
              "undefined" != typeof navigator &&
              "ReactNative" === navigator.product
                ? new l()
                : "undefined" != typeof navigator
                ? (function (e) {
                    var t,
                      r =
                        "" !== (t = e) &&
                        u.reduce(function (e, r) {
                          var i = r[0],
                            s = r[1];
                          if (e) return e;
                          var n = s.exec(t);
                          return !!n && [i, n];
                        }, !1);
                    if (!r) return null;
                    var i = r[0],
                      a = r[1];
                    if ("searchbot" === i) return new c();
                    var l =
                      a[1] && a[1].split(".").join("_").split("_").slice(0, 3);
                    l
                      ? l.length < 3 &&
                        (l = s(
                          s([], l, !0),
                          (function (e) {
                            for (var t = [], r = 0; r < e; r++) t.push("0");
                            return t;
                          })(3 - l.length),
                          !0
                        ))
                      : (l = []);
                    var f = l.join("."),
                      p = (function (e) {
                        for (var t = 0, r = h.length; t < r; t++) {
                          var i = h[t],
                            s = i[0];
                          if (i[1].exec(e)) return s;
                        }
                        return null;
                      })(e),
                      g = d.exec(e);
                    return g && g[1] ? new o(i, f, p, g[1]) : new n(i, f, p);
                  })(navigator.userAgent)
                : void 0 !== i && i.version
                ? new a(i.version.slice(1))
                : null;
            if (null === e) return "unknown";
            let t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
            return "browser" === e.type
              ? [t, e.name, e.version].join("-")
              : [t, e.version].join("-");
          })(),
          m = (function () {
            var e;
            let t = el();
            return t === ei.browser
              ? [
                  t,
                  (null == (e = (0, p.getLocation)()) ? void 0 : e.host) ||
                    "unknown",
                ].join(":")
              : t;
          })();
        return [[e, t].join("-"), ["js", f].join("-"), g, m].join("/");
      }
      function ef({
        protocol: e,
        version: t,
        relayUrl: r,
        sdkVersion: i,
        auth: s,
        projectId: n,
        useOnCloseEvent: a,
        bundleId: o,
        packageName: c,
      }) {
        let l = r.split("?"),
          d = eh(e, t, i),
          u = (function (e, t) {
            let r = new URLSearchParams(e);
            for (let e of Object.keys(t).sort())
              if (t.hasOwnProperty(e)) {
                let i = t[e];
                void 0 !== i && r.set(e, i);
              }
            return r.toString();
          })(l[1] || "", {
            auth: s,
            ua: d,
            projectId: n,
            useOnCloseEvent: a || void 0,
            packageName: c || void 0,
            bundleId: o || void 0,
          });
        return l[0] + "?" + u;
      }
      function ep(e, t) {
        return e.filter((e) => t.includes(e)).length === e.length;
      }
      function eg(e) {
        return Object.fromEntries(e.entries());
      }
      function em(e) {
        return new Map(Object.entries(e));
      }
      function eb(e = f.FIVE_MINUTES, t) {
        let r, i, s, n;
        let a = (0, f.toMiliseconds)(e || f.FIVE_MINUTES);
        return {
          resolve: (e) => {
            s && r && (clearTimeout(s), r(e), (n = Promise.resolve(e)));
          },
          reject: (e) => {
            s && i && (clearTimeout(s), i(e));
          },
          done: () =>
            new Promise((e, o) => {
              if (n) return e(n);
              (s = setTimeout(() => {
                let e = Error(t);
                (n = Promise.reject(e)), o(e);
              }, a)),
                (r = e),
                (i = o);
            }),
        };
      }
      function ey(e, t, r) {
        return new Promise(async (i, s) => {
          let n = setTimeout(() => s(Error(r)), t);
          try {
            let t = await e;
            i(t);
          } catch (e) {
            s(e);
          }
          clearTimeout(n);
        });
      }
      function ew(e, t) {
        if ("string" == typeof t && t.startsWith(`${e}:`)) return t;
        if ("topic" === e.toLowerCase()) {
          if ("string" != typeof t)
            throw Error(
              'Value must be "string" for expirer target type: topic'
            );
          return `topic:${t}`;
        }
        if ("id" === e.toLowerCase()) {
          if ("number" != typeof t)
            throw Error('Value must be "number" for expirer target type: id');
          return `id:${t}`;
        }
        throw Error(`Unknown expirer target type: ${e}`);
      }
      function ev(e) {
        return ew("topic", e);
      }
      function eA(e) {
        return ew("id", e);
      }
      function eE(e) {
        let [t, r] = e.split(":"),
          i = { id: void 0, topic: void 0 };
        if ("topic" === t && "string" == typeof r) i.topic = r;
        else if ("id" === t && Number.isInteger(Number(r))) i.id = Number(r);
        else
          throw Error(
            `Invalid target, expected id:number or topic:string, got ${t}:${r}`
          );
        return i;
      }
      function e_(e, t) {
        return (0, f.fromMiliseconds)(
          (t || Date.now()) + (0, f.toMiliseconds)(e)
        );
      }
      function eC(e) {
        return Date.now() >= (0, f.toMiliseconds)(e);
      }
      function eI(e, t) {
        return `${e}${t ? `:${t}` : ""}`;
      }
      function eS(e = [], t = []) {
        return [...new Set([...e, ...t])];
      }
      async function ex({ id: e, topic: t, wcDeepLink: i }) {
        var s, n;
        try {
          if (!i) return;
          let a = "string" == typeof i ? JSON.parse(i) : i,
            o = a?.href;
          if ("string" != typeof o) return;
          let c = (function (e, t, r) {
              let i = `requestId=${t}&sessionTopic=${r}`;
              e.endsWith("/") && (e = e.slice(0, -1));
              let s = `${e}`;
              if (e.startsWith("https://t.me")) {
                let t = e.includes("?") ? "&startapp=" : "?startapp=";
                s = `${s}${t}${(function (e, t = !1) {
                  let r = J.from(e).toString("base64");
                  return t ? r.replace(/[=]/g, "") : r;
                })(i, !0)}`;
              } else s = `${s}/wc?${i}`;
              return s;
            })(o, e, t),
            l = el();
          if (l === ei.browser) {
            let e;
            if (!(null != (s = (0, p.getDocument)()) && s.hasFocus())) {
              console.warn("Document does not have focus, skipping deeplink.");
              return;
            }
            (n = c),
              (e = "_self"),
              !(function () {
                try {
                  return window.self !== window.top;
                } catch {
                  return !1;
                }
              })()
                ? (("u" > typeof window &&
                    (!!window.TelegramWebviewProxy ||
                      !!window.Telegram ||
                      !!window.TelegramWebviewProxyProto)) ||
                    n.startsWith("https://") ||
                    n.startsWith("http://")) &&
                  (e = "_blank")
                : (e = "_top"),
              window.open(n, e, "noreferrer noopener");
          } else
            l === ei.reactNative &&
              "u" > typeof (null == r.g ? void 0 : r.g.Linking) &&
              (await r.g.Linking.openURL(c));
        } catch (e) {
          console.error(e);
        }
      }
      async function eN(e, t) {
        let r = "";
        try {
          if (ec() && (r = localStorage.getItem(t))) return r;
          r = await e.getItem(t);
        } catch (e) {
          console.error(e);
        }
        return r;
      }
      function eT(e, t) {
        if (!e.includes(t)) return null;
        let r = e.split(/([&,?,=])/),
          i = r.indexOf(t);
        return r[i + 2];
      }
      function eP() {
        return "u" > typeof crypto && null != crypto && crypto.randomUUID
          ? crypto.randomUUID()
          : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
              let t = (16 * Math.random()) | 0;
              return ("x" === e ? t : (3 & t) | 8).toString(16);
            });
      }
      function eO() {
        return "u" > typeof Z && "true" === Z.env.IS_VITEST;
      }
      function ek(e) {
        return J.from(e, "base64").toString("utf-8");
      }
      function eR(e) {
        return new Promise((t) => setTimeout(t, e));
      }
      function eD(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function eM(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function eU(e) {
        if ("function" != typeof e || "function" != typeof e.create)
          throw Error("Hash should be wrapped by utils.wrapConstructor");
        eD(e.outputLen), eD(e.blockLen);
      }
      function eL(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function eB(e, t) {
        eM(e);
        let r = t.outputLen;
        if (e.length < r)
          throw Error(
            "digestInto() expects output buffer of length at least " + r
          );
      }
      let ej = BigInt(0x100000000 - 1),
        eF = BigInt(32),
        e$ = (e, t, r) => (e << r) | (t >>> (32 - r)),
        ez = (e, t, r) => (t << r) | (e >>> (32 - r)),
        eW = (e, t, r) => (t << (r - 32)) | (e >>> (64 - r)),
        eH = (e, t, r) => (e << (r - 32)) | (t >>> (64 - r)),
        eq =
          "object" == typeof globalThis && "crypto" in globalThis
            ? globalThis.crypto
            : void 0;
      function eV(e) {
        return new DataView(e.buffer, e.byteOffset, e.byteLength);
      }
      function eK(e, t) {
        return (e << (32 - t)) | (e >>> t);
      }
      let eG = 68 === new Uint8Array(new Uint32Array([0x11223344]).buffer)[0];
      function eY(e) {
        for (let r = 0; r < e.length; r++) {
          var t;
          e[r] =
            (((t = e[r]) << 24) & 0xff000000) |
            ((t << 8) & 0xff0000) |
            ((t >>> 8) & 65280) |
            ((t >>> 24) & 255);
        }
      }
      function eQ(e) {
        return (
          "string" == typeof e &&
            (e = (function (e) {
              if ("string" != typeof e)
                throw Error("utf8ToBytes expected string, got " + typeof e);
              return new Uint8Array(new TextEncoder().encode(e));
            })(e)),
          eM(e),
          e
        );
      }
      class eZ {
        clone() {
          return this._cloneInto();
        }
      }
      function eJ(e) {
        let t = (t) => e().update(eQ(t)).digest(),
          r = e();
        return (
          (t.outputLen = r.outputLen),
          (t.blockLen = r.blockLen),
          (t.create = () => e()),
          t
        );
      }
      function eX(e = 32) {
        if (eq && "function" == typeof eq.getRandomValues)
          return eq.getRandomValues(new Uint8Array(e));
        if (eq && "function" == typeof eq.randomBytes) return eq.randomBytes(e);
        throw Error("crypto.getRandomValues must be defined");
      }
      let e0 = [],
        e1 = [],
        e2 = [],
        e3 = BigInt(0),
        e5 = BigInt(1),
        e8 = BigInt(2),
        e6 = BigInt(7),
        e4 = BigInt(256),
        e9 = BigInt(113);
      for (let e = 0, t = e5, r = 1, i = 0; e < 24; e++) {
        ([r, i] = [i, (2 * r + 3 * i) % 5]),
          e0.push(2 * (5 * i + r)),
          e1.push((((e + 1) * (e + 2)) / 2) % 64);
        let s = e3;
        for (let e = 0; e < 7; e++)
          (t = ((t << e5) ^ ((t >> e6) * e9)) % e4) & e8 &&
            (s ^= e5 << ((e5 << BigInt(e)) - e5));
        e2.push(s);
      }
      let [e7, te] = (function (e, t = !1) {
          let r = new Uint32Array(e.length),
            i = new Uint32Array(e.length);
          for (let s = 0; s < e.length; s++) {
            let { h: n, l: a } = (function (e, t = !1) {
              return t
                ? { h: Number(e & ej), l: Number((e >> eF) & ej) }
                : { h: 0 | Number((e >> eF) & ej), l: 0 | Number(e & ej) };
            })(e[s], t);
            [r[s], i[s]] = [n, a];
          }
          return [r, i];
        })(e2, !0),
        tt = (e, t, r) => (r > 32 ? eW(e, t, r) : e$(e, t, r)),
        tr = (e, t, r) => (r > 32 ? eH(e, t, r) : ez(e, t, r));
      class ti extends eZ {
        constructor(e, t, r, i = !1, s = 24) {
          if (
            (super(),
            (this.blockLen = e),
            (this.suffix = t),
            (this.outputLen = r),
            (this.enableXOF = i),
            (this.rounds = s),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            eD(r),
            0 >= this.blockLen || this.blockLen >= 200)
          )
            throw Error("Sha3 supports only keccak-f1600 function");
          (this.state = new Uint8Array(200)),
            (this.state32 = (function (e) {
              return new Uint32Array(
                e.buffer,
                e.byteOffset,
                Math.floor(e.byteLength / 4)
              );
            })(this.state));
        }
        keccak() {
          eG || eY(this.state32),
            (function (e, t = 24) {
              let r = new Uint32Array(10);
              for (let i = 24 - t; i < 24; i++) {
                for (let t = 0; t < 10; t++)
                  r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
                for (let t = 0; t < 10; t += 2) {
                  let i = (t + 8) % 10,
                    s = (t + 2) % 10,
                    n = r[s],
                    a = r[s + 1],
                    o = tt(n, a, 1) ^ r[i],
                    c = tr(n, a, 1) ^ r[i + 1];
                  for (let r = 0; r < 50; r += 10)
                    (e[t + r] ^= o), (e[t + r + 1] ^= c);
                }
                let t = e[2],
                  s = e[3];
                for (let r = 0; r < 24; r++) {
                  let i = e1[r],
                    n = tt(t, s, i),
                    a = tr(t, s, i),
                    o = e0[r];
                  (t = e[o]), (s = e[o + 1]), (e[o] = n), (e[o + 1] = a);
                }
                for (let t = 0; t < 50; t += 10) {
                  for (let i = 0; i < 10; i++) r[i] = e[t + i];
                  for (let i = 0; i < 10; i++)
                    e[t + i] ^= ~r[(i + 2) % 10] & r[(i + 4) % 10];
                }
                (e[0] ^= e7[i]), (e[1] ^= te[i]);
              }
              r.fill(0);
            })(this.state32, this.rounds),
            eG || eY(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(e) {
          eL(this);
          let { blockLen: t, state: r } = this,
            i = (e = eQ(e)).length;
          for (let s = 0; s < i; ) {
            let n = Math.min(t - this.pos, i - s);
            for (let t = 0; t < n; t++) r[this.pos++] ^= e[s++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: e, suffix: t, pos: r, blockLen: i } = this;
          (e[r] ^= t),
            (128 & t) != 0 && r === i - 1 && this.keccak(),
            (e[i - 1] ^= 128),
            this.keccak();
        }
        writeInto(e) {
          eL(this, !1), eM(e), this.finish();
          let t = this.state,
            { blockLen: r } = this;
          for (let i = 0, s = e.length; i < s; ) {
            this.posOut >= r && this.keccak();
            let n = Math.min(r - this.posOut, s - i);
            e.set(t.subarray(this.posOut, this.posOut + n), i),
              (this.posOut += n),
              (i += n);
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF)
            throw Error("XOF is not possible for this instance");
          return this.writeInto(e);
        }
        xof(e) {
          return eD(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if ((eB(e, this), this.finished))
            throw Error("digest() was already called");
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), this.state.fill(0);
        }
        _cloneInto(e) {
          let {
            blockLen: t,
            suffix: r,
            outputLen: i,
            rounds: s,
            enableXOF: n,
          } = this;
          return (
            e || (e = new ti(t, r, i, n, s)),
            e.state32.set(this.state32),
            (e.pos = this.pos),
            (e.posOut = this.posOut),
            (e.finished = this.finished),
            (e.rounds = s),
            (e.suffix = r),
            (e.outputLen = i),
            (e.enableXOF = n),
            (e.destroyed = this.destroyed),
            e
          );
        }
      }
      let ts = eJ(() => new ti(136, 1, 32));
      function tn(e) {
        let t = `Ethereum Signed Message:
${e.length}`,
          r = new TextEncoder().encode(t + e);
        return "0x" + J.from(ts(r)).toString("hex");
      }
      async function ta(e, t, r, i, s, n) {
        switch (r.t) {
          case "eip191":
            return await to(e, t, r.s);
          case "eip1271":
            return await tc(e, t, r.s, i, s, n);
          default:
            throw Error(
              `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r.t}`
            );
        }
      }
      async function to(e, t, r) {
        return (
          (await W({ hash: tn(t), signature: r })).toLowerCase() ===
          e.toLowerCase()
        );
      }
      async function tc(e, t, r, i, s, n) {
        let a = X(i);
        if (!a.namespace || !a.reference)
          throw Error(
            `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${i}`
          );
        try {
          let a = "0x1626ba7e",
            o = r.substring(2),
            c = tn(t).substring(2),
            l =
              a +
              c +
              "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000041" +
              o,
            d = await fetch(
              `${
                n || "https://rpc.walletconnect.org/v1"
              }/?chainId=${i}&projectId=${s}`,
              {
                method: "POST",
                body: JSON.stringify({
                  id: Date.now() + Math.floor(1e3 * Math.random()),
                  jsonrpc: "2.0",
                  method: "eth_call",
                  params: [{ to: e, data: l }, "latest"],
                }),
              }
            ),
            { result: u } = await d.json();
          return !!u && u.slice(0, a.length).toLowerCase() === a.toLowerCase();
        } catch (e) {
          return console.error("isValidEip1271Signature: ", e), !1;
        }
      }
      function tl(e) {
        let t = atob(e),
          r = new Uint8Array(t.length);
        for (let e = 0; e < t.length; e++) r[e] = t.charCodeAt(e);
        let i = r[0];
        if (0 === i) throw Error("No signatures found");
        if (r.length < 1 + 64 * i)
          throw Error("Transaction data too short for claimed signature count");
        if (r.length < 100) throw Error("Transaction too short");
        let s = J.from(e, "base64").slice(1, 65);
        return H.A.encode(s);
      }
      var td = Object.defineProperty,
        tu = Object.defineProperties,
        th = Object.getOwnPropertyDescriptors,
        tf = Object.getOwnPropertySymbols,
        tp = Object.prototype.hasOwnProperty,
        tg = Object.prototype.propertyIsEnumerable,
        tm = (e, t, r) =>
          t in e
            ? td(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        tb = (e, t) => {
          for (var r in t || (t = {})) tp.call(t, r) && tm(e, r, t[r]);
          if (tf) for (var r of tf(t)) tg.call(t, r) && tm(e, r, t[r]);
          return e;
        },
        ty = (e, t) => tu(e, th(t));
      let tw = (e) => e?.split(":"),
        tv = (e) => {
          let t = e && tw(e);
          if (t) return e.includes("did:pkh:") ? t[3] : t[1];
        },
        tA = (e) => {
          let t = e && tw(e);
          if (t) return t[2] + ":" + t[3];
        },
        tE = (e) => {
          let t = e && tw(e);
          if (t) return t.pop();
        };
      async function t_(e) {
        let { cacao: t, projectId: r } = e,
          { s: i, p: s } = t,
          n = tC(s, s.iss),
          a = tE(s.iss);
        return await ta(a, n, i, tA(s.iss), r);
      }
      let tC = (e, t) => {
        let r = `${e.domain} wants you to sign in with your Ethereum account:`,
          i = tE(t);
        if (!e.aud && !e.uri)
          throw Error(
            "Either `aud` or `uri` is required to construct the message"
          );
        let s = e.statement || void 0,
          n = `URI: ${e.aud || e.uri}`,
          a = `Version: ${e.version}`,
          o = `Chain ID: ${tv(t)}`,
          c = `Nonce: ${e.nonce}`,
          l = `Issued At: ${e.iat}`,
          d = e.exp ? `Expiration Time: ${e.exp}` : void 0,
          u = e.nbf ? `Not Before: ${e.nbf}` : void 0,
          h = e.requestId ? `Request ID: ${e.requestId}` : void 0,
          f = e.resources
            ? `Resources:${e.resources
                .map(
                  (e) => `
- ${e}`
                )
                .join("")}`
            : void 0,
          p = tk(e.resources);
        return (
          p &&
            (s = (function (e = "", t) {
              tI(t);
              let r =
                "I further authorize the stated URI to perform the following actions on my behalf: ";
              if (e.includes(r)) return e;
              let i = [],
                s = 0;
              Object.keys(t.att).forEach((e) => {
                let r = Object.keys(t.att[e]).map((e) => ({
                  ability: e.split("/")[0],
                  action: e.split("/")[1],
                }));
                r.sort((e, t) => e.action.localeCompare(t.action));
                let n = {};
                r.forEach((e) => {
                  n[e.ability] || (n[e.ability] = []),
                    n[e.ability].push(e.action);
                });
                let a = Object.keys(n).map(
                  (t) => (
                    s++, `(${s}) '${t}': '${n[t].join("', '")}' for '${e}'.`
                  )
                );
                i.push(a.join(", ").replace(".,", "."));
              });
              let n = i.join(" "),
                a = `${r}${n}`;
              return `${e ? e + " " : ""}${a}`;
            })(s, tx(p))),
          [r, i, "", s, "", n, a, o, c, l, d, u, h, f].filter((e) => null != e)
            .join(`
`)
        );
      };
      function tI(e) {
        if (!e) throw Error("No recap provided, value is undefined");
        if (!e.att) throw Error("No `att` property found");
        let t = Object.keys(e.att);
        if (!(null != t && t.length))
          throw Error("No resources found in `att` property");
        t.forEach((t) => {
          let r = e.att[t];
          if (Array.isArray(r) || "object" != typeof r)
            throw Error(`Resource must be an object: ${t}`);
          if (!Object.keys(r).length)
            throw Error(`Resource object is empty: ${t}`);
          Object.keys(r).forEach((e) => {
            let t = r[e];
            if (!Array.isArray(t))
              throw Error(
                `Ability limits ${e} must be an array of objects, found: ${t}`
              );
            if (!t.length)
              throw Error(
                `Value of ${e} is empty array, must be an array with objects`
              );
            t.forEach((t) => {
              if ("object" != typeof t)
                throw Error(
                  `Ability limits (${e}) must be an array of objects, found: ${t}`
                );
            });
          });
        });
      }
      function tS(e) {
        return (
          tI(e),
          `urn:recap:${J.from(JSON.stringify(e))
            .toString("base64")
            .replace(/=/g, "")}`
        );
      }
      function tx(e) {
        var t;
        let r =
          ((t = e.replace("urn:recap:", "")),
          JSON.parse(J.from(t, "base64").toString("utf-8")));
        return tI(r), r;
      }
      function tN(e, t, r) {
        return tS(
          (function (e, t, r, i = {}) {
            return (
              r?.sort((e, t) => e.localeCompare(t)),
              {
                att: {
                  [e]: (function (e, t, r = {}) {
                    return Object.assign(
                      {},
                      ...(t = t?.sort((e, t) => e.localeCompare(t))).map(
                        (t) => ({ [`${e}/${t}`]: [r] })
                      )
                    );
                  })(t, r, i),
                },
              }
            );
          })(e, t, r)
        );
      }
      function tT(e, t) {
        return tS(
          (function (e, t) {
            tI(e), tI(t);
            let r = Object.keys(e.att)
                .concat(Object.keys(t.att))
                .sort((e, t) => e.localeCompare(t)),
              i = { att: {} };
            return (
              r.forEach((r) => {
                var s, n;
                Object.keys((null == (s = e.att) ? void 0 : s[r]) || {})
                  .concat(
                    Object.keys((null == (n = t.att) ? void 0 : n[r]) || {})
                  )
                  .sort((e, t) => e.localeCompare(t))
                  .forEach((s) => {
                    var n, a;
                    i.att[r] = ty(tb({}, i.att[r]), {
                      [s]:
                        (null == (n = e.att[r]) ? void 0 : n[s]) ||
                        (null == (a = t.att[r]) ? void 0 : a[s]),
                    });
                  });
              }),
              i
            );
          })(tx(e), tx(t))
        );
      }
      function tP(e) {
        var t;
        let r = tx(e);
        tI(r);
        let i = null == (t = r.att) ? void 0 : t.eip155;
        return i ? Object.keys(i).map((e) => e.split("/")[1]) : [];
      }
      function tO(e) {
        let t = tx(e);
        tI(t);
        let r = [];
        return (
          Object.values(t.att).forEach((e) => {
            Object.values(e).forEach((e) => {
              var t;
              null != (t = e?.[0]) && t.chains && r.push(e[0].chains);
            });
          }),
          [...new Set(r.flat())]
        );
      }
      function tk(e) {
        var t;
        if (!e) return;
        let r = e?.[e.length - 1];
        return (t = r) && t.includes("urn:recap:") ? r : void 0;
      }
      function tR(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function tD(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function tM(e, ...t) {
        if (!tD(e)) throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function tU(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function tL(e) {
        if ("boolean" != typeof e) throw Error(`boolean expected, not ${e}`);
      }
      let tB = (e) =>
          new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
        tj = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
      if (68 !== new Uint8Array(new Uint32Array([0x11223344]).buffer)[0])
        throw Error("Non little-endian hardware is not supported");
      function tF(e) {
        if ("string" == typeof e)
          e = (function (e) {
            if ("string" != typeof e) throw Error("string expected");
            return new Uint8Array(new TextEncoder().encode(e));
          })(e);
        else if (tD(e)) e = tW(e);
        else throw Error("Uint8Array expected, got " + typeof e);
        return e;
      }
      function t$(e, t, r = !0) {
        if (void 0 === t) return new Uint8Array(e);
        if (t.length !== e)
          throw Error(
            "invalid output length, expected " + e + ", got: " + t.length
          );
        if (r && t.byteOffset % 4 != 0)
          throw Error("invalid output, must be aligned");
        return t;
      }
      function tz(e, t, r, i) {
        if ("function" == typeof e.setBigUint64) return e.setBigUint64(t, r, i);
        let s = BigInt(32),
          n = BigInt(0xffffffff),
          a = Number((r >> s) & n),
          o = Number(r & n),
          c = 4 * !!i,
          l = 4 * !i;
        e.setUint32(t + c, a, i), e.setUint32(t + l, o, i);
      }
      function tW(e) {
        return Uint8Array.from(e);
      }
      function tH(...e) {
        for (let t = 0; t < e.length; t++) e[t].fill(0);
      }
      let tq = (e) => Uint8Array.from(e.split("").map((e) => e.charCodeAt(0))),
        tV = tq("expand 16-byte k"),
        tK = tq("expand 32-byte k"),
        tG = tB(tV),
        tY = tB(tK);
      function tQ(e, t) {
        return (e << t) | (e >>> (32 - t));
      }
      function tZ(e) {
        return e.byteOffset % 4 == 0;
      }
      let tJ = 0x100000000 - 1,
        tX = new Uint32Array(),
        t0 = (e, t) => (255 & e[t++]) | ((255 & e[t++]) << 8);
      class t1 {
        constructor(e) {
          (this.blockLen = 16),
            (this.outputLen = 16),
            (this.buffer = new Uint8Array(16)),
            (this.r = new Uint16Array(10)),
            (this.h = new Uint16Array(10)),
            (this.pad = new Uint16Array(8)),
            (this.pos = 0),
            (this.finished = !1),
            tM((e = tF(e)), 32);
          let t = t0(e, 0),
            r = t0(e, 2),
            i = t0(e, 4),
            s = t0(e, 6),
            n = t0(e, 8),
            a = t0(e, 10),
            o = t0(e, 12),
            c = t0(e, 14);
          (this.r[0] = 8191 & t),
            (this.r[1] = ((t >>> 13) | (r << 3)) & 8191),
            (this.r[2] = ((r >>> 10) | (i << 6)) & 7939),
            (this.r[3] = ((i >>> 7) | (s << 9)) & 8191),
            (this.r[4] = ((s >>> 4) | (n << 12)) & 255),
            (this.r[5] = (n >>> 1) & 8190),
            (this.r[6] = ((n >>> 14) | (a << 2)) & 8191),
            (this.r[7] = ((a >>> 11) | (o << 5)) & 8065),
            (this.r[8] = ((o >>> 8) | (c << 8)) & 8191),
            (this.r[9] = (c >>> 5) & 127);
          for (let t = 0; t < 8; t++) this.pad[t] = t0(e, 16 + 2 * t);
        }
        process(e, t, r = !1) {
          let { h: i, r: s } = this,
            n = s[0],
            a = s[1],
            o = s[2],
            c = s[3],
            l = s[4],
            d = s[5],
            u = s[6],
            h = s[7],
            f = s[8],
            p = s[9],
            g = t0(e, t + 0),
            m = t0(e, t + 2),
            b = t0(e, t + 4),
            y = t0(e, t + 6),
            w = t0(e, t + 8),
            v = t0(e, t + 10),
            A = t0(e, t + 12),
            E = t0(e, t + 14),
            _ = i[0] + (8191 & g),
            C = i[1] + (((g >>> 13) | (m << 3)) & 8191),
            I = i[2] + (((m >>> 10) | (b << 6)) & 8191),
            S = i[3] + (((b >>> 7) | (y << 9)) & 8191),
            x = i[4] + (((y >>> 4) | (w << 12)) & 8191),
            N = i[5] + ((w >>> 1) & 8191),
            T = i[6] + (((w >>> 14) | (v << 2)) & 8191),
            P = i[7] + (((v >>> 11) | (A << 5)) & 8191),
            O = i[8] + (((A >>> 8) | (E << 8)) & 8191),
            k = i[9] + ((E >>> 5) | (2048 * !r)),
            R = 0,
            D = 0 + _ * n + 5 * p * C + 5 * f * I + 5 * h * S + 5 * u * x;
          (R = D >>> 13),
            (D &= 8191),
            (D += 5 * d * N + 5 * l * T + 5 * c * P + 5 * o * O + 5 * a * k),
            (R += D >>> 13),
            (D &= 8191);
          let M = R + _ * a + C * n + 5 * p * I + 5 * f * S + 5 * h * x;
          (R = M >>> 13),
            (M &= 8191),
            (M += 5 * u * N + 5 * d * T + 5 * l * P + 5 * c * O + 5 * o * k),
            (R += M >>> 13),
            (M &= 8191);
          let U = R + _ * o + C * a + I * n + 5 * p * S + 5 * f * x;
          (R = U >>> 13),
            (U &= 8191),
            (U += 5 * h * N + 5 * u * T + 5 * d * P + 5 * l * O + 5 * c * k),
            (R += U >>> 13),
            (U &= 8191);
          let L = R + _ * c + C * o + I * a + S * n + 5 * p * x;
          (R = L >>> 13),
            (L &= 8191),
            (L += 5 * f * N + 5 * h * T + 5 * u * P + 5 * d * O + 5 * l * k),
            (R += L >>> 13),
            (L &= 8191);
          let B = R + _ * l + C * c + I * o + S * a + x * n;
          (R = B >>> 13),
            (B &= 8191),
            (B += 5 * p * N + 5 * f * T + 5 * h * P + 5 * u * O + 5 * d * k),
            (R += B >>> 13),
            (B &= 8191);
          let j = R + _ * d + C * l + I * c + S * o + x * a;
          (R = j >>> 13),
            (j &= 8191),
            (j += N * n + 5 * p * T + 5 * f * P + 5 * h * O + 5 * u * k),
            (R += j >>> 13),
            (j &= 8191);
          let F = R + _ * u + C * d + I * l + S * c + x * o;
          (R = F >>> 13),
            (F &= 8191),
            (F += N * a + T * n + 5 * p * P + 5 * f * O + 5 * h * k),
            (R += F >>> 13),
            (F &= 8191);
          let $ = R + _ * h + C * u + I * d + S * l + x * c;
          (R = $ >>> 13),
            ($ &= 8191),
            ($ += N * o + T * a + P * n + 5 * p * O + 5 * f * k),
            (R += $ >>> 13),
            ($ &= 8191);
          let z = R + _ * f + C * h + I * u + S * d + x * l;
          (R = z >>> 13),
            (z &= 8191),
            (z += N * c + T * o + P * a + O * n + 5 * p * k),
            (R += z >>> 13),
            (z &= 8191);
          let W = R + _ * p + C * f + I * h + S * u + x * d;
          (R = W >>> 13),
            (W &= 8191),
            (W += N * l + T * c + P * o + O * a + k * n),
            (R += W >>> 13),
            (W &= 8191),
            (D = 8191 & (R = ((R = ((R << 2) + R) | 0) + D) | 0)),
            (R >>>= 13),
            (M += R),
            (i[0] = D),
            (i[1] = M),
            (i[2] = U),
            (i[3] = L),
            (i[4] = B),
            (i[5] = j),
            (i[6] = F),
            (i[7] = $),
            (i[8] = z),
            (i[9] = W);
        }
        finalize() {
          let { h: e, pad: t } = this,
            r = new Uint16Array(10),
            i = e[1] >>> 13;
          e[1] &= 8191;
          for (let t = 2; t < 10; t++)
            (e[t] += i), (i = e[t] >>> 13), (e[t] &= 8191);
          (e[0] += 5 * i),
            (i = e[0] >>> 13),
            (e[0] &= 8191),
            (e[1] += i),
            (i = e[1] >>> 13),
            (e[1] &= 8191),
            (e[2] += i),
            (r[0] = e[0] + 5),
            (i = r[0] >>> 13),
            (r[0] &= 8191);
          for (let t = 1; t < 10; t++)
            (r[t] = e[t] + i), (i = r[t] >>> 13), (r[t] &= 8191);
          r[9] -= 8192;
          let s = (1 ^ i) - 1;
          for (let e = 0; e < 10; e++) r[e] &= s;
          s = ~s;
          for (let t = 0; t < 10; t++) e[t] = (e[t] & s) | r[t];
          (e[0] = (e[0] | (e[1] << 13)) & 65535),
            (e[1] = ((e[1] >>> 3) | (e[2] << 10)) & 65535),
            (e[2] = ((e[2] >>> 6) | (e[3] << 7)) & 65535),
            (e[3] = ((e[3] >>> 9) | (e[4] << 4)) & 65535),
            (e[4] = ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14)) & 65535),
            (e[5] = ((e[6] >>> 2) | (e[7] << 11)) & 65535),
            (e[6] = ((e[7] >>> 5) | (e[8] << 8)) & 65535),
            (e[7] = ((e[8] >>> 8) | (e[9] << 5)) & 65535);
          let n = e[0] + t[0];
          e[0] = 65535 & n;
          for (let r = 1; r < 8; r++)
            (n = (((e[r] + t[r]) | 0) + (n >>> 16)) | 0), (e[r] = 65535 & n);
          tH(r);
        }
        update(e) {
          tU(this);
          let { buffer: t, blockLen: r } = this,
            i = (e = tF(e)).length;
          for (let s = 0; s < i; ) {
            let n = Math.min(r - this.pos, i - s);
            if (n === r) {
              for (; r <= i - s; s += r) this.process(e, s);
              continue;
            }
            t.set(e.subarray(s, s + n), this.pos),
              (this.pos += n),
              (s += n),
              this.pos === r && (this.process(t, 0, !1), (this.pos = 0));
          }
          return this;
        }
        destroy() {
          tH(this.h, this.r, this.buffer, this.pad);
        }
        digestInto(e) {
          tU(this),
            (function (e, t) {
              tM(e);
              let r = t.outputLen;
              if (e.length < r)
                throw Error(
                  "digestInto() expects output buffer of length at least " + r
                );
            })(e, this),
            (this.finished = !0);
          let { buffer: t, h: r } = this,
            { pos: i } = this;
          if (i) {
            for (t[i++] = 1; i < 16; i++) t[i] = 0;
            this.process(t, 0, !0);
          }
          this.finalize();
          let s = 0;
          for (let t = 0; t < 8; t++)
            (e[s++] = r[t] >>> 0), (e[s++] = r[t] >>> 8);
          return e;
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
      }
      let t2 = (function (e) {
          let t = (t, r) => e(r).update(tF(t)).digest(),
            r = e(new Uint8Array(32));
          return (
            (t.outputLen = r.outputLen),
            (t.blockLen = r.blockLen),
            (t.create = (t) => e(t)),
            t
          );
        })((e) => new t1(e)),
        t3 = (function (e, t) {
          let {
            allowShortKeys: r,
            extendNonceFn: i,
            counterLength: s,
            counterRight: n,
            rounds: a,
          } = (function (e, t) {
            if (null == t || "object" != typeof t)
              throw Error("options must be defined");
            return Object.assign(e, t);
          })(
            {
              allowShortKeys: !1,
              counterLength: 8,
              counterRight: !1,
              rounds: 20,
            },
            t
          );
          if ("function" != typeof e) throw Error("core must be a function");
          return (
            tR(s),
            tR(a),
            tL(n),
            tL(r),
            (t, o, c, l, d = 0) => {
              tM(t), tM(o), tM(c);
              let u = c.length;
              if (
                (void 0 === l && (l = new Uint8Array(u)),
                tM(l),
                tR(d),
                d < 0 || d >= tJ)
              )
                throw Error("arx: counter overflow");
              if (l.length < u)
                throw Error(
                  `arx: output (${l.length}) is shorter than data (${u})`
                );
              let h = [],
                f = t.length,
                p,
                g;
              if (32 === f) h.push((p = tW(t))), (g = tY);
              else if (16 === f && r)
                (p = new Uint8Array(32)).set(t),
                  p.set(t, 16),
                  (g = tG),
                  h.push(p);
              else throw Error(`arx: invalid 32-byte key, got length=${f}`);
              tZ(o) || h.push((o = tW(o)));
              let m = tB(p);
              if (i) {
                if (24 !== o.length)
                  throw Error("arx: extended nonce must be 24 bytes");
                i(g, m, tB(o.subarray(0, 16)), m), (o = o.subarray(16));
              }
              let b = 16 - s;
              if (b !== o.length)
                throw Error(`arx: nonce must be ${b} or 16 bytes`);
              if (12 !== b) {
                let e = new Uint8Array(12);
                e.set(o, n ? 0 : 12 - o.length), (o = e), h.push(o);
              }
              return (
                (function (e, t, r, i, s, n, a, o) {
                  let c = s.length,
                    l = new Uint8Array(64),
                    d = tB(l),
                    u = tZ(s) && tZ(n),
                    h = u ? tB(s) : tX,
                    f = u ? tB(n) : tX;
                  for (let p = 0; p < c; a++) {
                    if ((e(t, r, i, d, a, o), a >= tJ))
                      throw Error("arx: counter overflow");
                    let g = Math.min(64, c - p);
                    if (u && 64 === g) {
                      let e = p / 4;
                      if (p % 4 != 0)
                        throw Error("arx: invalid block position");
                      for (let t = 0, r; t < 16; t++)
                        f[(r = e + t)] = h[r] ^ d[t];
                      p += 64;
                      continue;
                    }
                    for (let e = 0, t; e < g; e++) n[(t = p + e)] = s[t] ^ l[e];
                    p += g;
                  }
                })(e, g, m, tB(o), c, l, d, a),
                tH(...h),
                l
              );
            }
          );
        })(
          function (e, t, r, i, s, n = 20) {
            let a = e[0],
              o = e[1],
              c = e[2],
              l = e[3],
              d = t[0],
              u = t[1],
              h = t[2],
              f = t[3],
              p = t[4],
              g = t[5],
              m = t[6],
              b = t[7],
              y = r[0],
              w = r[1],
              v = r[2],
              A = a,
              E = o,
              _ = c,
              C = l,
              I = d,
              S = u,
              x = h,
              N = f,
              T = p,
              P = g,
              O = m,
              k = b,
              R = s,
              D = y,
              M = w,
              U = v;
            for (let e = 0; e < n; e += 2)
              (T = (T + (R = tQ(R ^ (A = (A + I) | 0), 16))) | 0),
                (A = (A + (I = tQ(I ^ T, 12))) | 0),
                (T = (T + (R = tQ(R ^ A, 8))) | 0),
                (I = tQ(I ^ T, 7)),
                (P = (P + (D = tQ(D ^ (E = (E + S) | 0), 16))) | 0),
                (E = (E + (S = tQ(S ^ P, 12))) | 0),
                (P = (P + (D = tQ(D ^ E, 8))) | 0),
                (S = tQ(S ^ P, 7)),
                (O = (O + (M = tQ(M ^ (_ = (_ + x) | 0), 16))) | 0),
                (_ = (_ + (x = tQ(x ^ O, 12))) | 0),
                (O = (O + (M = tQ(M ^ _, 8))) | 0),
                (x = tQ(x ^ O, 7)),
                (k = (k + (U = tQ(U ^ (C = (C + N) | 0), 16))) | 0),
                (C = (C + (N = tQ(N ^ k, 12))) | 0),
                (k = (k + (U = tQ(U ^ C, 8))) | 0),
                (N = tQ(N ^ k, 7)),
                (O = (O + (U = tQ(U ^ (A = (A + S) | 0), 16))) | 0),
                (A = (A + (S = tQ(S ^ O, 12))) | 0),
                (O = (O + (U = tQ(U ^ A, 8))) | 0),
                (S = tQ(S ^ O, 7)),
                (k = (k + (R = tQ(R ^ (E = (E + x) | 0), 16))) | 0),
                (E = (E + (x = tQ(x ^ k, 12))) | 0),
                (k = (k + (R = tQ(R ^ E, 8))) | 0),
                (x = tQ(x ^ k, 7)),
                (T = (T + (D = tQ(D ^ (_ = (_ + N) | 0), 16))) | 0),
                (_ = (_ + (N = tQ(N ^ T, 12))) | 0),
                (T = (T + (D = tQ(D ^ _, 8))) | 0),
                (N = tQ(N ^ T, 7)),
                (P = (P + (M = tQ(M ^ (C = (C + I) | 0), 16))) | 0),
                (C = (C + (I = tQ(I ^ P, 12))) | 0),
                (P = (P + (M = tQ(M ^ C, 8))) | 0),
                (I = tQ(I ^ P, 7));
            let L = 0;
            (i[L++] = (a + A) | 0),
              (i[L++] = (o + E) | 0),
              (i[L++] = (c + _) | 0),
              (i[L++] = (l + C) | 0),
              (i[L++] = (d + I) | 0),
              (i[L++] = (u + S) | 0),
              (i[L++] = (h + x) | 0),
              (i[L++] = (f + N) | 0),
              (i[L++] = (p + T) | 0),
              (i[L++] = (g + P) | 0),
              (i[L++] = (m + O) | 0),
              (i[L++] = (b + k) | 0),
              (i[L++] = (s + R) | 0),
              (i[L++] = (y + D) | 0),
              (i[L++] = (w + M) | 0),
              (i[L++] = (v + U) | 0);
          },
          { counterRight: !1, counterLength: 4, allowShortKeys: !1 }
        ),
        t5 = new Uint8Array(16),
        t8 = (e, t) => {
          e.update(t);
          let r = t.length % 16;
          r && e.update(t5.subarray(r));
        },
        t6 = new Uint8Array(32);
      function t4(e, t, r, i, s) {
        let n = e(t, r, t6),
          a = t2.create(n);
        s && t8(a, s), t8(a, i);
        let o = new Uint8Array(16),
          c = tj(o);
        tz(c, 0, BigInt(s ? s.length : 0), !0),
          tz(c, 8, BigInt(i.length), !0),
          a.update(o);
        let l = a.digest();
        return tH(n, o), l;
      }
      let t9 = ((e, t) => {
        function r(i, ...s) {
          if ((tM(i), void 0 !== e.nonceLength)) {
            let t = s[0];
            if (!t) throw Error("nonce / iv required");
            e.varSizeNonce ? tM(t) : tM(t, e.nonceLength);
          }
          let n = e.tagLength;
          n && void 0 !== s[1] && tM(s[1]);
          let a = t(i, ...s),
            o = (e, t) => {
              if (void 0 !== t) {
                if (2 !== e) throw Error("cipher output not supported");
                tM(t);
              }
            },
            c = !1;
          return {
            encrypt(e, t) {
              if (c)
                throw Error("cannot encrypt() twice with same key + nonce");
              return (c = !0), tM(e), o(a.encrypt.length, t), a.encrypt(e, t);
            },
            decrypt(e, t) {
              if ((tM(e), n && e.length < n))
                throw Error(
                  "invalid ciphertext length: smaller than tagLength=" + n
                );
              return o(a.decrypt.length, t), a.decrypt(e, t);
            },
          };
        }
        return Object.assign(r, e), r;
      })(
        { blockSize: 64, nonceLength: 12, tagLength: 16 },
        ((e) => (t, r, i) => ({
          encrypt(s, n) {
            let a = s.length;
            (n = t$(a + 16, n, !1)).set(s);
            let o = n.subarray(0, -16);
            e(t, r, o, o, 1);
            let c = t4(e, t, r, o, i);
            return n.set(c, a), tH(c), n;
          },
          decrypt(s, n) {
            n = t$(s.length - 16, n, !1);
            let a = s.subarray(0, -16),
              o = s.subarray(-16),
              c = t4(e, t, r, a, i);
            if (
              !(function (e, t) {
                if (e.length !== t.length) return !1;
                let r = 0;
                for (let i = 0; i < e.length; i++) r |= e[i] ^ t[i];
                return 0 === r;
              })(o, c)
            )
              throw Error("invalid tag");
            return n.set(s.subarray(0, -16)), e(t, r, n, n, 1), tH(c), n;
          },
        }))(t3)
      );
      class t7 extends eZ {
        constructor(e, t) {
          super(), (this.finished = !1), (this.destroyed = !1), eU(e);
          let r = eQ(t);
          if (
            ((this.iHash = e.create()), "function" != typeof this.iHash.update)
          )
            throw Error("Expected instance of class which extends utils.Hash");
          (this.blockLen = this.iHash.blockLen),
            (this.outputLen = this.iHash.outputLen);
          let i = this.blockLen,
            s = new Uint8Array(i);
          s.set(r.length > i ? e.create().update(r).digest() : r);
          for (let e = 0; e < s.length; e++) s[e] ^= 54;
          this.iHash.update(s), (this.oHash = e.create());
          for (let e = 0; e < s.length; e++) s[e] ^= 106;
          this.oHash.update(s), s.fill(0);
        }
        update(e) {
          return eL(this), this.iHash.update(e), this;
        }
        digestInto(e) {
          eL(this),
            eM(e, this.outputLen),
            (this.finished = !0),
            this.iHash.digestInto(e),
            this.oHash.update(e),
            this.oHash.digestInto(e),
            this.destroy();
        }
        digest() {
          let e = new Uint8Array(this.oHash.outputLen);
          return this.digestInto(e), e;
        }
        _cloneInto(e) {
          e || (e = Object.create(Object.getPrototypeOf(this), {}));
          let {
            oHash: t,
            iHash: r,
            finished: i,
            destroyed: s,
            blockLen: n,
            outputLen: a,
          } = this;
          return (
            (e.finished = i),
            (e.destroyed = s),
            (e.blockLen = n),
            (e.outputLen = a),
            (e.oHash = t._cloneInto(e.oHash)),
            (e.iHash = r._cloneInto(e.iHash)),
            e
          );
        }
        destroy() {
          (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
        }
      }
      let re = (e, t, r) => new t7(e, t).update(r).digest();
      re.create = (e, t) => new t7(e, t);
      let rt = new Uint8Array([0]),
        rr = new Uint8Array(),
        ri = (e, t, r, i, s) =>
          (function (e, t, r, i = 32) {
            if ((eU(e), eD(i), i > 255 * e.outputLen))
              throw Error("Length should be <= 255*HashLen");
            let s = Math.ceil(i / e.outputLen);
            void 0 === r && (r = rr);
            let n = new Uint8Array(s * e.outputLen),
              a = re.create(e, t),
              o = a._cloneInto(),
              c = new Uint8Array(a.outputLen);
            for (let t = 0; t < s; t++)
              (rt[0] = t + 1),
                o
                  .update(0 === t ? rr : c)
                  .update(r)
                  .update(rt)
                  .digestInto(c),
                n.set(c, e.outputLen * t),
                a._cloneInto(o);
            return (
              a.destroy(), o.destroy(), c.fill(0), rt.fill(0), n.slice(0, i)
            );
          })(
            e,
            (function (e, t, r) {
              return (
                eU(e),
                void 0 === r && (r = new Uint8Array(e.outputLen)),
                re(e, eQ(r), eQ(t))
              );
            })(e, t, r),
            i,
            s
          );
      class rs extends eZ {
        constructor(e, t, r, i) {
          super(),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.buffer = new Uint8Array(e)),
            (this.view = eV(this.buffer));
        }
        update(e) {
          eL(this);
          let { view: t, buffer: r, blockLen: i } = this,
            s = (e = eQ(e)).length;
          for (let n = 0; n < s; ) {
            let a = Math.min(i - this.pos, s - n);
            if (a === i) {
              let t = eV(e);
              for (; i <= s - n; n += i) this.process(t, n);
              continue;
            }
            r.set(e.subarray(n, n + a), this.pos),
              (this.pos += a),
              (n += a),
              this.pos === i && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          eL(this), eB(e, this), (this.finished = !0);
          let { buffer: t, view: r, blockLen: i, isLE: s } = this,
            { pos: n } = this;
          (t[n++] = 128),
            this.buffer.subarray(n).fill(0),
            this.padOffset > i - n && (this.process(r, 0), (n = 0));
          for (let e = n; e < i; e++) t[e] = 0;
          (function (e, t, r, i) {
            if ("function" == typeof e.setBigUint64)
              return e.setBigUint64(t, r, i);
            let s = BigInt(32),
              n = BigInt(0xffffffff),
              a = Number((r >> s) & n),
              o = Number(r & n),
              c = 4 * !!i,
              l = 4 * !i;
            e.setUint32(t + c, a, i), e.setUint32(t + l, o, i);
          })(r, i - 8, BigInt(8 * this.length), s),
            this.process(r, 0);
          let a = eV(e),
            o = this.outputLen;
          if (o % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
          let c = o / 4,
            l = this.get();
          if (c > l.length) throw Error("_sha2: outputLen bigger than state");
          for (let e = 0; e < c; e++) a.setUint32(4 * e, l[e], s);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: s,
            destroyed: n,
            pos: a,
          } = this;
          return (
            (e.length = i),
            (e.pos = a),
            (e.finished = s),
            (e.destroyed = n),
            i % t && e.buffer.set(r),
            e
          );
        }
      }
      let rn = new Uint32Array([
          0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
          0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
          0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
          0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f,
          0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d,
          0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x6ca6351, 0x14292967,
          0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354,
          0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
          0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585,
          0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
          0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee,
          0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb,
          0xbef9a3f7, 0xc67178f2,
        ]),
        ra = new Uint32Array([
          0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f,
          0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
        ]),
        ro = new Uint32Array(64);
      class rc extends rs {
        constructor() {
          super(64, 32, 8, !1),
            (this.A = 0 | ra[0]),
            (this.B = 0 | ra[1]),
            (this.C = 0 | ra[2]),
            (this.D = 0 | ra[3]),
            (this.E = 0 | ra[4]),
            (this.F = 0 | ra[5]),
            (this.G = 0 | ra[6]),
            (this.H = 0 | ra[7]);
        }
        get() {
          let { A: e, B: t, C: r, D: i, E: s, F: n, G: a, H: o } = this;
          return [e, t, r, i, s, n, a, o];
        }
        set(e, t, r, i, s, n, a, o) {
          (this.A = 0 | e),
            (this.B = 0 | t),
            (this.C = 0 | r),
            (this.D = 0 | i),
            (this.E = 0 | s),
            (this.F = 0 | n),
            (this.G = 0 | a),
            (this.H = 0 | o);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4) ro[r] = e.getUint32(t, !1);
          for (let e = 16; e < 64; e++) {
            let t = ro[e - 15],
              r = ro[e - 2],
              i = eK(t, 7) ^ eK(t, 18) ^ (t >>> 3),
              s = eK(r, 17) ^ eK(r, 19) ^ (r >>> 10);
            ro[e] = (s + ro[e - 7] + i + ro[e - 16]) | 0;
          }
          let { A: r, B: i, C: s, D: n, E: a, F: o, G: c, H: l } = this;
          for (let e = 0; e < 64; e++) {
            var d, u, h, f;
            let t =
                (l +
                  (eK(a, 6) ^ eK(a, 11) ^ eK(a, 25)) +
                  (((d = a) & o) ^ (~d & c)) +
                  rn[e] +
                  ro[e]) |
                0,
              p =
                ((eK(r, 2) ^ eK(r, 13) ^ eK(r, 22)) +
                  (((u = r) & (h = i)) ^ (u & (f = s)) ^ (h & f))) |
                0;
            (l = c),
              (c = o),
              (o = a),
              (a = (n + t) | 0),
              (n = s),
              (s = i),
              (i = r),
              (r = (t + p) | 0);
          }
          (r = (r + this.A) | 0),
            (i = (i + this.B) | 0),
            (s = (s + this.C) | 0),
            (n = (n + this.D) | 0),
            (a = (a + this.E) | 0),
            (o = (o + this.F) | 0),
            (c = (c + this.G) | 0),
            (l = (l + this.H) | 0),
            this.set(r, i, s, n, a, o, c, l);
        }
        roundClean() {
          ro.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
        }
      }
      let rl = eJ(() => new rc()),
        rd = BigInt(0);
      function ru(e) {
        return (
          e instanceof Uint8Array ||
          (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
        );
      }
      function rh(e) {
        if (!ru(e)) throw Error("Uint8Array expected");
      }
      let rf = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0")
        ),
        rp = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function rg(e) {
        return e >= rp._0 && e <= rp._9
          ? e - rp._0
          : e >= rp.A && e <= rp.F
          ? e - (rp.A - 10)
          : e >= rp.a && e <= rp.f
          ? e - (rp.a - 10)
          : void 0;
      }
      function rm(e) {
        if ("string" != typeof e)
          throw Error("hex string expected, got " + typeof e);
        let t = e.length,
          r = t / 2;
        if (t % 2)
          throw Error("hex string expected, got unpadded hex of length " + t);
        let i = new Uint8Array(r);
        for (let t = 0, s = 0; t < r; t++, s += 2) {
          let r = rg(e.charCodeAt(s)),
            n = rg(e.charCodeAt(s + 1));
          if (void 0 === r || void 0 === n)
            throw Error(
              'hex string expected, got non-hex character "' +
                (e[s] + e[s + 1]) +
                '" at index ' +
                s
            );
          i[t] = 16 * r + n;
        }
        return i;
      }
      function rb(e) {
        return (
          rh(e),
          (function (e) {
            if ("string" != typeof e)
              throw Error("hex string expected, got " + typeof e);
            return "" === e ? rd : BigInt("0x" + e);
          })(
            (function (e) {
              rh(e);
              let t = "";
              for (let r = 0; r < e.length; r++) t += rf[e[r]];
              return t;
            })(Uint8Array.from(e).reverse())
          )
        );
      }
      function ry(e, t, r) {
        let i;
        if ("string" == typeof t)
          try {
            i = rm(t);
          } catch (t) {
            throw Error(e + " must be hex string or Uint8Array, cause: " + t);
          }
        else if (ru(t)) i = Uint8Array.from(t);
        else throw Error(e + " must be hex string or Uint8Array");
        let s = i.length;
        if ("number" == typeof r && s !== r)
          throw Error(e + " of length " + r + " expected, got " + s);
        return i;
      }
      let rw = (e) => "bigint" == typeof e && rd <= e;
      function rv(e, t, r, i) {
        if (!(rw(t) && rw(r) && rw(i)) || !(r <= t) || !(t < i))
          throw Error(
            "expected valid " + e + ": " + r + " <= n < " + i + ", got " + t
          );
      }
      let rA = {
          bigint: (e) => "bigint" == typeof e,
          function: (e) => "function" == typeof e,
          boolean: (e) => "boolean" == typeof e,
          string: (e) => "string" == typeof e,
          stringOrUint8Array: (e) => "string" == typeof e || ru(e),
          isSafeInteger: (e) => Number.isSafeInteger(e),
          array: (e) => Array.isArray(e),
          field: (e, t) => t.Fp.isValid(e),
          hash: (e) =>
            "function" == typeof e && Number.isSafeInteger(e.outputLen),
        },
        rE = BigInt(0),
        r_ = BigInt(1);
      function rC(e, t) {
        let r = e % t;
        return r >= rE ? r : t + r;
      }
      function rI(e, t, r) {
        let i = e;
        for (; t-- > rE; ) (i *= i), (i %= r);
        return i;
      }
      BigInt(0), BigInt(1), BigInt(0), BigInt(1), BigInt(2), BigInt(8);
      let rS = BigInt(0),
        rx = BigInt(1),
        rN = BigInt(
          "57896044618658097711785492504343953926634992332820282019728792003956564819949"
        );
      BigInt(0);
      let rT = BigInt(1),
        rP = BigInt(2),
        rO = BigInt(3),
        rk = BigInt(5);
      BigInt(8);
      let rR = (function (e) {
          let t =
              ((function (e, t, r = {}) {
                let i = (t, r, i) => {
                  let s = rA[r];
                  if ("function" != typeof s)
                    throw Error("invalid validator function");
                  let n = e[t];
                  if (!(i && void 0 === n) && !s(n, e))
                    throw Error(
                      "param " +
                        String(t) +
                        " is invalid. Expected " +
                        r +
                        ", got " +
                        n
                    );
                };
                for (let [e, r] of Object.entries(t)) i(e, r, !1);
                for (let [e, t] of Object.entries(r)) i(e, t, !0);
              })(
                e,
                { a: "bigint" },
                {
                  montgomeryBits: "isSafeInteger",
                  nByteLength: "isSafeInteger",
                  adjustScalarBytes: "function",
                  domain: "function",
                  powPminus2: "function",
                  Gu: "bigint",
                }
              ),
              Object.freeze({ ...e })),
            { P: r } = t,
            i = (e) => rC(e, r),
            s = t.montgomeryBits,
            n = Math.ceil(s / 8),
            a = t.nByteLength,
            o = t.adjustScalarBytes || ((e) => e),
            c =
              t.powPminus2 ||
              ((e) =>
                (function (e, t, r) {
                  if (t < rE)
                    throw Error("invalid exponent, negatives unsupported");
                  if (r <= rE) throw Error("invalid modulus");
                  if (r === r_) return rE;
                  let i = r_;
                  for (; t > rE; )
                    t & r_ && (i = (i * e) % r), (e = (e * e) % r), (t >>= r_);
                  return i;
                })(e, r - BigInt(2), r));
          function l(e, t, r) {
            let s = i(e * (t - r));
            return [(t = i(t - s)), (r = i(r + s))];
          }
          let d = (t.a - BigInt(2)) / BigInt(4);
          function u(e) {
            var t;
            return rm((t = i(e)).toString(16).padStart(2 * n, "0")).reverse();
          }
          function h(e, t) {
            let h = (function (e, t) {
              rv("u", e, rS, r), rv("scalar", t, rS, r);
              let n = rx,
                a = rS,
                o = e,
                u = rx,
                h = rS,
                f;
              for (let r = BigInt(s - 1); r >= rS; r--) {
                let s = (t >> r) & rx;
                (h ^= s),
                  (n = (f = l(h, n, o))[0]),
                  (o = f[1]),
                  (a = (f = l(h, a, u))[0]),
                  (u = f[1]),
                  (h = s);
                let c = n + a,
                  p = i(c * c),
                  g = n - a,
                  m = i(g * g),
                  b = p - m,
                  y = o + u,
                  w = i((o - u) * c),
                  v = i(y * g),
                  A = w + v,
                  E = w - v;
                (o = i(A * A)),
                  (u = i(e * i(E * E))),
                  (n = i(p * m)),
                  (a = i(b * (p + i(d * b))));
              }
              return (
                (n = (f = l(h, n, o))[0]),
                (o = f[1]),
                (a = (f = l(h, a, u))[0]),
                (u = f[1]),
                i(n * c(a))
              );
            })(
              (function (e) {
                let t = ry("u coordinate", e, n);
                return 32 === a && (t[31] &= 127), rb(t);
              })(t),
              (function (e) {
                let t = ry("scalar", e),
                  r = t.length;
                if (r !== n && r !== a)
                  throw Error(
                    "invalid scalar, expected " +
                      ("" + n + " or ") +
                      a +
                      " bytes, got " +
                      r
                  );
                return rb(o(t));
              })(e)
            );
            if (h === rS) throw Error("invalid private or public key received");
            return u(h);
          }
          let f = u(t.Gu);
          function p(e) {
            return h(e, f);
          }
          return {
            scalarMult: h,
            scalarMultBase: p,
            getSharedSecret: (e, t) => h(e, t),
            getPublicKey: (e) => p(e),
            utils: { randomPrivateKey: () => t.randomBytes(t.nByteLength) },
            GuBytes: f,
          };
        })({
          P: rN,
          a: BigInt(486662),
          montgomeryBits: 255,
          nByteLength: 32,
          Gu: BigInt(9),
          powPminus2: (e) => {
            let { pow_p_5_8: t, b2: r } = (function (e) {
              let t = BigInt(10),
                r = BigInt(20),
                i = BigInt(40),
                s = BigInt(80),
                n = (((e * e) % rN) * e) % rN,
                a = (rI(n, rP, rN) * n) % rN,
                o = (rI(a, rT, rN) * e) % rN,
                c = (rI(o, rk, rN) * o) % rN,
                l = (rI(c, t, rN) * c) % rN,
                d = (rI(l, r, rN) * l) % rN,
                u = (rI(d, i, rN) * d) % rN,
                h = (rI(u, s, rN) * u) % rN,
                f = (rI(h, s, rN) * u) % rN,
                p = (rI(f, t, rN) * c) % rN;
              return { pow_p_5_8: (rI(p, rP, rN) * e) % rN, b2: n };
            })(e);
            return rC(rI(t, rO, rN) * r, rN);
          },
          adjustScalarBytes: function (e) {
            return (e[0] &= 248), (e[31] &= 127), (e[31] |= 64), e;
          },
          randomBytes: eX,
        }),
        rD = "base10",
        rM = "base16",
        rU = "base64pad",
        rL = "base64url",
        rB = "utf8",
        rj = 1,
        rF = 2;
      function r$() {
        let e = rR.utils.randomPrivateKey(),
          t = rR.getPublicKey(e);
        return { privateKey: (0, V.dI)(e, rM), publicKey: (0, V.dI)(t, rM) };
      }
      function rz() {
        let e = eX(32);
        return (0, V.dI)(e, rM);
      }
      function rW(e, t) {
        let r = ri(
          rl,
          rR.getSharedSecret((0, V.sH)(e, rM), (0, V.sH)(t, rM)),
          void 0,
          void 0,
          32
        );
        return (0, V.dI)(r, rM);
      }
      function rH(e) {
        let t = rl((0, V.sH)(e, rM));
        return (0, V.dI)(t, rM);
      }
      function rq(e) {
        let t = rl((0, V.sH)(e, rB));
        return (0, V.dI)(t, rM);
      }
      function rV(e) {
        return (0, V.sH)(`${e}`, rD);
      }
      function rK(e) {
        return Number((0, V.dI)(e, rD));
      }
      function rG(e) {
        let t = rV("u" > typeof e.type ? e.type : 0);
        if (rK(t) === rj && typeof e.senderPublicKey > "u")
          throw Error("Missing sender public key for type 1 envelope");
        let r =
            "u" > typeof e.senderPublicKey
              ? (0, V.sH)(e.senderPublicKey, rM)
              : void 0,
          i = "u" > typeof e.iv ? (0, V.sH)(e.iv, rM) : eX(12);
        return rJ({
          type: t,
          sealed: t9((0, V.sH)(e.symKey, rM), i).encrypt(
            (0, V.sH)(e.message, rB)
          ),
          iv: i,
          senderPublicKey: r,
          encoding: e.encoding,
        });
      }
      function rY(e) {
        let t = (0, V.sH)(e.symKey, rM),
          { sealed: r, iv: i } = rX(e),
          s = t9(t, i).decrypt(r);
        if (null === s) throw Error("Failed to decrypt");
        return (0, V.dI)(s, rB);
      }
      function rQ(e, t) {
        let r = rV(rF),
          i = eX(12);
        return rJ({ type: r, sealed: (0, V.sH)(e, rB), iv: i, encoding: t });
      }
      function rZ(e, t) {
        let { sealed: r } = rX({ encoded: e, encoding: t });
        return (0, V.dI)(r, rB);
      }
      function rJ(e) {
        let { encoding: t = rU } = e;
        if (rK(e.type) === rF)
          return (0, V.dI)((0, V.xW)([e.type, e.sealed]), t);
        if (rK(e.type) === rj) {
          if (typeof e.senderPublicKey > "u")
            throw Error("Missing sender public key for type 1 envelope");
          return (0, V.dI)(
            (0, V.xW)([e.type, e.senderPublicKey, e.iv, e.sealed]),
            t
          );
        }
        return (0, V.dI)((0, V.xW)([e.type, e.iv, e.sealed]), t);
      }
      function rX(e) {
        let { encoded: t, encoding: r = rU } = e,
          i = (0, V.sH)(t, r),
          s = i.slice(0, 1);
        if (rK(s) === rj) {
          let e = i.slice(1, 33),
            t = i.slice(33, 45);
          return { type: s, sealed: i.slice(45), iv: t, senderPublicKey: e };
        }
        if (rK(s) === rF) return { type: s, sealed: i.slice(1), iv: eX(12) };
        let n = i.slice(1, 13);
        return { type: s, sealed: i.slice(13), iv: n };
      }
      function r0(e, t) {
        let r = rX({ encoded: e, encoding: t?.encoding });
        return r1({
          type: rK(r.type),
          senderPublicKey:
            "u" > typeof r.senderPublicKey
              ? (0, V.dI)(r.senderPublicKey, rM)
              : void 0,
          receiverPublicKey: t?.receiverPublicKey,
        });
      }
      function r1(e) {
        let t = e?.type || 0;
        if (t === rj) {
          if (typeof e?.senderPublicKey > "u")
            throw Error("missing sender public key");
          if (typeof e?.receiverPublicKey > "u")
            throw Error("missing receiver public key");
        }
        return {
          type: t,
          senderPublicKey: e?.senderPublicKey,
          receiverPublicKey: e?.receiverPublicKey,
        };
      }
      function r2(e) {
        return (
          e.type === rj &&
          "string" == typeof e.senderPublicKey &&
          "string" == typeof e.receiverPublicKey
        );
      }
      function r3(e) {
        return e.type === rF;
      }
      function r5(e, t) {
        let [r, i, s] = e.split("."),
          n = J.from(
            (function (e) {
              let t = e.replace(/-/g, "+").replace(/_/g, "/"),
                r = t.length % 4;
              return r > 0 && (t += "=".repeat(4 - r)), t;
            })(s),
            "base64"
          );
        if (64 !== n.length) throw Error("Invalid signature length");
        let a = n.slice(0, 32).toString("hex"),
          o = n.slice(32, 64).toString("hex"),
          c = rl(`${r}.${i}`),
          l = new K.ec("p256").keyFromPublic(
            {
              x: J.from(t.x, "base64").toString("hex"),
              y: J.from(t.y, "base64").toString("hex"),
            },
            "hex"
          ),
          d = (0, V.dI)(c, rM);
        if (!l.verify(d, { r: a, s: o })) throw Error("Invalid signature");
        return (0, q.Cq)(e).payload;
      }
      function r8(e) {
        return e?.relay || { protocol: "irn" };
      }
      function r6(e) {
        let t = Q[e];
        if (typeof t > "u") throw Error(`Relay Protocol not supported: ${e}`);
        return t;
      }
      function r4(e) {
        var t;
        if (!e.includes("wc:")) {
          let t = ek(e);
          null != t && t.includes("wc:") && (e = t);
        }
        let r = (e = (e = e.includes("wc://")
            ? e.replace("wc://", "")
            : e).includes("wc:")
            ? e.replace("wc:", "")
            : e).indexOf(":"),
          i = -1 !== e.indexOf("?") ? e.indexOf("?") : void 0,
          s = e.substring(0, r),
          n = e.substring(r + 1, i).split("@"),
          a = new URLSearchParams("u" > typeof i ? e.substring(i) : ""),
          o = {};
        a.forEach((e, t) => {
          o[t] = e;
        });
        let c = "string" == typeof o.methods ? o.methods.split(",") : void 0;
        return {
          protocol: s,
          topic: (t = n[0]).startsWith("//") ? t.substring(2) : t,
          version: parseInt(n[1], 10),
          symKey: o.symKey,
          relay: (function (e, t = "-") {
            let r = {},
              i = "relay" + t;
            return (
              Object.keys(e).forEach((t) => {
                if (t.startsWith(i)) {
                  let s = t.replace(i, ""),
                    n = e[t];
                  r[s] = n;
                }
              }),
              r
            );
          })(o),
          methods: c,
          expiryTimestamp: o.expiryTimestamp
            ? parseInt(o.expiryTimestamp, 10)
            : void 0,
        };
      }
      function r9(e) {
        let t = new URLSearchParams(),
          r = (function (e, t = "-") {
            let r = {};
            return (
              Object.keys(e).forEach((i) => {
                e[i] && (r["relay" + t + i] = e[i]);
              }),
              r
            );
          })(e.relay);
        Object.keys(r)
          .sort()
          .forEach((e) => {
            t.set(e, r[e]);
          }),
          t.set("symKey", e.symKey),
          e.expiryTimestamp &&
            t.set("expiryTimestamp", e.expiryTimestamp.toString()),
          e.methods && t.set("methods", e.methods.join(","));
        let i = t.toString();
        return `${e.protocol}:${e.topic}@${e.version}?${i}`;
      }
      function r7(e, t, r) {
        return `${e}?wc_ev=${r}&topic=${t}`;
      }
      var ie = Object.defineProperty,
        it = Object.defineProperties,
        ir = Object.getOwnPropertyDescriptors,
        ii = Object.getOwnPropertySymbols,
        is = Object.prototype.hasOwnProperty,
        ia = Object.prototype.propertyIsEnumerable,
        io = (e, t, r) =>
          t in e
            ? ie(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ic = (e, t) => {
          for (var r in t || (t = {})) is.call(t, r) && io(e, r, t[r]);
          if (ii) for (var r of ii(t)) ia.call(t, r) && io(e, r, t[r]);
          return e;
        },
        il = (e, t) => it(e, ir(t));
      function id(e) {
        let t = [];
        return (
          e.forEach((e) => {
            let [r, i] = e.split(":");
            t.push(`${r}:${i}`);
          }),
          t
        );
      }
      function iu(e) {
        return e.includes(":");
      }
      function ih(e) {
        return iu(e) ? e.split(":")[0] : e;
      }
      function ip(e, t) {
        let r = (function (e) {
          let t = {};
          return (
            e?.forEach((e) => {
              var r;
              let [i, s] = e.split(":");
              t[i] ||
                (t[i] = { accounts: [], chains: [], events: [], methods: [] }),
                t[i].accounts.push(e),
                null == (r = t[i].chains) || r.push(`${i}:${s}`);
            }),
            t
          );
        })((t = t.map((e) => e.replace("did:pkh:", ""))));
        for (let [t, i] of Object.entries(r))
          i.methods ? (i.methods = eS(i.methods, e)) : (i.methods = e),
            (i.events = ["chainChanged", "accountsChanged"]);
        return r;
      }
      let ig = {
          INVALID_METHOD: { message: "Invalid method.", code: 1001 },
          INVALID_EVENT: { message: "Invalid event.", code: 1002 },
          INVALID_UPDATE_REQUEST: {
            message: "Invalid update request.",
            code: 1003,
          },
          INVALID_EXTEND_REQUEST: {
            message: "Invalid extend request.",
            code: 1004,
          },
          INVALID_SESSION_SETTLE_REQUEST: {
            message: "Invalid session settle request.",
            code: 1005,
          },
          UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 },
          UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 },
          UNAUTHORIZED_UPDATE_REQUEST: {
            message: "Unauthorized update request.",
            code: 3003,
          },
          UNAUTHORIZED_EXTEND_REQUEST: {
            message: "Unauthorized extend request.",
            code: 3004,
          },
          USER_REJECTED: { message: "User rejected.", code: 5e3 },
          USER_REJECTED_CHAINS: {
            message: "User rejected chains.",
            code: 5001,
          },
          USER_REJECTED_METHODS: {
            message: "User rejected methods.",
            code: 5002,
          },
          USER_REJECTED_EVENTS: {
            message: "User rejected events.",
            code: 5003,
          },
          UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 },
          UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 },
          UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 },
          UNSUPPORTED_ACCOUNTS: {
            message: "Unsupported accounts.",
            code: 5103,
          },
          UNSUPPORTED_NAMESPACE_KEY: {
            message: "Unsupported namespace key.",
            code: 5104,
          },
          USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 },
          SESSION_SETTLEMENT_FAILED: {
            message: "Session settlement failed.",
            code: 7e3,
          },
          WC_METHOD_UNSUPPORTED: {
            message: "Unsupported wc_ method.",
            code: 10001,
          },
        },
        im = {
          NOT_INITIALIZED: { message: "Not initialized.", code: 1 },
          NO_MATCHING_KEY: { message: "No matching key.", code: 2 },
          RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 },
          RESUBSCRIBED: { message: "Resubscribed.", code: 4 },
          MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 },
          EXPIRED: { message: "Expired.", code: 6 },
          UNKNOWN_TYPE: { message: "Unknown type.", code: 7 },
          MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 },
          NON_CONFORMING_NAMESPACES: {
            message: "Non conforming namespaces.",
            code: 9,
          },
        };
      function ib(e, t) {
        let { message: r, code: i } = im[e];
        return { message: t ? `${r} ${t}` : r, code: i };
      }
      function iy(e, t) {
        let { message: r, code: i } = ig[e];
        return { message: t ? `${r} ${t}` : r, code: i };
      }
      function iw(e, t) {
        return (
          !!Array.isArray(e) && (!("u" > typeof t) || !e.length || e.every(t))
        );
      }
      function iv(e) {
        return (
          Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length
        );
      }
      function iA(e) {
        return typeof e > "u";
      }
      function iE(e, t) {
        return !!(t && iA(e)) || ("string" == typeof e && !!e.trim().length);
      }
      function i_(e, t) {
        return !!(t && iA(e)) || ("number" == typeof e && !isNaN(e));
      }
      function iC(e, t) {
        let { requiredNamespaces: r } = t,
          i = Object.keys(e.namespaces),
          s = Object.keys(r),
          n = !0;
        return (
          !!ep(s, i) &&
          (i.forEach((t) => {
            let { accounts: i, methods: s, events: a } = e.namespaces[t],
              o = id(i),
              c = r[t];
            (ep(er(t, c), o) && ep(c.methods, s) && ep(c.events, a)) ||
              (n = !1);
          }),
          n)
        );
      }
      function iI(e) {
        return !!(iE(e, !1) && e.includes(":")) && 2 === e.split(":").length;
      }
      function iS(e) {
        function t(e) {
          try {
            return "u" > typeof new URL(e);
          } catch {
            return !1;
          }
        }
        try {
          if (iE(e, !1)) {
            if (t(e)) return !0;
            let r = ek(e);
            return t(r);
          }
        } catch {}
        return !1;
      }
      function ix(e) {
        var t;
        return null == (t = e?.proposer) ? void 0 : t.publicKey;
      }
      function iN(e) {
        return e?.topic;
      }
      function iT(e, t) {
        let r = null;
        return (
          iE(e?.publicKey, !1) ||
            (r = ib(
              "MISSING_OR_INVALID",
              `${t} controller public key should be a string`
            )),
          r
        );
      }
      function iP(e) {
        let t = !0;
        return (
          iw(e) ? e.length && (t = e.every((e) => iE(e, !1))) : (t = !1), t
        );
      }
      function iO(e, t) {
        let r = null;
        return (
          Object.values(e).forEach((e) => {
            var i;
            let s;
            if (r) return;
            let n =
              ((i = `${t}, namespace`),
              (s = null),
              iP(e?.methods)
                ? iP(e?.events) ||
                  (s = iy(
                    "UNSUPPORTED_EVENTS",
                    `${i}, events should be an array of strings or empty array for no events`
                  ))
                : (s = iy(
                    "UNSUPPORTED_METHODS",
                    `${i}, methods should be an array of strings or empty array for no methods`
                  )),
              s);
            n && (r = n);
          }),
          r
        );
      }
      function ik(e, t, r) {
        let i = null;
        if (e && iv(e)) {
          let s;
          let n = iO(e, t);
          n && (i = n);
          let a =
            ((s = null),
            Object.entries(e).forEach(([e, i]) => {
              var n, a;
              let o;
              if (s) return;
              let c =
                ((n = er(e, i)),
                (a = `${t} ${r}`),
                (o = null),
                iw(n) && n.length
                  ? n.forEach((e) => {
                      o ||
                        iI(e) ||
                        (o = iy(
                          "UNSUPPORTED_CHAINS",
                          `${a}, chain ${e} should be a string and conform to "namespace:chainId" format`
                        ));
                    })
                  : iI(e) ||
                    (o = iy(
                      "UNSUPPORTED_CHAINS",
                      `${a}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`
                    )),
                o);
              c && (s = c);
            }),
            s);
          a && (i = a);
        } else
          i = ib(
            "MISSING_OR_INVALID",
            `${t}, ${r} should be an object with data`
          );
        return i;
      }
      function iR(e, t) {
        let r = null;
        if (e && iv(e)) {
          let i;
          let s = iO(e, t);
          s && (r = s);
          let n =
            ((i = null),
            Object.values(e).forEach((e) => {
              var r, s;
              let n;
              if (i) return;
              let a =
                ((r = e?.accounts),
                (s = `${t} namespace`),
                (n = null),
                iw(r)
                  ? r.forEach((e) => {
                      n ||
                        (function (e) {
                          if (iE(e, !1) && e.includes(":")) {
                            let t = e.split(":");
                            if (3 === t.length) {
                              let e = t[0] + ":" + t[1];
                              return !!t[2] && iI(e);
                            }
                          }
                          return !1;
                        })(e) ||
                        (n = iy(
                          "UNSUPPORTED_ACCOUNTS",
                          `${s}, account ${e} should be a string and conform to "namespace:chainId:address" format`
                        ));
                    })
                  : (n = iy(
                      "UNSUPPORTED_ACCOUNTS",
                      `${s}, accounts should be an array of strings conforming to "namespace:chainId:address" format`
                    )),
                n);
              a && (i = a);
            }),
            i);
          n && (r = n);
        } else
          r = ib(
            "MISSING_OR_INVALID",
            `${t}, namespaces should be an object with data`
          );
        return r;
      }
      function iD(e) {
        return iE(e.protocol, !0);
      }
      function iM(e, t) {
        let r = !1;
        return (
          t && !e
            ? (r = !0)
            : e &&
              iw(e) &&
              e.length &&
              e.forEach((e) => {
                r = iD(e);
              }),
          r
        );
      }
      function iU(e) {
        return "number" == typeof e;
      }
      function iL(e) {
        return "u" > typeof e;
      }
      function iB(e) {
        return !(
          !e ||
          "object" != typeof e ||
          !e.code ||
          !i_(e.code, !1) ||
          !e.message ||
          !iE(e.message, !1)
        );
      }
      function ij(e) {
        return !(iA(e) || !iE(e.method, !1));
      }
      function iF(e) {
        return !(
          iA(e) ||
          (iA(e.result) && iA(e.error)) ||
          !i_(e.id, !1) ||
          !iE(e.jsonrpc, !1)
        );
      }
      function i$(e) {
        return !(iA(e) || !iE(e.name, !1));
      }
      function iz(e, t) {
        return !(
          !iI(t) ||
          !(function (e) {
            let t = [];
            return (
              Object.values(e).forEach((e) => {
                t.push(...id(e.accounts));
              }),
              t
            );
          })(e).includes(t)
        );
      }
      function iW(e, t, r) {
        return (
          !!iE(r, !1) &&
          (function (e, t) {
            let r = [];
            return (
              Object.values(e).forEach((e) => {
                id(e.accounts).includes(t) && r.push(...e.methods);
              }),
              r
            );
          })(e, t).includes(r)
        );
      }
      function iH(e, t, r) {
        return (
          !!iE(r, !1) &&
          (function (e, t) {
            let r = [];
            return (
              Object.values(e).forEach((e) => {
                id(e.accounts).includes(t) && r.push(...e.events);
              }),
              r
            );
          })(e, t).includes(r)
        );
      }
      function iq(e, t, r) {
        let i = null,
          s = (function (e) {
            let t = {};
            return (
              Object.keys(e).forEach((r) => {
                var i;
                r.includes(":")
                  ? (t[r] = e[r])
                  : null == (i = e[r].chains) ||
                    i.forEach((i) => {
                      t[i] = { methods: e[r].methods, events: e[r].events };
                    });
              }),
              t
            );
          })(e),
          n = (function (e) {
            let t = {};
            return (
              Object.keys(e).forEach((r) => {
                if (r.includes(":")) t[r] = e[r];
                else {
                  let i = id(e[r].accounts);
                  i?.forEach((i) => {
                    t[i] = {
                      accounts: e[r].accounts.filter((e) =>
                        e.includes(`${i}:`)
                      ),
                      methods: e[r].methods,
                      events: e[r].events,
                    };
                  });
                }
              }),
              t
            );
          })(t),
          a = Object.keys(s),
          o = Object.keys(n),
          c = iV(Object.keys(e)),
          l = iV(Object.keys(t)),
          d = c.filter((e) => !l.includes(e));
        return (
          d.length &&
            (i = ib(
              "NON_CONFORMING_NAMESPACES",
              `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${d.toString()}
      Received: ${Object.keys(t).toString()}`
            )),
          ep(a, o) ||
            (i = ib(
              "NON_CONFORMING_NAMESPACES",
              `${r} namespaces chains don't satisfy required namespaces.
      Required: ${a.toString()}
      Approved: ${o.toString()}`
            )),
          Object.keys(t).forEach((e) => {
            if (!e.includes(":") || i) return;
            let s = id(t[e].accounts);
            s.includes(e) ||
              (i = ib(
                "NON_CONFORMING_NAMESPACES",
                `${r} namespaces accounts don't satisfy namespace accounts for ${e}
        Required: ${e}
        Approved: ${s.toString()}`
              ));
          }),
          a.forEach((e) => {
            i ||
              (ep(s[e].methods, n[e].methods)
                ? ep(s[e].events, n[e].events) ||
                  (i = ib(
                    "NON_CONFORMING_NAMESPACES",
                    `${r} namespaces events don't satisfy namespace events for ${e}`
                  ))
                : (i = ib(
                    "NON_CONFORMING_NAMESPACES",
                    `${r} namespaces methods don't satisfy namespace methods for ${e}`
                  )));
          }),
          i
        );
      }
      function iV(e) {
        return [
          ...new Set(e.map((e) => (e.includes(":") ? e.split(":")[0] : e))),
        ];
      }
      function iK(e, t) {
        return i_(e, !1) && e <= t.max && e >= t.min;
      }
      function iG() {
        let e = el();
        return new Promise((t) => {
          switch (e) {
            case ei.browser:
              t(ec() && navigator?.onLine);
              break;
            case ei.reactNative:
              t(iY());
              break;
            case ei.node:
            default:
              t(!0);
          }
        });
      }
      async function iY() {
        if (en() && "u" > typeof r.g && null != r.g && r.g.NetInfo) {
          let e = await (null == r.g ? void 0 : r.g.NetInfo.fetch());
          return e?.isConnected;
        }
        return !0;
      }
      function iQ(e) {
        var t, i;
        switch (el()) {
          case ei.browser:
            (t = e),
              !en() &&
                ec() &&
                (window.addEventListener("online", () => t(!0)),
                window.addEventListener("offline", () => t(!1)));
            break;
          case ei.reactNative:
            (i = e),
              en() &&
                "u" > typeof r.g &&
                null != r.g &&
                r.g.NetInfo &&
                r.g?.NetInfo.addEventListener((e) => i(e?.isConnected));
          case ei.node:
        }
      }
      let iZ = {};
      class iJ {
        static get(e) {
          return iZ[e];
        }
        static set(e, t) {
          iZ[e] = t;
        }
        static delete(e) {
          delete iZ[e];
        }
      }
    },
    50879: (e, t, r) => {
      "use strict";
      r.d(t, {
        $s: () => l,
        Kc: () => u,
        Kz: () => d,
        Vg: () => c,
        WA: () => h,
        aO: () => a,
        n3: () => o,
      });
      var i = r(28245),
        s = r(42503),
        n = r(13933);
      function a(e) {
        let t = Object.entries(e)
            .map(([e, t]) => (void 0 === t || !1 === t ? null : [e, t]))
            .filter(Boolean),
          r = t.reduce((e, [t]) => Math.max(e, t.length), 0);
        return t.map(([e, t]) => `  ${`${e}:`.padEnd(r + 1)}  ${t}`).join("\n");
      }
      class o extends n.C {
        constructor() {
          super(
            "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.\nUse `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.",
            { name: "FeeConflictError" }
          );
        }
      }
      n.C;
      class c extends n.C {
        constructor({ transaction: e }) {
          super("Cannot infer a transaction type from provided transaction.", {
            metaMessages: [
              "Provided Transaction:",
              "{",
              a(e),
              "}",
              "",
              "To infer the type, either provide:",
              "- a `type` to the Transaction, or",
              "- an EIP-1559 Transaction with `maxFeePerGas`, or",
              "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
              "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
              "- an EIP-7702 Transaction with `authorizationList`, or",
              "- a Legacy Transaction with `gasPrice`",
            ],
            name: "InvalidSerializableTransactionError",
          });
        }
      }
      n.C, n.C, n.C;
      class l extends n.C {
        constructor(
          e,
          {
            account: t,
            docsPath: r,
            chain: n,
            data: o,
            gas: c,
            gasPrice: l,
            maxFeePerGas: d,
            maxPriorityFeePerGas: u,
            nonce: h,
            to: f,
            value: p,
          }
        ) {
          super(e.shortMessage, {
            cause: e,
            docsPath: r,
            metaMessages: [
              ...(e.metaMessages ? [...e.metaMessages, " "] : []),
              "Request Arguments:",
              a({
                chain: n && `${n?.name} (id: ${n?.id})`,
                from: t?.address,
                to: f,
                value:
                  void 0 !== p &&
                  `${(0, i.c)(p)} ${n?.nativeCurrency?.symbol || "ETH"}`,
                data: o,
                gas: c,
                gasPrice: void 0 !== l && `${(0, s.Q)(l)} gwei`,
                maxFeePerGas: void 0 !== d && `${(0, s.Q)(d)} gwei`,
                maxPriorityFeePerGas: void 0 !== u && `${(0, s.Q)(u)} gwei`,
                nonce: h,
              }),
            ].filter(Boolean),
            name: "TransactionExecutionError",
          }),
            Object.defineProperty(this, "cause", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.cause = e);
        }
      }
      class d extends n.C {
        constructor({
          blockHash: e,
          blockNumber: t,
          blockTag: r,
          hash: i,
          index: s,
        }) {
          let n = "Transaction";
          r &&
            void 0 !== s &&
            (n = `Transaction at block time "${r}" at index "${s}"`),
            e &&
              void 0 !== s &&
              (n = `Transaction at block hash "${e}" at index "${s}"`),
            t &&
              void 0 !== s &&
              (n = `Transaction at block number "${t}" at index "${s}"`),
            i && (n = `Transaction with hash "${i}"`),
            super(`${n} could not be found.`, {
              name: "TransactionNotFoundError",
            });
        }
      }
      class u extends n.C {
        constructor({ hash: e }) {
          super(
            `Transaction receipt with hash "${e}" could not be found. The Transaction may not be processed on a block yet.`,
            { name: "TransactionReceiptNotFoundError" }
          );
        }
      }
      class h extends n.C {
        constructor({ hash: e }) {
          super(
            `Timed out while waiting for transaction with hash "${e}" to be confirmed.`,
            { name: "WaitForTransactionReceiptTimeoutError" }
          );
        }
      }
    },
    51746: (e, t) => {
      "use strict";
      (t.byteLength = function (e) {
        var t = c(e),
          r = t[0],
          i = t[1];
        return ((r + i) * 3) / 4 - i;
      }),
        (t.toByteArray = function (e) {
          var t,
            r,
            n = c(e),
            a = n[0],
            o = n[1],
            l = new s(((a + o) * 3) / 4 - o),
            d = 0,
            u = o > 0 ? a - 4 : a;
          for (r = 0; r < u; r += 4)
            (t =
              (i[e.charCodeAt(r)] << 18) |
              (i[e.charCodeAt(r + 1)] << 12) |
              (i[e.charCodeAt(r + 2)] << 6) |
              i[e.charCodeAt(r + 3)]),
              (l[d++] = (t >> 16) & 255),
              (l[d++] = (t >> 8) & 255),
              (l[d++] = 255 & t);
          return (
            2 === o &&
              ((t = (i[e.charCodeAt(r)] << 2) | (i[e.charCodeAt(r + 1)] >> 4)),
              (l[d++] = 255 & t)),
            1 === o &&
              ((t =
                (i[e.charCodeAt(r)] << 10) |
                (i[e.charCodeAt(r + 1)] << 4) |
                (i[e.charCodeAt(r + 2)] >> 2)),
              (l[d++] = (t >> 8) & 255),
              (l[d++] = 255 & t)),
            l
          );
        }),
        (t.fromByteArray = function (e) {
          for (
            var t, i = e.length, s = i % 3, n = [], a = 0, o = i - s;
            a < o;
            a += 16383
          )
            n.push(
              (function (e, t, i) {
                for (var s, n = [], a = t; a < i; a += 3)
                  (s =
                    ((e[a] << 16) & 0xff0000) +
                    ((e[a + 1] << 8) & 65280) +
                    (255 & e[a + 2])),
                    n.push(
                      r[(s >> 18) & 63] +
                        r[(s >> 12) & 63] +
                        r[(s >> 6) & 63] +
                        r[63 & s]
                    );
                return n.join("");
              })(e, a, a + 16383 > o ? o : a + 16383)
            );
          return (
            1 === s
              ? n.push(r[(t = e[i - 1]) >> 2] + r[(t << 4) & 63] + "==")
              : 2 === s &&
                n.push(
                  r[(t = (e[i - 2] << 8) + e[i - 1]) >> 10] +
                    r[(t >> 4) & 63] +
                    r[(t << 2) & 63] +
                    "="
                ),
            n.join("")
          );
        });
      for (
        var r = [],
          i = [],
          s = "undefined" != typeof Uint8Array ? Uint8Array : Array,
          n =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          a = 0,
          o = n.length;
        a < o;
        ++a
      )
        (r[a] = n[a]), (i[n.charCodeAt(a)] = a);
      function c(e) {
        var t = e.length;
        if (t % 4 > 0)
          throw Error("Invalid string. Length must be a multiple of 4");
        var r = e.indexOf("=");
        -1 === r && (r = t);
        var i = r === t ? 0 : 4 - (r % 4);
        return [r, i];
      }
      (i["-".charCodeAt(0)] = 62), (i["_".charCodeAt(0)] = 63);
    },
    52321: (e, t, r) => {
      "use strict";
      r.d(t, {
        JW: () => I,
        XX: () => W,
        c0: () => S,
        ge: () => $,
        qy: () => C,
        s6: () => x,
      });
      let i = globalThis,
        s = i.trustedTypes,
        n = s ? s.createPolicy("lit-html", { createHTML: (e) => e }) : void 0,
        a = "$lit$",
        o = `lit$${Math.random().toFixed(9).slice(2)}$`,
        c = "?" + o,
        l = `<${c}>`,
        d = document,
        u = () => d.createComment(""),
        h = (e) =>
          null === e || ("object" != typeof e && "function" != typeof e),
        f = Array.isArray,
        p = (e) => f(e) || "function" == typeof e?.[Symbol.iterator],
        g = "[ 	\n\f\r]",
        m = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
        b = /-->/g,
        y = />/g,
        w = RegExp(
          `>|${g}(?:([^\\s"'>=/]+)(${g}*=${g}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
          "g"
        ),
        v = /'/g,
        A = /"/g,
        E = /^(?:script|style|textarea|title)$/i,
        _ =
          (e) =>
          (t, ...r) => ({ _$litType$: e, strings: t, values: r }),
        C = _(1),
        I = _(2),
        S = (_(3), Symbol.for("lit-noChange")),
        x = Symbol.for("lit-nothing"),
        N = new WeakMap(),
        T = d.createTreeWalker(d, 129);
      function P(e, t) {
        if (!f(e) || !e.hasOwnProperty("raw"))
          throw Error("invalid template strings array");
        return void 0 !== n ? n.createHTML(t) : t;
      }
      let O = (e, t) => {
        let r = e.length - 1,
          i = [],
          s,
          n = 2 === t ? "<svg>" : 3 === t ? "<math>" : "",
          c = m;
        for (let t = 0; t < r; t++) {
          let r = e[t],
            d,
            u,
            h = -1,
            f = 0;
          for (
            ;
            f < r.length && ((c.lastIndex = f), null !== (u = c.exec(r)));

          )
            (f = c.lastIndex),
              c === m
                ? "!--" === u[1]
                  ? (c = b)
                  : void 0 !== u[1]
                  ? (c = y)
                  : void 0 !== u[2]
                  ? (E.test(u[2]) && (s = RegExp("</" + u[2], "g")), (c = w))
                  : void 0 !== u[3] && (c = w)
                : c === w
                ? ">" === u[0]
                  ? ((c = s ?? m), (h = -1))
                  : void 0 === u[1]
                  ? (h = -2)
                  : ((h = c.lastIndex - u[2].length),
                    (d = u[1]),
                    (c = void 0 === u[3] ? w : '"' === u[3] ? A : v))
                : c === A || c === v
                ? (c = w)
                : c === b || c === y
                ? (c = m)
                : ((c = w), (s = void 0));
          let p = c === w && e[t + 1].startsWith("/>") ? " " : "";
          n +=
            c === m
              ? r + l
              : h >= 0
              ? (i.push(d), r.slice(0, h) + a + r.slice(h) + o + p)
              : r + o + (-2 === h ? t : p);
        }
        return [
          P(
            e,
            n +
              (e[r] || "<?>") +
              (2 === t ? "</svg>" : 3 === t ? "</math>" : "")
          ),
          i,
        ];
      };
      class k {
        constructor({ strings: e, _$litType$: t }, r) {
          let i;
          this.parts = [];
          let n = 0,
            l = 0,
            d = e.length - 1,
            h = this.parts,
            [f, p] = O(e, t);
          if (
            ((this.el = k.createElement(f, r)),
            (T.currentNode = this.el.content),
            2 === t || 3 === t)
          ) {
            let e = this.el.content.firstChild;
            e.replaceWith(...e.childNodes);
          }
          for (; null !== (i = T.nextNode()) && h.length < d; ) {
            if (1 === i.nodeType) {
              if (i.hasAttributes())
                for (let e of i.getAttributeNames())
                  if (e.endsWith(a)) {
                    let t = p[l++],
                      r = i.getAttribute(e).split(o),
                      s = /([.?@])?(.*)/.exec(t);
                    h.push({
                      type: 1,
                      index: n,
                      name: s[2],
                      strings: r,
                      ctor:
                        "." === s[1]
                          ? L
                          : "?" === s[1]
                          ? B
                          : "@" === s[1]
                          ? j
                          : U,
                    }),
                      i.removeAttribute(e);
                  } else
                    e.startsWith(o) &&
                      (h.push({ type: 6, index: n }), i.removeAttribute(e));
              if (E.test(i.tagName)) {
                let e = i.textContent.split(o),
                  t = e.length - 1;
                if (t > 0) {
                  i.textContent = s ? s.emptyScript : "";
                  for (let r = 0; r < t; r++)
                    i.append(e[r], u()),
                      T.nextNode(),
                      h.push({ type: 2, index: ++n });
                  i.append(e[t], u());
                }
              }
            } else if (8 === i.nodeType) {
              if (i.data === c) h.push({ type: 2, index: n });
              else {
                let e = -1;
                for (; -1 !== (e = i.data.indexOf(o, e + 1)); )
                  h.push({ type: 7, index: n }), (e += o.length - 1);
              }
            }
            n++;
          }
        }
        static createElement(e, t) {
          let r = d.createElement("template");
          return (r.innerHTML = e), r;
        }
      }
      function R(e, t, r = e, i) {
        if (t === S) return t;
        let s = void 0 !== i ? r._$Co?.[i] : r._$Cl,
          n = h(t) ? void 0 : t._$litDirective$;
        return (
          s?.constructor !== n &&
            (s?._$AO?.(!1),
            void 0 === n ? (s = void 0) : (s = new n(e))._$AT(e, r, i),
            void 0 !== i ? ((r._$Co ??= [])[i] = s) : (r._$Cl = s)),
          void 0 !== s && (t = R(e, s._$AS(e, t.values), s, i)),
          t
        );
      }
      class D {
        constructor(e, t) {
          (this._$AV = []),
            (this._$AN = void 0),
            (this._$AD = e),
            (this._$AM = t);
        }
        get parentNode() {
          return this._$AM.parentNode;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        u(e) {
          let {
              el: { content: t },
              parts: r,
            } = this._$AD,
            i = (e?.creationScope ?? d).importNode(t, !0);
          T.currentNode = i;
          let s = T.nextNode(),
            n = 0,
            a = 0,
            o = r[0];
          for (; void 0 !== o; ) {
            if (n === o.index) {
              let t;
              2 === o.type
                ? (t = new M(s, s.nextSibling, this, e))
                : 1 === o.type
                ? (t = new o.ctor(s, o.name, o.strings, this, e))
                : 6 === o.type && (t = new F(s, this, e)),
                this._$AV.push(t),
                (o = r[++a]);
            }
            n !== o?.index && ((s = T.nextNode()), n++);
          }
          return (T.currentNode = d), i;
        }
        p(e) {
          let t = 0;
          for (let r of this._$AV)
            void 0 !== r &&
              (void 0 !== r.strings
                ? (r._$AI(e, r, t), (t += r.strings.length - 2))
                : r._$AI(e[t])),
              t++;
        }
      }
      class M {
        get _$AU() {
          return this._$AM?._$AU ?? this._$Cv;
        }
        constructor(e, t, r, i) {
          (this.type = 2),
            (this._$AH = x),
            (this._$AN = void 0),
            (this._$AA = e),
            (this._$AB = t),
            (this._$AM = r),
            (this.options = i),
            (this._$Cv = i?.isConnected ?? !0);
        }
        get parentNode() {
          let e = this._$AA.parentNode,
            t = this._$AM;
          return void 0 !== t && 11 === e?.nodeType && (e = t.parentNode), e;
        }
        get startNode() {
          return this._$AA;
        }
        get endNode() {
          return this._$AB;
        }
        _$AI(e, t = this) {
          h((e = R(this, e, t)))
            ? e === x || null == e || "" === e
              ? (this._$AH !== x && this._$AR(), (this._$AH = x))
              : e !== this._$AH && e !== S && this._(e)
            : void 0 !== e._$litType$
            ? this.$(e)
            : void 0 !== e.nodeType
            ? this.T(e)
            : p(e)
            ? this.k(e)
            : this._(e);
        }
        O(e) {
          return this._$AA.parentNode.insertBefore(e, this._$AB);
        }
        T(e) {
          this._$AH !== e && (this._$AR(), (this._$AH = this.O(e)));
        }
        _(e) {
          this._$AH !== x && h(this._$AH)
            ? (this._$AA.nextSibling.data = e)
            : this.T(d.createTextNode(e)),
            (this._$AH = e);
        }
        $(e) {
          let { values: t, _$litType$: r } = e,
            i =
              "number" == typeof r
                ? this._$AC(e)
                : (void 0 === r.el &&
                    (r.el = k.createElement(P(r.h, r.h[0]), this.options)),
                  r);
          if (this._$AH?._$AD === i) this._$AH.p(t);
          else {
            let e = new D(i, this),
              r = e.u(this.options);
            e.p(t), this.T(r), (this._$AH = e);
          }
        }
        _$AC(e) {
          let t = N.get(e.strings);
          return void 0 === t && N.set(e.strings, (t = new k(e))), t;
        }
        k(e) {
          f(this._$AH) || ((this._$AH = []), this._$AR());
          let t = this._$AH,
            r,
            i = 0;
          for (let s of e)
            i === t.length
              ? t.push(
                  (r = new M(this.O(u()), this.O(u()), this, this.options))
                )
              : (r = t[i]),
              r._$AI(s),
              i++;
          i < t.length &&
            (this._$AR(r && r._$AB.nextSibling, i), (t.length = i));
        }
        _$AR(e = this._$AA.nextSibling, t) {
          for (this._$AP?.(!1, !0, t); e && e !== this._$AB; ) {
            let t = e.nextSibling;
            e.remove(), (e = t);
          }
        }
        setConnected(e) {
          void 0 === this._$AM && ((this._$Cv = e), this._$AP?.(e));
        }
      }
      class U {
        get tagName() {
          return this.element.tagName;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        constructor(e, t, r, i, s) {
          (this.type = 1),
            (this._$AH = x),
            (this._$AN = void 0),
            (this.element = e),
            (this.name = t),
            (this._$AM = i),
            (this.options = s),
            r.length > 2 || "" !== r[0] || "" !== r[1]
              ? ((this._$AH = Array(r.length - 1).fill(new String())),
                (this.strings = r))
              : (this._$AH = x);
        }
        _$AI(e, t = this, r, i) {
          let s = this.strings,
            n = !1;
          if (void 0 === s)
            (n = !h((e = R(this, e, t, 0))) || (e !== this._$AH && e !== S)) &&
              (this._$AH = e);
          else {
            let i, a;
            let o = e;
            for (e = s[0], i = 0; i < s.length - 1; i++)
              (a = R(this, o[r + i], t, i)) === S && (a = this._$AH[i]),
                (n ||= !h(a) || a !== this._$AH[i]),
                a === x ? (e = x) : e !== x && (e += (a ?? "") + s[i + 1]),
                (this._$AH[i] = a);
          }
          n && !i && this.j(e);
        }
        j(e) {
          e === x
            ? this.element.removeAttribute(this.name)
            : this.element.setAttribute(this.name, e ?? "");
        }
      }
      class L extends U {
        constructor() {
          super(...arguments), (this.type = 3);
        }
        j(e) {
          this.element[this.name] = e === x ? void 0 : e;
        }
      }
      class B extends U {
        constructor() {
          super(...arguments), (this.type = 4);
        }
        j(e) {
          this.element.toggleAttribute(this.name, !!e && e !== x);
        }
      }
      class j extends U {
        constructor(e, t, r, i, s) {
          super(e, t, r, i, s), (this.type = 5);
        }
        _$AI(e, t = this) {
          if ((e = R(this, e, t, 0) ?? x) === S) return;
          let r = this._$AH,
            i =
              (e === x && r !== x) ||
              e.capture !== r.capture ||
              e.once !== r.once ||
              e.passive !== r.passive,
            s = e !== x && (r === x || i);
          i && this.element.removeEventListener(this.name, this, r),
            s && this.element.addEventListener(this.name, this, e),
            (this._$AH = e);
        }
        handleEvent(e) {
          "function" == typeof this._$AH
            ? this._$AH.call(this.options?.host ?? this.element, e)
            : this._$AH.handleEvent(e);
        }
      }
      class F {
        constructor(e, t, r) {
          (this.element = e),
            (this.type = 6),
            (this._$AN = void 0),
            (this._$AM = t),
            (this.options = r);
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        _$AI(e) {
          R(this, e);
        }
      }
      let $ = {
          M: a,
          P: o,
          A: c,
          C: 1,
          L: O,
          R: D,
          D: p,
          V: R,
          I: M,
          H: U,
          N: B,
          U: j,
          B: L,
          F: F,
        },
        z = i.litHtmlPolyfillSupport;
      z?.(k, M), (i.litHtmlVersions ??= []).push("3.2.1");
      let W = (e, t, r) => {
        let i = r?.renderBefore ?? t,
          s = i._$litPart$;
        if (void 0 === s) {
          let e = r?.renderBefore ?? null;
          i._$litPart$ = s = new M(t.insertBefore(u(), e), e, void 0, r ?? {});
        }
        return s._$AI(e), s;
      };
    },
    52436: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => s });
      let i = !1;
      async function s(e, t = {}) {
        let r;
        if (i) return [];
        (i = !0),
          e.setState((e) => ({
            ...e,
            status: e.current ? "reconnecting" : "connecting",
          }));
        let n = [];
        if (t.connectors?.length)
          for (let r of t.connectors) {
            let t;
            (t = "function" == typeof r ? e._internal.connectors.setup(r) : r),
              n.push(t);
          }
        else n.push(...e.connectors);
        try {
          r = await e.storage?.getItem("recentConnectorId");
        } catch {}
        let a = {};
        for (let [, t] of e.state.connections) a[t.connector.id] = 1;
        r && (a[r] = 0);
        let o =
            Object.keys(a).length > 0
              ? [...n].sort((e, t) => (a[e.id] ?? 10) - (a[t.id] ?? 10))
              : n,
          c = !1,
          l = [],
          d = [];
        for (let t of o) {
          let r = await t.getProvider().catch(() => void 0);
          if (!r || d.some((e) => e === r) || !(await t.isAuthorized()))
            continue;
          let i = await t.connect({ isReconnecting: !0 }).catch(() => null);
          i &&
            (t.emitter.off("connect", e._internal.events.connect),
            t.emitter.on("change", e._internal.events.change),
            t.emitter.on("disconnect", e._internal.events.disconnect),
            e.setState((e) => {
              let r = new Map(c ? e.connections : new Map()).set(t.uid, {
                accounts: i.accounts,
                chainId: i.chainId,
                connector: t,
              });
              return { ...e, current: c ? e.current : t.uid, connections: r };
            }),
            l.push({ accounts: i.accounts, chainId: i.chainId, connector: t }),
            d.push(r),
            (c = !0));
        }
        return (
          ("reconnecting" === e.state.status ||
            "connecting" === e.state.status) &&
            (c
              ? e.setState((e) => ({ ...e, status: "connected" }))
              : e.setState((e) => ({
                  ...e,
                  connections: new Map(),
                  current: null,
                  status: "disconnected",
                }))),
          (i = !1),
          l
        );
      }
    },
    52502: (e, t, r) => {
      "use strict";
      r.d(t, { h: () => o });
      var i = r(1220),
        s = r(98866),
        n = r(55480);
      let a = (0, i.BX)({ message: "", variant: "info", open: !1 }),
        o = {
          state: a,
          subscribeKey: (e, t) => (0, s.u$)(a, e, t),
          open(e, t) {
            let { debug: r } = n.H.state,
              { shortMessage: i, longMessage: s } = e;
            r && ((a.message = i), (a.variant = t), (a.open = !0)),
              s && console.error("function" == typeof s ? s() : s);
          },
          close() {
            (a.open = !1), (a.message = ""), (a.variant = "info");
          },
        };
    },
    52617: (e, t, r) => {
      "use strict";
      function i(e, t) {
        return "light" === t
          ? {
              "--w3m-accent": e?.["--w3m-accent"] || "hsla(231, 100%, 70%, 1)",
              "--w3m-background": "#fff",
            }
          : {
              "--w3m-accent": e?.["--w3m-accent"] || "hsla(230, 100%, 67%, 1)",
              "--w3m-background": "#121313",
            };
      }
      r.d(t, { o: () => i });
    },
    53473: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => u });
      var i = r(13933),
        s = r(4058),
        n = r(73168),
        a = r(34561);
      let o = new (r(20390).A)(8192);
      var c = r(37407),
        l = r(59350),
        d = r(95789);
      function u(
        {
          key: e,
          methods: t,
          name: r,
          request: u,
          retryCount: h = 3,
          retryDelay: f = 150,
          timeout: p,
          type: g,
        },
        m
      ) {
        return {
          config: {
            key: e,
            methods: t,
            name: r,
            request: u,
            retryCount: h,
            retryDelay: f,
            timeout: p,
            type: g,
          },
          request: (function (e, t = {}) {
            return async (r, d = {}) => {
              let {
                  dedupe: u = !1,
                  methods: h,
                  retryDelay: f = 150,
                  retryCount: p = 3,
                  uid: g,
                } = { ...t, ...d },
                { method: m } = r;
              if (
                h?.exclude?.includes(m) ||
                (h?.include && !h.include.includes(m))
              )
                throw new n.ab(Error("method not supported"), { method: m });
              let b = u ? (0, a.i3)(`${g}.${(0, l.A)(r)}`) : void 0;
              return (function (e, { enabled: t = !0, id: r }) {
                if (!t || !r) return e();
                if (o.get(r)) return o.get(r);
                let i = e().finally(() => o.delete(r));
                return o.set(r, i), i;
              })(
                () =>
                  (0, c.b)(
                    async () => {
                      try {
                        return await e(r);
                      } catch (e) {
                        switch (e.code) {
                          case n.XU.code:
                            throw new n.XU(e);
                          case n.CL.code:
                            throw new n.CL(e);
                          case n.Gi.code:
                            throw new n.Gi(e, { method: r.method });
                          case n.D5.code:
                            throw new n.D5(e);
                          case n.bq.code:
                            throw new n.bq(e);
                          case n.Di.code:
                            throw new n.Di(e);
                          case n.hA.code:
                            throw new n.hA(e);
                          case n.qZ.code:
                            throw new n.qZ(e);
                          case n.YW.code:
                            throw new n.YW(e);
                          case n.ab.code:
                            throw new n.ab(e, { method: r.method });
                          case n.s0.code:
                            throw new n.s0(e);
                          case n.xQ.code:
                            throw new n.xQ(e);
                          case n.vx.code:
                            throw new n.vx(e);
                          case n.sV.code:
                            throw new n.sV(e);
                          case n.Sf.code:
                            throw new n.Sf(e);
                          case n.RV.code:
                            throw new n.RV(e);
                          case n.xq.code:
                            throw new n.xq(e);
                          case n.ch.code:
                            throw new n.ch(e);
                          case 5e3:
                            throw new n.vx(e);
                          default:
                            if (e instanceof i.C) throw e;
                            throw new n.MI(e);
                        }
                      }
                    },
                    {
                      delay: ({ count: e, error: t }) => {
                        if (t && t instanceof s.Ci) {
                          let e = t?.headers?.get("Retry-After");
                          if (e?.match(/\d/)) return 1e3 * Number.parseInt(e);
                        }
                        return ~~(1 << e) * f;
                      },
                      retryCount: p,
                      shouldRetry: ({ error: e }) => {
                        var t;
                        return "code" in (t = e) && "number" == typeof t.code
                          ? -1 === t.code ||
                              t.code === n.s0.code ||
                              t.code === n.bq.code
                          : !(t instanceof s.Ci) ||
                              !t.status ||
                              403 === t.status ||
                              408 === t.status ||
                              413 === t.status ||
                              429 === t.status ||
                              500 === t.status ||
                              502 === t.status ||
                              503 === t.status ||
                              504 === t.status ||
                              !1;
                      },
                    }
                  ),
                { enabled: u, id: b }
              );
            };
          })(u, { methods: t, retryCount: h, retryDelay: f, uid: (0, d.L)() }),
          value: m,
        };
      }
    },
    53560: (e, t, r) => {
      "use strict";
      r.d(t, { e: () => u });
      var i = r(89709),
        s = r(98782),
        n = r(91136),
        a = r(54029),
        o = r(63542);
      class c extends o.C {
        constructor({ type: e }) {
          super("Circular reference detected.", {
            metaMessages: [`Struct "${e}" is a circular reference.`],
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "CircularReferenceError",
            });
        }
      }
      var l = r(98957),
        d = r(39382);
      function u(e) {
        let t = {},
          r = e.length;
        for (let i = 0; i < r; i++) {
          let r = e[i];
          if (!(0, l.WL)(r)) continue;
          let s = (0, l.FO)(r);
          if (!s) throw new a.s7({ signature: r, type: "struct" });
          let n = s.properties.split(";"),
            o = [],
            c = n.length;
          for (let e = 0; e < c; e++) {
            let t = n[e].trim();
            if (!t) continue;
            let r = (0, d.Pj)(t, { type: "struct" });
            o.push(r);
          }
          if (!o.length) throw new a.X9({ signature: r });
          t[s.name] = o;
        }
        let o = {},
          u = Object.entries(t),
          f = u.length;
        for (let e = 0; e < f; e++) {
          let [r, a] = u[e];
          o[r] = (function e(t, r, a = new Set()) {
            let o = [],
              l = t.length;
            for (let u = 0; u < l; u++) {
              let l = t[u];
              if (i.wj.test(l.type)) o.push(l);
              else {
                let t = (0, i.Yv)(h, l.type);
                if (!t?.type) throw new n.nx({ abiParameter: l });
                let { array: u, type: f } = t;
                if (f in r) {
                  if (a.has(f)) throw new c({ type: f });
                  o.push({
                    ...l,
                    type: `tuple${u ?? ""}`,
                    components: e(r[f] ?? [], r, new Set([...a, f])),
                  });
                } else if ((0, d._o)(f)) o.push(l);
                else throw new s.zz({ type: f });
              }
            }
            return o;
          })(a, t);
        }
        return o;
      }
      let h = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
    },
    54029: (e, t, r) => {
      "use strict";
      r.d(t, { X9: () => a, s7: () => s, x8: () => n });
      var i = r(63542);
      class s extends i.C {
        constructor({ signature: e, type: t }) {
          super(`Invalid ${t} signature.`, { details: e }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "InvalidSignatureError",
            });
        }
      }
      class n extends i.C {
        constructor({ signature: e }) {
          super("Unknown signature.", { details: e }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "UnknownSignatureError",
            });
        }
      }
      class a extends i.C {
        constructor({ signature: e }) {
          super("Invalid struct signature.", {
            details: e,
            metaMessages: ["No properties exist."],
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "InvalidStructSignatureError",
            });
        }
      }
    },
    54685: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => i });
      let i = (function (e) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        let t = new Uint8Array(256);
        for (let e = 0; e < t.length; e++) t[e] = 255;
        for (let r = 0; r < e.length; r++) {
          let i = e.charAt(r),
            s = i.charCodeAt(0);
          if (255 !== t[s]) throw TypeError(i + " is ambiguous");
          t[s] = r;
        }
        let r = e.length,
          i = e.charAt(0),
          s = Math.log(r) / Math.log(256),
          n = Math.log(256) / Math.log(r);
        function a(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          let n = 0,
            a = 0,
            o = 0;
          for (; e[n] === i; ) a++, n++;
          let c = ((e.length - n) * s + 1) >>> 0,
            l = new Uint8Array(c);
          for (; n < e.length; ) {
            let i = e.charCodeAt(n);
            if (i > 255) return;
            let s = t[i];
            if (255 === s) return;
            let a = 0;
            for (let e = c - 1; (0 !== s || a < o) && -1 !== e; e--, a++)
              (s += (r * l[e]) >>> 0),
                (l[e] = s % 256 >>> 0),
                (s = (s / 256) >>> 0);
            if (0 !== s) throw Error("Non-zero carry");
            (o = a), n++;
          }
          let d = c - o;
          for (; d !== c && 0 === l[d]; ) d++;
          let u = new Uint8Array(a + (c - d)),
            h = a;
          for (; d !== c; ) u[h++] = l[d++];
          return u;
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            let s = 0,
              a = 0,
              o = 0,
              c = t.length;
            for (; o !== c && 0 === t[o]; ) o++, s++;
            let l = ((c - o) * n + 1) >>> 0,
              d = new Uint8Array(l);
            for (; o !== c; ) {
              let e = t[o],
                i = 0;
              for (let t = l - 1; (0 !== e || i < a) && -1 !== t; t--, i++)
                (e += (256 * d[t]) >>> 0),
                  (d[t] = e % r >>> 0),
                  (e = (e / r) >>> 0);
              if (0 !== e) throw Error("Non-zero carry");
              (a = i), o++;
            }
            let u = l - a;
            for (; u !== l && 0 === d[u]; ) u++;
            let h = i.repeat(s);
            for (; u < l; ++u) h += e.charAt(d[u]);
            return h;
          },
          decodeUnsafe: a,
          decode: function (e) {
            let t = a(e);
            if (t) return t;
            throw Error("Non-base" + r + " character");
          },
        };
      })("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    },
    55459: (e, t) => {
      (t.read = function (e, t, r, i, s) {
        var n,
          a,
          o = 8 * s - i - 1,
          c = (1 << o) - 1,
          l = c >> 1,
          d = -7,
          u = r ? s - 1 : 0,
          h = r ? -1 : 1,
          f = e[t + u];
        for (
          u += h, n = f & ((1 << -d) - 1), f >>= -d, d += o;
          d > 0;
          n = 256 * n + e[t + u], u += h, d -= 8
        );
        for (
          a = n & ((1 << -d) - 1), n >>= -d, d += i;
          d > 0;
          a = 256 * a + e[t + u], u += h, d -= 8
        );
        if (0 === n) n = 1 - l;
        else {
          if (n === c) return a ? NaN : (1 / 0) * (f ? -1 : 1);
          (a += Math.pow(2, i)), (n -= l);
        }
        return (f ? -1 : 1) * a * Math.pow(2, n - i);
      }),
        (t.write = function (e, t, r, i, s, n) {
          var a,
            o,
            c,
            l = 8 * n - s - 1,
            d = (1 << l) - 1,
            u = d >> 1,
            h = 5960464477539062e-23 * (23 === s),
            f = i ? 0 : n - 1,
            p = i ? 1 : -1,
            g = +(t < 0 || (0 === t && 1 / t < 0));
          for (
            isNaN((t = Math.abs(t))) || t === 1 / 0
              ? ((o = +!!isNaN(t)), (a = d))
              : ((a = Math.floor(Math.log(t) / Math.LN2)),
                t * (c = Math.pow(2, -a)) < 1 && (a--, (c *= 2)),
                a + u >= 1 ? (t += h / c) : (t += h * Math.pow(2, 1 - u)),
                t * c >= 2 && (a++, (c /= 2)),
                a + u >= d
                  ? ((o = 0), (a = d))
                  : a + u >= 1
                  ? ((o = (t * c - 1) * Math.pow(2, s)), (a += u))
                  : ((o = t * Math.pow(2, u - 1) * Math.pow(2, s)), (a = 0)));
            s >= 8;
            e[r + f] = 255 & o, f += p, o /= 256, s -= 8
          );
          for (
            a = (a << s) | o, l += s;
            l > 0;
            e[r + f] = 255 & a, f += p, a /= 256, l -= 8
          );
          e[r + f - p] |= 128 * g;
        });
    },
    55480: (e, t, r) => {
      "use strict";
      r.d(t, { H: () => l });
      var i = r(1220),
        s = r(98866),
        n = r(28977),
        a = r(12319);
      let o = {
          getFeatureValue(e, t) {
            let r = t?.[e];
            return void 0 === r ? n.oU.DEFAULT_FEATURES[e] : r;
          },
          filterSocialsByPlatform(e) {
            if (!e || !e.length) return e;
            if (a.w.isTelegram()) {
              if (a.w.isIos()) return e.filter((e) => "google" !== e);
              if (a.w.isMac()) return e.filter((e) => "x" !== e);
              if (a.w.isAndroid())
                return e.filter((e) => !["facebook", "x"].includes(e));
            }
            return e;
          },
        },
        c = (0, i.BX)({
          features: n.oU.DEFAULT_FEATURES,
          projectId: "",
          sdkType: "appkit",
          sdkVersion: "html-wagmi-undefined",
          defaultAccountTypes: n.oU.DEFAULT_ACCOUNT_TYPES,
        }),
        l = {
          state: c,
          subscribeKey: (e, t) => (0, s.u$)(c, e, t),
          setOptions(e) {
            Object.assign(c, e);
          },
          setFeatures(e) {
            if (!e) return;
            c.features || (c.features = n.oU.DEFAULT_FEATURES);
            let t = { ...c.features, ...e };
            (c.features = t),
              c.features.socials &&
                (c.features.socials = o.filterSocialsByPlatform(
                  c.features.socials
                ));
          },
          setProjectId(e) {
            c.projectId = e;
          },
          setCustomRpcUrls(e) {
            c.customRpcUrls = e;
          },
          setAllWallets(e) {
            c.allWallets = e;
          },
          setIncludeWalletIds(e) {
            c.includeWalletIds = e;
          },
          setExcludeWalletIds(e) {
            c.excludeWalletIds = e;
          },
          setFeaturedWalletIds(e) {
            c.featuredWalletIds = e;
          },
          setTokens(e) {
            c.tokens = e;
          },
          setTermsConditionsUrl(e) {
            c.termsConditionsUrl = e;
          },
          setPrivacyPolicyUrl(e) {
            c.privacyPolicyUrl = e;
          },
          setCustomWallets(e) {
            c.customWallets = e;
          },
          setIsSiweEnabled(e) {
            c.isSiweEnabled = e;
          },
          setIsUniversalProvider(e) {
            c.isUniversalProvider = e;
          },
          setSdkVersion(e) {
            c.sdkVersion = e;
          },
          setMetadata(e) {
            c.metadata = e;
          },
          setDisableAppend(e) {
            c.disableAppend = e;
          },
          setEIP6963Enabled(e) {
            c.enableEIP6963 = e;
          },
          setDebug(e) {
            c.debug = e;
          },
          setEnableWalletConnect(e) {
            c.enableWalletConnect = e;
          },
          setEnableWalletGuide(e) {
            c.enableWalletGuide = e;
          },
          setEnableAuthLogger(e) {
            c.enableAuthLogger = e;
          },
          setEnableWallets(e) {
            c.enableWallets = e;
          },
          setHasMultipleAddresses(e) {
            c.hasMultipleAddresses = e;
          },
          setSIWX(e) {
            c.siwx = e;
          },
          setConnectMethodsOrder(e) {
            c.features = { ...c.features, connectMethodsOrder: e };
          },
          setWalletFeaturesOrder(e) {
            c.features = { ...c.features, walletFeaturesOrder: e };
          },
          setSocialsOrder(e) {
            c.features = { ...c.features, socials: e };
          },
          setCollapseWallets(e) {
            c.features = { ...c.features, collapseWallets: e };
          },
          setEnableEmbedded(e) {
            c.enableEmbedded = e;
          },
          setAllowUnsupportedChain(e) {
            c.allowUnsupportedChain = e;
          },
          setManualWCControl(e) {
            c.manualWCControl = e;
          },
          setDefaultAccountTypes(e = {}) {
            Object.entries(e).forEach(([e, t]) => {
              t && (c.defaultAccountTypes[e] = t);
            });
          },
          getSnapshot: () => (0, i.P9)(c),
        };
    },
    55563: (e, t, r) => {
      "use strict";
      r.d(t, { Af: () => f, ZJ: () => l, aT: () => h });
      var i = r(13933),
        s = r(60587),
        n = r(72427),
        a = r(11914),
        o = r(34561);
      let c = new TextEncoder();
      function l(e, t = {}) {
        var r, i;
        return "number" == typeof e || "bigint" == typeof e
          ? ((r = e), (i = t), h((0, o.cK)(r, i)))
          : "boolean" == typeof e
          ? (function (e, t = {}) {
              let r = new Uint8Array(1);
              return ((r[0] = Number(e)), "number" == typeof t.size)
                ? ((0, a.Sl)(r, { size: t.size }),
                  (0, n.eV)(r, { size: t.size }))
                : r;
            })(e, t)
          : (0, s.q)(e)
          ? h(e, t)
          : f(e, t);
      }
      let d = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
      function u(e) {
        return e >= d.zero && e <= d.nine
          ? e - d.zero
          : e >= d.A && e <= d.F
          ? e - (d.A - 10)
          : e >= d.a && e <= d.f
          ? e - (d.a - 10)
          : void 0;
      }
      function h(e, t = {}) {
        let r = e;
        t.size &&
          ((0, a.Sl)(r, { size: t.size }),
          (r = (0, n.eV)(r, { dir: "right", size: t.size })));
        let s = r.slice(2);
        s.length % 2 && (s = `0${s}`);
        let o = s.length / 2,
          c = new Uint8Array(o);
        for (let e = 0, t = 0; e < o; e++) {
          let r = u(s.charCodeAt(t++)),
            n = u(s.charCodeAt(t++));
          if (void 0 === r || void 0 === n)
            throw new i.C(
              `Invalid byte sequence ("${s[t - 2]}${s[t - 1]}" in "${s}").`
            );
          c[e] = 16 * r + n;
        }
        return c;
      }
      function f(e, t = {}) {
        let r = c.encode(e);
        return "number" == typeof t.size
          ? ((0, a.Sl)(r, { size: t.size }),
            (0, n.eV)(r, { dir: "right", size: t.size }))
          : r;
      }
    },
    55762: (e) => {
      "use strict";
      e.exports = function () {
        throw Error(
          "ws does not work in the browser. Browser clients must use the native WebSocket object"
        );
      };
    },
    56538: (e, t, r) => {
      "use strict";
      r.d(t, { Q: () => n });
      var i = r(89709);
      let s = /^tuple(?<array>(\[(\d*)\])*)$/;
      function n(e) {
        let t = "",
          r = e.length;
        for (let n = 0; n < r; n++)
          (t += (function e(t) {
            let r = t.type;
            if (s.test(t.type) && "components" in t) {
              r = "(";
              let n = t.components.length;
              for (let i = 0; i < n; i++)
                (r += e(t.components[i])), i < n - 1 && (r += ", ");
              let a = (0, i.Yv)(s, t.type);
              return (r += `)${a?.array ?? ""}`), e({ ...t, type: r });
            }
            return ("indexed" in t && t.indexed && (r = `${r} indexed`), t.name)
              ? `${r} ${t.name}`
              : r;
          })(e[n])),
            n !== r - 1 && (t += ", ");
        return t;
      }
    },
    56674: (e, t, r) => {
      "use strict";
      function i(
        e,
        { errorInstance: t = Error("timed out"), timeout: r, signal: i }
      ) {
        return new Promise((s, n) => {
          (async () => {
            let a;
            try {
              let o = new AbortController();
              r > 0 &&
                (a = setTimeout(() => {
                  i ? o.abort() : n(t);
                }, r)),
                s(await e({ signal: o?.signal || null }));
            } catch (e) {
              e?.name === "AbortError" && n(t), n(e);
            } finally {
              clearTimeout(a);
            }
          })();
        });
      }
      r.d(t, { w: () => i });
    },
    57771: (e, t, r) => {
      "use strict";
      function i(e, t) {
        return JSON.parse(e, (e, r) => {
          let i = r;
          return (
            i?.__type === "bigint" && (i = BigInt(i.value)),
            i?.__type === "Map" && (i = new Map(i.value)),
            t?.(e, i) ?? i
          );
        });
      }
      r.d(t, { i: () => i });
    },
    58051: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => h });
      var i = r(1220),
        s = r(28977),
        n = r(12319),
        a = r(83941),
        o = r(44826),
        c = r(73442),
        l = r(65374),
        d = r(24836);
      let u = (0, i.BX)({
          currentTab: 0,
          tokenBalance: [],
          smartAccountDeployed: !1,
          addressLabels: new Map(),
          allAccounts: [],
        }),
        h = {
          state: u,
          replaceState(e) {
            e && Object.assign(u, (0, i.KR)(e));
          },
          subscribe: (e) =>
            c.W.subscribeChainProp("accountState", (t) => {
              if (t) return e(t);
            }),
          subscribeKey(e, t, r) {
            let i;
            return c.W.subscribeChainProp(
              "accountState",
              (r) => {
                if (r) {
                  let s = r[e];
                  i !== s && ((i = s), t(s));
                }
              },
              r
            );
          },
          setStatus(e, t) {
            c.W.setAccountProp("status", e, t);
          },
          getCaipAddress: (e) => c.W.getAccountProp("caipAddress", e),
          setCaipAddress(e, t) {
            let r = e ? n.w.getPlainAddress(e) : void 0;
            t === c.W.state.activeChain && (c.W.state.activeCaipAddress = e),
              c.W.setAccountProp("caipAddress", e, t),
              c.W.setAccountProp("address", r, t);
          },
          setBalance(e, t, r) {
            c.W.setAccountProp("balance", e, r),
              c.W.setAccountProp("balanceSymbol", t, r);
          },
          setProfileName(e, t) {
            c.W.setAccountProp("profileName", e, t);
          },
          setProfileImage(e, t) {
            c.W.setAccountProp("profileImage", e, t);
          },
          setUser(e, t) {
            c.W.setAccountProp("user", e, t);
          },
          setAddressExplorerUrl(e, t) {
            c.W.setAccountProp("addressExplorerUrl", e, t);
          },
          setSmartAccountDeployed(e, t) {
            c.W.setAccountProp("smartAccountDeployed", e, t);
          },
          setCurrentTab(e) {
            c.W.setAccountProp("currentTab", e, c.W.state.activeChain);
          },
          setTokenBalance(e, t) {
            e && c.W.setAccountProp("tokenBalance", e, t);
          },
          setShouldUpdateToAddress(e, t) {
            c.W.setAccountProp("shouldUpdateToAddress", e, t);
          },
          setAllAccounts(e, t) {
            c.W.setAccountProp("allAccounts", e, t);
          },
          addAddressLabel(e, t, r) {
            let i = c.W.getAccountProp("addressLabels", r) || new Map();
            i.set(e, t), c.W.setAccountProp("addressLabels", i, r);
          },
          removeAddressLabel(e, t) {
            let r = c.W.getAccountProp("addressLabels", t) || new Map();
            r.delete(e), c.W.setAccountProp("addressLabels", r, t);
          },
          setConnectedWalletInfo(e, t) {
            c.W.setAccountProp("connectedWalletInfo", e, t, !1);
          },
          setPreferredAccountType(e, t) {
            c.W.setAccountProp("preferredAccountType", e, t);
          },
          setSocialProvider(e, t) {
            e && c.W.setAccountProp("socialProvider", e, t);
          },
          setSocialWindow(e, t) {
            c.W.setAccountProp("socialWindow", e ? (0, i.KR)(e) : void 0, t);
          },
          setFarcasterUrl(e, t) {
            c.W.setAccountProp("farcasterUrl", e, t);
          },
          async fetchTokenBalance(e) {
            u.balanceLoading = !0;
            let t = c.W.state.activeCaipNetwork?.caipNetworkId,
              r = c.W.state.activeCaipNetwork?.chainNamespace,
              i = c.W.state.activeCaipAddress,
              h = i ? n.w.getPlainAddress(i) : void 0;
            if (
              u.lastRetry &&
              !n.w.isAllowedRetry(u.lastRetry, 30 * s.oU.ONE_SEC_MS)
            )
              return (u.balanceLoading = !1), [];
            try {
              if (h && t && r) {
                let e = await o.T.getBalance(h, t),
                  i = e.balances.filter((e) => "0" !== e.quantity.decimals);
                return (
                  this.setTokenBalance(i, r),
                  d.GN.setBalances(a.s.mapBalancesToSwapTokens(e.balances)),
                  (u.lastRetry = void 0),
                  (u.balanceLoading = !1),
                  i
                );
              }
            } catch (t) {
              (u.lastRetry = Date.now()),
                e?.(t),
                l.P.showError("Token Balance Unavailable");
            } finally {
              u.balanceLoading = !1;
            }
            return [];
          },
          resetAccount(e) {
            c.W.resetAccount(e);
          },
        };
    },
    58222: (e, t, r) => {
      "use strict";
      r.d(t, { xW: () => y, sH: () => eQ, dI: () => eZ });
      var i = {};
      r.r(i), r.d(i, { identity: () => D });
      var s = {};
      r.r(s), r.d(s, { base2: () => M });
      var n = {};
      r.r(n), r.d(n, { base8: () => U });
      var a = {};
      r.r(a), r.d(a, { base10: () => L });
      var o = {};
      r.r(o), r.d(o, { base16: () => B, base16upper: () => j });
      var c = {};
      r.r(c),
        r.d(c, {
          base32: () => F,
          base32hex: () => H,
          base32hexpad: () => V,
          base32hexpadupper: () => K,
          base32hexupper: () => q,
          base32pad: () => z,
          base32padupper: () => W,
          base32upper: () => $,
          base32z: () => G,
        });
      var l = {};
      r.r(l), r.d(l, { base36: () => Y, base36upper: () => Q });
      var d = {};
      r.r(d), r.d(d, { base58btc: () => Z, base58flickr: () => J });
      var u = {};
      r.r(u),
        r.d(u, {
          base64: () => X,
          base64pad: () => ee,
          base64url: () => et,
          base64urlpad: () => er,
        });
      var h = {};
      r.r(h), r.d(h, { base256emoji: () => ea });
      var f = {};
      r.r(f), r.d(f, { sha256: () => ev, sha512: () => eA });
      var p = {};
      r.r(p), r.d(p, { identity: () => eE });
      var g = {};
      r.r(g),
        r.d(g, {
          code: () => eC,
          decode: () => eS,
          encode: () => eI,
          name: () => e_,
        });
      var m = {};
      function b(e = 0) {
        return null != globalThis.Buffer &&
          null != globalThis.Buffer.allocUnsafe
          ? globalThis.Buffer.allocUnsafe(e)
          : new Uint8Array(e);
      }
      function y(e, t) {
        t || (t = e.reduce((e, t) => e + t.length, 0));
        let r = b(t),
          i = 0;
        for (let t of e) r.set(t, i), (i += t.length);
        return r;
      }
      r.r(m),
        r.d(m, {
          code: () => eP,
          decode: () => ek,
          encode: () => eO,
          name: () => eT,
        });
      let w = function (e, t) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
        for (var s = 0; s < e.length; s++) {
          var n = e.charAt(s),
            a = n.charCodeAt(0);
          if (255 !== r[a]) throw TypeError(n + " is ambiguous");
          r[a] = s;
        }
        var o = e.length,
          c = e.charAt(0),
          l = Math.log(o) / Math.log(256),
          d = Math.log(256) / Math.log(o);
        function u(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[0]) {
            for (var i = 0, s = 0; e[t] === c; ) i++, t++;
            for (
              var n = ((e.length - t) * l + 1) >>> 0, a = new Uint8Array(n);
              e[t];

            ) {
              var d = r[e.charCodeAt(t)];
              if (255 === d) return;
              for (
                var u = 0, h = n - 1;
                (0 !== d || u < s) && -1 !== h;
                h--, u++
              )
                (d += (o * a[h]) >>> 0),
                  (a[h] = d % 256 >>> 0),
                  (d = (d / 256) >>> 0);
              if (0 !== d) throw Error("Non-zero carry");
              (s = u), t++;
            }
            if (" " !== e[t]) {
              for (var f = n - s; f !== n && 0 === a[f]; ) f++;
              for (var p = new Uint8Array(i + (n - f)), g = i; f !== n; )
                p[g++] = a[f++];
              return p;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            for (var r = 0, i = 0, s = 0, n = t.length; s !== n && 0 === t[s]; )
              s++, r++;
            for (
              var a = ((n - s) * d + 1) >>> 0, l = new Uint8Array(a);
              s !== n;

            ) {
              for (
                var u = t[s], h = 0, f = a - 1;
                (0 !== u || h < i) && -1 !== f;
                f--, h++
              )
                (u += (256 * l[f]) >>> 0),
                  (l[f] = u % o >>> 0),
                  (u = (u / o) >>> 0);
              if (0 !== u) throw Error("Non-zero carry");
              (i = h), s++;
            }
            for (var p = a - i; p !== a && 0 === l[p]; ) p++;
            for (var g = c.repeat(r); p < a; ++p) g += e.charAt(l[p]);
            return g;
          },
          decodeUnsafe: u,
          decode: function (e) {
            var r = u(e);
            if (r) return r;
            throw Error(`Non-${t} character`);
          },
        };
      };
      new Uint8Array(0);
      let v = (e, t) => {
          if (e === t) return !0;
          if (e.byteLength !== t.byteLength) return !1;
          for (let r = 0; r < e.byteLength; r++) if (e[r] !== t[r]) return !1;
          return !0;
        },
        A = (e) => {
          if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
            return e;
          if (e instanceof ArrayBuffer) return new Uint8Array(e);
          if (ArrayBuffer.isView(e))
            return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw Error("Unknown type, must be binary type");
        },
        E = (e) => new TextEncoder().encode(e),
        _ = (e) => new TextDecoder().decode(e);
      class C {
        constructor(e, t, r) {
          (this.name = e), (this.prefix = t), (this.baseEncode = r);
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class I {
        constructor(e, t, r) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error("Invalid prefix character");
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
        }
        decode(e) {
          if ("string" == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${
                  this.name
                } decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error("Can only multibase decode strings");
        }
        or(e) {
          return x(this, e);
        }
      }
      class S {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return x(this, e);
        }
        decode(e) {
          let t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(
              e
            )}, only inputs prefixed with ${Object.keys(
              this.decoders
            )} are supported`
          );
        }
      }
      let x = (e, t) =>
        new S({
          ...(e.decoders || { [e.prefix]: e }),
          ...(t.decoders || { [t.prefix]: t }),
        });
      class N {
        constructor(e, t, r, i) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = r),
            (this.baseDecode = i),
            (this.encoder = new C(e, t, r)),
            (this.decoder = new I(e, t, i));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let T = ({ name: e, prefix: t, encode: r, decode: i }) =>
          new N(e, t, r, i),
        P = ({ prefix: e, name: t, alphabet: r }) => {
          let { encode: i, decode: s } = w(r, t);
          return T({ prefix: e, name: t, encode: i, decode: (e) => A(s(e)) });
        },
        O = (e, t, r, i) => {
          let s = {};
          for (let e = 0; e < t.length; ++e) s[t[e]] = e;
          let n = e.length;
          for (; "=" === e[n - 1]; ) --n;
          let a = new Uint8Array(((n * r) / 8) | 0),
            o = 0,
            c = 0,
            l = 0;
          for (let t = 0; t < n; ++t) {
            let n = s[e[t]];
            if (void 0 === n) throw SyntaxError(`Non-${i} character`);
            (c = (c << r) | n),
              (o += r) >= 8 && ((o -= 8), (a[l++] = 255 & (c >> o)));
          }
          if (o >= r || 255 & (c << (8 - o)))
            throw SyntaxError("Unexpected end of data");
          return a;
        },
        k = (e, t, r) => {
          let i = "=" === t[t.length - 1],
            s = (1 << r) - 1,
            n = "",
            a = 0,
            o = 0;
          for (let i = 0; i < e.length; ++i)
            for (o = (o << 8) | e[i], a += 8; a > r; )
              (a -= r), (n += t[s & (o >> a)]);
          if ((a && (n += t[s & (o << (r - a))]), i))
            for (; (n.length * r) & 7; ) n += "=";
          return n;
        },
        R = ({ name: e, prefix: t, bitsPerChar: r, alphabet: i }) =>
          T({
            prefix: t,
            name: e,
            encode: (e) => k(e, i, r),
            decode: (t) => O(t, i, r, e),
          }),
        D = T({
          prefix: "\0",
          name: "identity",
          encode: (e) => _(e),
          decode: (e) => E(e),
        }),
        M = R({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 }),
        U = R({
          prefix: "7",
          name: "base8",
          alphabet: "01234567",
          bitsPerChar: 3,
        }),
        L = P({ prefix: "9", name: "base10", alphabet: "0123456789" }),
        B = R({
          prefix: "f",
          name: "base16",
          alphabet: "0123456789abcdef",
          bitsPerChar: 4,
        }),
        j = R({
          prefix: "F",
          name: "base16upper",
          alphabet: "0123456789ABCDEF",
          bitsPerChar: 4,
        }),
        F = R({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5,
        }),
        $ = R({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5,
        }),
        z = R({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5,
        }),
        W = R({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5,
        }),
        H = R({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5,
        }),
        q = R({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5,
        }),
        V = R({
          prefix: "t",
          name: "base32hexpad",
          alphabet: "0123456789abcdefghijklmnopqrstuv=",
          bitsPerChar: 5,
        }),
        K = R({
          prefix: "T",
          name: "base32hexpadupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
          bitsPerChar: 5,
        }),
        G = R({
          prefix: "h",
          name: "base32z",
          alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
          bitsPerChar: 5,
        }),
        Y = P({
          prefix: "k",
          name: "base36",
          alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
        }),
        Q = P({
          prefix: "K",
          name: "base36upper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        }),
        Z = P({
          name: "base58btc",
          prefix: "z",
          alphabet:
            "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
        }),
        J = P({
          name: "base58flickr",
          prefix: "Z",
          alphabet:
            "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
        }),
        X = R({
          prefix: "m",
          name: "base64",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          bitsPerChar: 6,
        }),
        ee = R({
          prefix: "M",
          name: "base64pad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6,
        }),
        et = R({
          prefix: "u",
          name: "base64url",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6,
        }),
        er = R({
          prefix: "U",
          name: "base64urlpad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6,
        }),
        ei = Array.from(
          "\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"
        ),
        es = ei.reduce((e, t, r) => ((e[r] = t), e), []),
        en = ei.reduce((e, t, r) => ((e[t.codePointAt(0)] = r), e), []),
        ea = T({
          prefix: "\uD83D\uDE80",
          name: "base256emoji",
          encode: function (e) {
            return e.reduce((e, t) => (e += es[t]), "");
          },
          decode: function (e) {
            let t = [];
            for (let r of e) {
              let e = en[r.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${r}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        });
      function eo(e, t, r) {
        t = t || [];
        for (var i = (r = r || 0); e >= 0x80000000; )
          (t[r++] = (255 & e) | 128), (e /= 128);
        for (; -128 & e; ) (t[r++] = (255 & e) | 128), (e >>>= 7);
        return (t[r] = 0 | e), (eo.bytes = r - i + 1), t;
      }
      function ec(e, t) {
        var r,
          i = 0,
          t = t || 0,
          s = 0,
          n = t,
          a = e.length;
        do {
          if (n >= a)
            throw ((ec.bytes = 0), RangeError("Could not decode varint"));
          (r = e[n++]),
            (i += s < 28 ? (127 & r) << s : (127 & r) * Math.pow(2, s)),
            (s += 7);
        } while (r >= 128);
        return (ec.bytes = n - t), i;
      }
      let el = {
          encode: eo,
          decode: ec,
          encodingLength: function (e) {
            return e < 128
              ? 1
              : e < 16384
              ? 2
              : e < 2097152
              ? 3
              : e < 0x10000000
              ? 4
              : e < 0x800000000
              ? 5
              : e < 0x40000000000
              ? 6
              : e < 0x2000000000000
              ? 7
              : e < 0x100000000000000
              ? 8
              : e < 0x8000000000000000
              ? 9
              : 10;
          },
        },
        ed = (e, t = 0) => [el.decode(e, t), el.decode.bytes],
        eu = (e, t, r = 0) => (el.encode(e, t, r), t),
        eh = (e) => el.encodingLength(e),
        ef = (e, t) => {
          let r = t.byteLength,
            i = eh(e),
            s = i + eh(r),
            n = new Uint8Array(s + r);
          return eu(e, n, 0), eu(r, n, i), n.set(t, s), new em(e, r, t, n);
        },
        ep = (e) => {
          let t = A(e),
            [r, i] = ed(t),
            [s, n] = ed(t.subarray(i)),
            a = t.subarray(i + n);
          if (a.byteLength !== s) throw Error("Incorrect length");
          return new em(r, s, a, t);
        },
        eg = (e, t) =>
          e === t ||
          (e.code === t.code && e.size === t.size && v(e.bytes, t.bytes));
      class em {
        constructor(e, t, r, i) {
          (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
        }
      }
      let eb = ({ name: e, code: t, encode: r }) => new ey(e, t, r);
      class ey {
        constructor(e, t, r) {
          (this.name = e), (this.code = t), (this.encode = r);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array
              ? ef(this.code, t)
              : t.then((e) => ef(this.code, e));
          }
          throw Error("Unknown type, must be binary type");
        }
      }
      let ew = (e) => async (t) =>
          new Uint8Array(await crypto.subtle.digest(e, t)),
        ev = eb({ name: "sha2-256", code: 18, encode: ew("SHA-256") }),
        eA = eb({ name: "sha2-512", code: 19, encode: ew("SHA-512") }),
        eE = {
          code: 0,
          name: "identity",
          encode: A,
          digest: (e) => ef(0, A(e)),
        },
        e_ = "raw",
        eC = 85,
        eI = (e) => A(e),
        eS = (e) => A(e),
        ex = new TextEncoder(),
        eN = new TextDecoder(),
        eT = "json",
        eP = 512,
        eO = (e) => ex.encode(JSON.stringify(e)),
        ek = (e) => JSON.parse(eN.decode(e));
      class eR {
        constructor(e, t, r, i) {
          (this.code = t),
            (this.version = e),
            (this.multihash = r),
            (this.bytes = i),
            (this.byteOffset = i.byteOffset),
            (this.byteLength = i.byteLength),
            (this.asCID = this),
            (this._baseCache = new Map()),
            Object.defineProperties(this, {
              byteOffset: ez,
              byteLength: ez,
              code: e$,
              version: e$,
              multihash: e$,
              bytes: e$,
              _baseCache: ez,
              asCID: ez,
            });
        }
        toV0() {
          if (0 === this.version) return this;
          {
            let { code: e, multihash: t } = this;
            if (e !== eL)
              throw Error("Cannot convert a non dag-pb CID to CIDv0");
            if (t.code !== eB)
              throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            return eR.createV0(t);
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              let { code: e, digest: t } = this.multihash,
                r = ef(e, t);
              return eR.createV1(this.code, r);
            }
            case 1:
              return this;
            default:
              throw Error(
                `Can not convert CID version ${this.version} to version 0. This is a bug please report`
              );
          }
        }
        equals(e) {
          return (
            e &&
            this.code === e.code &&
            this.version === e.version &&
            eg(this.multihash, e.multihash)
          );
        }
        toString(e) {
          let { bytes: t, version: r, _baseCache: i } = this;
          return 0 === r ? eM(t, i, e || Z.encoder) : eU(t, i, e || F.encoder);
        }
        toJSON() {
          return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes,
          };
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        static isCID(e) {
          return eW(/^0\.0/, eH), !!(e && (e[eF] || e.asCID === e));
        }
        get toBaseEncodedString() {
          throw Error("Deprecated, use .toString()");
        }
        get codec() {
          throw Error(
            '"codec" property is deprecated, use integer "code" property instead'
          );
        }
        get buffer() {
          throw Error(
            "Deprecated .buffer property, use .bytes to get Uint8Array instead"
          );
        }
        get multibaseName() {
          throw Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw Error('"prefix" property is deprecated');
        }
        static asCID(e) {
          if (e instanceof eR) return e;
          if (null != e && e.asCID === e) {
            let { version: t, code: r, multihash: i, bytes: s } = e;
            return new eR(t, r, i, s || ej(t, r, i.bytes));
          }
          if (null == e || !0 !== e[eF]) return null;
          {
            let { version: t, multihash: r, code: i } = e,
              s = ep(r);
            return eR.create(t, i, s);
          }
        }
        static create(e, t, r) {
          if ("number" != typeof t)
            throw Error("String codecs are no longer supported");
          switch (e) {
            case 0:
              if (t === eL) return new eR(e, t, r, r.bytes);
              throw Error(
                `Version 0 CID must use dag-pb (code: ${eL}) block encoding`
              );
            case 1: {
              let i = ej(e, t, r.bytes);
              return new eR(e, t, r, i);
            }
            default:
              throw Error("Invalid version");
          }
        }
        static createV0(e) {
          return eR.create(0, eL, e);
        }
        static createV1(e, t) {
          return eR.create(1, e, t);
        }
        static decode(e) {
          let [t, r] = eR.decodeFirst(e);
          if (r.length) throw Error("Incorrect length");
          return t;
        }
        static decodeFirst(e) {
          let t = eR.inspectBytes(e),
            r = t.size - t.multihashSize,
            i = A(e.subarray(r, r + t.multihashSize));
          if (i.byteLength !== t.multihashSize) throw Error("Incorrect length");
          let s = i.subarray(t.multihashSize - t.digestSize),
            n = new em(t.multihashCode, t.digestSize, s, i);
          return [
            0 === t.version ? eR.createV0(n) : eR.createV1(t.codec, n),
            e.subarray(t.size),
          ];
        }
        static inspectBytes(e) {
          let t = 0,
            r = () => {
              let [r, i] = ed(e.subarray(t));
              return (t += i), r;
            },
            i = r(),
            s = eL;
          if (
            (18 === i ? ((i = 0), (t = 0)) : 1 === i && (s = r()),
            0 !== i && 1 !== i)
          )
            throw RangeError(`Invalid CID version ${i}`);
          let n = t,
            a = r(),
            o = r(),
            c = t + o;
          return {
            version: i,
            codec: s,
            multihashCode: a,
            digestSize: o,
            multihashSize: c - n,
            size: c,
          };
        }
        static parse(e, t) {
          let [r, i] = eD(e, t),
            s = eR.decode(i);
          return s._baseCache.set(r, e), s;
        }
      }
      let eD = (e, t) => {
          switch (e[0]) {
            case "Q": {
              let r = t || Z;
              return [Z.prefix, r.decode(`${Z.prefix}${e}`)];
            }
            case Z.prefix: {
              let r = t || Z;
              return [Z.prefix, r.decode(e)];
            }
            case F.prefix: {
              let r = t || F;
              return [F.prefix, r.decode(e)];
            }
            default:
              if (null == t)
                throw Error(
                  "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
                );
              return [e[0], t.decode(e)];
          }
        },
        eM = (e, t, r) => {
          let { prefix: i } = r;
          if (i !== Z.prefix)
            throw Error(`Cannot string encode V0 in ${r.name} encoding`);
          let s = t.get(i);
          if (null != s) return s;
          {
            let s = r.encode(e).slice(1);
            return t.set(i, s), s;
          }
        },
        eU = (e, t, r) => {
          let { prefix: i } = r,
            s = t.get(i);
          if (null != s) return s;
          {
            let s = r.encode(e);
            return t.set(i, s), s;
          }
        },
        eL = 112,
        eB = 18,
        ej = (e, t, r) => {
          let i = eh(e),
            s = i + eh(t),
            n = new Uint8Array(s + r.byteLength);
          return eu(e, n, 0), eu(t, n, i), n.set(r, s), n;
        },
        eF = Symbol.for("@ipld/js-cid/CID"),
        e$ = { writable: !1, configurable: !1, enumerable: !0 },
        ez = { writable: !1, enumerable: !1, configurable: !1 },
        eW = (e, t) => {
          if (e.test("0.0.0-dev")) console.warn(t);
          else throw Error(t);
        },
        eH = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,
        eq = { ...i, ...s, ...n, ...a, ...o, ...c, ...l, ...d, ...u, ...h };
      function eV(e, t, r, i) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: r },
          decoder: { decode: i },
        };
      }
      ({ ...f, ...p });
      let eK = eV(
          "utf8",
          "u",
          (e) => "u" + new TextDecoder("utf8").decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        eG = eV(
          "ascii",
          "a",
          (e) => {
            let t = "a";
            for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
            return t;
          },
          (e) => {
            let t = b((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
            return t;
          }
        ),
        eY = {
          utf8: eK,
          "utf-8": eK,
          hex: eq.base16,
          latin1: eG,
          ascii: eG,
          binary: eG,
          ...eq,
        };
      function eQ(e, t = "utf8") {
        let r = eY[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(e, "utf8")
          : r.decoder.decode(`${r.prefix}${e}`);
      }
      function eZ(e, t = "utf8") {
        let r = eY[t];
        if (!r) throw Error(`Unsupported encoding "${t}"`);
        return ("utf8" === t || "utf-8" === t) &&
          null != globalThis.Buffer &&
          null != globalThis.Buffer.from
          ? globalThis.Buffer.from(
              e.buffer,
              e.byteOffset,
              e.byteLength
            ).toString("utf8")
          : r.encoder.encode(e).substring(1);
      }
    },
    58653: (e, t, r) => {
      "use strict";
      r.d(t, { i: () => s });
      var i = r(93965);
      let s = {
        cacheExpiry: {
          portfolio: 3e4,
          nativeBalance: 3e4,
          ens: 3e5,
          identity: 3e5,
        },
        isCacheExpired: (e, t) => Date.now() - e > t,
        getActiveNetworkProps() {
          let e = s.getActiveNamespace(),
            t = s.getActiveCaipNetworkId(),
            r = t ? t.split(":")[1] : void 0;
          return {
            namespace: e,
            caipNetworkId: t,
            chainId: r ? (isNaN(Number(r)) ? r : Number(r)) : void 0,
          };
        },
        setWalletConnectDeepLink({ name: e, href: t }) {
          try {
            i.Ud.setItem(
              i.Ws.DEEPLINK_CHOICE,
              JSON.stringify({ href: t, name: e })
            );
          } catch {
            console.info("Unable to set WalletConnect deep link");
          }
        },
        getWalletConnectDeepLink() {
          try {
            let e = i.Ud.getItem(i.Ws.DEEPLINK_CHOICE);
            if (e) return JSON.parse(e);
          } catch {
            console.info("Unable to get WalletConnect deep link");
          }
        },
        deleteWalletConnectDeepLink() {
          try {
            i.Ud.removeItem(i.Ws.DEEPLINK_CHOICE);
          } catch {
            console.info("Unable to delete WalletConnect deep link");
          }
        },
        setActiveNamespace(e) {
          try {
            i.Ud.setItem(i.Ws.ACTIVE_NAMESPACE, e);
          } catch {
            console.info("Unable to set active namespace");
          }
        },
        setActiveCaipNetworkId(e) {
          try {
            i.Ud.setItem(i.Ws.ACTIVE_CAIP_NETWORK_ID, e),
              s.setActiveNamespace(e.split(":")[0]);
          } catch {
            console.info("Unable to set active caip network id");
          }
        },
        getActiveCaipNetworkId() {
          try {
            return i.Ud.getItem(i.Ws.ACTIVE_CAIP_NETWORK_ID);
          } catch {
            console.info("Unable to get active caip network id");
            return;
          }
        },
        deleteActiveCaipNetworkId() {
          try {
            i.Ud.removeItem(i.Ws.ACTIVE_CAIP_NETWORK_ID);
          } catch {
            console.info("Unable to delete active caip network id");
          }
        },
        deleteConnectedConnectorId(e) {
          try {
            let t = (0, i.T8)(e);
            i.Ud.removeItem(t);
          } catch {
            console.info("Unable to delete connected connector id");
          }
        },
        setAppKitRecent(e) {
          try {
            let t = s.getRecentWallets();
            t.find((t) => t.id === e.id) ||
              (t.unshift(e),
              t.length > 2 && t.pop(),
              i.Ud.setItem(i.Ws.RECENT_WALLETS, JSON.stringify(t)));
          } catch {
            console.info("Unable to set AppKit recent");
          }
        },
        getRecentWallets() {
          try {
            let e = i.Ud.getItem(i.Ws.RECENT_WALLETS);
            return e ? JSON.parse(e) : [];
          } catch {
            console.info("Unable to get AppKit recent");
          }
          return [];
        },
        setConnectedConnectorId(e, t) {
          try {
            let r = (0, i.T8)(e);
            i.Ud.setItem(r, t);
          } catch {
            console.info("Unable to set Connected Connector Id");
          }
        },
        getActiveNamespace() {
          try {
            return i.Ud.getItem(i.Ws.ACTIVE_NAMESPACE);
          } catch {
            console.info("Unable to get active namespace");
          }
        },
        getConnectedConnectorId(e) {
          if (e)
            try {
              let t = (0, i.T8)(e);
              return i.Ud.getItem(t);
            } catch (t) {
              console.info(
                "Unable to get connected connector id in namespace ",
                e
              );
            }
        },
        setConnectedSocialProvider(e) {
          try {
            i.Ud.setItem(i.Ws.CONNECTED_SOCIAL, e);
          } catch {
            console.info("Unable to set connected social provider");
          }
        },
        getConnectedSocialProvider() {
          try {
            return i.Ud.getItem(i.Ws.CONNECTED_SOCIAL);
          } catch {
            console.info("Unable to get connected social provider");
          }
        },
        deleteConnectedSocialProvider() {
          try {
            i.Ud.removeItem(i.Ws.CONNECTED_SOCIAL);
          } catch {
            console.info("Unable to delete connected social provider");
          }
        },
        getConnectedSocialUsername() {
          try {
            return i.Ud.getItem(i.Ws.CONNECTED_SOCIAL_USERNAME);
          } catch {
            console.info("Unable to get connected social username");
          }
        },
        getStoredActiveCaipNetworkId() {
          let e = i.Ud.getItem(i.Ws.ACTIVE_CAIP_NETWORK_ID);
          return e?.split(":")?.[1];
        },
        setConnectionStatus(e) {
          try {
            i.Ud.setItem(i.Ws.CONNECTION_STATUS, e);
          } catch {
            console.info("Unable to set connection status");
          }
        },
        getConnectionStatus() {
          try {
            return i.Ud.getItem(i.Ws.CONNECTION_STATUS);
          } catch {
            return;
          }
        },
        getConnectedNamespaces() {
          try {
            let e = i.Ud.getItem(i.Ws.CONNECTED_NAMESPACES);
            if (!e?.length) return [];
            return e.split(",");
          } catch {
            return [];
          }
        },
        setConnectedNamespaces(e) {
          try {
            let t = Array.from(new Set(e));
            i.Ud.setItem(i.Ws.CONNECTED_NAMESPACES, t.join(","));
          } catch {
            console.info("Unable to set namespaces in storage");
          }
        },
        addConnectedNamespace(e) {
          try {
            let t = s.getConnectedNamespaces();
            t.includes(e) || (t.push(e), s.setConnectedNamespaces(t));
          } catch {
            console.info("Unable to add connected namespace");
          }
        },
        removeConnectedNamespace(e) {
          try {
            let t = s.getConnectedNamespaces(),
              r = t.indexOf(e);
            r > -1 && (t.splice(r, 1), s.setConnectedNamespaces(t));
          } catch {
            console.info("Unable to remove connected namespace");
          }
        },
        getTelegramSocialProvider() {
          try {
            return i.Ud.getItem(i.Ws.TELEGRAM_SOCIAL_PROVIDER);
          } catch {
            return console.info("Unable to get telegram social provider"), null;
          }
        },
        setTelegramSocialProvider(e) {
          try {
            i.Ud.setItem(i.Ws.TELEGRAM_SOCIAL_PROVIDER, e);
          } catch {
            console.info("Unable to set telegram social provider");
          }
        },
        removeTelegramSocialProvider() {
          try {
            i.Ud.removeItem(i.Ws.TELEGRAM_SOCIAL_PROVIDER);
          } catch {
            console.info("Unable to remove telegram social provider");
          }
        },
        getBalanceCache() {
          let e = {};
          try {
            let t = i.Ud.getItem(i.Ws.PORTFOLIO_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get balance cache");
          }
          return e;
        },
        removeAddressFromBalanceCache(e) {
          try {
            let t = s.getBalanceCache();
            i.Ud.setItem(
              i.Ws.PORTFOLIO_CACHE,
              JSON.stringify({ ...t, [e]: void 0 })
            );
          } catch {
            console.info("Unable to remove address from balance cache", e);
          }
        },
        getBalanceCacheForCaipAddress(e) {
          try {
            let t = s.getBalanceCache()[e];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.portfolio)
            )
              return t.balance;
            s.removeAddressFromBalanceCache(e);
          } catch {
            console.info("Unable to get balance cache for address", e);
          }
        },
        updateBalanceCache(e) {
          try {
            let t = s.getBalanceCache();
            (t[e.caipAddress] = e),
              i.Ud.setItem(i.Ws.PORTFOLIO_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update balance cache", e);
          }
        },
        getNativeBalanceCache() {
          let e = {};
          try {
            let t = i.Ud.getItem(i.Ws.NATIVE_BALANCE_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get balance cache");
          }
          return e;
        },
        removeAddressFromNativeBalanceCache(e) {
          try {
            let t = s.getBalanceCache();
            i.Ud.setItem(
              i.Ws.NATIVE_BALANCE_CACHE,
              JSON.stringify({ ...t, [e]: void 0 })
            );
          } catch {
            console.info("Unable to remove address from balance cache", e);
          }
        },
        getNativeBalanceCacheForCaipAddress(e) {
          try {
            let t = s.getNativeBalanceCache()[e];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.nativeBalance)
            )
              return t;
            console.info("Discarding cache for address", e),
              s.removeAddressFromBalanceCache(e);
          } catch {
            console.info("Unable to get balance cache for address", e);
          }
        },
        updateNativeBalanceCache(e) {
          try {
            let t = s.getNativeBalanceCache();
            (t[e.caipAddress] = e),
              i.Ud.setItem(i.Ws.NATIVE_BALANCE_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update balance cache", e);
          }
        },
        getEnsCache() {
          let e = {};
          try {
            let t = i.Ud.getItem(i.Ws.ENS_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get ens name cache");
          }
          return e;
        },
        getEnsFromCacheForAddress(e) {
          try {
            let t = s.getEnsCache()[e];
            if (t && !this.isCacheExpired(t.timestamp, this.cacheExpiry.ens))
              return t.ens;
            s.removeEnsFromCache(e);
          } catch {
            console.info("Unable to get ens name from cache", e);
          }
        },
        updateEnsCache(e) {
          try {
            let t = s.getEnsCache();
            (t[e.address] = e), i.Ud.setItem(i.Ws.ENS_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update ens name cache", e);
          }
        },
        removeEnsFromCache(e) {
          try {
            let t = s.getEnsCache();
            i.Ud.setItem(i.Ws.ENS_CACHE, JSON.stringify({ ...t, [e]: void 0 }));
          } catch {
            console.info("Unable to remove ens name from cache", e);
          }
        },
        getIdentityCache() {
          let e = {};
          try {
            let t = i.Ud.getItem(i.Ws.IDENTITY_CACHE);
            e = t ? JSON.parse(t) : {};
          } catch {
            console.info("Unable to get identity cache");
          }
          return e;
        },
        getIdentityFromCacheForAddress(e) {
          try {
            let t = s.getIdentityCache()[e];
            if (
              t &&
              !this.isCacheExpired(t.timestamp, this.cacheExpiry.identity)
            )
              return t.identity;
            s.removeIdentityFromCache(e);
          } catch {
            console.info("Unable to get identity from cache", e);
          }
        },
        updateIdentityCache(e) {
          try {
            let t = s.getIdentityCache();
            (t[e.address] = { identity: e.identity, timestamp: e.timestamp }),
              i.Ud.setItem(i.Ws.IDENTITY_CACHE, JSON.stringify(t));
          } catch {
            console.info("Unable to update identity cache", e);
          }
        },
        removeIdentityFromCache(e) {
          try {
            let t = s.getIdentityCache();
            i.Ud.setItem(
              i.Ws.IDENTITY_CACHE,
              JSON.stringify({ ...t, [e]: void 0 })
            );
          } catch {
            console.info("Unable to remove identity from cache", e);
          }
        },
        clearAddressCache() {
          try {
            i.Ud.removeItem(i.Ws.PORTFOLIO_CACHE),
              i.Ud.removeItem(i.Ws.NATIVE_BALANCE_CACHE),
              i.Ud.removeItem(i.Ws.ENS_CACHE),
              i.Ud.removeItem(i.Ws.IDENTITY_CACHE);
          } catch {
            console.info("Unable to clear address cache");
          }
        },
      };
    },
    59350: (e, t, r) => {
      "use strict";
      r.d(t, { A: () => i });
      let i = (e, t, r) =>
        JSON.stringify(
          e,
          (e, r) => {
            let i = "bigint" == typeof r ? r.toString() : r;
            return "function" == typeof t ? t(e, i) : i;
          },
          r
        );
    },
    60587: (e, t, r) => {
      "use strict";
      function i(e, { strict: t = !0 } = {}) {
        return (
          !!e &&
          "string" == typeof e &&
          (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x"))
        );
      }
      r.d(t, { q: () => i });
    },
    60861: (e, t) => {
      "use strict";
      function r(e) {
        let {
          ampFirst: t = !1,
          hybrid: r = !1,
          hasQuery: i = !1,
        } = void 0 === e ? {} : e;
        return t || (r && i);
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "isInAmpMode", {
          enumerable: !0,
          get: function () {
            return r;
          },
        });
    },
    62023: (e, t, r) => {
      "use strict";
      r.d(t, { eL: () => i, pj: () => n, sz: () => s });
      let i = { gwei: 9, wei: 18 },
        s = { ether: -9, wei: 9 },
        n = { ether: -18, gwei: -9 };
    },
    62609: (e, t, r) => {
      "use strict";
      r.d(t, { f: () => p });
      var i = r(1220),
        s = r(98866);
      let n = {
        convertEVMChainIdToCoinType(e) {
          if (e >= 0x80000000) throw Error("Invalid chainId");
          return (0x80000000 | e) >>> 0;
        },
      };
      var a = r(58653),
        o = r(58051),
        c = r(44826),
        l = r(73442),
        d = r(3824),
        u = r(66254),
        h = r(67869);
      let f = (0, i.BX)({ suggestions: [], loading: !1 }),
        p = {
          state: f,
          subscribe: (e) => (0, i.B1)(f, () => e(f)),
          subscribeKey: (e, t) => (0, s.u$)(f, e, t),
          async resolveName(e) {
            try {
              return await c.T.lookupEnsName(e);
            } catch (e) {
              throw Error(
                e?.reasons?.[0]?.description || "Error resolving name"
              );
            }
          },
          async isNameRegistered(e) {
            try {
              return await c.T.lookupEnsName(e), !0;
            } catch {
              return !1;
            }
          },
          async getSuggestions(e) {
            try {
              return (
                (f.loading = !0),
                (f.suggestions = []),
                (f.suggestions =
                  (await c.T.getEnsNameSuggestions(e)).suggestions.map((e) => ({
                    ...e,
                    name: e.name,
                  })) || []),
                f.suggestions
              );
            } catch (e) {
              throw Error(
                this.parseEnsApiError(e, "Error fetching name suggestions")
              );
            } finally {
              f.loading = !1;
            }
          },
          async getNamesForAddress(e) {
            try {
              if (!l.W.state.activeCaipNetwork) return [];
              let t = a.i.getEnsFromCacheForAddress(e);
              if (t) return t;
              let r = await c.T.reverseLookupEnsName({ address: e });
              return (
                a.i.updateEnsCache({
                  address: e,
                  ens: r,
                  timestamp: Date.now(),
                }),
                r
              );
            } catch (e) {
              throw Error(
                this.parseEnsApiError(e, "Error fetching names for address")
              );
            }
          },
          async registerName(e) {
            let t = l.W.state.activeCaipNetwork;
            if (!t) throw Error("Network not found");
            let r = o.U.state.address,
              i = u.a.getAuthConnector();
            if (!r || !i) throw Error("Address or auth connector not found");
            f.loading = !0;
            try {
              let i = JSON.stringify({
                name: e,
                attributes: {},
                timestamp: Math.floor(Date.now() / 1e3),
              });
              h.I.pushTransactionStack({
                view: "RegisterAccountNameSuccess",
                goBack: !1,
                replace: !0,
                onCancel() {
                  f.loading = !1;
                },
              });
              let s = await d.x.signMessage(i),
                a = t.id;
              if (!a) throw Error("Network not found");
              let l = n.convertEVMChainIdToCoinType(Number(a));
              await c.T.registerEnsName({
                coinType: l,
                address: r,
                signature: s,
                message: i,
              }),
                o.U.setProfileName(e, t.chainNamespace),
                h.I.replace("RegisterAccountNameSuccess");
            } catch (r) {
              let t = this.parseEnsApiError(r, `Error registering name ${e}`);
              throw (h.I.replace("RegisterAccountName"), Error(t));
            } finally {
              f.loading = !1;
            }
          },
          validateName: (e) => /^[a-zA-Z0-9-]{4,}$/u.test(e),
          parseEnsApiError: (e, t) => e?.reasons?.[0]?.description || t,
        };
    },
    63542: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => i });
      class i extends Error {
        constructor(e, t = {}) {
          let r =
              t.cause instanceof i
                ? t.cause.details
                : t.cause?.message
                ? t.cause.message
                : t.details,
            s = (t.cause instanceof i && t.cause.docsPath) || t.docsPath;
          super(
            [
              e || "An error occurred.",
              "",
              ...(t.metaMessages ? [...t.metaMessages, ""] : []),
              ...(s ? [`Docs: https://abitype.dev${s}`] : []),
              ...(r ? [`Details: ${r}`] : []),
              "Version: abitype@1.0.8",
            ].join("\n")
          ),
            Object.defineProperty(this, "details", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "docsPath", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "metaMessages", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "shortMessage", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "AbiTypeError",
            }),
            t.cause && (this.cause = t.cause),
            (this.details = r),
            (this.docsPath = s),
            (this.metaMessages = t.metaMessages),
            (this.shortMessage = e);
        }
      }
    },
    64663: (e, t, r) => {
      "use strict";
      function i() {
        return (
          (null === r.g || void 0 === r.g ? void 0 : r.g.crypto) ||
          (null === r.g || void 0 === r.g ? void 0 : r.g.msCrypto) ||
          {}
        );
      }
      function s() {
        let e = i();
        return e.subtle || e.webkitSubtle;
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.isBrowserCryptoAvailable =
          t.getSubtleCrypto =
          t.getBrowerCrypto =
            void 0),
        (t.getBrowerCrypto = i),
        (t.getSubtleCrypto = s),
        (t.isBrowserCryptoAvailable = function () {
          return !!i() && !!s();
        });
    },
    64874: (e, t, r) => {
      "use strict";
      var i = r(20920),
        s = r(3285);
      function n() {
        (this.pending = null),
          (this.pendingTotal = 0),
          (this.blockSize = this.constructor.blockSize),
          (this.outSize = this.constructor.outSize),
          (this.hmacStrength = this.constructor.hmacStrength),
          (this.padLength = this.constructor.padLength / 8),
          (this.endian = "big"),
          (this._delta8 = this.blockSize / 8),
          (this._delta32 = this.blockSize / 32);
      }
      (t.BlockHash = n),
        (n.prototype.update = function (e, t) {
          if (
            ((e = i.toArray(e, t)),
            this.pending
              ? (this.pending = this.pending.concat(e))
              : (this.pending = e),
            (this.pendingTotal += e.length),
            this.pending.length >= this._delta8)
          ) {
            var r = (e = this.pending).length % this._delta8;
            (this.pending = e.slice(e.length - r, e.length)),
              0 === this.pending.length && (this.pending = null),
              (e = i.join32(e, 0, e.length - r, this.endian));
            for (var s = 0; s < e.length; s += this._delta32)
              this._update(e, s, s + this._delta32);
          }
          return this;
        }),
        (n.prototype.digest = function (e) {
          return (
            this.update(this._pad()), s(null === this.pending), this._digest(e)
          );
        }),
        (n.prototype._pad = function () {
          var e = this.pendingTotal,
            t = this._delta8,
            r = t - ((e + this.padLength) % t),
            i = Array(r + this.padLength);
          i[0] = 128;
          for (var s = 1; s < r; s++) i[s] = 0;
          if (((e <<= 3), "big" === this.endian)) {
            for (var n = 8; n < this.padLength; n++) i[s++] = 0;
            (i[s++] = 0),
              (i[s++] = 0),
              (i[s++] = 0),
              (i[s++] = 0),
              (i[s++] = (e >>> 24) & 255),
              (i[s++] = (e >>> 16) & 255),
              (i[s++] = (e >>> 8) & 255),
              (i[s++] = 255 & e);
          } else
            for (
              n = 8,
                i[s++] = 255 & e,
                i[s++] = (e >>> 8) & 255,
                i[s++] = (e >>> 16) & 255,
                i[s++] = (e >>> 24) & 255,
                i[s++] = 0,
                i[s++] = 0,
                i[s++] = 0,
                i[s++] = 0;
              n < this.padLength;
              n++
            )
              i[s++] = 0;
          return i;
        });
    },
    65103: (e, t, r) => {
      "use strict";
      r.d(t, { C: () => i });
      let i = {
        validateCaipAddress(e) {
          if (e.split(":")?.length !== 3) throw Error("Invalid CAIP Address");
          return e;
        },
        parseCaipAddress(e) {
          let t = e.split(":");
          if (3 !== t.length) throw Error(`Invalid CAIP-10 address: ${e}`);
          let [r, i, s] = t;
          if (!r || !i || !s) throw Error(`Invalid CAIP-10 address: ${e}`);
          return { chainNamespace: r, chainId: i, address: s };
        },
        parseCaipNetworkId(e) {
          let t = e.split(":");
          if (2 !== t.length) throw Error(`Invalid CAIP-2 network id: ${e}`);
          let [r, i] = t;
          if (!r || !i) throw Error(`Invalid CAIP-2 network id: ${e}`);
          return { chainNamespace: r, chainId: i };
        },
      };
    },
    65374: (e, t, r) => {
      "use strict";
      r.d(t, { P: () => c });
      var i = r(1220),
        s = r(98866),
        n = r(12319);
      let a = Object.freeze({
          message: "",
          variant: "success",
          svg: void 0,
          open: !1,
          autoClose: !0,
        }),
        o = (0, i.BX)({ ...a }),
        c = {
          state: o,
          subscribeKey: (e, t) => (0, s.u$)(o, e, t),
          showLoading(e, t = {}) {
            this._showMessage({ message: e, variant: "loading", ...t });
          },
          showSuccess(e) {
            this._showMessage({ message: e, variant: "success" });
          },
          showSvg(e, t) {
            this._showMessage({ message: e, svg: t });
          },
          showError(e) {
            let t = n.w.parseError(e);
            this._showMessage({ message: t, variant: "error" });
          },
          hide() {
            (o.message = a.message),
              (o.variant = a.variant),
              (o.svg = a.svg),
              (o.open = a.open),
              (o.autoClose = a.autoClose);
          },
          _showMessage({
            message: e,
            svg: t,
            variant: r = "success",
            autoClose: i = a.autoClose,
          }) {
            o.open
              ? ((o.open = !1),
                setTimeout(() => {
                  (o.message = e),
                    (o.variant = r),
                    (o.svg = t),
                    (o.open = !0),
                    (o.autoClose = i);
                }, 150))
              : ((o.message = e),
                (o.variant = r),
                (o.svg = t),
                (o.open = !0),
                (o.autoClose = i));
          },
        };
    },
    65607: (e, t, r) => {
      "use strict";
      e.exports = r(66388);
    },
    65727: (e, t, r) => {
      "use strict";
      let i = r(88759);
      e.exports = n;
      let s =
        (function () {
          function e(e) {
            return void 0 !== e && e;
          }
          try {
            if ("undefined" != typeof globalThis) return globalThis;
            return (
              Object.defineProperty(Object.prototype, "globalThis", {
                get: function () {
                  return (
                    delete Object.prototype.globalThis, (this.globalThis = this)
                  );
                },
                configurable: !0,
              }),
              globalThis
            );
          } catch (t) {
            return e(self) || e(window) || e(this) || {};
          }
        })().console || {};
      function n(e) {
        var t, r;
        (e = e || {}).browser = e.browser || {};
        let i = e.browser.transmit;
        if (i && "function" != typeof i.send)
          throw Error("pino: transmit option must have a send function");
        let d = e.browser.write || s;
        e.browser.write && (e.browser.asObject = !0);
        let u = e.serializers || {},
          g = Array.isArray((t = e.browser.serialize))
            ? t.filter(function (e) {
                return "!stdSerializers.err" !== e;
              })
            : !0 === t && Object.keys(u),
          m = e.browser.serialize;
        Array.isArray(e.browser.serialize) &&
          e.browser.serialize.indexOf("!stdSerializers.err") > -1 &&
          (m = !1),
          "function" == typeof d &&
            (d.error = d.fatal = d.warn = d.info = d.debug = d.trace = d),
          !1 === e.enabled && (e.level = "silent");
        let b = e.level || "info",
          y = Object.create(d);
        y.log || (y.log = h),
          Object.defineProperty(y, "levelVal", {
            get: function () {
              return "silent" === this.level
                ? 1 / 0
                : this.levels.values[this.level];
            },
          }),
          Object.defineProperty(y, "level", {
            get: function () {
              return this._level;
            },
            set: function (e) {
              if ("silent" !== e && !this.levels.values[e])
                throw Error("unknown level " + e);
              (this._level = e),
                a(w, y, "error", "log"),
                a(w, y, "fatal", "error"),
                a(w, y, "warn", "error"),
                a(w, y, "info", "log"),
                a(w, y, "debug", "log"),
                a(w, y, "trace", "log");
            },
          });
        let w = {
          transmit: i,
          serialize: g,
          asObject: e.browser.asObject,
          levels: ["error", "fatal", "warn", "info", "debug", "trace"],
          timestamp:
            "function" == typeof (r = e).timestamp
              ? r.timestamp
              : !1 === r.timestamp
              ? f
              : p,
        };
        return (
          (y.levels = n.levels),
          (y.level = b),
          (y.setMaxListeners =
            y.getMaxListeners =
            y.emit =
            y.addListener =
            y.on =
            y.prependListener =
            y.once =
            y.prependOnceListener =
            y.removeListener =
            y.removeAllListeners =
            y.listeners =
            y.listenerCount =
            y.eventNames =
            y.write =
            y.flush =
              h),
          (y.serializers = u),
          (y._serialize = g),
          (y._stdErrSerialize = m),
          (y.child = function (t, r) {
            if (!t) throw Error("missing bindings for child Pino");
            (r = r || {}),
              g && t.serializers && (r.serializers = t.serializers);
            let s = r.serializers;
            if (g && s) {
              var n = Object.assign({}, u, s),
                a = !0 === e.browser.serialize ? Object.keys(n) : g;
              delete t.serializers, o([t], a, n, this._stdErrSerialize);
            }
            function d(e) {
              (this._childLevel = (0 | e._childLevel) + 1),
                (this.error = c(e, t, "error")),
                (this.fatal = c(e, t, "fatal")),
                (this.warn = c(e, t, "warn")),
                (this.info = c(e, t, "info")),
                (this.debug = c(e, t, "debug")),
                (this.trace = c(e, t, "trace")),
                n && ((this.serializers = n), (this._serialize = a)),
                i && (this._logEvent = l([].concat(e._logEvent.bindings, t)));
            }
            return (d.prototype = this), new d(this);
          }),
          i && (y._logEvent = l()),
          y
        );
      }
      function a(e, t, r, a) {
        let c = Object.getPrototypeOf(t);
        (t[r] =
          t.levelVal > t.levels.values[r]
            ? h
            : c[r]
            ? c[r]
            : s[r] || s[a] || h),
          (function (e, t, r) {
            if (e.transmit || t[r] !== h) {
              var a;
              t[r] =
                ((a = t[r]),
                function () {
                  let c = e.timestamp(),
                    d = Array(arguments.length),
                    u =
                      Object.getPrototypeOf && Object.getPrototypeOf(this) === s
                        ? s
                        : this;
                  for (var h = 0; h < d.length; h++) d[h] = arguments[h];
                  if (
                    (e.serialize &&
                      !e.asObject &&
                      o(
                        d,
                        this._serialize,
                        this.serializers,
                        this._stdErrSerialize
                      ),
                    e.asObject
                      ? a.call(
                          u,
                          (function (e, t, r, s) {
                            e._serialize &&
                              o(
                                r,
                                e._serialize,
                                e.serializers,
                                e._stdErrSerialize
                              );
                            let a = r.slice(),
                              c = a[0],
                              l = {};
                            s && (l.time = s), (l.level = n.levels.values[t]);
                            let d = (0 | e._childLevel) + 1;
                            if (
                              (d < 1 && (d = 1),
                              null !== c && "object" == typeof c)
                            ) {
                              for (; d-- && "object" == typeof a[0]; )
                                Object.assign(l, a.shift());
                              c = a.length ? i(a.shift(), a) : void 0;
                            } else
                              "string" == typeof c && (c = i(a.shift(), a));
                            return void 0 !== c && (l.msg = c), l;
                          })(this, r, d, c)
                        )
                      : a.apply(u, d),
                    e.transmit)
                  ) {
                    let i = e.transmit.level || t.level,
                      s = n.levels.values[i],
                      a = n.levels.values[r];
                    if (a < s) return;
                    (function (e, t, r) {
                      let i = t.send,
                        s = t.ts,
                        n = t.methodLevel,
                        a = t.methodValue,
                        c = t.val,
                        d = e._logEvent.bindings;
                      o(
                        r,
                        e._serialize || Object.keys(e.serializers),
                        e.serializers,
                        void 0 === e._stdErrSerialize || e._stdErrSerialize
                      ),
                        (e._logEvent.ts = s),
                        (e._logEvent.messages = r.filter(function (e) {
                          return -1 === d.indexOf(e);
                        })),
                        (e._logEvent.level.label = n),
                        (e._logEvent.level.value = a),
                        i(n, e._logEvent, c),
                        (e._logEvent = l(d));
                    })(
                      this,
                      {
                        ts: c,
                        methodLevel: r,
                        methodValue: a,
                        transmitLevel: i,
                        transmitValue:
                          n.levels.values[e.transmit.level || t.level],
                        send: e.transmit.send,
                        val: t.levelVal,
                      },
                      d
                    );
                  }
                });
            }
          })(e, t, r);
      }
      function o(e, t, r, i) {
        for (let s in e)
          if (i && e[s] instanceof Error) e[s] = n.stdSerializers.err(e[s]);
          else if ("object" == typeof e[s] && !Array.isArray(e[s]))
            for (let i in e[s])
              t && t.indexOf(i) > -1 && i in r && (e[s][i] = r[i](e[s][i]));
      }
      function c(e, t, r) {
        return function () {
          let i = Array(1 + arguments.length);
          i[0] = t;
          for (var s = 1; s < i.length; s++) i[s] = arguments[s - 1];
          return e[r].apply(this, i);
        };
      }
      function l(e) {
        return {
          ts: 0,
          messages: [],
          bindings: e || [],
          level: { label: "", value: 0 },
        };
      }
      function d() {
        return {};
      }
      function u(e) {
        return e;
      }
      function h() {}
      function f() {
        return !1;
      }
      function p() {
        return Date.now();
      }
      (n.levels = {
        values: {
          fatal: 60,
          error: 50,
          warn: 40,
          info: 30,
          debug: 20,
          trace: 10,
        },
        labels: {
          10: "trace",
          20: "debug",
          30: "info",
          40: "warn",
          50: "error",
          60: "fatal",
        },
      }),
        (n.stdSerializers = {
          mapHttpRequest: d,
          mapHttpResponse: d,
          wrapRequestSerializer: u,
          wrapResponseSerializer: u,
          wrapErrorSerializer: u,
          req: d,
          res: d,
          err: function (e) {
            let t = {
              type: e.constructor.name,
              msg: e.message,
              stack: e.stack,
            };
            for (let r in e) void 0 === t[r] && (t[r] = e[r]);
            return t;
          },
        }),
        (n.stdTimeFunctions = Object.assign(
          {},
          {
            nullTime: f,
            epochTime: p,
            unixTime: function () {
              return Math.round(Date.now() / 1e3);
            },
            isoTime: function () {
              return new Date(Date.now()).toISOString();
            },
          }
        ));
    },
    66254: (e, t, r) => {
      "use strict";
      r.d(t, { a: () => m });
      var i = r(1220),
        s = r(98866),
        n = r(45553),
        a = r(52617),
        o = r(73442);
      let c = {
        handleSolanaDeeplinkRedirect(e) {
          if (o.W.state.activeChain === n.o.CHAIN.SOLANA) {
            let t = window.location.href,
              r = encodeURIComponent(t);
            if ("Phantom" === e && !("phantom" in window)) {
              let e = t.startsWith("https") ? "https" : "http",
                i = t.split("/")[2],
                s = encodeURIComponent(`${e}://${i}`);
              window.location.href = `https://phantom.app/ul/browse/${r}?ref=${s}`;
            }
            "Coinbase Wallet" !== e ||
              "coinbaseSolana" in window ||
              (window.location.href = `https://go.cb-w.com/dapp?cb_url=${r}`);
          }
        },
      };
      var l = r(58653),
        d = r(72880),
        u = r(55480),
        h = r(67869),
        f = r(45069);
      let p = {
          eip155: void 0,
          solana: void 0,
          polkadot: void 0,
          bip122: void 0,
        },
        g = (0, i.BX)({
          allConnectors: [],
          connectors: [],
          activeConnector: void 0,
          filterByNamespace: void 0,
          activeConnectorIds: { ...p },
        }),
        m = {
          state: g,
          subscribe: (e) =>
            (0, i.B1)(g, () => {
              e(g);
            }),
          subscribeKey: (e, t) => (0, s.u$)(g, e, t),
          initialize(e) {
            e.forEach((e) => {
              let t = l.i.getConnectedConnectorId(e);
              t && this.setConnectorId(t, e);
            });
          },
          setActiveConnector(e) {
            e && (g.activeConnector = (0, i.KR)(e));
          },
          setConnectors(e) {
            e
              .filter(
                (e) =>
                  !g.allConnectors.some(
                    (t) =>
                      t.id === e.id &&
                      this.getConnectorName(t.name) ===
                        this.getConnectorName(e.name) &&
                      t.chain === e.chain
                  )
              )
              .forEach((e) => {
                "MULTI_CHAIN" !== e.type && g.allConnectors.push((0, i.KR)(e));
              }),
              (g.connectors = this.mergeMultiChainConnectors(g.allConnectors));
          },
          removeAdapter(e) {
            (g.allConnectors = g.allConnectors.filter((t) => t.chain !== e)),
              (g.connectors = this.mergeMultiChainConnectors(g.allConnectors));
          },
          mergeMultiChainConnectors(e) {
            let t = this.generateConnectorMapByName(e),
              r = [];
            return (
              t.forEach((e) => {
                let t = e[0],
                  i = t?.id === n.o.CONNECTOR_ID.AUTH;
                e.length > 1 && t
                  ? r.push({
                      name: t.name,
                      imageUrl: t.imageUrl,
                      imageId: t.imageId,
                      connectors: [...e],
                      type: i ? "AUTH" : "MULTI_CHAIN",
                      chain: "eip155",
                      id: t?.id || "",
                    })
                  : t && r.push(t);
              }),
              r
            );
          },
          generateConnectorMapByName(e) {
            let t = new Map();
            return (
              e.forEach((e) => {
                let { name: r } = e,
                  i = this.getConnectorName(r);
                if (!i) return;
                let s = t.get(i) || [];
                s.find((t) => t.chain === e.chain) || s.push(e), t.set(i, s);
              }),
              t
            );
          },
          getConnectorName: (e) => (e && { "Trust Wallet": "Trust" }[e]) || e,
          getUniqueConnectorsByName(e) {
            let t = [];
            return (
              e.forEach((e) => {
                t.find((t) => t.chain === e.chain) || t.push(e);
              }),
              t
            );
          },
          addConnector(e) {
            if (e.id === n.o.CONNECTOR_ID.AUTH) {
              let t = (0, i.P9)(u.H.state),
                r = f.W.getSnapshot().themeMode,
                s = f.W.getSnapshot().themeVariables;
              e?.provider?.syncDappData?.({
                metadata: t.metadata,
                sdkVersion: t.sdkVersion,
                projectId: t.projectId,
                sdkType: t.sdkType,
              }),
                e?.provider?.syncTheme({
                  themeMode: r,
                  themeVariables: s,
                  w3mThemeVariables: a.o(s, r),
                }),
                this.setConnectors([e]);
            } else this.setConnectors([e]);
          },
          getAuthConnector(e) {
            let t = e || o.W.state.activeChain,
              r = g.connectors.find((e) => e.id === n.o.CONNECTOR_ID.AUTH);
            return r
              ? r?.connectors?.length
                ? r.connectors.find((e) => e.chain === t)
                : r
              : void 0;
          },
          getAnnouncedConnectorRdns: () =>
            g.connectors
              .filter((e) => "ANNOUNCED" === e.type)
              .map((e) => e.info?.rdns),
          getConnectorById: (e) => g.allConnectors.find((t) => t.id === e),
          getConnector: (e, t) =>
            g.allConnectors
              .filter((e) => e.chain === o.W.state.activeChain)
              .find((r) => r.explorerId === e || r.info?.rdns === t),
          syncIfAuthConnector(e) {
            if ("ID_AUTH" !== e.id) return;
            let t = (0, i.P9)(u.H.state),
              r = f.W.getSnapshot().themeMode,
              s = f.W.getSnapshot().themeVariables;
            e?.provider?.syncDappData?.({
              metadata: t.metadata,
              sdkVersion: t.sdkVersion,
              sdkType: t.sdkType,
              projectId: t.projectId,
            }),
              e.provider.syncTheme({
                themeMode: r,
                themeVariables: s,
                w3mThemeVariables: (0, a.o)(s, r),
              });
          },
          getConnectorsByNamespace(e) {
            let t = g.allConnectors.filter((t) => t.chain === e);
            return this.mergeMultiChainConnectors(t);
          },
          selectWalletConnector(e) {
            let t = m.getConnector(e.id, e.rdns);
            o.W.state.activeChain === n.o.CHAIN.SOLANA &&
              c.handleSolanaDeeplinkRedirect(t?.name || e.name || ""),
              t
                ? h.I.push("ConnectingExternal", { connector: t })
                : h.I.push("ConnectingWalletConnect", { wallet: e });
          },
          getConnectors(e) {
            return e
              ? this.getConnectorsByNamespace(e)
              : this.mergeMultiChainConnectors(g.allConnectors);
          },
          setFilterByNamespace(e) {
            (g.filterByNamespace = e),
              (g.connectors = this.getConnectors(e)),
              d.N.setFilterByNamespace(e);
          },
          setConnectorId(e, t) {
            e &&
              ((g.activeConnectorIds = { ...g.activeConnectorIds, [t]: e }),
              l.i.setConnectedConnectorId(t, e));
          },
          removeConnectorId(e) {
            (g.activeConnectorIds = { ...g.activeConnectorIds, [e]: void 0 }),
              l.i.deleteConnectedConnectorId(e);
          },
          getConnectorId(e) {
            if (e) return g.activeConnectorIds[e];
          },
          isConnected: (e) =>
            e
              ? !!g.activeConnectorIds[e]
              : Object.values(g.activeConnectorIds).some((e) => !!e),
          resetConnectorIds() {
            g.activeConnectorIds = { ...p };
          },
        };
    },
    66388: (e, t, r) => {
      "use strict";
      var i = r(12115),
        s =
          "function" == typeof Object.is
            ? Object.is
            : function (e, t) {
                return (
                  (e === t && (0 !== e || 1 / e == 1 / t)) || (e != e && t != t)
                );
              },
        n = i.useState,
        a = i.useEffect,
        o = i.useLayoutEffect,
        c = i.useDebugValue;
      function l(e) {
        var t = e.getSnapshot;
        e = e.value;
        try {
          var r = t();
          return !s(e, r);
        } catch (e) {
          return !0;
        }
      }
      var d =
        "undefined" == typeof window ||
        void 0 === window.document ||
        void 0 === window.document.createElement
          ? function (e, t) {
              return t();
            }
          : function (e, t) {
              var r = t(),
                i = n({ inst: { value: r, getSnapshot: t } }),
                s = i[0].inst,
                d = i[1];
              return (
                o(
                  function () {
                    (s.value = r), (s.getSnapshot = t), l(s) && d({ inst: s });
                  },
                  [e, r, t]
                ),
                a(
                  function () {
                    return (
                      l(s) && d({ inst: s }),
                      e(function () {
                        l(s) && d({ inst: s });
                      })
                    );
                  },
                  [e]
                ),
                c(r),
                r
              );
            };
      t.useSyncExternalStore =
        void 0 !== i.useSyncExternalStore ? i.useSyncExternalStore : d;
    },
    66725: (e, t, r) => {
      var i;
      function s(e) {
        this.rand = e;
      }
      if (
        ((e.exports = function (e) {
          return i || (i = new s(null)), i.generate(e);
        }),
        (e.exports.Rand = s),
        (s.prototype.generate = function (e) {
          return this._rand(e);
        }),
        (s.prototype._rand = function (e) {
          if (this.rand.getBytes) return this.rand.getBytes(e);
          for (var t = new Uint8Array(e), r = 0; r < t.length; r++)
            t[r] = this.rand.getByte();
          return t;
        }),
        "object" == typeof self)
      )
        self.crypto && self.crypto.getRandomValues
          ? (s.prototype._rand = function (e) {
              var t = new Uint8Array(e);
              return self.crypto.getRandomValues(t), t;
            })
          : self.msCrypto && self.msCrypto.getRandomValues
          ? (s.prototype._rand = function (e) {
              var t = new Uint8Array(e);
              return self.msCrypto.getRandomValues(t), t;
            })
          : "object" == typeof window &&
            (s.prototype._rand = function () {
              throw Error("Not implemented yet");
            });
      else
        try {
          var n = r(73776);
          if ("function" != typeof n.randomBytes) throw Error("Not supported");
          s.prototype._rand = function (e) {
            return n.randomBytes(e);
          };
        } catch (e) {}
    },
    66969: (e, t, r) => {
      "use strict";
      r.d(t, { Fl: () => n, NV: () => a, ii: () => s });
      var i = r(13933);
      class s extends i.C {
        constructor({ offset: e, position: t, size: r }) {
          super(
            `Slice ${
              "start" === t ? "starting" : "ending"
            } at offset "${e}" is out-of-bounds (size: ${r}).`,
            { name: "SliceOffsetOutOfBoundsError" }
          );
        }
      }
      class n extends i.C {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} size (${e}) exceeds padding size (${t}).`,
            { name: "SizeExceedsPaddingSizeError" }
          );
        }
      }
      class a extends i.C {
        constructor({ size: e, targetSize: t, type: r }) {
          super(
            `${r.charAt(0).toUpperCase()}${r
              .slice(1)
              .toLowerCase()} is expected to be ${t} ${r} long, but is ${e} ${r} long.`,
            { name: "InvalidBytesLengthError" }
          );
        }
      }
    },
    67243: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => g }), r(77931);
      var i = r(45553),
        s = r(73537),
        n = r(58051),
        a = r(73442),
        o = r(3824),
        c = r(66254),
        l = r(70417),
        d = r(81701),
        u = r(55480),
        h = r(67869),
        f = r(65374),
        p = r(12319);
      let g = {
        getSIWX: () => u.H.state.siwx,
        async initializeIfEnabled() {
          let e = u.H.state.siwx,
            t = a.W.getActiveCaipAddress();
          if (!(e && t)) return;
          let [r, i, s] = t.split(":");
          if (a.W.checkIfSupportedNetwork(r))
            try {
              if ((await e.getSessions(`${r}:${i}`, s)).length) return;
              await d.W.open({ view: "SIWXSignMessage" });
            } catch (e) {
              console.error("SIWXUtil:initializeIfEnabled", e),
                l.E.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_ERROR",
                  properties: this.getSIWXEventProperties(),
                }),
                await o.x._getClient()?.disconnect().catch(console.error),
                h.I.reset("Connect"),
                f.P.showError(
                  "A problem occurred while trying initialize authentication"
                );
            }
        },
        async requestSignMessage() {
          let e = u.H.state.siwx,
            t = p.w.getPlainAddress(a.W.getActiveCaipAddress()),
            r = a.W.getActiveCaipNetwork(),
            s = o.x._getClient();
          if (!e) throw Error("SIWX is not enabled");
          if (!t) throw Error("No ActiveCaipAddress found");
          if (!r) throw Error("No ActiveCaipNetwork or client found");
          if (!s) throw Error("No ConnectionController client found");
          try {
            let n = await e.createMessage({
                chainId: r.caipNetworkId,
                accountAddress: t,
              }),
              a = n.toString();
            c.a.getConnectorId(r.chainNamespace) === i.o.CONNECTOR_ID.AUTH &&
              h.I.pushTransactionStack({ view: null, goBack: !1, replace: !0 });
            let o = await s.signMessage(a);
            await e.addSession({ data: n, message: a, signature: o }),
              d.W.close(),
              l.E.sendEvent({
                type: "track",
                event: "SIWX_AUTH_SUCCESS",
                properties: this.getSIWXEventProperties(),
              });
          } catch (t) {
            let e = this.getSIWXEventProperties();
            (d.W.state.open && "ApproveTransaction" !== h.I.state.view) ||
              (await d.W.open({ view: "SIWXSignMessage" })),
              e.isSmartAccount
                ? f.P.showError(
                    "This application might not support Smart Accounts"
                  )
                : f.P.showError("Signature declined"),
              l.E.sendEvent({
                type: "track",
                event: "SIWX_AUTH_ERROR",
                properties: e,
              }),
              console.error("SWIXUtil:requestSignMessage", t);
          }
        },
        async cancelSignMessage() {
          try {
            let e = this.getSIWX();
            e?.getRequired?.() ? await o.x.disconnect() : d.W.close(),
              h.I.reset("Connect"),
              l.E.sendEvent({
                event: "CLICK_CANCEL_SIWX",
                type: "track",
                properties: this.getSIWXEventProperties(),
              });
          } catch (e) {
            console.error("SIWXUtil:cancelSignMessage", e);
          }
        },
        async getSessions() {
          let e = u.H.state.siwx,
            t = p.w.getPlainAddress(a.W.getActiveCaipAddress()),
            r = a.W.getActiveCaipNetwork();
          return e && t && r ? e.getSessions(r.caipNetworkId, t) : [];
        },
        async isSIWXCloseDisabled() {
          let e = this.getSIWX();
          if (e) {
            let t = "ApproveTransaction" === h.I.state.view,
              r = "SIWXSignMessage" === h.I.state.view;
            if (t || r)
              return (
                e.getRequired?.() && 0 === (await this.getSessions()).length
              );
          }
          return !1;
        },
        async universalProviderAuthenticate({
          universalProvider: e,
          chains: t,
          methods: r,
        }) {
          let i = g.getSIWX(),
            s = new Set(t.map((e) => e.split(":")[0]));
          if (!i || 1 !== s.size || !s.has("eip155")) return !1;
          let o = await i.createMessage({
              chainId: a.W.getActiveCaipNetwork()?.caipNetworkId || "",
              accountAddress: "",
            }),
            c = await e.authenticate({
              nonce: o.nonce,
              domain: o.domain,
              uri: o.uri,
              exp: o.expirationTime,
              iat: o.issuedAt,
              nbf: o.notBefore,
              requestId: o.requestId,
              version: o.version,
              resources: o.resources,
              statement: o.statement,
              chainId: o.chainId,
              methods: r,
              chains: [o.chainId, ...t.filter((e) => e !== o.chainId)],
            });
          if (
            (f.P.showLoading("Authenticating...", { autoClose: !1 }),
            n.U.setConnectedWalletInfo(
              {
                ...c.session.peer.metadata,
                name: c.session.peer.metadata.name,
                icon: c.session.peer.metadata.icons?.[0],
                type: "WALLET_CONNECT",
              },
              Array.from(s)[0]
            ),
            c?.auths?.length)
          ) {
            let t = c.auths.map((t) => {
              let r = e.client.formatAuthMessage({
                request: t.p,
                iss: t.p.iss,
              });
              return {
                data: {
                  ...t.p,
                  accountAddress: t.p.iss.split(":").slice(-1).join(""),
                  chainId: t.p.iss.split(":").slice(2, 4).join(":"),
                  uri: t.p.aud,
                  version: t.p.version || o.version,
                  expirationTime: t.p.exp,
                  issuedAt: t.p.iat,
                  notBefore: t.p.nbf,
                },
                message: r,
                signature: t.s.s,
                cacao: t,
              };
            });
            try {
              await i.setSessions(t),
                l.E.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_SUCCESS",
                  properties: g.getSIWXEventProperties(),
                });
            } catch (t) {
              throw (
                (console.error(
                  "SIWX:universalProviderAuth - failed to set sessions",
                  t
                ),
                l.E.sendEvent({
                  type: "track",
                  event: "SIWX_AUTH_ERROR",
                  properties: g.getSIWXEventProperties(),
                }),
                await e.disconnect().catch(console.error),
                t)
              );
            } finally {
              f.P.hide();
            }
          }
          return !0;
        },
        getSIWXEventProperties: () => ({
          network: a.W.state.activeCaipNetwork?.caipNetworkId || "",
          isSmartAccount:
            n.U.state.preferredAccountType === s.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
        }),
        async clearSessions() {
          let e = this.getSIWX();
          e && (await e.setSessions([]));
        },
      };
    },
    67869: (e, t, r) => {
      "use strict";
      r.d(t, { I: () => u });
      var i = r(1220),
        s = r(98866),
        n = r(58051),
        a = r(73442),
        o = r(66254),
        c = r(81701),
        l = r(55480);
      let d = (0, i.BX)({
          view: "Connect",
          history: ["Connect"],
          transactionStack: [],
        }),
        u = {
          state: d,
          subscribeKey: (e, t) => (0, s.u$)(d, e, t),
          pushTransactionStack(e) {
            d.transactionStack.push(e);
          },
          popTransactionStack(e) {
            let t = d.transactionStack.pop();
            if (t) {
              if (e) this.goBack(), t?.onCancel?.();
              else {
                if (t.goBack) this.goBack();
                else if (t.replace) {
                  let e = d.history.indexOf("ConnectingSiwe");
                  e > 0
                    ? this.goBackToIndex(e - 1)
                    : (c.W.close(), (d.history = []));
                } else t.view && this.reset(t.view);
                t?.onSuccess?.();
              }
            }
          },
          push(e, t) {
            e !== d.view && ((d.view = e), d.history.push(e), (d.data = t));
          },
          reset(e, t) {
            (d.view = e), (d.history = [e]), (d.data = t);
          },
          replace(e, t) {
            d.history.at(-1) !== e &&
              ((d.view = e),
              (d.history[d.history.length - 1] = e),
              (d.data = t));
          },
          goBack() {
            let e =
              !a.W.state.activeCaipAddress &&
              "ConnectingFarcaster" === this.state.view;
            if (
              d.history.length > 1 &&
              !d.history.includes("UnsupportedChain")
            ) {
              d.history.pop();
              let [e] = d.history.slice(-1);
              e && (d.view = e);
            } else c.W.close();
            d.data?.wallet && (d.data.wallet = void 0),
              setTimeout(() => {
                if (e) {
                  n.U.setFarcasterUrl(void 0, a.W.state.activeChain);
                  let e = o.a.getAuthConnector();
                  e?.provider?.reload();
                  let t = (0, i.P9)(l.H.state);
                  e?.provider?.syncDappData?.({
                    metadata: t.metadata,
                    sdkVersion: t.sdkVersion,
                    projectId: t.projectId,
                    sdkType: t.sdkType,
                  });
                }
              }, 100);
          },
          goBackToIndex(e) {
            if (d.history.length > 1) {
              d.history = d.history.slice(0, e + 1);
              let [t] = d.history.slice(-1);
              t && (d.view = t);
            }
          },
        };
    },
    68463: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => i });
      var i = r(94820);
    },
    68836: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => a });
      var i = r(98957),
        s = r(53560),
        n = r(39382);
      function a(e) {
        let t = (0, s.e)(e),
          r = [],
          a = e.length;
        for (let s = 0; s < a; s++) {
          let a = e[s];
          (0, i.WL)(a) || r.push((0, n.uT)(a, t));
        }
        return r;
      }
    },
    70064: (e, t, r) => {
      "use strict";
      var i = r(78239),
        s = r(98392),
        n = r(43770),
        a = r(92963),
        o = i.assert;
      function c(e) {
        a.call(this, "short", e),
          (this.a = new s(e.a, 16).toRed(this.red)),
          (this.b = new s(e.b, 16).toRed(this.red)),
          (this.tinv = this.two.redInvm()),
          (this.zeroA = 0 === this.a.fromRed().cmpn(0)),
          (this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3)),
          (this.endo = this._getEndomorphism(e)),
          (this._endoWnafT1 = [, , , ,]),
          (this._endoWnafT2 = [, , , ,]);
      }
      function l(e, t, r, i) {
        a.BasePoint.call(this, e, "affine"),
          null === t && null === r
            ? ((this.x = null), (this.y = null), (this.inf = !0))
            : ((this.x = new s(t, 16)),
              (this.y = new s(r, 16)),
              i &&
                (this.x.forceRed(this.curve.red),
                this.y.forceRed(this.curve.red)),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.y.red || (this.y = this.y.toRed(this.curve.red)),
              (this.inf = !1));
      }
      function d(e, t, r, i) {
        a.BasePoint.call(this, e, "jacobian"),
          null === t && null === r && null === i
            ? ((this.x = this.curve.one),
              (this.y = this.curve.one),
              (this.z = new s(0)))
            : ((this.x = new s(t, 16)),
              (this.y = new s(r, 16)),
              (this.z = new s(i, 16))),
          this.x.red || (this.x = this.x.toRed(this.curve.red)),
          this.y.red || (this.y = this.y.toRed(this.curve.red)),
          this.z.red || (this.z = this.z.toRed(this.curve.red)),
          (this.zOne = this.z === this.curve.one);
      }
      n(c, a),
        (e.exports = c),
        (c.prototype._getEndomorphism = function (e) {
          if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
            if (e.beta) t = new s(e.beta, 16).toRed(this.red);
            else {
              var t,
                r,
                i,
                n = this._getEndoRoots(this.p);
              t = (t = 0 > n[0].cmp(n[1]) ? n[0] : n[1]).toRed(this.red);
            }
            if (e.lambda) r = new s(e.lambda, 16);
            else {
              var a = this._getEndoRoots(this.n);
              0 === this.g.mul(a[0]).x.cmp(this.g.x.redMul(t))
                ? (r = a[0])
                : ((r = a[1]),
                  o(0 === this.g.mul(r).x.cmp(this.g.x.redMul(t))));
            }
            return (
              (i = e.basis
                ? e.basis.map(function (e) {
                    return { a: new s(e.a, 16), b: new s(e.b, 16) };
                  })
                : this._getEndoBasis(r)),
              { beta: t, lambda: r, basis: i }
            );
          }
        }),
        (c.prototype._getEndoRoots = function (e) {
          var t = e === this.p ? this.red : s.mont(e),
            r = new s(2).toRed(t).redInvm(),
            i = r.redNeg(),
            n = new s(3).toRed(t).redNeg().redSqrt().redMul(r);
          return [i.redAdd(n).fromRed(), i.redSub(n).fromRed()];
        }),
        (c.prototype._getEndoBasis = function (e) {
          for (
            var t,
              r,
              i,
              n,
              a,
              o,
              c,
              l,
              d,
              u = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
              h = e,
              f = this.n.clone(),
              p = new s(1),
              g = new s(0),
              m = new s(0),
              b = new s(1),
              y = 0;
            0 !== h.cmpn(0);

          ) {
            var w = f.div(h);
            (l = f.sub(w.mul(h))), (d = m.sub(w.mul(p)));
            var v = b.sub(w.mul(g));
            if (!i && 0 > l.cmp(u))
              (t = c.neg()), (r = p), (i = l.neg()), (n = d);
            else if (i && 2 == ++y) break;
            (c = l), (f = h), (h = l), (m = p), (p = d), (b = g), (g = v);
          }
          (a = l.neg()), (o = d);
          var A = i.sqr().add(n.sqr());
          return (
            a.sqr().add(o.sqr()).cmp(A) >= 0 && ((a = t), (o = r)),
            i.negative && ((i = i.neg()), (n = n.neg())),
            a.negative && ((a = a.neg()), (o = o.neg())),
            [
              { a: i, b: n },
              { a: a, b: o },
            ]
          );
        }),
        (c.prototype._endoSplit = function (e) {
          var t = this.endo.basis,
            r = t[0],
            i = t[1],
            s = i.b.mul(e).divRound(this.n),
            n = r.b.neg().mul(e).divRound(this.n),
            a = s.mul(r.a),
            o = n.mul(i.a),
            c = s.mul(r.b),
            l = n.mul(i.b);
          return { k1: e.sub(a).sub(o), k2: c.add(l).neg() };
        }),
        (c.prototype.pointFromX = function (e, t) {
          (e = new s(e, 16)).red || (e = e.toRed(this.red));
          var r = e
              .redSqr()
              .redMul(e)
              .redIAdd(e.redMul(this.a))
              .redIAdd(this.b),
            i = r.redSqrt();
          if (0 !== i.redSqr().redSub(r).cmp(this.zero))
            throw Error("invalid point");
          var n = i.fromRed().isOdd();
          return ((t && !n) || (!t && n)) && (i = i.redNeg()), this.point(e, i);
        }),
        (c.prototype.validate = function (e) {
          if (e.inf) return !0;
          var t = e.x,
            r = e.y,
            i = this.a.redMul(t),
            s = t.redSqr().redMul(t).redIAdd(i).redIAdd(this.b);
          return 0 === r.redSqr().redISub(s).cmpn(0);
        }),
        (c.prototype._endoWnafMulAdd = function (e, t, r) {
          for (
            var i = this._endoWnafT1, s = this._endoWnafT2, n = 0;
            n < e.length;
            n++
          ) {
            var a = this._endoSplit(t[n]),
              o = e[n],
              c = o._getBeta();
            a.k1.negative && (a.k1.ineg(), (o = o.neg(!0))),
              a.k2.negative && (a.k2.ineg(), (c = c.neg(!0))),
              (i[2 * n] = o),
              (i[2 * n + 1] = c),
              (s[2 * n] = a.k1),
              (s[2 * n + 1] = a.k2);
          }
          for (
            var l = this._wnafMulAdd(1, i, s, 2 * n, r), d = 0;
            d < 2 * n;
            d++
          )
            (i[d] = null), (s[d] = null);
          return l;
        }),
        n(l, a.BasePoint),
        (c.prototype.point = function (e, t, r) {
          return new l(this, e, t, r);
        }),
        (c.prototype.pointFromJSON = function (e, t) {
          return l.fromJSON(this, e, t);
        }),
        (l.prototype._getBeta = function () {
          if (this.curve.endo) {
            var e = this.precomputed;
            if (e && e.beta) return e.beta;
            var t = this.curve.point(
              this.x.redMul(this.curve.endo.beta),
              this.y
            );
            if (e) {
              var r = this.curve,
                i = function (e) {
                  return r.point(e.x.redMul(r.endo.beta), e.y);
                };
              (e.beta = t),
                (t.precomputed = {
                  beta: null,
                  naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(i) },
                  doubles: e.doubles && {
                    step: e.doubles.step,
                    points: e.doubles.points.map(i),
                  },
                });
            }
            return t;
          }
        }),
        (l.prototype.toJSON = function () {
          return this.precomputed
            ? [
                this.x,
                this.y,
                this.precomputed && {
                  doubles: this.precomputed.doubles && {
                    step: this.precomputed.doubles.step,
                    points: this.precomputed.doubles.points.slice(1),
                  },
                  naf: this.precomputed.naf && {
                    wnd: this.precomputed.naf.wnd,
                    points: this.precomputed.naf.points.slice(1),
                  },
                },
              ]
            : [this.x, this.y];
        }),
        (l.fromJSON = function (e, t, r) {
          "string" == typeof t && (t = JSON.parse(t));
          var i = e.point(t[0], t[1], r);
          if (!t[2]) return i;
          function s(t) {
            return e.point(t[0], t[1], r);
          }
          var n = t[2];
          return (
            (i.precomputed = {
              beta: null,
              doubles: n.doubles && {
                step: n.doubles.step,
                points: [i].concat(n.doubles.points.map(s)),
              },
              naf: n.naf && {
                wnd: n.naf.wnd,
                points: [i].concat(n.naf.points.map(s)),
              },
            }),
            i
          );
        }),
        (l.prototype.inspect = function () {
          return this.isInfinity()
            ? "<EC Point Infinity>"
            : "<EC Point x: " +
                this.x.fromRed().toString(16, 2) +
                " y: " +
                this.y.fromRed().toString(16, 2) +
                ">";
        }),
        (l.prototype.isInfinity = function () {
          return this.inf;
        }),
        (l.prototype.add = function (e) {
          if (this.inf) return e;
          if (e.inf) return this;
          if (this.eq(e)) return this.dbl();
          if (this.neg().eq(e) || 0 === this.x.cmp(e.x))
            return this.curve.point(null, null);
          var t = this.y.redSub(e.y);
          0 !== t.cmpn(0) && (t = t.redMul(this.x.redSub(e.x).redInvm()));
          var r = t.redSqr().redISub(this.x).redISub(e.x),
            i = t.redMul(this.x.redSub(r)).redISub(this.y);
          return this.curve.point(r, i);
        }),
        (l.prototype.dbl = function () {
          if (this.inf) return this;
          var e = this.y.redAdd(this.y);
          if (0 === e.cmpn(0)) return this.curve.point(null, null);
          var t = this.curve.a,
            r = this.x.redSqr(),
            i = e.redInvm(),
            s = r.redAdd(r).redIAdd(r).redIAdd(t).redMul(i),
            n = s.redSqr().redISub(this.x.redAdd(this.x)),
            a = s.redMul(this.x.redSub(n)).redISub(this.y);
          return this.curve.point(n, a);
        }),
        (l.prototype.getX = function () {
          return this.x.fromRed();
        }),
        (l.prototype.getY = function () {
          return this.y.fromRed();
        }),
        (l.prototype.mul = function (e) {
          return ((e = new s(e, 16)), this.isInfinity())
            ? this
            : this._hasDoubles(e)
            ? this.curve._fixedNafMul(this, e)
            : this.curve.endo
            ? this.curve._endoWnafMulAdd([this], [e])
            : this.curve._wnafMul(this, e);
        }),
        (l.prototype.mulAdd = function (e, t, r) {
          var i = [this, t],
            s = [e, r];
          return this.curve.endo
            ? this.curve._endoWnafMulAdd(i, s)
            : this.curve._wnafMulAdd(1, i, s, 2);
        }),
        (l.prototype.jmulAdd = function (e, t, r) {
          var i = [this, t],
            s = [e, r];
          return this.curve.endo
            ? this.curve._endoWnafMulAdd(i, s, !0)
            : this.curve._wnafMulAdd(1, i, s, 2, !0);
        }),
        (l.prototype.eq = function (e) {
          return (
            this === e ||
            (this.inf === e.inf &&
              (this.inf || (0 === this.x.cmp(e.x) && 0 === this.y.cmp(e.y))))
          );
        }),
        (l.prototype.neg = function (e) {
          if (this.inf) return this;
          var t = this.curve.point(this.x, this.y.redNeg());
          if (e && this.precomputed) {
            var r = this.precomputed,
              i = function (e) {
                return e.neg();
              };
            t.precomputed = {
              naf: r.naf && { wnd: r.naf.wnd, points: r.naf.points.map(i) },
              doubles: r.doubles && {
                step: r.doubles.step,
                points: r.doubles.points.map(i),
              },
            };
          }
          return t;
        }),
        (l.prototype.toJ = function () {
          return this.inf
            ? this.curve.jpoint(null, null, null)
            : this.curve.jpoint(this.x, this.y, this.curve.one);
        }),
        n(d, a.BasePoint),
        (c.prototype.jpoint = function (e, t, r) {
          return new d(this, e, t, r);
        }),
        (d.prototype.toP = function () {
          if (this.isInfinity()) return this.curve.point(null, null);
          var e = this.z.redInvm(),
            t = e.redSqr(),
            r = this.x.redMul(t),
            i = this.y.redMul(t).redMul(e);
          return this.curve.point(r, i);
        }),
        (d.prototype.neg = function () {
          return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
        }),
        (d.prototype.add = function (e) {
          if (this.isInfinity()) return e;
          if (e.isInfinity()) return this;
          var t = e.z.redSqr(),
            r = this.z.redSqr(),
            i = this.x.redMul(t),
            s = e.x.redMul(r),
            n = this.y.redMul(t.redMul(e.z)),
            a = e.y.redMul(r.redMul(this.z)),
            o = i.redSub(s),
            c = n.redSub(a);
          if (0 === o.cmpn(0))
            return 0 !== c.cmpn(0)
              ? this.curve.jpoint(null, null, null)
              : this.dbl();
          var l = o.redSqr(),
            d = l.redMul(o),
            u = i.redMul(l),
            h = c.redSqr().redIAdd(d).redISub(u).redISub(u),
            f = c.redMul(u.redISub(h)).redISub(n.redMul(d)),
            p = this.z.redMul(e.z).redMul(o);
          return this.curve.jpoint(h, f, p);
        }),
        (d.prototype.mixedAdd = function (e) {
          if (this.isInfinity()) return e.toJ();
          if (e.isInfinity()) return this;
          var t = this.z.redSqr(),
            r = this.x,
            i = e.x.redMul(t),
            s = this.y,
            n = e.y.redMul(t).redMul(this.z),
            a = r.redSub(i),
            o = s.redSub(n);
          if (0 === a.cmpn(0))
            return 0 !== o.cmpn(0)
              ? this.curve.jpoint(null, null, null)
              : this.dbl();
          var c = a.redSqr(),
            l = c.redMul(a),
            d = r.redMul(c),
            u = o.redSqr().redIAdd(l).redISub(d).redISub(d),
            h = o.redMul(d.redISub(u)).redISub(s.redMul(l)),
            f = this.z.redMul(a);
          return this.curve.jpoint(u, h, f);
        }),
        (d.prototype.dblp = function (e) {
          if (0 === e || this.isInfinity()) return this;
          if (!e) return this.dbl();
          if (this.curve.zeroA || this.curve.threeA) {
            var t,
              r = this;
            for (t = 0; t < e; t++) r = r.dbl();
            return r;
          }
          var i = this.curve.a,
            s = this.curve.tinv,
            n = this.x,
            a = this.y,
            o = this.z,
            c = o.redSqr().redSqr(),
            l = a.redAdd(a);
          for (t = 0; t < e; t++) {
            var d = n.redSqr(),
              u = l.redSqr(),
              h = u.redSqr(),
              f = d.redAdd(d).redIAdd(d).redIAdd(i.redMul(c)),
              p = n.redMul(u),
              g = f.redSqr().redISub(p.redAdd(p)),
              m = p.redISub(g),
              b = f.redMul(m);
            b = b.redIAdd(b).redISub(h);
            var y = l.redMul(o);
            t + 1 < e && (c = c.redMul(h)), (n = g), (o = y), (l = b);
          }
          return this.curve.jpoint(n, l.redMul(s), o);
        }),
        (d.prototype.dbl = function () {
          return this.isInfinity()
            ? this
            : this.curve.zeroA
            ? this._zeroDbl()
            : this.curve.threeA
            ? this._threeDbl()
            : this._dbl();
        }),
        (d.prototype._zeroDbl = function () {
          if (this.zOne) {
            var e,
              t,
              r,
              i = this.x.redSqr(),
              s = this.y.redSqr(),
              n = s.redSqr(),
              a = this.x.redAdd(s).redSqr().redISub(i).redISub(n);
            a = a.redIAdd(a);
            var o = i.redAdd(i).redIAdd(i),
              c = o.redSqr().redISub(a).redISub(a),
              l = n.redIAdd(n);
            (l = (l = l.redIAdd(l)).redIAdd(l)),
              (e = c),
              (t = o.redMul(a.redISub(c)).redISub(l)),
              (r = this.y.redAdd(this.y));
          } else {
            var d = this.x.redSqr(),
              u = this.y.redSqr(),
              h = u.redSqr(),
              f = this.x.redAdd(u).redSqr().redISub(d).redISub(h);
            f = f.redIAdd(f);
            var p = d.redAdd(d).redIAdd(d),
              g = p.redSqr(),
              m = h.redIAdd(h);
            (m = (m = m.redIAdd(m)).redIAdd(m)),
              (e = g.redISub(f).redISub(f)),
              (t = p.redMul(f.redISub(e)).redISub(m)),
              (r = (r = this.y.redMul(this.z)).redIAdd(r));
          }
          return this.curve.jpoint(e, t, r);
        }),
        (d.prototype._threeDbl = function () {
          if (this.zOne) {
            var e,
              t,
              r,
              i = this.x.redSqr(),
              s = this.y.redSqr(),
              n = s.redSqr(),
              a = this.x.redAdd(s).redSqr().redISub(i).redISub(n);
            a = a.redIAdd(a);
            var o = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),
              c = o.redSqr().redISub(a).redISub(a);
            e = c;
            var l = n.redIAdd(n);
            (l = (l = l.redIAdd(l)).redIAdd(l)),
              (t = o.redMul(a.redISub(c)).redISub(l)),
              (r = this.y.redAdd(this.y));
          } else {
            var d = this.z.redSqr(),
              u = this.y.redSqr(),
              h = this.x.redMul(u),
              f = this.x.redSub(d).redMul(this.x.redAdd(d));
            f = f.redAdd(f).redIAdd(f);
            var p = h.redIAdd(h),
              g = (p = p.redIAdd(p)).redAdd(p);
            (e = f.redSqr().redISub(g)),
              (r = this.y.redAdd(this.z).redSqr().redISub(u).redISub(d));
            var m = u.redSqr();
            (m = (m = (m = m.redIAdd(m)).redIAdd(m)).redIAdd(m)),
              (t = f.redMul(p.redISub(e)).redISub(m));
          }
          return this.curve.jpoint(e, t, r);
        }),
        (d.prototype._dbl = function () {
          var e = this.curve.a,
            t = this.x,
            r = this.y,
            i = this.z,
            s = i.redSqr().redSqr(),
            n = t.redSqr(),
            a = r.redSqr(),
            o = n.redAdd(n).redIAdd(n).redIAdd(e.redMul(s)),
            c = t.redAdd(t),
            l = (c = c.redIAdd(c)).redMul(a),
            d = o.redSqr().redISub(l.redAdd(l)),
            u = l.redISub(d),
            h = a.redSqr();
          h = (h = (h = h.redIAdd(h)).redIAdd(h)).redIAdd(h);
          var f = o.redMul(u).redISub(h),
            p = r.redAdd(r).redMul(i);
          return this.curve.jpoint(d, f, p);
        }),
        (d.prototype.trpl = function () {
          if (!this.curve.zeroA) return this.dbl().add(this);
          var e = this.x.redSqr(),
            t = this.y.redSqr(),
            r = this.z.redSqr(),
            i = t.redSqr(),
            s = e.redAdd(e).redIAdd(e),
            n = s.redSqr(),
            a = this.x.redAdd(t).redSqr().redISub(e).redISub(i),
            o = (a = (a = (a = a.redIAdd(a)).redAdd(a).redIAdd(a)).redISub(
              n
            )).redSqr(),
            c = i.redIAdd(i);
          c = (c = (c = c.redIAdd(c)).redIAdd(c)).redIAdd(c);
          var l = s.redIAdd(a).redSqr().redISub(n).redISub(o).redISub(c),
            d = t.redMul(l);
          d = (d = d.redIAdd(d)).redIAdd(d);
          var u = this.x.redMul(o).redISub(d);
          u = (u = u.redIAdd(u)).redIAdd(u);
          var h = this.y.redMul(l.redMul(c.redISub(l)).redISub(a.redMul(o)));
          h = (h = (h = h.redIAdd(h)).redIAdd(h)).redIAdd(h);
          var f = this.z.redAdd(a).redSqr().redISub(r).redISub(o);
          return this.curve.jpoint(u, h, f);
        }),
        (d.prototype.mul = function (e, t) {
          return (e = new s(e, t)), this.curve._wnafMul(this, e);
        }),
        (d.prototype.eq = function (e) {
          if ("affine" === e.type) return this.eq(e.toJ());
          if (this === e) return !0;
          var t = this.z.redSqr(),
            r = e.z.redSqr();
          if (0 !== this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0)) return !1;
          var i = t.redMul(this.z),
            s = r.redMul(e.z);
          return 0 === this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0);
        }),
        (d.prototype.eqXToP = function (e) {
          var t = this.z.redSqr(),
            r = e.toRed(this.curve.red).redMul(t);
          if (0 === this.x.cmp(r)) return !0;
          for (var i = e.clone(), s = this.curve.redN.redMul(t); ; ) {
            if ((i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)) return !1;
            if ((r.redIAdd(s), 0 === this.x.cmp(r))) return !0;
          }
        }),
        (d.prototype.inspect = function () {
          return this.isInfinity()
            ? "<EC JPoint Infinity>"
            : "<EC JPoint x: " +
                this.x.toString(16, 2) +
                " y: " +
                this.y.toString(16, 2) +
                " z: " +
                this.z.toString(16, 2) +
                ">";
        }),
        (d.prototype.isInfinity = function () {
          return 0 === this.z.cmpn(0);
        });
    },
    70083: (e, t, r) => {
      "use strict";
      var i = r(98392),
        s = r(78239),
        n = s.assert;
      function a(e, t) {
        if (e instanceof a) return e;
        this._importDER(e, t) ||
          (n(e.r && e.s, "Signature without r or s"),
          (this.r = new i(e.r, 16)),
          (this.s = new i(e.s, 16)),
          void 0 === e.recoveryParam
            ? (this.recoveryParam = null)
            : (this.recoveryParam = e.recoveryParam));
      }
      function o() {
        this.place = 0;
      }
      function c(e, t) {
        var r = e[t.place++];
        if (!(128 & r)) return r;
        var i = 15 & r;
        if (0 === i || i > 4 || 0 === e[t.place]) return !1;
        for (var s = 0, n = 0, a = t.place; n < i; n++, a++)
          (s <<= 8), (s |= e[a]), (s >>>= 0);
        return !(s <= 127) && ((t.place = a), s);
      }
      function l(e) {
        for (var t = 0, r = e.length - 1; !e[t] && !(128 & e[t + 1]) && t < r; )
          t++;
        return 0 === t ? e : e.slice(t);
      }
      function d(e, t) {
        if (t < 128) {
          e.push(t);
          return;
        }
        var r = 1 + ((Math.log(t) / Math.LN2) >>> 3);
        for (e.push(128 | r); --r; ) e.push((t >>> (r << 3)) & 255);
        e.push(t);
      }
      (e.exports = a),
        (a.prototype._importDER = function (e, t) {
          e = s.toArray(e, t);
          var r = new o();
          if (48 !== e[r.place++]) return !1;
          var n = c(e, r);
          if (!1 === n || n + r.place !== e.length || 2 !== e[r.place++])
            return !1;
          var a = c(e, r);
          if (!1 === a || (128 & e[r.place]) != 0) return !1;
          var l = e.slice(r.place, a + r.place);
          if (((r.place += a), 2 !== e[r.place++])) return !1;
          var d = c(e, r);
          if (!1 === d || e.length !== d + r.place || (128 & e[r.place]) != 0)
            return !1;
          var u = e.slice(r.place, d + r.place);
          if (0 === l[0]) {
            if (!(128 & l[1])) return !1;
            l = l.slice(1);
          }
          if (0 === u[0]) {
            if (!(128 & u[1])) return !1;
            u = u.slice(1);
          }
          return (
            (this.r = new i(l)),
            (this.s = new i(u)),
            (this.recoveryParam = null),
            !0
          );
        }),
        (a.prototype.toDER = function (e) {
          var t = this.r.toArray(),
            r = this.s.toArray();
          for (
            128 & t[0] && (t = [0].concat(t)),
              128 & r[0] && (r = [0].concat(r)),
              t = l(t),
              r = l(r);
            !r[0] && !(128 & r[1]);

          )
            r = r.slice(1);
          var i = [2];
          d(i, t.length), (i = i.concat(t)).push(2), d(i, r.length);
          var n = i.concat(r),
            a = [48];
          return d(a, n.length), (a = a.concat(n)), s.encode(a, e);
        });
    },
    70417: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => g });
      var i = r(1220),
        s = r(45553),
        n = r(93965),
        a = r(12319),
        o = r(32464),
        c = r(58051),
        l = r(52502),
        d = r(55480);
      let u = a.w.getAnalyticsUrl(),
        h = new o.Z({ baseUrl: u, clientId: null }),
        f = ["MODAL_CREATED"],
        p = (0, i.BX)({
          timestamp: Date.now(),
          reportedErrors: {},
          data: { type: "track", event: "MODAL_CREATED" },
        }),
        g = {
          state: p,
          subscribe: (e) => (0, i.B1)(p, () => e(p)),
          getSdkProperties() {
            let { projectId: e, sdkType: t, sdkVersion: r } = d.H.state;
            return { projectId: e, st: t, sv: r || "html-wagmi-4.2.2" };
          },
          async _sendAnalyticsEvent(e) {
            try {
              let t = c.U.state.address;
              if (f.includes(e.data.event) || "undefined" == typeof window)
                return;
              await h.post({
                path: "/e",
                params: g.getSdkProperties(),
                body: {
                  eventId: a.w.getUUID(),
                  url: window.location.href,
                  domain: window.location.hostname,
                  timestamp: e.timestamp,
                  props: { ...e.data, address: t },
                },
              }),
                (p.reportedErrors.FORBIDDEN = !1);
            } catch (e) {
              e instanceof Error &&
                e.cause instanceof Response &&
                e.cause.status === s.o.HTTP_STATUS_CODES.FORBIDDEN &&
                !p.reportedErrors.FORBIDDEN &&
                (l.h.open(
                  {
                    shortMessage: "Invalid App Configuration",
                    longMessage: `Origin ${
                      (0, n.IP)() ? window.origin : "uknown"
                    } not found on Allowlist - update configuration on cloud.reown.com`,
                  },
                  "error"
                ),
                (p.reportedErrors.FORBIDDEN = !0));
            }
          },
          sendEvent(e) {
            (p.timestamp = Date.now()),
              (p.data = e),
              d.H.state.features?.analytics && g._sendAnalyticsEvent(p);
          },
        };
    },
    71018: (e, t, r) => {
      "use strict";
      r.d(t, {
        D5: () => I,
        U5: () => C,
        h6: () => s.a,
        iP: () => E,
        oI: () => _,
      });
      var i = r(65727),
        s = r.n(i),
        n = r(25042);
      let a = { level: "info" },
        o = "custom_context";
      class c {
        constructor(e) {
          (this.nodeValue = e),
            (this.sizeInBytes = new TextEncoder().encode(
              this.nodeValue
            ).length),
            (this.next = null);
        }
        get value() {
          return this.nodeValue;
        }
        get size() {
          return this.sizeInBytes;
        }
      }
      class l {
        constructor(e) {
          (this.head = null),
            (this.tail = null),
            (this.lengthInNodes = 0),
            (this.maxSizeInBytes = e),
            (this.sizeInBytes = 0);
        }
        append(e) {
          let t = new c(e);
          if (t.size > this.maxSizeInBytes)
            throw Error(
              `[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`
            );
          for (; this.size + t.size > this.maxSizeInBytes; ) this.shift();
          this.head ? this.tail && (this.tail.next = t) : (this.head = t),
            (this.tail = t),
            this.lengthInNodes++,
            (this.sizeInBytes += t.size);
        }
        shift() {
          if (!this.head) return;
          let e = this.head;
          (this.head = this.head.next),
            this.head || (this.tail = null),
            this.lengthInNodes--,
            (this.sizeInBytes -= e.size);
        }
        toArray() {
          let e = [],
            t = this.head;
          for (; null !== t; ) e.push(t.value), (t = t.next);
          return e;
        }
        get length() {
          return this.lengthInNodes;
        }
        get size() {
          return this.sizeInBytes;
        }
        toOrderedArray() {
          return Array.from(this);
        }
        [Symbol.iterator]() {
          let e = this.head;
          return {
            next: () => {
              if (!e) return { done: !0, value: null };
              let t = e.value;
              return (e = e.next), { done: !1, value: t };
            },
          };
        }
      }
      class d {
        constructor(e, t = 1024e3) {
          (this.level = e ?? "error"),
            (this.levelValue = i.levels.values[this.level]),
            (this.MAX_LOG_SIZE_IN_BYTES = t),
            (this.logs = new l(this.MAX_LOG_SIZE_IN_BYTES));
        }
        forwardToConsole(e, t) {
          t === i.levels.values.error
            ? console.error(e)
            : t === i.levels.values.warn
            ? console.warn(e)
            : t === i.levels.values.debug
            ? console.debug(e)
            : t === i.levels.values.trace
            ? console.trace(e)
            : console.log(e);
        }
        appendToLogs(e) {
          this.logs.append(
            (0, n.h)({ timestamp: new Date().toISOString(), log: e })
          );
          let t = "string" == typeof e ? JSON.parse(e).level : e.level;
          t >= this.levelValue && this.forwardToConsole(e, t);
        }
        getLogs() {
          return this.logs;
        }
        clearLogs() {
          this.logs = new l(this.MAX_LOG_SIZE_IN_BYTES);
        }
        getLogArray() {
          return Array.from(this.logs);
        }
        logsToBlob(e) {
          let t = this.getLogArray();
          return (
            t.push((0, n.h)({ extraMetadata: e })),
            new Blob(t, { type: "application/json" })
          );
        }
      }
      class u {
        constructor(e, t = 1024e3) {
          this.baseChunkLogger = new d(e, t);
        }
        write(e) {
          this.baseChunkLogger.appendToLogs(e);
        }
        getLogs() {
          return this.baseChunkLogger.getLogs();
        }
        clearLogs() {
          this.baseChunkLogger.clearLogs();
        }
        getLogArray() {
          return this.baseChunkLogger.getLogArray();
        }
        logsToBlob(e) {
          return this.baseChunkLogger.logsToBlob(e);
        }
        downloadLogsBlobInBrowser(e) {
          let t = URL.createObjectURL(this.logsToBlob(e)),
            r = document.createElement("a");
          (r.href = t),
            (r.download = `walletconnect-logs-${new Date().toISOString()}.txt`),
            document.body.appendChild(r),
            r.click(),
            document.body.removeChild(r),
            URL.revokeObjectURL(t);
        }
      }
      class h {
        constructor(e, t = 1024e3) {
          this.baseChunkLogger = new d(e, t);
        }
        write(e) {
          this.baseChunkLogger.appendToLogs(e);
        }
        getLogs() {
          return this.baseChunkLogger.getLogs();
        }
        clearLogs() {
          this.baseChunkLogger.clearLogs();
        }
        getLogArray() {
          return this.baseChunkLogger.getLogArray();
        }
        logsToBlob(e) {
          return this.baseChunkLogger.logsToBlob(e);
        }
      }
      var f = Object.defineProperty,
        p = Object.defineProperties,
        g = Object.getOwnPropertyDescriptors,
        m = Object.getOwnPropertySymbols,
        b = Object.prototype.hasOwnProperty,
        y = Object.prototype.propertyIsEnumerable,
        w = (e, t, r) =>
          t in e
            ? f(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        v = (e, t) => {
          for (var r in t || (t = {})) b.call(t, r) && w(e, r, t[r]);
          if (m) for (var r of m(t)) y.call(t, r) && w(e, r, t[r]);
          return e;
        },
        A = (e, t) => p(e, g(t));
      function E(e) {
        return A(v({}, e), { level: e?.level || a.level });
      }
      function _(e, t = o) {
        return typeof e.bindings > "u"
          ? (function (e, t = o) {
              return e[t] || "";
            })(e, t)
          : e.bindings().context || "";
      }
      function C(e, t, r = o) {
        let i = (function (e, t, r = o) {
          let i = _(e, r);
          return i.trim() ? `${i}/${t}` : t;
        })(e, t, r);
        return (function (e, t, r = o) {
          return (e[r] = t), e;
        })(e.child({ context: i }), i, r);
      }
      function I(e) {
        return "u" > typeof e.loggerOverride &&
          "string" != typeof e.loggerOverride
          ? { logger: e.loggerOverride, chunkLoggerController: null }
          : "u" > typeof window
          ? (function (e) {
              var t, r;
              let i = new u(
                null == (t = e.opts) ? void 0 : t.level,
                e.maxSizeInBytes
              );
              return {
                logger: s()(
                  A(v({}, e.opts), {
                    level: "trace",
                    browser: A(
                      v({}, null == (r = e.opts) ? void 0 : r.browser),
                      { write: (e) => i.write(e) }
                    ),
                  })
                ),
                chunkLoggerController: i,
              };
            })(e)
          : (function (e) {
              var t;
              let r = new h(
                null == (t = e.opts) ? void 0 : t.level,
                e.maxSizeInBytes
              );
              return {
                logger: s()(A(v({}, e.opts), { level: "trace" }), r),
                chunkLoggerController: r,
              };
            })(e);
      }
    },
    71084: (e, t, r) => {
      "use strict";
      let i, s, n;
      r.d(t, {
        JX: () => l,
        RF: () => c,
        W5: () => h,
        ck: () => p,
        ds: () => d,
        fD: () => f,
      });
      var a = r(85896),
        o = r(52617);
      function c(e, t) {
        (i = document.createElement("style")),
          (s = document.createElement("style")),
          (n = document.createElement("style")),
          (i.textContent = u(e).core.cssText),
          (s.textContent = u(e).dark.cssText),
          (n.textContent = u(e).light.cssText),
          document.head.appendChild(i),
          document.head.appendChild(s),
          document.head.appendChild(n),
          l(t);
      }
      function l(e) {
        s &&
          n &&
          ("light" === e
            ? (s.removeAttribute("media"), (n.media = "enabled"))
            : (n.removeAttribute("media"), (s.media = "enabled")));
      }
      function d(e) {
        i &&
          s &&
          n &&
          ((i.textContent = u(e).core.cssText),
          (s.textContent = u(e).dark.cssText),
          (n.textContent = u(e).light.cssText));
      }
      function u(e) {
        return {
          core: (0, a.AH)`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${(0, a.iz)(
          e?.["--w3m-color-mix-strength"]
            ? `${e["--w3m-color-mix-strength"]}%`
            : "0%"
        )};
        --w3m-font-family: ${(0, a.iz)(
          e?.["--w3m-font-family"] ||
            "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;"
        )};
        --w3m-font-size-master: ${(0, a.iz)(
          e?.["--w3m-font-size-master"] || "10px"
        )};
        --w3m-border-radius-master: ${(0, a.iz)(
          e?.["--w3m-border-radius-master"] || "4px"
        )};
        --w3m-z-index: ${(0, a.iz)(e?.["--w3m-z-index"] || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
          light: (0, a.AH)`
      :root {
        --w3m-color-mix: ${(0, a.iz)(e?.["--w3m-color-mix"] || "#fff")};
        --w3m-accent: ${(0, a.iz)((0, o.o)(e, "dark")["--w3m-accent"])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${(0, a.iz)(
          (0, o.o)(e, "dark")["--w3m-background"]
        )};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
          dark: (0, a.AH)`
      :root {
        --w3m-color-mix: ${(0, a.iz)(e?.["--w3m-color-mix"] || "#000")};
        --w3m-accent: ${(0, a.iz)((0, o.o)(e, "light")["--w3m-accent"])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${(0, a.iz)(
          (0, o.o)(e, "light")["--w3m-background"]
        )};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `,
        };
      }
      let h = (0, a.AH)`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`,
        f = (0, a.AH)`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`,
        p = (0, a.AH)`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`;
    },
    71124: (e, t) => {
      "use strict";
      function r(e) {
        var t;
        let { config: r, src: i, width: s, quality: n } = e,
          a =
            n ||
            (null == (t = r.qualities)
              ? void 0
              : t.reduce((e, t) =>
                  Math.abs(t - 75) < Math.abs(e - 75) ? t : e
                )) ||
            75;
        return i;
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "default", {
          enumerable: !0,
          get: function () {
            return i;
          },
        }),
        (r.__next_img_default = !0);
      let i = r;
    },
    72427: (e, t, r) => {
      "use strict";
      r.d(t, { db: () => n, eV: () => s });
      var i = r(66969);
      function s(e, { dir: t, size: r = 32 } = {}) {
        return "string" == typeof e
          ? n(e, { dir: t, size: r })
          : (function (e, { dir: t, size: r = 32 } = {}) {
              if (null === r) return e;
              if (e.length > r)
                throw new i.Fl({
                  size: e.length,
                  targetSize: r,
                  type: "bytes",
                });
              let s = new Uint8Array(r);
              for (let i = 0; i < r; i++) {
                let n = "right" === t;
                s[n ? i : r - i - 1] = e[n ? i : e.length - i - 1];
              }
              return s;
            })(e, { dir: t, size: r });
      }
      function n(e, { dir: t, size: r = 32 } = {}) {
        if (null === r) return e;
        let s = e.replace("0x", "");
        if (s.length > 2 * r)
          throw new i.Fl({
            size: Math.ceil(s.length / 2),
            targetSize: r,
            type: "hex",
          });
        return `0x${s["right" === t ? "padEnd" : "padStart"](2 * r, "0")}`;
      }
    },
    72557: (e, t, r) => {
      "use strict";
      r.d(t, { E: () => i });
      let i = {
        ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
        ERROR_CODE_DEFAULT: 5e3,
        ERROR_INVALID_CHAIN_ID: 32603,
      };
    },
    72757: (e, t, r) => {
      "use strict";
      function i(e, t, r) {
        let i = e[t.name];
        if ("function" == typeof i) return i;
        let s = e[r];
        return "function" == typeof s ? s : (r) => t(e, r);
      }
      r.d(t, { T: () => i });
    },
    72880: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => b });
      var i = r(1220),
        s = r(98866),
        n = r(14744),
        a = r(12319),
        o = r(32464),
        c = r(58653),
        l = r(29936),
        d = r(73442),
        u = r(66254),
        h = r(70417),
        f = r(55480);
      let p = a.w.getApiUrl(),
        g = new o.Z({ baseUrl: p, clientId: null }),
        m = (0, i.BX)({
          promises: {},
          page: 1,
          count: 0,
          featured: [],
          allFeatured: [],
          recommended: [],
          allRecommended: [],
          wallets: [],
          search: [],
          isAnalyticsEnabled: !1,
          excludedRDNS: [],
          isFetchingRecommendedWallets: !1,
        }),
        b = {
          state: m,
          subscribeKey: (e, t) => (0, s.u$)(m, e, t),
          _getSdkProperties() {
            let { projectId: e, sdkType: t, sdkVersion: r } = f.H.state;
            return {
              projectId: e,
              st: t || "appkit",
              sv: r || "html-wagmi-4.2.2",
            };
          },
          _filterOutExtensions: (e) =>
            f.H.state.isUniversalProvider
              ? e.filter(
                  (e) => !!(e.mobile_link || e.desktop_link || e.webapp_link)
                )
              : e,
          async _fetchWalletImage(e) {
            let t = `${g.baseUrl}/getWalletImage/${e}`,
              r = await g.getBlob({ path: t, params: b._getSdkProperties() });
            l.j.setWalletImage(e, URL.createObjectURL(r));
          },
          async _fetchNetworkImage(e) {
            let t = `${g.baseUrl}/public/getAssetImage/${e}`,
              r = await g.getBlob({ path: t, params: b._getSdkProperties() });
            l.j.setNetworkImage(e, URL.createObjectURL(r));
          },
          async _fetchConnectorImage(e) {
            let t = `${g.baseUrl}/public/getAssetImage/${e}`,
              r = await g.getBlob({ path: t, params: b._getSdkProperties() });
            l.j.setConnectorImage(e, URL.createObjectURL(r));
          },
          async _fetchCurrencyImage(e) {
            let t = `${g.baseUrl}/public/getCurrencyImage/${e}`,
              r = await g.getBlob({ path: t, params: b._getSdkProperties() });
            l.j.setCurrencyImage(e, URL.createObjectURL(r));
          },
          async _fetchTokenImage(e) {
            let t = `${g.baseUrl}/public/getTokenImage/${e}`,
              r = await g.getBlob({ path: t, params: b._getSdkProperties() });
            l.j.setTokenImage(e, URL.createObjectURL(r));
          },
          async fetchNetworkImages() {
            let e = d.W.getAllRequestedCaipNetworks(),
              t = e
                ?.map(({ assets: e }) => e?.imageId)
                .filter(Boolean)
                .filter((e) => !n.$.getNetworkImageById(e));
            t &&
              (await Promise.allSettled(t.map((e) => b._fetchNetworkImage(e))));
          },
          async fetchConnectorImages() {
            let { connectors: e } = u.a.state,
              t = e.map(({ imageId: e }) => e).filter(Boolean);
            await Promise.allSettled(t.map((e) => b._fetchConnectorImage(e)));
          },
          async fetchCurrencyImages(e = []) {
            await Promise.allSettled(e.map((e) => b._fetchCurrencyImage(e)));
          },
          async fetchTokenImages(e = []) {
            await Promise.allSettled(e.map((e) => b._fetchTokenImage(e)));
          },
          async fetchFeaturedWallets() {
            let { featuredWalletIds: e } = f.H.state;
            if (e?.length) {
              let { data: t } = await g.get({
                path: "/getWallets",
                params: {
                  ...b._getSdkProperties(),
                  page: "1",
                  entries: e?.length ? String(e.length) : "4",
                  include: e?.join(","),
                },
              });
              t.sort((t, r) => e.indexOf(t.id) - e.indexOf(r.id));
              let r = t.map((e) => e.image_id).filter(Boolean);
              await Promise.allSettled(r.map((e) => b._fetchWalletImage(e))),
                (m.featured = t),
                (m.allFeatured = t);
            }
          },
          async fetchRecommendedWallets() {
            try {
              m.isFetchingRecommendedWallets = !0;
              let {
                  includeWalletIds: e,
                  excludeWalletIds: t,
                  featuredWalletIds: r,
                } = f.H.state,
                i = [...(t ?? []), ...(r ?? [])].filter(Boolean),
                s = d.W.getRequestedCaipNetworkIds().join(","),
                { data: n, count: a } = await g.get({
                  path: "/getWallets",
                  params: {
                    ...b._getSdkProperties(),
                    page: "1",
                    chains: s,
                    entries: "4",
                    include: e?.join(","),
                    exclude: i?.join(","),
                  },
                }),
                o = c.i.getRecentWallets(),
                l = n.map((e) => e.image_id).filter(Boolean),
                u = o.map((e) => e.image_id).filter(Boolean);
              await Promise.allSettled(
                [...l, ...u].map((e) => b._fetchWalletImage(e))
              ),
                (m.recommended = n),
                (m.allRecommended = n),
                (m.count = a ?? 0);
            } catch {
            } finally {
              m.isFetchingRecommendedWallets = !1;
            }
          },
          async fetchWallets({ page: e }) {
            let {
                includeWalletIds: t,
                excludeWalletIds: r,
                featuredWalletIds: i,
              } = f.H.state,
              s = d.W.getRequestedCaipNetworkIds().join(","),
              n = [
                ...m.recommended.map(({ id: e }) => e),
                ...(r ?? []),
                ...(i ?? []),
              ].filter(Boolean),
              { data: o, count: c } = await g.get({
                path: "/getWallets",
                params: {
                  ...b._getSdkProperties(),
                  page: String(e),
                  entries: "40",
                  chains: s,
                  include: t?.join(","),
                  exclude: n.join(","),
                },
              }),
              l = o
                .slice(0, 20)
                .map((e) => e.image_id)
                .filter(Boolean);
            await Promise.allSettled(l.map((e) => b._fetchWalletImage(e))),
              (m.wallets = a.w.uniqueBy(
                [...m.wallets, ...b._filterOutExtensions(o)],
                "id"
              )),
              (m.count = c > m.count ? c : m.count),
              (m.page = e);
          },
          async initializeExcludedWalletRdns({ ids: e }) {
            let t = d.W.getRequestedCaipNetworkIds().join(","),
              { data: r } = await g.get({
                path: "/getWallets",
                params: {
                  ...b._getSdkProperties(),
                  page: "1",
                  entries: String(e.length),
                  chains: t,
                  include: e?.join(","),
                },
              });
            r &&
              r.forEach((e) => {
                e?.rdns && m.excludedRDNS.push(e.rdns);
              });
          },
          async searchWallet({ search: e, badge: t }) {
            let { includeWalletIds: r, excludeWalletIds: i } = f.H.state;
            m.search = [];
            let s = d.W.getRequestedCaipNetworkIds().join(","),
              { data: n } = await g.get({
                path: "/getWallets",
                params: {
                  ...b._getSdkProperties(),
                  page: "1",
                  entries: "100",
                  search: e?.trim(),
                  badge_type: t,
                  chains: s,
                  include: r?.join(","),
                  exclude: i?.join(","),
                },
              });
            h.E.sendEvent({
              type: "track",
              event: "SEARCH_WALLET",
              properties: { badge: t ?? "", search: e ?? "" },
            });
            let o = n.map((e) => e.image_id).filter(Boolean);
            await Promise.allSettled([
              ...o.map((e) => b._fetchWalletImage(e)),
              a.w.wait(300),
            ]),
              (m.search = b._filterOutExtensions(n));
          },
          initPromise(e, t) {
            let r = m.promises[e];
            return r || (m.promises[e] = t());
          },
          prefetch: ({
            fetchConnectorImages: e = !0,
            fetchFeaturedWallets: t = !0,
            fetchRecommendedWallets: r = !0,
            fetchNetworkImages: i = !0,
          } = {}) =>
            Promise.allSettled(
              [
                e && b.initPromise("connectorImages", b.fetchConnectorImages),
                t && b.initPromise("featuredWallets", b.fetchFeaturedWallets),
                r &&
                  b.initPromise(
                    "recommendedWallets",
                    b.fetchRecommendedWallets
                  ),
                i && b.initPromise("networkImages", b.fetchNetworkImages),
              ].filter(Boolean)
            ),
          prefetchAnalyticsConfig() {
            f.H.state.features?.analytics && b.fetchAnalyticsConfig();
          },
          async fetchAnalyticsConfig() {
            try {
              let { isAnalyticsEnabled: e } = await g.get({
                path: "/getAnalyticsConfig",
                params: b._getSdkProperties(),
              });
              f.H.setFeatures({ analytics: e });
            } catch (e) {
              f.H.setFeatures({ analytics: !1 });
            }
          },
          setFilterByNamespace(e) {
            if (!e) {
              (m.featured = m.allFeatured), (m.recommended = m.allRecommended);
              return;
            }
            let t = d.W.getRequestedCaipNetworkIds().join(",");
            (m.featured = m.allFeatured.filter((e) =>
              e.chains?.some((e) => t.includes(e))
            )),
              (m.recommended = m.allRecommended.filter((e) =>
                e.chains?.some((e) => t.includes(e))
              ));
          },
        };
    },
    73168: (e, t, r) => {
      "use strict";
      r.d(t, {
        CL: () => c,
        D5: () => d,
        Di: () => h,
        Gi: () => l,
        MI: () => I,
        RV: () => E,
        Sf: () => A,
        XU: () => o,
        YW: () => g,
        ab: () => m,
        bq: () => u,
        ch: () => C,
        hA: () => f,
        qZ: () => p,
        s0: () => b,
        sV: () => v,
        vx: () => w,
        xQ: () => y,
        xq: () => _,
      });
      var i = r(13933),
        s = r(4058);
      class n extends i.C {
        constructor(
          e,
          { code: t, docsPath: r, metaMessages: i, name: n, shortMessage: a }
        ) {
          super(a, {
            cause: e,
            docsPath: r,
            metaMessages: i || e?.metaMessages,
            name: n || "RpcError",
          }),
            Object.defineProperty(this, "code", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.name = n || e.name),
            (this.code = e instanceof s.J8 ? e.code : t ?? -1);
        }
      }
      class a extends n {
        constructor(e, t) {
          super(e, t),
            Object.defineProperty(this, "data", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: void 0,
            }),
            (this.data = t.data);
        }
      }
      class o extends n {
        constructor(e) {
          super(e, {
            code: o.code,
            name: "ParseRpcError",
            shortMessage:
              "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",
          });
        }
      }
      Object.defineProperty(o, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32700,
      });
      class c extends n {
        constructor(e) {
          super(e, {
            code: c.code,
            name: "InvalidRequestRpcError",
            shortMessage: "JSON is not a valid request object.",
          });
        }
      }
      Object.defineProperty(c, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32600,
      });
      class l extends n {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: l.code,
            name: "MethodNotFoundRpcError",
            shortMessage: `The method${
              t ? ` "${t}"` : ""
            } does not exist / is not available.`,
          });
        }
      }
      Object.defineProperty(l, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32601,
      });
      class d extends n {
        constructor(e) {
          super(e, {
            code: d.code,
            name: "InvalidParamsRpcError",
            shortMessage:
              "Invalid parameters were provided to the RPC method.\nDouble check you have provided the correct parameters.",
          });
        }
      }
      Object.defineProperty(d, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32602,
      });
      class u extends n {
        constructor(e) {
          super(e, {
            code: u.code,
            name: "InternalRpcError",
            shortMessage: "An internal error was received.",
          });
        }
      }
      Object.defineProperty(u, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32603,
      });
      class h extends n {
        constructor(e) {
          super(e, {
            code: h.code,
            name: "InvalidInputRpcError",
            shortMessage:
              "Missing or invalid parameters.\nDouble check you have provided the correct parameters.",
          });
        }
      }
      Object.defineProperty(h, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32e3,
      });
      class f extends n {
        constructor(e) {
          super(e, {
            code: f.code,
            name: "ResourceNotFoundRpcError",
            shortMessage: "Requested resource not found.",
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ResourceNotFoundRpcError",
            });
        }
      }
      Object.defineProperty(f, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32001,
      });
      class p extends n {
        constructor(e) {
          super(e, {
            code: p.code,
            name: "ResourceUnavailableRpcError",
            shortMessage: "Requested resource not available.",
          });
        }
      }
      Object.defineProperty(p, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32002,
      });
      class g extends n {
        constructor(e) {
          super(e, {
            code: g.code,
            name: "TransactionRejectedRpcError",
            shortMessage: "Transaction creation failed.",
          });
        }
      }
      Object.defineProperty(g, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32003,
      });
      class m extends n {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: m.code,
            name: "MethodNotSupportedRpcError",
            shortMessage: `Method${t ? ` "${t}"` : ""} is not supported.`,
          });
        }
      }
      Object.defineProperty(m, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32004,
      });
      class b extends n {
        constructor(e) {
          super(e, {
            code: b.code,
            name: "LimitExceededRpcError",
            shortMessage: "Request exceeds defined limit.",
          });
        }
      }
      Object.defineProperty(b, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32005,
      });
      class y extends n {
        constructor(e) {
          super(e, {
            code: y.code,
            name: "JsonRpcVersionUnsupportedError",
            shortMessage: "Version of JSON-RPC protocol is not supported.",
          });
        }
      }
      Object.defineProperty(y, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: -32006,
      });
      class w extends a {
        constructor(e) {
          super(e, {
            code: w.code,
            name: "UserRejectedRequestError",
            shortMessage: "User rejected the request.",
          });
        }
      }
      Object.defineProperty(w, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4001,
      });
      class v extends a {
        constructor(e) {
          super(e, {
            code: v.code,
            name: "UnauthorizedProviderError",
            shortMessage:
              "The requested method and/or account has not been authorized by the user.",
          });
        }
      }
      Object.defineProperty(v, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4100,
      });
      class A extends a {
        constructor(e, { method: t } = {}) {
          super(e, {
            code: A.code,
            name: "UnsupportedProviderMethodError",
            shortMessage: `The Provider does not support the requested method${
              t ? ` " ${t}"` : ""
            }.`,
          });
        }
      }
      Object.defineProperty(A, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4200,
      });
      class E extends a {
        constructor(e) {
          super(e, {
            code: E.code,
            name: "ProviderDisconnectedError",
            shortMessage: "The Provider is disconnected from all chains.",
          });
        }
      }
      Object.defineProperty(E, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4900,
      });
      class _ extends a {
        constructor(e) {
          super(e, {
            code: _.code,
            name: "ChainDisconnectedError",
            shortMessage:
              "The Provider is not connected to the requested chain.",
          });
        }
      }
      Object.defineProperty(_, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4901,
      });
      class C extends a {
        constructor(e) {
          super(e, {
            code: C.code,
            name: "SwitchChainError",
            shortMessage: "An error occurred when attempting to switch chain.",
          });
        }
      }
      Object.defineProperty(C, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 4902,
      });
      class I extends n {
        constructor(e) {
          super(e, {
            name: "UnknownRpcError",
            shortMessage: "An unknown RPC error occurred.",
          });
        }
      }
    },
    73442: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => _ });
      var i = r(1220),
        s = r(98866),
        n = r(76190),
        a = r(45553),
        o = r(66254);
      function c(e, t) {
        return o.a.getConnectorId(e) === t;
      }
      var l = r(28977),
        d = r(12319),
        u = r(58653),
        h = r(58051),
        f = r(3824),
        p = r(70417),
        g = r(81701),
        m = r(55480),
        b = r(6578),
        y = r(67869),
        w = r(79875);
      let v = {
          currentTab: 0,
          tokenBalance: [],
          smartAccountDeployed: !1,
          addressLabels: new Map(),
          allAccounts: [],
          user: void 0,
        },
        A = {
          caipNetwork: void 0,
          supportsAllNetworks: !0,
          smartAccountEnabledNetworks: [],
        },
        E = (0, i.BX)({
          chains: (0, s.zC)(),
          activeCaipAddress: void 0,
          activeChain: void 0,
          activeCaipNetwork: void 0,
          noAdapters: !1,
          universalAdapter: {
            networkControllerClient: void 0,
            connectionControllerClient: void 0,
          },
          isSwitchingNamespace: !1,
        }),
        _ = {
          state: E,
          subscribe: (e) =>
            (0, i.B1)(E, () => {
              e(E);
            }),
          subscribeKey: (e, t) => (0, s.u$)(E, e, t),
          subscribeChainProp(e, t, r) {
            let s;
            return (0, i.B1)(E.chains, () => {
              let i = r || E.activeChain;
              if (i) {
                let r = E.chains.get(i)?.[e];
                s !== r && ((s = r), t(r));
              }
            });
          },
          initialize(e, t, r) {
            let { chainId: s, namespace: n } = u.i.getActiveNetworkProps(),
              a = t?.find((e) => e.id.toString() === s?.toString()),
              o = e.find((e) => e?.namespace === n) || e?.[0],
              c = new Set([...(t?.map((e) => e.chainNamespace) ?? [])]);
            (e?.length !== 0 && o) || (E.noAdapters = !0),
              !E.noAdapters &&
                ((E.activeChain = o?.namespace),
                (E.activeCaipNetwork = a),
                this.setChainNetworkData(o?.namespace, { caipNetwork: a }),
                E.activeChain && b.z.set({ activeChain: o?.namespace })),
              c.forEach((e) => {
                let s = t?.filter((t) => t.chainNamespace === e);
                _.state.chains.set(e, {
                  namespace: e,
                  networkState: (0, i.BX)({ ...A, caipNetwork: s?.[0] }),
                  accountState: (0, i.BX)(v),
                  caipNetworks: s ?? [],
                  ...r,
                }),
                  this.setRequestedCaipNetworks(s ?? [], e);
              });
          },
          removeAdapter(e) {
            if (E.activeChain === e) {
              let t = Array.from(E.chains.entries()).find(([t]) => t !== e);
              if (t) {
                let e = t[1]?.caipNetworks?.[0];
                e && this.setActiveCaipNetwork(e);
              }
            }
            E.chains.delete(e);
          },
          addAdapter(
            e,
            { networkControllerClient: t, connectionControllerClient: r },
            i
          ) {
            E.chains.set(e.namespace, {
              namespace: e.namespace,
              networkState: { ...A, caipNetwork: i[0] },
              accountState: v,
              caipNetworks: i,
              connectionControllerClient: r,
              networkControllerClient: t,
            }),
              this.setRequestedCaipNetworks(
                i?.filter((t) => t.chainNamespace === e.namespace) ?? [],
                e.namespace
              );
          },
          addNetwork(e) {
            let t = E.chains.get(e.chainNamespace);
            if (t) {
              let r = [...(t.caipNetworks || [])];
              t.caipNetworks?.find((t) => t.id === e.id) || r.push(e),
                E.chains.set(e.chainNamespace, { ...t, caipNetworks: r }),
                this.setRequestedCaipNetworks(r, e.chainNamespace);
            }
          },
          removeNetwork(e, t) {
            let r = E.chains.get(e);
            if (r) {
              let i = E.activeCaipNetwork?.id === t,
                s = [...(r.caipNetworks?.filter((e) => e.id !== t) || [])];
              i &&
                r?.caipNetworks?.[0] &&
                this.setActiveCaipNetwork(r.caipNetworks[0]),
                E.chains.set(e, { ...r, caipNetworks: s }),
                this.setRequestedCaipNetworks(s || [], e);
            }
          },
          setAdapterNetworkState(e, t) {
            let r = E.chains.get(e);
            r &&
              ((r.networkState = { ...(r.networkState || A), ...t }),
              E.chains.set(e, r));
          },
          setChainAccountData(e, t, r = !0) {
            if (!e)
              throw Error("Chain is required to update chain account data");
            let i = E.chains.get(e);
            if (i) {
              let r = { ...(i.accountState || v), ...t };
              E.chains.set(e, { ...i, accountState: r }),
                (1 === E.chains.size || E.activeChain === e) &&
                  (t.caipAddress && (E.activeCaipAddress = t.caipAddress),
                  h.U.replaceState(r));
            }
          },
          setChainNetworkData(e, t) {
            if (!e) return;
            let r = E.chains.get(e);
            if (r) {
              let i = { ...(r.networkState || A), ...t };
              E.chains.set(e, { ...r, networkState: i });
            }
          },
          setAccountProp(e, t, r, i = !0) {
            this.setChainAccountData(r, { [e]: t }, i),
              "status" === e &&
                "disconnected" === t &&
                r &&
                o.a.removeConnectorId(r);
          },
          setActiveNamespace(e) {
            E.activeChain = e;
            let t = e ? E.chains.get(e) : void 0,
              r = t?.networkState?.caipNetwork;
            r?.id &&
              e &&
              ((E.activeCaipAddress = t?.accountState?.caipAddress),
              (E.activeCaipNetwork = r),
              this.setChainNetworkData(e, { caipNetwork: r }),
              u.i.setActiveCaipNetworkId(r?.caipNetworkId),
              b.z.set({ activeChain: e, selectedNetworkId: r?.caipNetworkId }));
          },
          setActiveCaipNetwork(e) {
            if (!e) return;
            E.activeChain !== e.chainNamespace &&
              this.setIsSwitchingNamespace(!0);
            let t = E.chains.get(e.chainNamespace);
            (E.activeChain = e.chainNamespace),
              (E.activeCaipNetwork = e),
              this.setChainNetworkData(e.chainNamespace, { caipNetwork: e }),
              t?.accountState?.address
                ? (E.activeCaipAddress = `${e.chainNamespace}:${e.id}:${t?.accountState?.address}`)
                : (E.activeCaipAddress = void 0),
              this.setAccountProp(
                "caipAddress",
                E.activeCaipAddress,
                e.chainNamespace
              ),
              t && h.U.replaceState(t.accountState),
              w.R.resetSend(),
              b.z.set({
                activeChain: E.activeChain,
                selectedNetworkId: E.activeCaipNetwork?.caipNetworkId,
              }),
              u.i.setActiveCaipNetworkId(e.caipNetworkId),
              this.checkIfSupportedNetwork(e.chainNamespace) ||
                m.H.state.allowUnsupportedChain ||
                f.x.state.wcBasic ||
                this.showUnsupportedChainUI();
          },
          addCaipNetwork(e) {
            if (!e) return;
            let t = E.chains.get(e.chainNamespace);
            t && t?.caipNetworks?.push(e);
          },
          async switchActiveNamespace(e) {
            if (!e) return;
            let t = e !== _.state.activeChain,
              r = _.getNetworkData(e)?.caipNetwork,
              i = _.getCaipNetworkByNamespace(e, r?.id);
            t && i && (await _.switchActiveNetwork(i));
          },
          async switchActiveNetwork(e) {
            let t = _.state.chains.get(_.state.activeChain);
            t?.caipNetworks?.some((e) => e.id === E.activeCaipNetwork?.id) ||
              y.I.goBack();
            let r = this.getNetworkControllerClient(e.chainNamespace);
            r &&
              (await r.switchCaipNetwork(e),
              p.E.sendEvent({
                type: "track",
                event: "SWITCH_NETWORK",
                properties: { network: e.caipNetworkId },
              }));
          },
          getNetworkControllerClient(e) {
            let t = e || E.activeChain,
              r = E.chains.get(t);
            if (!r) throw Error("Chain adapter not found");
            if (!r.networkControllerClient)
              throw Error("NetworkController client not set");
            return r.networkControllerClient;
          },
          getConnectionControllerClient(e) {
            let t = e || E.activeChain;
            if (!t)
              throw Error(
                "Chain is required to get connection controller client"
              );
            let r = E.chains.get(t);
            if (!r?.connectionControllerClient)
              throw Error("ConnectionController client not set");
            return r.connectionControllerClient;
          },
          getAccountProp(e, t) {
            let r = E.activeChain;
            if ((t && (r = t), !r)) return;
            let i = E.chains.get(r)?.accountState;
            if (i) return i[e];
          },
          getNetworkProp(e, t) {
            let r = E.chains.get(t)?.networkState;
            if (r) return r[e];
          },
          getRequestedCaipNetworks(e) {
            let t = E.chains.get(e),
              {
                approvedCaipNetworkIds: r = [],
                requestedCaipNetworks: i = [],
              } = t?.networkState || {};
            return d.w.sortRequestedNetworks(r, i);
          },
          getAllRequestedCaipNetworks() {
            let e = [];
            return (
              E.chains.forEach((t) => {
                let r = this.getRequestedCaipNetworks(t.namespace);
                e.push(...r);
              }),
              e
            );
          },
          setRequestedCaipNetworks(e, t) {
            this.setAdapterNetworkState(t, { requestedCaipNetworks: e });
          },
          getAllApprovedCaipNetworkIds() {
            let e = [];
            return (
              E.chains.forEach((t) => {
                let r = this.getApprovedCaipNetworkIds(t.namespace);
                e.push(...r);
              }),
              e
            );
          },
          getActiveCaipNetwork: () => E.activeCaipNetwork,
          getActiveCaipAddress: () => E.activeCaipAddress,
          getApprovedCaipNetworkIds(e) {
            let t = E.chains.get(e);
            return t?.networkState?.approvedCaipNetworkIds || [];
          },
          async setApprovedCaipNetworksData(e) {
            let t = this.getNetworkControllerClient(),
              r = await t?.getApprovedCaipNetworksData();
            this.setAdapterNetworkState(e, {
              approvedCaipNetworkIds: r?.approvedCaipNetworkIds,
              supportsAllNetworks: r?.supportsAllNetworks,
            });
          },
          checkIfSupportedNetwork(e, t) {
            let r = t || E.activeCaipNetwork,
              i = this.getRequestedCaipNetworks(e);
            return !i.length || i?.some((e) => e.id === r?.id);
          },
          checkIfSupportedChainId(e) {
            if (!E.activeChain) return !0;
            let t = this.getRequestedCaipNetworks(E.activeChain);
            return t?.some((t) => t.id === e);
          },
          setSmartAccountEnabledNetworks(e, t) {
            this.setAdapterNetworkState(t, { smartAccountEnabledNetworks: e });
          },
          checkIfSmartAccountEnabled() {
            let e = n.L.caipNetworkIdToNumber(
                E.activeCaipNetwork?.caipNetworkId
              ),
              t = E.activeChain;
            if (!t || !e) return !1;
            let r = this.getNetworkProp("smartAccountEnabledNetworks", t);
            return !!r?.includes(Number(e));
          },
          getActiveNetworkTokenAddress() {
            let e = E.activeCaipNetwork?.chainNamespace || "eip155",
              t = E.activeCaipNetwork?.id || 1,
              r = l.oU.NATIVE_TOKEN_ADDRESS[e];
            return `${e}:${t}:${r}`;
          },
          showUnsupportedChainUI() {
            g.W.open({ view: "UnsupportedChain" });
          },
          checkIfNamesSupported() {
            let e = E.activeCaipNetwork;
            return !!(
              e?.chainNamespace &&
              l.oU.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(e.chainNamespace)
            );
          },
          resetNetwork(e) {
            this.setAdapterNetworkState(e, {
              approvedCaipNetworkIds: void 0,
              supportsAllNetworks: !0,
              smartAccountEnabledNetworks: [],
            });
          },
          resetAccount(e) {
            if (!e) throw Error("Chain is required to set account prop");
            (E.activeCaipAddress = void 0),
              this.setChainAccountData(e, {
                smartAccountDeployed: !1,
                currentTab: 0,
                caipAddress: void 0,
                address: void 0,
                balance: void 0,
                balanceSymbol: void 0,
                profileName: void 0,
                profileImage: void 0,
                addressExplorerUrl: void 0,
                tokenBalance: [],
                connectedWalletInfo: void 0,
                preferredAccountType: void 0,
                socialProvider: void 0,
                socialWindow: void 0,
                farcasterUrl: void 0,
                allAccounts: [],
                user: void 0,
                status: "disconnected",
              }),
              o.a.removeConnectorId(e);
          },
          async disconnect(e) {
            let t = (function (e) {
              let t = Array.from(_.state.chains.keys()),
                r = [];
              return (
                e
                  ? (r.push([e, _.state.chains.get(e)]),
                    c(e, a.o.CONNECTOR_ID.WALLET_CONNECT)
                      ? t.forEach((t) => {
                          t !== e &&
                            c(t, a.o.CONNECTOR_ID.WALLET_CONNECT) &&
                            r.push([t, _.state.chains.get(t)]);
                        })
                      : c(e, a.o.CONNECTOR_ID.AUTH) &&
                        t.forEach((t) => {
                          t !== e &&
                            c(t, a.o.CONNECTOR_ID.AUTH) &&
                            r.push([t, _.state.chains.get(t)]);
                        }))
                  : (r = Array.from(_.state.chains.entries())),
                r
              );
            })(e);
            try {
              w.R.resetSend();
              let r = await Promise.allSettled(
                t.map(async ([e, t]) => {
                  try {
                    let { caipAddress: r } = this.getAccountData(e) || {};
                    r &&
                      t.connectionControllerClient?.disconnect &&
                      (await t.connectionControllerClient.disconnect(e)),
                      this.resetAccount(e),
                      this.resetNetwork(e);
                  } catch (t) {
                    throw Error(
                      `Failed to disconnect chain ${e}: ${t.message}`
                    );
                  }
                })
              );
              f.x.resetWcConnection();
              let i = r.filter((e) => "rejected" === e.status);
              if (i.length > 0)
                throw Error(i.map((e) => e.reason.message).join(", "));
              u.i.deleteConnectedSocialProvider(),
                e ? o.a.removeConnectorId(e) : o.a.resetConnectorIds(),
                p.E.sendEvent({
                  type: "track",
                  event: "DISCONNECT_SUCCESS",
                  properties: { namespace: e || "all" },
                });
            } catch (e) {
              console.error(e.message || "Failed to disconnect chains"),
                p.E.sendEvent({
                  type: "track",
                  event: "DISCONNECT_ERROR",
                  properties: {
                    message: e.message || "Failed to disconnect chains",
                  },
                });
            }
          },
          setIsSwitchingNamespace(e) {
            E.isSwitchingNamespace = e;
          },
          getFirstCaipNetworkSupportsAuthConnector() {
            let e;
            let t = [];
            if (
              (E.chains.forEach((e) => {
                a.o.AUTH_CONNECTOR_SUPPORTED_CHAINS.find(
                  (t) => t === e.namespace
                ) &&
                  e.namespace &&
                  t.push(e.namespace);
              }),
              t.length > 0)
            ) {
              let e = t[0];
              return e ? E.chains.get(e)?.caipNetworks?.[0] : void 0;
            }
          },
          getAccountData: (e) =>
            e ? _.state.chains.get(e)?.accountState : h.U.state,
          getNetworkData(e) {
            let t = e || E.activeChain;
            if (t) return _.state.chains.get(t)?.networkState;
          },
          getCaipNetworkByNamespace(e, t) {
            if (!e) return;
            let r = _.state.chains.get(e),
              i = r?.caipNetworks?.find((e) => e.id === t);
            return i || r?.networkState?.caipNetwork || r?.caipNetworks?.[0];
          },
          getRequestedCaipNetworkIds() {
            let e = o.a.state.filterByNamespace;
            return (e ? [E.chains.get(e)] : Array.from(E.chains.values()))
              .flatMap((e) => e?.caipNetworks || [])
              .map((e) => e.caipNetworkId);
          },
        };
    },
    73537: (e, t, r) => {
      "use strict";
      r.d(t, {
        OH: () => n,
        Vl: () => c,
        gS: () => a,
        hy: () => s,
        s1: () => o,
      });
      var i = r(87358);
      let s =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_SDK_URL
            : void 0) || "https://secure.walletconnect.org/sdk",
        n =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_DEFAULT_LOG_LEVEL
            : void 0) || "error",
        a =
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_SDK_VERSION
            : void 0) || "4",
        o = {
          APP_EVENT_KEY: "@w3m-app/",
          FRAME_EVENT_KEY: "@w3m-frame/",
          RPC_METHOD_KEY: "RPC_",
          STORAGE_KEY: "@appkit-wallet/",
          SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
          EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
          LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
          LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
          EMAIL: "EMAIL",
          PREFERRED_ACCOUNT_TYPE: "PREFERRED_ACCOUNT_TYPE",
          SMART_ACCOUNT_ENABLED: "SMART_ACCOUNT_ENABLED",
          SMART_ACCOUNT_ENABLED_NETWORKS: "SMART_ACCOUNT_ENABLED_NETWORKS",
          SOCIAL_USERNAME: "SOCIAL_USERNAME",
          APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
          APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
          APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
          APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
          APP_CONNECT_SOCIAL: "@w3m-app/CONNECT_SOCIAL",
          APP_GET_SOCIAL_REDIRECT_URI: "@w3m-app/GET_SOCIAL_REDIRECT_URI",
          APP_GET_USER: "@w3m-app/GET_USER",
          APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
          APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
          APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
          APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
          APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
          APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
          APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
          APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
          APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
          APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
          APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS:
            "@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS",
          APP_INIT_SMART_ACCOUNT: "@w3m-app/INIT_SMART_ACCOUNT",
          APP_SET_PREFERRED_ACCOUNT: "@w3m-app/SET_PREFERRED_ACCOUNT",
          APP_CONNECT_FARCASTER: "@w3m-app/CONNECT_FARCASTER",
          APP_GET_FARCASTER_URI: "@w3m-app/GET_FARCASTER_URI",
          APP_RELOAD: "@w3m-app/RELOAD",
          FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
          FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
          FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
          FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
          FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
          FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
          FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
          FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
          FRAME_CONNECT_SOCIAL_SUCCESS: "@w3m-frame/CONNECT_SOCIAL_SUCCESS",
          FRAME_CONNECT_SOCIAL_ERROR: "@w3m-frame/CONNECT_SOCIAL_ERROR",
          FRAME_CONNECT_FARCASTER_SUCCESS:
            "@w3m-frame/CONNECT_FARCASTER_SUCCESS",
          FRAME_CONNECT_FARCASTER_ERROR: "@w3m-frame/CONNECT_FARCASTER_ERROR",
          FRAME_GET_FARCASTER_URI_SUCCESS:
            "@w3m-frame/GET_FARCASTER_URI_SUCCESS",
          FRAME_GET_FARCASTER_URI_ERROR: "@w3m-frame/GET_FARCASTER_URI_ERROR",
          FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS:
            "@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS",
          FRAME_GET_SOCIAL_REDIRECT_URI_ERROR:
            "@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR",
          FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
          FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
          FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
          FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
          FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
          FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
          FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
          FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
          FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
          FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
          FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
          FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
          FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
          FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS:
            "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
          FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR:
            "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
          FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS:
            "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
          FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR:
            "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
          FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
          FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
          FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
          FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR",
          FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS:
            "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS",
          FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR:
            "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR",
          FRAME_INIT_SMART_ACCOUNT_SUCCESS:
            "@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS",
          FRAME_INIT_SMART_ACCOUNT_ERROR: "@w3m-frame/INIT_SMART_ACCOUNT_ERROR",
          FRAME_SET_PREFERRED_ACCOUNT_SUCCESS:
            "@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS",
          FRAME_SET_PREFERRED_ACCOUNT_ERROR:
            "@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR",
          FRAME_READY: "@w3m-frame/READY",
          FRAME_RELOAD_SUCCESS: "@w3m-frame/RELOAD_SUCCESS",
          FRAME_RELOAD_ERROR: "@w3m-frame/RELOAD_ERROR",
          RPC_RESPONSE_TYPE_ERROR: "RPC_RESPONSE_ERROR",
          RPC_RESPONSE_TYPE_TX: "RPC_RESPONSE_TRANSACTION_HASH",
          RPC_RESPONSE_TYPE_OBJECT: "RPC_RESPONSE_OBJECT",
        },
        c = {
          SAFE_RPC_METHODS: [
            "eth_accounts",
            "eth_blockNumber",
            "eth_call",
            "eth_chainId",
            "eth_estimateGas",
            "eth_feeHistory",
            "eth_gasPrice",
            "eth_getAccount",
            "eth_getBalance",
            "eth_getBlockByHash",
            "eth_getBlockByNumber",
            "eth_getBlockReceipts",
            "eth_getBlockTransactionCountByHash",
            "eth_getBlockTransactionCountByNumber",
            "eth_getCode",
            "eth_getFilterChanges",
            "eth_getFilterLogs",
            "eth_getLogs",
            "eth_getProof",
            "eth_getStorageAt",
            "eth_getTransactionByBlockHashAndIndex",
            "eth_getTransactionByBlockNumberAndIndex",
            "eth_getTransactionByHash",
            "eth_getTransactionCount",
            "eth_getTransactionReceipt",
            "eth_getUncleCountByBlockHash",
            "eth_getUncleCountByBlockNumber",
            "eth_maxPriorityFeePerGas",
            "eth_newBlockFilter",
            "eth_newFilter",
            "eth_newPendingTransactionFilter",
            "eth_sendRawTransaction",
            "eth_syncing",
            "eth_uninstallFilter",
            "wallet_getCapabilities",
            "wallet_getCallsStatus",
            "eth_getUserOperationReceipt",
            "eth_estimateUserOperationGas",
            "eth_getUserOperationByHash",
            "eth_supportedEntryPoints",
            "wallet_getAssets",
          ],
          NOT_SAFE_RPC_METHODS: [
            "personal_sign",
            "eth_signTypedData_v4",
            "eth_sendTransaction",
            "solana_signMessage",
            "solana_signTransaction",
            "solana_signAllTransactions",
            "solana_signAndSendTransaction",
            "wallet_sendCalls",
            "wallet_grantPermissions",
            "wallet_revokePermissions",
            "eth_sendUserOperation",
          ],
          GET_CHAIN_ID: "eth_chainId",
          RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
          RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
          ACCOUNT_TYPES: { EOA: "eoa", SMART_ACCOUNT: "smartAccount" },
        };
    },
    74841: (e, t, r) => {
      "use strict";
      var i = r(87358);
      Object.defineProperty(t, "__esModule", { value: !0 }),
        !(function (e, t) {
          for (var r in t)
            Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
        })(t, {
          default: function () {
            return m;
          },
          defaultHead: function () {
            return h;
          },
        });
      let s = r(28140),
        n = r(49417),
        a = r(95155),
        o = n._(r(12115)),
        c = s._(r(1262)),
        l = r(90737),
        d = r(82073),
        u = r(60861);
      function h(e) {
        void 0 === e && (e = !1);
        let t = [(0, a.jsx)("meta", { charSet: "utf-8" }, "charset")];
        return (
          e ||
            t.push(
              (0, a.jsx)(
                "meta",
                { name: "viewport", content: "width=device-width" },
                "viewport"
              )
            ),
          t
        );
      }
      function f(e, t) {
        return "string" == typeof t || "number" == typeof t
          ? e
          : t.type === o.default.Fragment
          ? e.concat(
              o.default.Children.toArray(t.props.children).reduce(
                (e, t) =>
                  "string" == typeof t || "number" == typeof t
                    ? e
                    : e.concat(t),
                []
              )
            )
          : e.concat(t);
      }
      r(94781);
      let p = ["name", "httpEquiv", "charSet", "itemProp"];
      function g(e, t) {
        let { inAmpMode: r } = t;
        return e
          .reduce(f, [])
          .reverse()
          .concat(h(r).reverse())
          .filter(
            (function () {
              let e = new Set(),
                t = new Set(),
                r = new Set(),
                i = {};
              return (s) => {
                let n = !0,
                  a = !1;
                if (
                  s.key &&
                  "number" != typeof s.key &&
                  s.key.indexOf("$") > 0
                ) {
                  a = !0;
                  let t = s.key.slice(s.key.indexOf("$") + 1);
                  e.has(t) ? (n = !1) : e.add(t);
                }
                switch (s.type) {
                  case "title":
                  case "base":
                    t.has(s.type) ? (n = !1) : t.add(s.type);
                    break;
                  case "meta":
                    for (let e = 0, t = p.length; e < t; e++) {
                      let t = p[e];
                      if (s.props.hasOwnProperty(t)) {
                        if ("charSet" === t) r.has(t) ? (n = !1) : r.add(t);
                        else {
                          let e = s.props[t],
                            r = i[t] || new Set();
                          ("name" !== t || !a) && r.has(e)
                            ? (n = !1)
                            : (r.add(e), (i[t] = r));
                        }
                      }
                    }
                }
                return n;
              };
            })()
          )
          .reverse()
          .map((e, t) => {
            let s = e.key || t;
            if (
              i.env.__NEXT_OPTIMIZE_FONTS &&
              !r &&
              "link" === e.type &&
              e.props.href &&
              [
                "https://fonts.googleapis.com/css",
                "https://use.typekit.net/",
              ].some((t) => e.props.href.startsWith(t))
            ) {
              let t = { ...(e.props || {}) };
              return (
                (t["data-href"] = t.href),
                (t.href = void 0),
                (t["data-optimized-fonts"] = !0),
                o.default.cloneElement(e, t)
              );
            }
            return o.default.cloneElement(e, { key: s });
          });
      }
      let m = function (e) {
        let { children: t } = e,
          r = (0, o.useContext)(l.AmpStateContext),
          i = (0, o.useContext)(d.HeadManagerContext);
        return (0, a.jsx)(c.default, {
          reduceComponentsToState: g,
          headManager: i,
          inAmpMode: (0, u.isInAmpMode)(r),
          children: t,
        });
      };
      ("function" == typeof t.default ||
        ("object" == typeof t.default && null !== t.default)) &&
        void 0 === t.default.__esModule &&
        (Object.defineProperty(t.default, "__esModule", { value: !0 }),
        Object.assign(t.default, t),
        (e.exports = t.default));
    },
    75040: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "getImgProps", {
          enumerable: !0,
          get: function () {
            return o;
          },
        }),
        r(94781);
      let i = r(14105),
        s = r(20821);
      function n(e) {
        return void 0 !== e.default;
      }
      function a(e) {
        return void 0 === e
          ? e
          : "number" == typeof e
          ? Number.isFinite(e)
            ? e
            : NaN
          : "string" == typeof e && /^[0-9]+$/.test(e)
          ? parseInt(e, 10)
          : NaN;
      }
      function o(e, t) {
        var r, o;
        let c,
          l,
          d,
          {
            src: u,
            sizes: h,
            unoptimized: f = !1,
            priority: p = !1,
            loading: g,
            className: m,
            quality: b,
            width: y,
            height: w,
            fill: v = !1,
            style: A,
            overrideSrc: E,
            onLoad: _,
            onLoadingComplete: C,
            placeholder: I = "empty",
            blurDataURL: S,
            fetchPriority: x,
            decoding: N = "async",
            layout: T,
            objectFit: P,
            objectPosition: O,
            lazyBoundary: k,
            lazyRoot: R,
            ...D
          } = e,
          { imgConf: M, showAltText: U, blurComplete: L, defaultLoader: B } = t,
          j = M || s.imageConfigDefault;
        if ("allSizes" in j) c = j;
        else {
          let e = [...j.deviceSizes, ...j.imageSizes].sort((e, t) => e - t),
            t = j.deviceSizes.sort((e, t) => e - t),
            i = null == (r = j.qualities) ? void 0 : r.sort((e, t) => e - t);
          c = { ...j, allSizes: e, deviceSizes: t, qualities: i };
        }
        if (void 0 === B)
          throw Object.defineProperty(
            Error(
              "images.loaderFile detected but the file is missing default export.\nRead more: https://nextjs.org/docs/messages/invalid-images-config"
            ),
            "__NEXT_ERROR_CODE",
            { value: "E163", enumerable: !1, configurable: !0 }
          );
        let F = D.loader || B;
        delete D.loader, delete D.srcSet;
        let $ = "__next_img_default" in F;
        if ($) {
          if ("custom" === c.loader)
            throw Object.defineProperty(
              Error(
                'Image with src "' +
                  u +
                  '" is missing "loader" prop.\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader'
              ),
              "__NEXT_ERROR_CODE",
              { value: "E252", enumerable: !1, configurable: !0 }
            );
        } else {
          let e = F;
          F = (t) => {
            let { config: r, ...i } = t;
            return e(i);
          };
        }
        if (T) {
          "fill" === T && (v = !0);
          let e = {
            intrinsic: { maxWidth: "100%", height: "auto" },
            responsive: { width: "100%", height: "auto" },
          }[T];
          e && (A = { ...A, ...e });
          let t = { responsive: "100vw", fill: "100vw" }[T];
          t && !h && (h = t);
        }
        let z = "",
          W = a(y),
          H = a(w);
        if ((o = u) && "object" == typeof o && (n(o) || void 0 !== o.src)) {
          let e = n(u) ? u.default : u;
          if (!e.src)
            throw Object.defineProperty(
              Error(
                "An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received " +
                  JSON.stringify(e)
              ),
              "__NEXT_ERROR_CODE",
              { value: "E460", enumerable: !1, configurable: !0 }
            );
          if (!e.height || !e.width)
            throw Object.defineProperty(
              Error(
                "An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received " +
                  JSON.stringify(e)
              ),
              "__NEXT_ERROR_CODE",
              { value: "E48", enumerable: !1, configurable: !0 }
            );
          if (
            ((l = e.blurWidth),
            (d = e.blurHeight),
            (S = S || e.blurDataURL),
            (z = e.src),
            !v)
          ) {
            if (W || H) {
              if (W && !H) {
                let t = W / e.width;
                H = Math.round(e.height * t);
              } else if (!W && H) {
                let t = H / e.height;
                W = Math.round(e.width * t);
              }
            } else (W = e.width), (H = e.height);
          }
        }
        let q = !p && ("lazy" === g || void 0 === g);
        (!(u = "string" == typeof u ? u : z) ||
          u.startsWith("data:") ||
          u.startsWith("blob:")) &&
          ((f = !0), (q = !1)),
          c.unoptimized && (f = !0),
          $ &&
            !c.dangerouslyAllowSVG &&
            u.split("?", 1)[0].endsWith(".svg") &&
            (f = !0);
        let V = a(b),
          K = Object.assign(
            v
              ? {
                  position: "absolute",
                  height: "100%",
                  width: "100%",
                  left: 0,
                  top: 0,
                  right: 0,
                  bottom: 0,
                  objectFit: P,
                  objectPosition: O,
                }
              : {},
            U ? {} : { color: "transparent" },
            A
          ),
          G =
            L || "empty" === I
              ? null
              : "blur" === I
              ? 'url("data:image/svg+xml;charset=utf-8,' +
                (0, i.getImageBlurSvg)({
                  widthInt: W,
                  heightInt: H,
                  blurWidth: l,
                  blurHeight: d,
                  blurDataURL: S || "",
                  objectFit: K.objectFit,
                }) +
                '")'
              : 'url("' + I + '")',
          Y = G
            ? {
                backgroundSize: K.objectFit || "cover",
                backgroundPosition: K.objectPosition || "50% 50%",
                backgroundRepeat: "no-repeat",
                backgroundImage: G,
              }
            : {},
          Q = (function (e) {
            let {
              config: t,
              src: r,
              unoptimized: i,
              width: s,
              quality: n,
              sizes: a,
              loader: o,
            } = e;
            if (i) return { src: r, srcSet: void 0, sizes: void 0 };
            let { widths: c, kind: l } = (function (e, t, r) {
                let { deviceSizes: i, allSizes: s } = e;
                if (r) {
                  let e = /(^|\s)(1?\d?\d)vw/g,
                    t = [];
                  for (let i; (i = e.exec(r)); i) t.push(parseInt(i[2]));
                  if (t.length) {
                    let e = 0.01 * Math.min(...t);
                    return {
                      widths: s.filter((t) => t >= i[0] * e),
                      kind: "w",
                    };
                  }
                  return { widths: s, kind: "w" };
                }
                return "number" != typeof t
                  ? { widths: i, kind: "w" }
                  : {
                      widths: [
                        ...new Set(
                          [t, 2 * t].map(
                            (e) => s.find((t) => t >= e) || s[s.length - 1]
                          )
                        ),
                      ],
                      kind: "x",
                    };
              })(t, s, a),
              d = c.length - 1;
            return {
              sizes: a || "w" !== l ? a : "100vw",
              srcSet: c
                .map(
                  (e, i) =>
                    o({ config: t, src: r, quality: n, width: e }) +
                    " " +
                    ("w" === l ? e : i + 1) +
                    l
                )
                .join(", "),
              src: o({ config: t, src: r, quality: n, width: c[d] }),
            };
          })({
            config: c,
            src: u,
            unoptimized: f,
            width: W,
            quality: V,
            sizes: h,
            loader: F,
          });
        return {
          props: {
            ...D,
            loading: q ? "lazy" : g,
            fetchPriority: x,
            width: W,
            height: H,
            decoding: N,
            className: m,
            style: { ...K, ...Y },
            sizes: Q.sizes,
            srcSet: Q.srcSet,
            src: E || Q.src,
          },
          meta: { unoptimized: f, priority: p, placeholder: I, fill: v },
        };
      }
    },
    75578: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => n });
      var i = r(45553),
        s = r(30948);
      let n = {
        ConnectorExplorerIds: {
          [i.o.CONNECTOR_ID.COINBASE]:
            "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
          [i.o.CONNECTOR_ID.COINBASE_SDK]:
            "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
          [i.o.CONNECTOR_ID.SAFE]:
            "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
          [i.o.CONNECTOR_ID.LEDGER]:
            "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927",
          [i.o.CONNECTOR_ID.OKX]:
            "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
          [s.o.METMASK_CONNECTOR_NAME]:
            "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
          [s.o.TRUST_CONNECTOR_NAME]:
            "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
          [s.o.SOLFLARE_CONNECTOR_NAME]:
            "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
          [s.o.PHANTOM_CONNECTOR_NAME]:
            "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
          [s.o.COIN98_CONNECTOR_NAME]:
            "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01",
          [s.o.MAGIC_EDEN_CONNECTOR_NAME]:
            "8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6",
          [s.o.BACKPACK_CONNECTOR_NAME]:
            "2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0",
          [s.o.BITGET_CONNECTOR_NAME]:
            "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662",
          [s.o.FRONTIER_CONNECTOR_NAME]:
            "85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041",
          [s.o.XVERSE_CONNECTOR_NAME]:
            "2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b",
          [s.o.LEATHER_CONNECTOR_NAME]:
            "483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13",
        },
        NetworkImageIds: {
          1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
          42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
          43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
          56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
          250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
          10: "ab9c186a-c52f-464b-2906-ca59d760a400",
          137: "41d04d42-da3b-4453-8506-668cc0727900",
          5e3: "e86fae9b-b770-4eea-e520-150e12c81100",
          295: "6a97d510-cac8-4e58-c7ce-e8681b044c00",
          0xaa36a7: "e909ea0a-f92a-4512-c8fc-748044ea6800",
          84532: "a18a7ecd-e307-4360-4746-283182228e00",
          1301: "4eeea7ef-0014-4649-5d1d-07271a80f600",
          130: "2257980a-3463-48c6-cbac-a42d2a956e00",
          10143: "0a728e83-bacb-46db-7844-948f05434900",
          100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
          9001: "f926ff41-260d-4028-635e-91913fc28e00",
          324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
          314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
          4689: "34e68754-e536-40da-c153-6ef2e7188a00",
          1088: "3897a66d-40b9-4833-162f-a2c90531c900",
          1284: "161038da-44ae-4ec7-1208-0ea569454b00",
          1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
          7777777: "845c60df-d429-4991-e687-91ae45791600",
          42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
          8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
          0x4e454152: "3ff73439-a619-4894-9262-4470c773a100",
          2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
          2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
          80094: "e329c2c9-59b0-4a02-83e4-212ff3779900",
          "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp":
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z":
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          EtWTRABZaYq6iMfeYKouRu166VU2xqa1:
            "a1b58899-f671-4276-6a5e-56ca5bd59700",
          "000000000019d6689c085ae165831e93":
            "0b4838db-0161-4ffe-022d-532bf03dba00",
          "000000000933ea01ad0ee984209779ba":
            "39354064-d79b-420b-065d-f980c4b78200",
        },
        ConnectorImageIds: {
          [i.o.CONNECTOR_ID.COINBASE]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
          [i.o.CONNECTOR_ID.COINBASE_SDK]:
            "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
          [i.o.CONNECTOR_ID.SAFE]: "461db637-8616-43ce-035a-d89b8a1d5800",
          [i.o.CONNECTOR_ID.LEDGER]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
          [i.o.CONNECTOR_ID.WALLET_CONNECT]:
            "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
          [i.o.CONNECTOR_ID.INJECTED]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00",
        },
        ConnectorNamesMap: {
          [i.o.CONNECTOR_ID.INJECTED]: "Browser Wallet",
          [i.o.CONNECTOR_ID.WALLET_CONNECT]: "WalletConnect",
          [i.o.CONNECTOR_ID.COINBASE]: "Coinbase",
          [i.o.CONNECTOR_ID.COINBASE_SDK]: "Coinbase",
          [i.o.CONNECTOR_ID.LEDGER]: "Ledger",
          [i.o.CONNECTOR_ID.SAFE]: "Safe",
        },
        ConnectorTypesMap: {
          [i.o.CONNECTOR_ID.INJECTED]: "INJECTED",
          [i.o.CONNECTOR_ID.WALLET_CONNECT]: "WALLET_CONNECT",
          [i.o.CONNECTOR_ID.EIP6963]: "ANNOUNCED",
          [i.o.CONNECTOR_ID.AUTH]: "AUTH",
        },
        WalletConnectRpcChainIds: [
          1, 5, 0xaa36a7, 10, 420, 42161, 421613, 137, 80001, 42220, 0x4e454152,
          0x4e454153, 56, 97, 43114, 43113, 100, 8453, 84531, 7777777, 999, 324,
          280,
        ],
      };
    },
    76115: (e, t, r) => {
      "use strict";
      r.d(t, { M: () => s });
      var i = r(13933);
      class s extends i.C {
        constructor({ address: e }) {
          super(`Address "${e}" is invalid.`, {
            metaMessages: [
              "- Address must be a hex value of 20 bytes (40 hex characters).",
              "- Address must match its checksum counterpart.",
            ],
            name: "InvalidAddressError",
          });
        }
      }
    },
    76190: (e, t, r) => {
      "use strict";
      r.d(t, { L: () => i });
      let i = {
        caipNetworkIdToNumber: (e) => (e ? Number(e.split(":")[1]) : void 0),
        parseEvmChainId(e) {
          return "string" == typeof e ? this.caipNetworkIdToNumber(e) : e;
        },
        getNetworksByNamespace: (e, t) =>
          e?.filter((e) => e.chainNamespace === t) || [],
        getFirstNetworkByNamespace(e, t) {
          return this.getNetworksByNamespace(e, t)[0];
        },
      };
    },
    77608: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => d, o: () => l });
      var i = r(76115),
        s = r(55563),
        n = r(80329),
        a = r(20390),
        o = r(24784);
      let c = new a.A(8192);
      function l(e, t) {
        if (c.has(`${e}.${t}`)) return c.get(`${e}.${t}`);
        let r = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase(),
          i = (0, n.S)((0, s.Af)(r), "bytes"),
          a = (t ? r.substring(`${t}0x`.length) : r).split("");
        for (let e = 0; e < 40; e += 2)
          i[e >> 1] >> 4 >= 8 && a[e] && (a[e] = a[e].toUpperCase()),
            (15 & i[e >> 1]) >= 8 &&
              a[e + 1] &&
              (a[e + 1] = a[e + 1].toUpperCase());
        let o = `0x${a.join("")}`;
        return c.set(`${e}.${t}`, o), o;
      }
      function d(e, t) {
        if (!(0, o.P)(e, { strict: !1 })) throw new i.M({ address: e });
        return l(e, t);
      }
    },
    77931: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { l: () => n7, A: () => n9 });
      var s = r(16459),
        n = r.n(s),
        a = r(5566);
      class o {}
      class c extends o {
        constructor(e) {
          super();
        }
      }
      let l = a.FIVE_SECONDS,
        d = { pulse: "heartbeat_pulse" };
      class u extends c {
        constructor(e) {
          super(e),
            (this.events = new s.EventEmitter()),
            (this.interval = l),
            (this.interval = e?.interval || l);
        }
        static async init(e) {
          let t = new u(e);
          return await t.init(), t;
        }
        async init() {
          await this.initialize();
        }
        stop() {
          clearInterval(this.intervalRef);
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async initialize() {
          this.intervalRef = setInterval(
            () => this.pulse(),
            (0, a.toMiliseconds)(this.interval)
          );
        }
        pulse() {
          this.events.emit(d.pulse);
        }
      }
      let h =
          /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
        f =
          /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
        p = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
      function g(e, t) {
        if (
          "__proto__" === e ||
          ("constructor" === e && t && "object" == typeof t && "prototype" in t)
        ) {
          var r;
          (r = e),
            console.warn(
              `[destr] Dropping "${r}" key to prevent prototype pollution.`
            );
          return;
        }
        return t;
      }
      function m(e, t = {}) {
        if ("string" != typeof e) return e;
        let r = e.trim();
        if ('"' === e[0] && e.endsWith('"') && !e.includes("\\"))
          return r.slice(1, -1);
        if (r.length <= 9) {
          let e = r.toLowerCase();
          if ("true" === e) return !0;
          if ("false" === e) return !1;
          if ("undefined" === e) return;
          if ("null" === e) return null;
          if ("nan" === e) return Number.NaN;
          if ("infinity" === e) return Number.POSITIVE_INFINITY;
          if ("-infinity" === e) return Number.NEGATIVE_INFINITY;
        }
        if (!p.test(e)) {
          if (t.strict) throw SyntaxError("[destr] Invalid JSON");
          return e;
        }
        try {
          if (h.test(e) || f.test(e)) {
            if (t.strict) throw Error("[destr] Possible prototype pollution");
            return JSON.parse(e, g);
          }
          return JSON.parse(e);
        } catch (r) {
          if (t.strict) throw r;
          return e;
        }
      }
      var b = r(81029).Buffer;
      function y(e, ...t) {
        try {
          var r;
          return (r = e(...t)) && "function" == typeof r.then
            ? r
            : Promise.resolve(r);
        } catch (e) {
          return Promise.reject(e);
        }
      }
      function w(e) {
        if (
          (function (e) {
            let t = typeof e;
            return null === e || ("object" !== t && "function" !== t);
          })(e)
        )
          return String(e);
        if (
          (function (e) {
            let t = Object.getPrototypeOf(e);
            return !t || t.isPrototypeOf(Object);
          })(e) ||
          Array.isArray(e)
        )
          return JSON.stringify(e);
        if ("function" == typeof e.toJSON) return w(e.toJSON());
        throw Error("[unstorage] Cannot stringify value!");
      }
      let v = "base64:";
      function A(e) {
        return (
          (e &&
            e
              .split("?")[0]
              ?.replace(/[/\\]/g, ":")
              .replace(/:+/g, ":")
              .replace(/^:|:$/g, "")) ||
          ""
        );
      }
      function E(e) {
        return (e = A(e)) ? e + ":" : "";
      }
      let _ = () => {
        let e = new Map();
        return {
          name: "memory",
          getInstance: () => e,
          hasItem: (t) => e.has(t),
          getItem: (t) => e.get(t) ?? null,
          getItemRaw: (t) => e.get(t) ?? null,
          setItem(t, r) {
            e.set(t, r);
          },
          setItemRaw(t, r) {
            e.set(t, r);
          },
          removeItem(t) {
            e.delete(t);
          },
          getKeys: () => [...e.keys()],
          clear() {
            e.clear();
          },
          dispose() {
            e.clear();
          },
        };
      };
      function C(e, t, r) {
        return e.watch ? e.watch((e, i) => t(e, r + i)) : () => {};
      }
      async function I(e) {
        "function" == typeof e.dispose && (await y(e.dispose));
      }
      function S(e) {
        return new Promise((t, r) => {
          (e.oncomplete = e.onsuccess = () => t(e.result)),
            (e.onabort = e.onerror = () => r(e.error));
        });
      }
      function x(e, t) {
        let r = indexedDB.open(e);
        r.onupgradeneeded = () => r.result.createObjectStore(t);
        let i = S(r);
        return (e, r) => i.then((i) => r(i.transaction(t, e).objectStore(t)));
      }
      function N() {
        return i || (i = x("keyval-store", "keyval")), i;
      }
      function T(e, t = N()) {
        return t("readonly", (t) => S(t.get(e)));
      }
      var P = r(25042),
        O = (e = {}) => {
          let t;
          let r = e.base && e.base.length > 0 ? `${e.base}:` : "",
            i = (e) => r + e;
          return (
            e.dbName && e.storeName && (t = x(e.dbName, e.storeName)),
            {
              name: "idb-keyval",
              options: e,
              hasItem: async (e) => !(typeof (await T(i(e), t)) > "u"),
              getItem: async (e) => (await T(i(e), t)) ?? null,
              setItem: (e, r) =>
                (function (e, t, r = N()) {
                  return r("readwrite", (r) => (r.put(t, e), S(r.transaction)));
                })(i(e), r, t),
              removeItem: (e) =>
                (function (e, t = N()) {
                  return t("readwrite", (t) => (t.delete(e), S(t.transaction)));
                })(i(e), t),
              getKeys: () =>
                (function (e = N()) {
                  return e("readonly", (e) => {
                    var t, r;
                    if (e.getAllKeys) return S(e.getAllKeys());
                    let i = [];
                    return ((t = e),
                    (r = (e) => i.push(e.key)),
                    (t.openCursor().onsuccess = function () {
                      this.result && (r(this.result), this.result.continue());
                    }),
                    S(t.transaction)).then(() => i);
                  });
                })(t),
              clear: () =>
                (function (e = N()) {
                  return e("readwrite", (e) => (e.clear(), S(e.transaction)));
                })(t),
            }
          );
        };
      class k {
        constructor() {
          this.indexedDb = (function (e = {}) {
            let t = {
                mounts: { "": e.driver || _() },
                mountpoints: [""],
                watching: !1,
                watchListeners: [],
                unwatch: {},
              },
              r = (e) => {
                for (let r of t.mountpoints)
                  if (e.startsWith(r))
                    return {
                      base: r,
                      relativeKey: e.slice(r.length),
                      driver: t.mounts[r],
                    };
                return { base: "", relativeKey: e, driver: t.mounts[""] };
              },
              i = (e, r) =>
                t.mountpoints
                  .filter((t) => t.startsWith(e) || (r && e.startsWith(t)))
                  .map((r) => ({
                    relativeBase:
                      e.length > r.length ? e.slice(r.length) : void 0,
                    mountpoint: r,
                    driver: t.mounts[r],
                  })),
              s = (e, r) => {
                if (t.watching)
                  for (let i of ((r = A(r)), t.watchListeners)) i(e, r);
              },
              n = async () => {
                if (!t.watching)
                  for (let e in ((t.watching = !0), t.mounts))
                    t.unwatch[e] = await C(t.mounts[e], s, e);
              },
              a = async () => {
                if (t.watching) {
                  for (let e in t.unwatch) await t.unwatch[e]();
                  (t.unwatch = {}), (t.watching = !1);
                }
              },
              o = (e, t, i) => {
                let s = new Map(),
                  n = (e) => {
                    let t = s.get(e.base);
                    return (
                      t ||
                        ((t = { driver: e.driver, base: e.base, items: [] }),
                        s.set(e.base, t)),
                      t
                    );
                  };
                for (let i of e) {
                  let e = "string" == typeof i,
                    s = A(e ? i : i.key),
                    a = e ? void 0 : i.value,
                    o = e || !i.options ? t : { ...t, ...i.options },
                    c = r(s);
                  n(c).items.push({
                    key: s,
                    value: a,
                    relativeKey: c.relativeKey,
                    options: o,
                  });
                }
                return Promise.all([...s.values()].map((e) => i(e))).then((e) =>
                  e.flat()
                );
              },
              c = {
                hasItem(e, t = {}) {
                  let { relativeKey: i, driver: s } = r((e = A(e)));
                  return y(s.hasItem, i, t);
                },
                getItem(e, t = {}) {
                  let { relativeKey: i, driver: s } = r((e = A(e)));
                  return y(s.getItem, i, t).then((e) => m(e));
                },
                getItems: (e, t = {}) =>
                  o(e, t, (e) =>
                    e.driver.getItems
                      ? y(
                          e.driver.getItems,
                          e.items.map((e) => ({
                            key: e.relativeKey,
                            options: e.options,
                          })),
                          t
                        ).then((t) =>
                          t.map((t) => ({
                            key: (function (...e) {
                              return A(e.join(":"));
                            })(e.base, t.key),
                            value: m(t.value),
                          }))
                        )
                      : Promise.all(
                          e.items.map((t) =>
                            y(e.driver.getItem, t.relativeKey, t.options).then(
                              (e) => ({ key: t.key, value: m(e) })
                            )
                          )
                        )
                  ),
                getItemRaw(e, t = {}) {
                  let { relativeKey: i, driver: s } = r((e = A(e)));
                  return s.getItemRaw
                    ? y(s.getItemRaw, i, t)
                    : y(s.getItem, i, t).then((e) => {
                        var t;
                        return "string" == typeof e && e.startsWith(v)
                          ? ((t = e.slice(v.length)),
                            globalThis.Buffer
                              ? b.from(t, "base64")
                              : Uint8Array.from(globalThis.atob(t), (e) =>
                                  e.codePointAt(0)
                                ))
                          : e;
                      });
                },
                async setItem(e, t, i = {}) {
                  if (void 0 === t) return c.removeItem(e);
                  let { relativeKey: n, driver: a } = r((e = A(e)));
                  a.setItem &&
                    (await y(a.setItem, n, w(t), i), a.watch || s("update", e));
                },
                async setItems(e, t) {
                  await o(e, t, async (e) => {
                    if (e.driver.setItems)
                      return y(
                        e.driver.setItems,
                        e.items.map((e) => ({
                          key: e.relativeKey,
                          value: w(e.value),
                          options: e.options,
                        })),
                        t
                      );
                    e.driver.setItem &&
                      (await Promise.all(
                        e.items.map((t) =>
                          y(
                            e.driver.setItem,
                            t.relativeKey,
                            w(t.value),
                            t.options
                          )
                        )
                      ));
                  });
                },
                async setItemRaw(e, t, i = {}) {
                  if (void 0 === t) return c.removeItem(e, i);
                  let { relativeKey: n, driver: a } = r((e = A(e)));
                  if (a.setItemRaw) await y(a.setItemRaw, n, t, i);
                  else {
                    var o;
                    if (!a.setItem) return;
                    await y(
                      a.setItem,
                      n,
                      "string" == typeof t
                        ? t
                        : v +
                            ((o = t),
                            globalThis.Buffer
                              ? b.from(o).toString("base64")
                              : globalThis.btoa(String.fromCodePoint(...o))),
                      i
                    );
                  }
                  a.watch || s("update", e);
                },
                async removeItem(e, t = {}) {
                  "boolean" == typeof t && (t = { removeMeta: t });
                  let { relativeKey: i, driver: n } = r((e = A(e)));
                  n.removeItem &&
                    (await y(n.removeItem, i, t),
                    (t.removeMeta || t.removeMata) &&
                      (await y(n.removeItem, i + "$", t)),
                    n.watch || s("remove", e));
                },
                async getMeta(e, t = {}) {
                  "boolean" == typeof t && (t = { nativeOnly: t });
                  let { relativeKey: i, driver: s } = r((e = A(e))),
                    n = Object.create(null);
                  if (
                    (s.getMeta && Object.assign(n, await y(s.getMeta, i, t)),
                    !t.nativeOnly)
                  ) {
                    let e = await y(s.getItem, i + "$", t).then((e) => m(e));
                    e &&
                      "object" == typeof e &&
                      ("string" == typeof e.atime &&
                        (e.atime = new Date(e.atime)),
                      "string" == typeof e.mtime &&
                        (e.mtime = new Date(e.mtime)),
                      Object.assign(n, e));
                  }
                  return n;
                },
                setMeta(e, t, r = {}) {
                  return this.setItem(e + "$", t, r);
                },
                removeMeta(e, t = {}) {
                  return this.removeItem(e + "$", t);
                },
                async getKeys(e, t = {}) {
                  let r = i((e = E(e)), !0),
                    s = [],
                    n = [],
                    a = !0;
                  for (let e of r) {
                    for (let r of (e.driver.flags?.maxDepth || (a = !1),
                    await y(e.driver.getKeys, e.relativeBase, t))) {
                      let t = e.mountpoint + A(r);
                      s.some((e) => t.startsWith(e)) || n.push(t);
                    }
                    s = [
                      e.mountpoint,
                      ...s.filter((t) => !t.startsWith(e.mountpoint)),
                    ];
                  }
                  let o = void 0 !== t.maxDepth && !a;
                  return n.filter((r) => {
                    var i;
                    return (
                      (!o ||
                        (function (e, t) {
                          if (void 0 === t) return !0;
                          let r = 0,
                            i = e.indexOf(":");
                          for (; i > -1; ) r++, (i = e.indexOf(":", i + 1));
                          return r <= t;
                        })(r, t.maxDepth)) &&
                      ((i = e)
                        ? r.startsWith(i) && "$" !== r[r.length - 1]
                        : "$" !== r[r.length - 1])
                    );
                  });
                },
                async clear(e, t = {}) {
                  (e = E(e)),
                    await Promise.all(
                      i(e, !1).map(async (e) =>
                        e.driver.clear
                          ? y(e.driver.clear, e.relativeBase, t)
                          : e.driver.removeItem
                          ? Promise.all(
                              (
                                await e.driver.getKeys(e.relativeBase || "", t)
                              ).map((r) => e.driver.removeItem(r, t))
                            )
                          : void 0
                      )
                    );
                },
                async dispose() {
                  await Promise.all(Object.values(t.mounts).map((e) => I(e)));
                },
                watch: async (e) => (
                  await n(),
                  t.watchListeners.push(e),
                  async () => {
                    (t.watchListeners = t.watchListeners.filter(
                      (t) => t !== e
                    )),
                      0 === t.watchListeners.length && (await a());
                  }
                ),
                async unwatch() {
                  (t.watchListeners = []), await a();
                },
                mount(e, r) {
                  if ((e = E(e)) && t.mounts[e])
                    throw Error(`already mounted at ${e}`);
                  return (
                    e &&
                      (t.mountpoints.push(e),
                      t.mountpoints.sort((e, t) => t.length - e.length)),
                    (t.mounts[e] = r),
                    t.watching &&
                      Promise.resolve(C(r, s, e))
                        .then((r) => {
                          t.unwatch[e] = r;
                        })
                        .catch(console.error),
                    c
                  );
                },
                async unmount(e, r = !0) {
                  (e = E(e)) &&
                    t.mounts[e] &&
                    (t.watching &&
                      e in t.unwatch &&
                      (t.unwatch[e]?.(), delete t.unwatch[e]),
                    r && (await I(t.mounts[e])),
                    (t.mountpoints = t.mountpoints.filter((t) => t !== e)),
                    delete t.mounts[e]);
                },
                getMount(e = "") {
                  let t = r((e = A(e) + ":"));
                  return { driver: t.driver, base: t.base };
                },
                getMounts: (e = "", t = {}) =>
                  i((e = A(e)), t.parents).map((e) => ({
                    driver: e.driver,
                    base: e.mountpoint,
                  })),
                keys: (e, t = {}) => c.getKeys(e, t),
                get: (e, t = {}) => c.getItem(e, t),
                set: (e, t, r = {}) => c.setItem(e, t, r),
                has: (e, t = {}) => c.hasItem(e, t),
                del: (e, t = {}) => c.removeItem(e, t),
                remove: (e, t = {}) => c.removeItem(e, t),
              };
            return c;
          })({
            driver: O({
              dbName: "WALLET_CONNECT_V2_INDEXED_DB",
              storeName: "keyvaluestorage",
            }),
          });
        }
        async getKeys() {
          return this.indexedDb.getKeys();
        }
        async getEntries() {
          return (
            await this.indexedDb.getItems(await this.indexedDb.getKeys())
          ).map((e) => [e.key, e.value]);
        }
        async getItem(e) {
          let t = await this.indexedDb.getItem(e);
          if (null !== t) return t;
        }
        async setItem(e, t) {
          await this.indexedDb.setItem(e, (0, P.h)(t));
        }
        async removeItem(e) {
          await this.indexedDb.removeItem(e);
        }
      }
      var R =
          "u" > typeof globalThis
            ? globalThis
            : "u" > typeof window
            ? window
            : "u" > typeof r.g
            ? r.g
            : "u" > typeof self
            ? self
            : {},
        D = { exports: {} };
      function M(e) {
        var t;
        return [e[0], (0, P.j)(null != (t = e[1]) ? t : "")];
      }
      !(function () {
        function e() {}
        (e.prototype.getItem = function (e) {
          return this.hasOwnProperty(e) ? String(this[e]) : null;
        }),
          (e.prototype.setItem = function (e, t) {
            this[e] = String(t);
          }),
          (e.prototype.removeItem = function (e) {
            delete this[e];
          }),
          (e.prototype.clear = function () {
            let e = this;
            Object.keys(e).forEach(function (t) {
              (e[t] = void 0), delete e[t];
            });
          }),
          (e.prototype.key = function (e) {
            return (e = e || 0), Object.keys(this)[e];
          }),
          e.prototype.__defineGetter__("length", function () {
            return Object.keys(this).length;
          }),
          "u" > typeof R && R.localStorage
            ? (D.exports = R.localStorage)
            : "u" > typeof window && window.localStorage
            ? (D.exports = window.localStorage)
            : (D.exports = new e());
      })();
      class U {
        constructor() {
          this.localStorage = D.exports;
        }
        async getKeys() {
          return Object.keys(this.localStorage);
        }
        async getEntries() {
          return Object.entries(this.localStorage).map(M);
        }
        async getItem(e) {
          let t = this.localStorage.getItem(e);
          if (null !== t) return (0, P.j)(t);
        }
        async setItem(e, t) {
          this.localStorage.setItem(e, (0, P.h)(t));
        }
        async removeItem(e) {
          this.localStorage.removeItem(e);
        }
      }
      let L = async (e, t, r) => {
          let i = "wc_storage_version",
            s = await t.getItem(i);
          if (s && s >= 1) {
            r(t);
            return;
          }
          let n = await e.getKeys();
          if (!n.length) {
            r(t);
            return;
          }
          let a = [];
          for (; n.length; ) {
            let r = n.shift();
            if (!r) continue;
            let i = r.toLowerCase();
            if (
              i.includes("wc@") ||
              i.includes("walletconnect") ||
              i.includes("wc_") ||
              i.includes("wallet_connect")
            ) {
              let i = await e.getItem(r);
              await t.setItem(r, i), a.push(r);
            }
          }
          await t.setItem(i, 1), r(t), B(e, a);
        },
        B = async (e, t) => {
          t.length &&
            t.forEach(async (t) => {
              await e.removeItem(t);
            });
        };
      class j {
        constructor() {
          (this.initialized = !1),
            (this.setInitialized = (e) => {
              (this.storage = e), (this.initialized = !0);
            });
          let e = new U();
          this.storage = e;
          try {
            let t = new k();
            L(e, t, this.setInitialized);
          } catch {
            this.initialized = !0;
          }
        }
        async getKeys() {
          return await this.initialize(), this.storage.getKeys();
        }
        async getEntries() {
          return await this.initialize(), this.storage.getEntries();
        }
        async getItem(e) {
          return await this.initialize(), this.storage.getItem(e);
        }
        async setItem(e, t) {
          return await this.initialize(), this.storage.setItem(e, t);
        }
        async removeItem(e) {
          return await this.initialize(), this.storage.removeItem(e);
        }
        async initialize() {
          this.initialized ||
            (await new Promise((e) => {
              let t = setInterval(() => {
                this.initialized && (clearInterval(t), e());
              }, 20);
            }));
        }
      }
      var F = r(71018),
        $ = Object.defineProperty,
        z = (e, t, r) =>
          t in e
            ? $(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        W = (e, t, r) => z(e, "symbol" != typeof t ? t + "" : t, r);
      class H extends o {
        constructor(e) {
          super(),
            (this.opts = e),
            W(this, "protocol", "wc"),
            W(this, "version", 2);
        }
      }
      var q = Object.defineProperty,
        V = (e, t, r) =>
          t in e
            ? q(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        K = (e, t, r) => V(e, "symbol" != typeof t ? t + "" : t, r);
      class G extends o {
        constructor(e, t) {
          super(),
            (this.core = e),
            (this.logger = t),
            K(this, "records", new Map());
        }
      }
      class Y {
        constructor(e, t) {
          (this.logger = e), (this.core = t);
        }
      }
      class Q extends o {
        constructor(e, t) {
          super(), (this.relayer = e), (this.logger = t);
        }
      }
      class Z extends o {
        constructor(e) {
          super();
        }
      }
      class J {
        constructor(e, t, r, i) {
          (this.core = e), (this.logger = t), (this.name = r);
        }
      }
      var X = Object.defineProperty;
      class ee extends o {
        constructor(e, t) {
          super(), (this.relayer = e), (this.logger = t);
        }
      }
      class et extends o {
        constructor(e, t) {
          super(), (this.core = e), (this.logger = t);
        }
      }
      class er {
        constructor(e, t, r) {
          (this.core = e), (this.logger = t), (this.store = r);
        }
      }
      class ei {
        constructor(e, t) {
          (this.projectId = e), (this.logger = t);
        }
      }
      class es {
        constructor(e, t, r) {
          (this.core = e), (this.logger = t), (this.telemetryEnabled = r);
        }
      }
      var en = Object.defineProperty,
        ea = (e, t, r) =>
          t in e
            ? en(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        eo = (e, t, r) => ea(e, "symbol" != typeof t ? t + "" : t, r);
      n();
      class ec {
        constructor(e) {
          (this.opts = e), eo(this, "protocol", "wc"), eo(this, "version", 2);
        }
      }
      s.EventEmitter;
      class el {
        constructor(e) {
          this.client = e;
        }
      }
      var ed = r(20852),
        eu = r(49068),
        eh = r(58222);
      let ef = "INTERNAL_ERROR",
        ep = "SERVER_ERROR",
        eg = [-32700, -32600, -32601, -32602, -32603],
        em = {
          PARSE_ERROR: { code: -32700, message: "Parse error" },
          INVALID_REQUEST: { code: -32600, message: "Invalid Request" },
          METHOD_NOT_FOUND: { code: -32601, message: "Method not found" },
          INVALID_PARAMS: { code: -32602, message: "Invalid params" },
          [ef]: { code: -32603, message: "Internal error" },
          [ep]: { code: -32e3, message: "Server error" },
        };
      function eb(e) {
        return Object.keys(em).includes(e) ? em[e] : em[ep];
      }
      function ey(e, t, r) {
        return e.message.includes("getaddrinfo ENOTFOUND") ||
          e.message.includes("connect ECONNREFUSED")
          ? Error(`Unavailable ${r} RPC url at ${t}`)
          : e;
      }
      var ew = r(87822);
      function ev(e = 3) {
        return (
          Date.now() * Math.pow(10, e) +
          Math.floor(Math.random() * Math.pow(10, e))
        );
      }
      function eA(e = 6) {
        return BigInt(ev(e));
      }
      function eE(e, t, r) {
        return { id: r || ev(), jsonrpc: "2.0", method: e, params: t };
      }
      function e_(e, t) {
        return { id: e, jsonrpc: "2.0", result: t };
      }
      function eC(e, t, r) {
        var i, s, n;
        return {
          id: e,
          jsonrpc: "2.0",
          error:
            ((i = t),
            (s = r),
            void 0 === i
              ? eb(ef)
              : ("string" == typeof i &&
                  (i = Object.assign(Object.assign({}, eb(ep)), {
                    message: i,
                  })),
                void 0 !== s && (i.data = s),
                (n = i.code),
                eg.includes(n) &&
                  (i = (function (e) {
                    let t = Object.values(em).find((t) => t.code === e);
                    return t || em[ep];
                  })(i.code)),
                i)),
        };
      }
      class eI {}
      class eS extends eI {
        constructor() {
          super();
        }
      }
      class ex extends eS {
        constructor(e) {
          super();
        }
      }
      function eN(e, t) {
        let r = (function (e) {
          let t = e.match(RegExp(/^\w+:/, "gi"));
          if (t && t.length) return t[0];
        })(e);
        return void 0 !== r && new RegExp(t).test(r);
      }
      function eT(e) {
        return eN(e, "^https?:");
      }
      function eP(e) {
        return eN(e, "^wss?:");
      }
      function eO(e) {
        return (
          "object" == typeof e &&
          "id" in e &&
          "jsonrpc" in e &&
          "2.0" === e.jsonrpc
        );
      }
      function ek(e) {
        return eO(e) && "method" in e;
      }
      function eR(e) {
        return eO(e) && (eD(e) || eM(e));
      }
      function eD(e) {
        return "result" in e;
      }
      function eM(e) {
        return "error" in e;
      }
      class eU extends ex {
        constructor(e) {
          super(e),
            (this.events = new s.EventEmitter()),
            (this.hasRegisteredEventListeners = !1),
            (this.connection = this.setConnection(e)),
            this.connection.connected && this.registerEventListeners();
        }
        async connect(e = this.connection) {
          await this.open(e);
        }
        async disconnect() {
          await this.close();
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async request(e, t) {
          return this.requestStrict(
            eE(e.method, e.params || [], e.id || eA().toString()),
            t
          );
        }
        async requestStrict(e, t) {
          return new Promise(async (r, i) => {
            if (!this.connection.connected)
              try {
                await this.open();
              } catch (e) {
                i(e);
              }
            this.events.on(`${e.id}`, (e) => {
              eM(e) ? i(e.error) : r(e.result);
            });
            try {
              await this.connection.send(e, t);
            } catch (e) {
              i(e);
            }
          });
        }
        setConnection(e = this.connection) {
          return e;
        }
        onPayload(e) {
          this.events.emit("payload", e),
            eR(e)
              ? this.events.emit(`${e.id}`, e)
              : this.events.emit("message", { type: e.method, data: e.params });
        }
        onClose(e) {
          e &&
            3e3 === e.code &&
            this.events.emit(
              "error",
              Error(
                `WebSocket connection closed abnormally with code: ${e.code} ${
                  e.reason ? `(${e.reason})` : ""
                }`
              )
            ),
            this.events.emit("disconnect");
        }
        async open(e = this.connection) {
          (this.connection === e && this.connection.connected) ||
            (this.connection.connected && this.close(),
            "string" == typeof e &&
              (await this.connection.open(e), (e = this.connection)),
            (this.connection = this.setConnection(e)),
            await this.connection.open(),
            this.registerEventListeners(),
            this.events.emit("connect"));
        }
        async close() {
          await this.connection.close();
        }
        registerEventListeners() {
          this.hasRegisteredEventListeners ||
            (this.connection.on("payload", (e) => this.onPayload(e)),
            this.connection.on("close", (e) => this.onClose(e)),
            this.connection.on("error", (e) => this.events.emit("error", e)),
            this.connection.on("register_error", (e) => this.onClose()),
            (this.hasRegisteredEventListeners = !0));
        }
      }
      let eL = () =>
          "u" > typeof WebSocket ||
          ("u" > typeof r.g && "u" > typeof r.g.WebSocket) ||
          ("u" > typeof window && "u" > typeof window.WebSocket) ||
          ("u" > typeof self && "u" > typeof self.WebSocket),
        eB = (e) => e.split("?")[0],
        ej =
          "u" > typeof WebSocket
            ? WebSocket
            : "u" > typeof r.g && "u" > typeof r.g.WebSocket
            ? r.g.WebSocket
            : "u" > typeof window && "u" > typeof window.WebSocket
            ? window.WebSocket
            : "u" > typeof self && "u" > typeof self.WebSocket
            ? self.WebSocket
            : r(55762);
      class eF {
        constructor(e) {
          if (
            ((this.url = e),
            (this.events = new s.EventEmitter()),
            (this.registering = !1),
            !eP(e))
          )
            throw Error(
              `Provided URL is not compatible with WebSocket connection: ${e}`
            );
          this.url = e;
        }
        get connected() {
          return "u" > typeof this.socket;
        }
        get connecting() {
          return this.registering;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async open(e = this.url) {
          await this.register(e);
        }
        async close() {
          return new Promise((e, t) => {
            if (typeof this.socket > "u") {
              t(Error("Connection already closed"));
              return;
            }
            (this.socket.onclose = (t) => {
              this.onClose(t), e();
            }),
              this.socket.close();
          });
        }
        async send(e) {
          typeof this.socket > "u" && (this.socket = await this.register());
          try {
            this.socket.send((0, P.h)(e));
          } catch (t) {
            this.onError(e.id, t);
          }
        }
        register(e = this.url) {
          if (!eP(e))
            throw Error(
              `Provided URL is not compatible with WebSocket connection: ${e}`
            );
          if (this.registering) {
            let e = this.events.getMaxListeners();
            return (
              (this.events.listenerCount("register_error") >= e ||
                this.events.listenerCount("open") >= e) &&
                this.events.setMaxListeners(e + 1),
              new Promise((e, t) => {
                this.events.once("register_error", (e) => {
                  this.resetMaxListeners(), t(e);
                }),
                  this.events.once("open", () => {
                    if ((this.resetMaxListeners(), typeof this.socket > "u"))
                      return t(
                        Error("WebSocket connection is missing or invalid")
                      );
                    e(this.socket);
                  });
              })
            );
          }
          return (
            (this.url = e),
            (this.registering = !0),
            new Promise((t, r) => {
              let i = (0, ew.isReactNative)()
                  ? void 0
                  : {
                      rejectUnauthorized: !RegExp(
                        "wss?://localhost(:d{2,5})?"
                      ).test(e),
                    },
                s = new ej(e, [], i);
              eL()
                ? (s.onerror = (e) => {
                    r(this.emitError(e.error));
                  })
                : s.on("error", (e) => {
                    r(this.emitError(e));
                  }),
                (s.onopen = () => {
                  this.onOpen(s), t(s);
                });
            })
          );
        }
        onOpen(e) {
          (e.onmessage = (e) => this.onPayload(e)),
            (e.onclose = (e) => this.onClose(e)),
            (this.socket = e),
            (this.registering = !1),
            this.events.emit("open");
        }
        onClose(e) {
          (this.socket = void 0),
            (this.registering = !1),
            this.events.emit("close", e);
        }
        onPayload(e) {
          if (typeof e.data > "u") return;
          let t = "string" == typeof e.data ? (0, P.j)(e.data) : e.data;
          this.events.emit("payload", t);
        }
        onError(e, t) {
          let r = this.parseError(t),
            i = eC(e, r.message || r.toString());
          this.events.emit("payload", i);
        }
        parseError(e, t = this.url) {
          return ey(e, eB(t), "WS");
        }
        resetMaxListeners() {
          this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10);
        }
        emitError(e) {
          let t = this.parseError(
            Error(
              e?.message ||
                `WebSocket connection failed for host: ${eB(this.url)}`
            )
          );
          return this.events.emit("register_error", t), t;
        }
      }
      var e$ = r(26662),
        ez = r(81029).Buffer;
      let eW = "core",
        eH = `wc@2:${eW}:`,
        eq = { logger: "error" },
        eV = { database: ":memory:" },
        eK = "client_ed25519_seed",
        eG = a.ONE_DAY,
        eY = a.SIX_HOURS,
        eQ = "wss://relay.walletconnect.org",
        eZ = {
          message: "relayer_message",
          message_ack: "relayer_message_ack",
          connect: "relayer_connect",
          disconnect: "relayer_disconnect",
          error: "relayer_error",
          connection_stalled: "relayer_connection_stalled",
          publish: "relayer_publish",
        },
        eJ = {
          payload: "payload",
          connect: "connect",
          disconnect: "disconnect",
          error: "error",
        },
        eX = "2.19.1",
        e0 = { link_mode: "link_mode", relay: "relay" },
        e1 = { inbound: "inbound", outbound: "outbound" },
        e2 = "WALLETCONNECT_LINK_MODE_APPS",
        e3 = {
          created: "subscription_created",
          deleted: "subscription_deleted",
          sync: "subscription_sync",
          resubscribed: "subscription_resubscribed",
        },
        e5 =
          (a.FIVE_SECONDS,
          {
            wc_pairingDelete: {
              req: { ttl: a.ONE_DAY, prompt: !1, tag: 1e3 },
              res: { ttl: a.ONE_DAY, prompt: !1, tag: 1001 },
            },
            wc_pairingPing: {
              req: { ttl: a.THIRTY_SECONDS, prompt: !1, tag: 1002 },
              res: { ttl: a.THIRTY_SECONDS, prompt: !1, tag: 1003 },
            },
            unregistered_method: {
              req: { ttl: a.ONE_DAY, prompt: !1, tag: 0 },
              res: { ttl: a.ONE_DAY, prompt: !1, tag: 0 },
            },
          }),
        e8 = {
          create: "pairing_create",
          expire: "pairing_expire",
          delete: "pairing_delete",
          ping: "pairing_ping",
        },
        e6 = {
          created: "history_created",
          updated: "history_updated",
          deleted: "history_deleted",
          sync: "history_sync",
        },
        e4 = {
          created: "expirer_created",
          deleted: "expirer_deleted",
          expired: "expirer_expired",
          sync: "expirer_sync",
        },
        e9 = "https://verify.walletconnect.org",
        e7 = `${e9}/v3`,
        te = ["https://verify.walletconnect.com", e9],
        tt = {
          pairing_started: "pairing_started",
          pairing_uri_validation_success: "pairing_uri_validation_success",
          pairing_uri_not_expired: "pairing_uri_not_expired",
          store_new_pairing: "store_new_pairing",
          subscribing_pairing_topic: "subscribing_pairing_topic",
          subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
          existing_pairing: "existing_pairing",
          pairing_not_expired: "pairing_not_expired",
          emit_inactive_pairing: "emit_inactive_pairing",
          emit_session_proposal: "emit_session_proposal",
        },
        tr = {
          no_internet_connection: "no_internet_connection",
          malformed_pairing_uri: "malformed_pairing_uri",
          active_pairing_already_exists: "active_pairing_already_exists",
          subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
          pairing_expired: "pairing_expired",
          proposal_listener_not_found: "proposal_listener_not_found",
        },
        ti = {
          session_approve_started: "session_approve_started",
          session_namespaces_validation_success:
            "session_namespaces_validation_success",
          subscribing_session_topic: "subscribing_session_topic",
          subscribe_session_topic_success: "subscribe_session_topic_success",
          publishing_session_approve: "publishing_session_approve",
          session_approve_publish_success: "session_approve_publish_success",
          store_session: "store_session",
          publishing_session_settle: "publishing_session_settle",
          session_settle_publish_success: "session_settle_publish_success",
        },
        ts = {
          no_internet_connection: "no_internet_connection",
          proposal_expired: "proposal_expired",
          subscribe_session_topic_failure: "subscribe_session_topic_failure",
          session_approve_publish_failure: "session_approve_publish_failure",
          session_settle_publish_failure: "session_settle_publish_failure",
          session_approve_namespace_validation_failure:
            "session_approve_namespace_validation_failure",
          proposal_not_found: "proposal_not_found",
        },
        tn = {
          authenticated_session_approve_started:
            "authenticated_session_approve_started",
          create_authenticated_session_topic:
            "create_authenticated_session_topic",
          cacaos_verified: "cacaos_verified",
          store_authenticated_session: "store_authenticated_session",
          subscribing_authenticated_session_topic:
            "subscribing_authenticated_session_topic",
          subscribe_authenticated_session_topic_success:
            "subscribe_authenticated_session_topic_success",
          publishing_authenticated_session_approve:
            "publishing_authenticated_session_approve",
        },
        ta = {
          no_internet_connection: "no_internet_connection",
          invalid_cacao: "invalid_cacao",
          subscribe_authenticated_session_topic_failure:
            "subscribe_authenticated_session_topic_failure",
          authenticated_session_approve_publish_failure:
            "authenticated_session_approve_publish_failure",
          authenticated_session_pending_request_not_found:
            "authenticated_session_pending_request_not_found",
        };
      var to = function (e, t) {
        if (e.length >= 255) throw TypeError("Alphabet too long");
        for (var r = new Uint8Array(256), i = 0; i < r.length; i++) r[i] = 255;
        for (var s = 0; s < e.length; s++) {
          var n = e.charAt(s),
            a = n.charCodeAt(0);
          if (255 !== r[a]) throw TypeError(n + " is ambiguous");
          r[a] = s;
        }
        var o = e.length,
          c = e.charAt(0),
          l = Math.log(o) / Math.log(256),
          d = Math.log(256) / Math.log(o);
        function u(e) {
          if ("string" != typeof e) throw TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[0]) {
            for (var i = 0, s = 0; e[t] === c; ) i++, t++;
            for (
              var n = ((e.length - t) * l + 1) >>> 0, a = new Uint8Array(n);
              e[t];

            ) {
              var d = r[e.charCodeAt(t)];
              if (255 === d) return;
              for (
                var u = 0, h = n - 1;
                (0 !== d || u < s) && -1 !== h;
                h--, u++
              )
                (d += (o * a[h]) >>> 0),
                  (a[h] = d % 256 >>> 0),
                  (d = (d / 256) >>> 0);
              if (0 !== d) throw Error("Non-zero carry");
              (s = u), t++;
            }
            if (" " !== e[t]) {
              for (var f = n - s; f !== n && 0 === a[f]; ) f++;
              for (var p = new Uint8Array(i + (n - f)), g = i; f !== n; )
                p[g++] = a[f++];
              return p;
            }
          }
        }
        return {
          encode: function (t) {
            if (
              (t instanceof Uint8Array ||
                (ArrayBuffer.isView(t)
                  ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                  : Array.isArray(t) && (t = Uint8Array.from(t))),
              !(t instanceof Uint8Array))
            )
              throw TypeError("Expected Uint8Array");
            if (0 === t.length) return "";
            for (var r = 0, i = 0, s = 0, n = t.length; s !== n && 0 === t[s]; )
              s++, r++;
            for (
              var a = ((n - s) * d + 1) >>> 0, l = new Uint8Array(a);
              s !== n;

            ) {
              for (
                var u = t[s], h = 0, f = a - 1;
                (0 !== u || h < i) && -1 !== f;
                f--, h++
              )
                (u += (256 * l[f]) >>> 0),
                  (l[f] = u % o >>> 0),
                  (u = (u / o) >>> 0);
              if (0 !== u) throw Error("Non-zero carry");
              (i = h), s++;
            }
            for (var p = a - i; p !== a && 0 === l[p]; ) p++;
            for (var g = c.repeat(r); p < a; ++p) g += e.charAt(l[p]);
            return g;
          },
          decodeUnsafe: u,
          decode: function (e) {
            var r = u(e);
            if (r) return r;
            throw Error(`Non-${t} character`);
          },
        };
      };
      let tc = (e) => {
          if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
            return e;
          if (e instanceof ArrayBuffer) return new Uint8Array(e);
          if (ArrayBuffer.isView(e))
            return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
          throw Error("Unknown type, must be binary type");
        },
        tl = (e) => new TextEncoder().encode(e),
        td = (e) => new TextDecoder().decode(e);
      class tu {
        constructor(e, t, r) {
          (this.name = e), (this.prefix = t), (this.baseEncode = r);
        }
        encode(e) {
          if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class th {
        constructor(e, t, r) {
          if (((this.name = e), (this.prefix = t), void 0 === t.codePointAt(0)))
            throw Error("Invalid prefix character");
          (this.prefixCodePoint = t.codePointAt(0)), (this.baseDecode = r);
        }
        decode(e) {
          if ("string" == typeof e) {
            if (e.codePointAt(0) !== this.prefixCodePoint)
              throw Error(
                `Unable to decode multibase string ${JSON.stringify(e)}, ${
                  this.name
                } decoder only supports inputs prefixed with ${this.prefix}`
              );
            return this.baseDecode(e.slice(this.prefix.length));
          }
          throw Error("Can only multibase decode strings");
        }
        or(e) {
          return tp(this, e);
        }
      }
      class tf {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          return tp(this, e);
        }
        decode(e) {
          let t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(
              e
            )}, only inputs prefixed with ${Object.keys(
              this.decoders
            )} are supported`
          );
        }
      }
      let tp = (e, t) =>
        new tf({
          ...(e.decoders || { [e.prefix]: e }),
          ...(t.decoders || { [t.prefix]: t }),
        });
      class tg {
        constructor(e, t, r, i) {
          (this.name = e),
            (this.prefix = t),
            (this.baseEncode = r),
            (this.baseDecode = i),
            (this.encoder = new tu(e, t, r)),
            (this.decoder = new th(e, t, i));
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      let tm = ({ name: e, prefix: t, encode: r, decode: i }) =>
          new tg(e, t, r, i),
        tb = ({ prefix: e, name: t, alphabet: r }) => {
          let { encode: i, decode: s } = to(r, t);
          return tm({ prefix: e, name: t, encode: i, decode: (e) => tc(s(e)) });
        },
        ty = (e, t, r, i) => {
          let s = {};
          for (let e = 0; e < t.length; ++e) s[t[e]] = e;
          let n = e.length;
          for (; "=" === e[n - 1]; ) --n;
          let a = new Uint8Array(((n * r) / 8) | 0),
            o = 0,
            c = 0,
            l = 0;
          for (let t = 0; t < n; ++t) {
            let n = s[e[t]];
            if (void 0 === n) throw SyntaxError(`Non-${i} character`);
            (c = (c << r) | n),
              (o += r) >= 8 && ((o -= 8), (a[l++] = 255 & (c >> o)));
          }
          if (o >= r || 255 & (c << (8 - o)))
            throw SyntaxError("Unexpected end of data");
          return a;
        },
        tw = (e, t, r) => {
          let i = "=" === t[t.length - 1],
            s = (1 << r) - 1,
            n = "",
            a = 0,
            o = 0;
          for (let i = 0; i < e.length; ++i)
            for (o = (o << 8) | e[i], a += 8; a > r; )
              (a -= r), (n += t[s & (o >> a)]);
          if ((a && (n += t[s & (o << (r - a))]), i))
            for (; (n.length * r) & 7; ) n += "=";
          return n;
        },
        tv = ({ name: e, prefix: t, bitsPerChar: r, alphabet: i }) =>
          tm({
            prefix: t,
            name: e,
            encode: (e) => tw(e, i, r),
            decode: (t) => ty(t, i, r, e),
          });
      var tA = Object.freeze({
          __proto__: null,
          identity: tm({
            prefix: "\0",
            name: "identity",
            encode: (e) => td(e),
            decode: (e) => tl(e),
          }),
        }),
        tE = Object.freeze({
          __proto__: null,
          base2: tv({
            prefix: "0",
            name: "base2",
            alphabet: "01",
            bitsPerChar: 1,
          }),
        }),
        t_ = Object.freeze({
          __proto__: null,
          base8: tv({
            prefix: "7",
            name: "base8",
            alphabet: "01234567",
            bitsPerChar: 3,
          }),
        }),
        tC = Object.freeze({
          __proto__: null,
          base10: tb({ prefix: "9", name: "base10", alphabet: "0123456789" }),
        }),
        tI = Object.freeze({
          __proto__: null,
          base16: tv({
            prefix: "f",
            name: "base16",
            alphabet: "0123456789abcdef",
            bitsPerChar: 4,
          }),
          base16upper: tv({
            prefix: "F",
            name: "base16upper",
            alphabet: "0123456789ABCDEF",
            bitsPerChar: 4,
          }),
        });
      let tS = tv({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5,
        }),
        tx = tv({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5,
        }),
        tN = tv({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5,
        }),
        tT = tv({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5,
        }),
        tP = tv({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5,
        }),
        tO = tv({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5,
        }),
        tk = tv({
          prefix: "t",
          name: "base32hexpad",
          alphabet: "0123456789abcdefghijklmnopqrstuv=",
          bitsPerChar: 5,
        });
      var tR = Object.freeze({
          __proto__: null,
          base32: tS,
          base32upper: tx,
          base32pad: tN,
          base32padupper: tT,
          base32hex: tP,
          base32hexupper: tO,
          base32hexpad: tk,
          base32hexpadupper: tv({
            prefix: "T",
            name: "base32hexpadupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
            bitsPerChar: 5,
          }),
          base32z: tv({
            prefix: "h",
            name: "base32z",
            alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
            bitsPerChar: 5,
          }),
        }),
        tD = Object.freeze({
          __proto__: null,
          base36: tb({
            prefix: "k",
            name: "base36",
            alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
          }),
          base36upper: tb({
            prefix: "K",
            name: "base36upper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          }),
        }),
        tM = Object.freeze({
          __proto__: null,
          base58btc: tb({
            name: "base58btc",
            prefix: "z",
            alphabet:
              "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
          }),
          base58flickr: tb({
            name: "base58flickr",
            prefix: "Z",
            alphabet:
              "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
          }),
        });
      let tU = tv({
          prefix: "m",
          name: "base64",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          bitsPerChar: 6,
        }),
        tL = tv({
          prefix: "M",
          name: "base64pad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6,
        });
      var tB = Object.freeze({
        __proto__: null,
        base64: tU,
        base64pad: tL,
        base64url: tv({
          prefix: "u",
          name: "base64url",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6,
        }),
        base64urlpad: tv({
          prefix: "U",
          name: "base64urlpad",
          alphabet:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6,
        }),
      });
      let tj = Array.from(
          "\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"
        ),
        tF = tj.reduce((e, t, r) => ((e[r] = t), e), []),
        t$ = tj.reduce((e, t, r) => ((e[t.codePointAt(0)] = r), e), []);
      var tz = Object.freeze({
        __proto__: null,
        base256emoji: tm({
          prefix: "\uD83D\uDE80",
          name: "base256emoji",
          encode: function (e) {
            return e.reduce((e, t) => (e += tF[t]), "");
          },
          decode: function (e) {
            let t = [];
            for (let r of e) {
              let e = t$[r.codePointAt(0)];
              if (void 0 === e) throw Error(`Non-base256emoji character: ${r}`);
              t.push(e);
            }
            return new Uint8Array(t);
          },
        }),
      });
      function tW(e, t, r) {
        (t = t || []), (r = r || 0);
        for (var i = r; e >= 0x80000000; )
          (t[r++] = (255 & e) | 128), (e /= 128);
        for (; -128 & e; ) (t[r++] = (255 & e) | 128), (e >>>= 7);
        return (t[r] = 0 | e), (tW.bytes = r - i + 1), t;
      }
      function tH(e, t) {
        var r,
          i = 0,
          t = t || 0,
          s = 0,
          n = t,
          a = e.length;
        do {
          if (n >= a)
            throw ((tH.bytes = 0), RangeError("Could not decode varint"));
          (r = e[n++]),
            (i += s < 28 ? (127 & r) << s : (127 & r) * Math.pow(2, s)),
            (s += 7);
        } while (r >= 128);
        return (tH.bytes = n - t), i;
      }
      var tq = {
        encode: tW,
        encodingLength: function (e) {
          return e < 128
            ? 1
            : e < 16384
            ? 2
            : e < 2097152
            ? 3
            : e < 0x10000000
            ? 4
            : e < 0x800000000
            ? 5
            : e < 0x40000000000
            ? 6
            : e < 0x2000000000000
            ? 7
            : e < 0x100000000000000
            ? 8
            : e < 0x8000000000000000
            ? 9
            : 10;
        },
      };
      let tV = (e, t, r = 0) => (tq.encode(e, t, r), t),
        tK = (e) => tq.encodingLength(e),
        tG = (e, t) => {
          let r = t.byteLength,
            i = tK(e),
            s = i + tK(r),
            n = new Uint8Array(s + r);
          return tV(e, n, 0), tV(r, n, i), n.set(t, s), new tY(e, r, t, n);
        };
      class tY {
        constructor(e, t, r, i) {
          (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
        }
      }
      let tQ = ({ name: e, code: t, encode: r }) => new tZ(e, t, r);
      class tZ {
        constructor(e, t, r) {
          (this.name = e), (this.code = t), (this.encode = r);
        }
        digest(e) {
          if (e instanceof Uint8Array) {
            let t = this.encode(e);
            return t instanceof Uint8Array
              ? tG(this.code, t)
              : t.then((e) => tG(this.code, e));
          }
          throw Error("Unknown type, must be binary type");
        }
      }
      let tJ = (e) => async (t) =>
        new Uint8Array(await crypto.subtle.digest(e, t));
      var tX = Object.freeze({
          __proto__: null,
          sha256: tQ({ name: "sha2-256", code: 18, encode: tJ("SHA-256") }),
          sha512: tQ({ name: "sha2-512", code: 19, encode: tJ("SHA-512") }),
        }),
        t0 = Object.freeze({
          __proto__: null,
          identity: {
            code: 0,
            name: "identity",
            encode: tc,
            digest: (e) => tG(0, tc(e)),
          },
        });
      new TextEncoder(), new TextDecoder();
      let t1 = {
        ...tA,
        ...tE,
        ...t_,
        ...tC,
        ...tI,
        ...tR,
        ...tD,
        ...tM,
        ...tB,
        ...tz,
      };
      function t2(e, t, r, i) {
        return {
          name: e,
          prefix: t,
          encoder: { name: e, prefix: t, encode: r },
          decoder: { decode: i },
        };
      }
      ({ ...tX, ...t0 });
      let t3 = t2(
          "utf8",
          "u",
          (e) => "u" + new TextDecoder("utf8").decode(e),
          (e) => new TextEncoder().encode(e.substring(1))
        ),
        t5 = t2(
          "ascii",
          "a",
          (e) => {
            let t = "a";
            for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
            return t;
          },
          (e) => {
            let t = (function (e = 0) {
              return null != globalThis.Buffer &&
                null != globalThis.Buffer.allocUnsafe
                ? globalThis.Buffer.allocUnsafe(e)
                : new Uint8Array(e);
            })((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
            return t;
          }
        ),
        t8 = {
          utf8: t3,
          "utf-8": t3,
          hex: t1.base16,
          latin1: t5,
          ascii: t5,
          binary: t5,
          ...t1,
        };
      var t6 = Object.defineProperty,
        t4 = (e, t, r) =>
          t in e
            ? t6(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        t9 = (e, t, r) => t4(e, "symbol" != typeof t ? t + "" : t, r);
      class t7 {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            t9(this, "keychain", new Map()),
            t9(this, "name", "keychain"),
            t9(this, "version", "0.3"),
            t9(this, "initialized", !1),
            t9(this, "storagePrefix", eH),
            t9(this, "init", async () => {
              if (!this.initialized) {
                let e = await this.getKeyChain();
                "u" > typeof e && (this.keychain = e), (this.initialized = !0);
              }
            }),
            t9(
              this,
              "has",
              (e) => (this.isInitialized(), this.keychain.has(e))
            ),
            t9(this, "set", async (e, t) => {
              this.isInitialized(),
                this.keychain.set(e, t),
                await this.persist();
            }),
            t9(this, "get", (e) => {
              this.isInitialized();
              let t = this.keychain.get(e);
              if (typeof t > "u") {
                let { message: t } = (0, eu.GuA)(
                  "NO_MATCHING_KEY",
                  `${this.name}: ${e}`
                );
                throw Error(t);
              }
              return t;
            }),
            t9(this, "del", async (e) => {
              this.isInitialized(),
                this.keychain.delete(e),
                await this.persist();
            }),
            (this.core = e),
            (this.logger = (0, F.U5)(t, this.name));
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        async setKeyChain(e) {
          await this.core.storage.setItem(this.storageKey, (0, eu.h0Y)(e));
        }
        async getKeyChain() {
          let e = await this.core.storage.getItem(this.storageKey);
          return "u" > typeof e ? (0, eu.PUk)(e) : void 0;
        }
        async persist() {
          await this.setKeyChain(this.keychain);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = (0, eu.GuA)("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var re = Object.defineProperty,
        rt = (e, t, r) =>
          t in e
            ? re(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        rr = (e, t, r) => rt(e, "symbol" != typeof t ? t + "" : t, r);
      class ri {
        constructor(e, t, r) {
          (this.core = e),
            (this.logger = t),
            rr(this, "name", "crypto"),
            rr(this, "keychain"),
            rr(this, "randomSessionIdentifier", (0, eu.two)()),
            rr(this, "initialized", !1),
            rr(this, "init", async () => {
              this.initialized ||
                (await this.keychain.init(), (this.initialized = !0));
            }),
            rr(
              this,
              "hasKeys",
              (e) => (this.isInitialized(), this.keychain.has(e))
            ),
            rr(this, "getClientId", async () => {
              this.isInitialized();
              let e = await this.getClientSeed(),
                t = ed.TZ(e);
              return ed.UF(t.publicKey);
            }),
            rr(this, "generateKeyPair", () => {
              this.isInitialized();
              let e = (0, eu.TZl)();
              return this.setPrivateKey(e.publicKey, e.privateKey);
            }),
            rr(this, "signJWT", async (e) => {
              this.isInitialized();
              let t = await this.getClientSeed(),
                r = ed.TZ(t),
                i = this.randomSessionIdentifier;
              return await ed.FA(i, e, eG, r);
            }),
            rr(this, "generateSharedKey", (e, t, r) => {
              this.isInitialized();
              let i = this.getPrivateKey(e),
                s = (0, eu.ovp)(i, t);
              return this.setSymKey(s, r);
            }),
            rr(this, "setSymKey", async (e, t) => {
              this.isInitialized();
              let r = t || (0, eu.EN$)(e);
              return await this.keychain.set(r, e), r;
            }),
            rr(this, "deleteKeyPair", async (e) => {
              this.isInitialized(), await this.keychain.del(e);
            }),
            rr(this, "deleteSymKey", async (e) => {
              this.isInitialized(), await this.keychain.del(e);
            }),
            rr(this, "encode", async (e, t, r) => {
              this.isInitialized();
              let i = (0, eu.AwN)(r),
                s = (0, P.h)(t);
              if ((0, eu.ps1)(i)) return (0, eu.Tw2)(s, r?.encoding);
              if ((0, eu.V7m)(i)) {
                let t = i.senderPublicKey,
                  r = i.receiverPublicKey;
                e = await this.generateSharedKey(t, r);
              }
              let n = this.getSymKey(e),
                { type: a, senderPublicKey: o } = i;
              return (0, eu.wa2)({
                type: a,
                symKey: n,
                message: s,
                senderPublicKey: o,
                encoding: r?.encoding,
              });
            }),
            rr(this, "decode", async (e, t, r) => {
              this.isInitialized();
              let i = (0, eu.C5G)(t, r);
              if ((0, eu.ps1)(i)) {
                let e = (0, eu.F$L)(t, r?.encoding);
                return (0, P.j)(e);
              }
              if ((0, eu.V7m)(i)) {
                let t = i.receiverPublicKey,
                  r = i.senderPublicKey;
                e = await this.generateSharedKey(t, r);
              }
              try {
                let i = this.getSymKey(e),
                  s = (0, eu.YcA)({
                    symKey: i,
                    encoded: t,
                    encoding: r?.encoding,
                  });
                return (0, P.j)(s);
              } catch (t) {
                this.logger.error(
                  `Failed to decode message from topic: '${e}', clientId: '${await this.getClientId()}'`
                ),
                  this.logger.error(t);
              }
            }),
            rr(this, "getPayloadType", (e, t = eu.EWt) => {
              let r = (0, eu.iui)({ encoded: e, encoding: t });
              return (0, eu.x0t)(r.type);
            }),
            rr(this, "getPayloadSenderPublicKey", (e, t = eu.EWt) => {
              let r = (0, eu.iui)({ encoded: e, encoding: t });
              return r.senderPublicKey
                ? (0, eh.dI)(r.senderPublicKey, eu.bEt)
                : void 0;
            }),
            (this.core = e),
            (this.logger = (0, F.U5)(t, this.name)),
            (this.keychain = r || new t7(this.core, this.logger));
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        async setPrivateKey(e, t) {
          return await this.keychain.set(e, t), e;
        }
        getPrivateKey(e) {
          return this.keychain.get(e);
        }
        async getClientSeed() {
          let e = "";
          try {
            e = this.keychain.get(eK);
          } catch {
            (e = (0, eu.two)()), await this.keychain.set(eK, e);
          }
          return (function (e, t = "utf8") {
            let r = t8[t];
            if (!r) throw Error(`Unsupported encoding "${t}"`);
            return ("utf8" === t || "utf-8" === t) &&
              null != globalThis.Buffer &&
              null != globalThis.Buffer.from
              ? globalThis.Buffer.from(e, "utf8")
              : r.decoder.decode(`${r.prefix}${e}`);
          })(e, "base16");
        }
        getSymKey(e) {
          return this.keychain.get(e);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = (0, eu.GuA)("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var rs = Object.defineProperty,
        rn = Object.defineProperties,
        ra = Object.getOwnPropertyDescriptors,
        ro = Object.getOwnPropertySymbols,
        rc = Object.prototype.hasOwnProperty,
        rl = Object.prototype.propertyIsEnumerable,
        rd = (e, t, r) =>
          t in e
            ? rs(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ru = (e, t) => {
          for (var r in t || (t = {})) rc.call(t, r) && rd(e, r, t[r]);
          if (ro) for (var r of ro(t)) rl.call(t, r) && rd(e, r, t[r]);
          return e;
        },
        rh = (e, t) => rn(e, ra(t)),
        rf = (e, t, r) => rd(e, "symbol" != typeof t ? t + "" : t, r);
      class rp extends Y {
        constructor(e, t) {
          super(e, t),
            (this.logger = e),
            (this.core = t),
            rf(this, "messages", new Map()),
            rf(this, "messagesWithoutClientAck", new Map()),
            rf(this, "name", "messages"),
            rf(this, "version", "0.3"),
            rf(this, "initialized", !1),
            rf(this, "storagePrefix", eH),
            rf(this, "init", async () => {
              if (!this.initialized) {
                this.logger.trace("Initialized");
                try {
                  let e = await this.getRelayerMessages();
                  "u" > typeof e && (this.messages = e);
                  let t = await this.getRelayerMessagesWithoutClientAck();
                  "u" > typeof t && (this.messagesWithoutClientAck = t),
                    this.logger.debug(
                      `Successfully Restored records for ${this.name}`
                    ),
                    this.logger.trace({
                      type: "method",
                      method: "restore",
                      size: this.messages.size,
                    });
                } catch (e) {
                  this.logger.debug(
                    `Failed to Restore records for ${this.name}`
                  ),
                    this.logger.error(e);
                } finally {
                  this.initialized = !0;
                }
              }
            }),
            rf(this, "set", async (e, t, r) => {
              this.isInitialized();
              let i = (0, eu.ALl)(t),
                s = this.messages.get(e);
              if ((typeof s > "u" && (s = {}), "u" > typeof s[i])) return i;
              if (((s[i] = t), this.messages.set(e, s), r === e1.inbound)) {
                let r = this.messagesWithoutClientAck.get(e) || {};
                this.messagesWithoutClientAck.set(e, rh(ru({}, r), { [i]: t }));
              }
              return await this.persist(), i;
            }),
            rf(this, "get", (e) => {
              this.isInitialized();
              let t = this.messages.get(e);
              return typeof t > "u" && (t = {}), t;
            }),
            rf(this, "getWithoutAck", (e) => {
              this.isInitialized();
              let t = {};
              for (let r of e) {
                let e = this.messagesWithoutClientAck.get(r) || {};
                t[r] = Object.values(e);
              }
              return t;
            }),
            rf(
              this,
              "has",
              (e, t) => (
                this.isInitialized(), "u" > typeof this.get(e)[(0, eu.ALl)(t)]
              )
            ),
            rf(this, "ack", async (e, t) => {
              this.isInitialized();
              let r = this.messagesWithoutClientAck.get(e);
              if (typeof r > "u") return;
              let i = (0, eu.ALl)(t);
              delete r[i],
                0 === Object.keys(r).length
                  ? this.messagesWithoutClientAck.delete(e)
                  : this.messagesWithoutClientAck.set(e, r),
                await this.persist();
            }),
            rf(this, "del", async (e) => {
              this.isInitialized(),
                this.messages.delete(e),
                this.messagesWithoutClientAck.delete(e),
                await this.persist();
            }),
            (this.logger = (0, F.U5)(e, this.name)),
            (this.core = t);
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get storageKeyWithoutClientAck() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name +
            "_withoutClientAck"
          );
        }
        async setRelayerMessages(e) {
          await this.core.storage.setItem(this.storageKey, (0, eu.h0Y)(e));
        }
        async setRelayerMessagesWithoutClientAck(e) {
          await this.core.storage.setItem(
            this.storageKeyWithoutClientAck,
            (0, eu.h0Y)(e)
          );
        }
        async getRelayerMessages() {
          let e = await this.core.storage.getItem(this.storageKey);
          return "u" > typeof e ? (0, eu.PUk)(e) : void 0;
        }
        async getRelayerMessagesWithoutClientAck() {
          let e = await this.core.storage.getItem(
            this.storageKeyWithoutClientAck
          );
          return "u" > typeof e ? (0, eu.PUk)(e) : void 0;
        }
        async persist() {
          await this.setRelayerMessages(this.messages),
            await this.setRelayerMessagesWithoutClientAck(
              this.messagesWithoutClientAck
            );
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = (0, eu.GuA)("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var rg = Object.defineProperty,
        rm = Object.defineProperties,
        rb = Object.getOwnPropertyDescriptors,
        ry = Object.getOwnPropertySymbols,
        rw = Object.prototype.hasOwnProperty,
        rv = Object.prototype.propertyIsEnumerable,
        rA = (e, t, r) =>
          t in e
            ? rg(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        rE = (e, t) => {
          for (var r in t || (t = {})) rw.call(t, r) && rA(e, r, t[r]);
          if (ry) for (var r of ry(t)) rv.call(t, r) && rA(e, r, t[r]);
          return e;
        },
        r_ = (e, t) => rm(e, rb(t)),
        rC = (e, t, r) => rA(e, "symbol" != typeof t ? t + "" : t, r);
      class rI extends Q {
        constructor(e, t) {
          super(e, t),
            (this.relayer = e),
            (this.logger = t),
            rC(this, "events", new s.EventEmitter()),
            rC(this, "name", "publisher"),
            rC(this, "queue", new Map()),
            rC(this, "publishTimeout", (0, a.toMiliseconds)(a.ONE_MINUTE)),
            rC(
              this,
              "initialPublishTimeout",
              (0, a.toMiliseconds)(15 * a.ONE_SECOND)
            ),
            rC(this, "needsTransportRestart", !1),
            rC(this, "publish", async (e, t, r) => {
              var i;
              this.logger.debug("Publishing Payload"),
                this.logger.trace({
                  type: "method",
                  method: "publish",
                  params: { topic: e, message: t, opts: r },
                });
              let s = r?.ttl || eY,
                n = (0, eu.n6V)(r),
                a = r?.prompt || !1,
                o = r?.tag || 0,
                c = r?.id || eA().toString(),
                l = {
                  topic: e,
                  message: t,
                  opts: {
                    ttl: s,
                    relay: n,
                    prompt: a,
                    tag: o,
                    id: c,
                    attestation: r?.attestation,
                    tvf: r?.tvf,
                  },
                },
                d = `Failed to publish payload, please try again. id:${c} tag:${o}`;
              try {
                let i = new Promise(async (i) => {
                  let n = ({ id: e }) => {
                    l.opts.id === e &&
                      (this.removeRequestFromQueue(e),
                      this.relayer.events.removeListener(eZ.publish, n),
                      i(l));
                  };
                  this.relayer.events.on(eZ.publish, n);
                  let d = (0, eu.K3g)(
                    new Promise((i, n) => {
                      this.rpcPublish({
                        topic: e,
                        message: t,
                        ttl: s,
                        prompt: a,
                        tag: o,
                        id: c,
                        attestation: r?.attestation,
                        tvf: r?.tvf,
                      })
                        .then(i)
                        .catch((e) => {
                          this.logger.warn(e, e?.message), n(e);
                        });
                    }),
                    this.initialPublishTimeout,
                    `Failed initial publish, retrying.... id:${c} tag:${o}`
                  );
                  try {
                    await d, this.events.removeListener(eZ.publish, n);
                  } catch (e) {
                    this.queue.set(c, r_(rE({}, l), { attempt: 1 })),
                      this.logger.warn(e, e?.message);
                  }
                });
                this.logger.trace({
                  type: "method",
                  method: "publish",
                  params: { id: c, topic: e, message: t, opts: r },
                }),
                  await (0, eu.K3g)(i, this.publishTimeout, d);
              } catch (e) {
                if (
                  (this.logger.debug("Failed to Publish Payload"),
                  this.logger.error(e),
                  null != (i = r?.internal) && i.throwOnFailedPublish)
                )
                  throw e;
              } finally {
                this.queue.delete(c);
              }
            }),
            rC(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            rC(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            rC(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            rC(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.relayer = e),
            (this.logger = (0, F.U5)(t, this.name)),
            this.registerEventListeners();
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        async rpcPublish(e) {
          var t, r, i, s;
          let {
              topic: n,
              message: a,
              ttl: o = eY,
              prompt: c,
              tag: l,
              id: d,
              attestation: u,
              tvf: h,
            } = e,
            f = {
              method: (0, eu.aa1)((0, eu.n6V)().protocol).publish,
              params: rE(
                {
                  topic: n,
                  message: a,
                  ttl: o,
                  prompt: c,
                  tag: l,
                  attestation: u,
                },
                h
              ),
              id: d,
            };
          (0, eu.b07)(null == (t = f.params) ? void 0 : t.prompt) &&
            (null == (r = f.params) || delete r.prompt),
            (0, eu.b07)(null == (i = f.params) ? void 0 : i.tag) &&
              (null == (s = f.params) || delete s.tag),
            this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "message",
              direction: "outgoing",
              request: f,
            });
          let p = await this.relayer.request(f);
          return (
            this.relayer.events.emit(eZ.publish, e),
            this.logger.debug("Successfully Published Payload"),
            p
          );
        }
        removeRequestFromQueue(e) {
          this.queue.delete(e);
        }
        checkQueue() {
          this.queue.forEach(async (e, t) => {
            let r = e.attempt + 1;
            this.queue.set(t, r_(rE({}, e), { attempt: r }));
            let { topic: i, message: s, opts: n, attestation: a } = e;
            this.logger.warn(
              {},
              `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${r}`
            ),
              await this.rpcPublish(
                r_(rE({}, e), {
                  topic: i,
                  message: s,
                  ttl: n.ttl,
                  prompt: n.prompt,
                  tag: n.tag,
                  id: n.id,
                  attestation: a,
                  tvf: n.tvf,
                })
              ),
              this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
          });
        }
        registerEventListeners() {
          this.relayer.core.heartbeat.on(d.pulse, () => {
            if (this.needsTransportRestart) {
              (this.needsTransportRestart = !1),
                this.relayer.events.emit(eZ.connection_stalled);
              return;
            }
            this.checkQueue();
          }),
            this.relayer.on(eZ.message_ack, (e) => {
              this.removeRequestFromQueue(e.id.toString());
            });
        }
      }
      var rS = Object.defineProperty,
        rx = (e, t, r) =>
          t in e
            ? rS(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        rN = (e, t, r) => rx(e, "symbol" != typeof t ? t + "" : t, r);
      class rT {
        constructor() {
          rN(this, "map", new Map()),
            rN(this, "set", (e, t) => {
              let r = this.get(e);
              this.exists(e, t) || this.map.set(e, [...r, t]);
            }),
            rN(this, "get", (e) => this.map.get(e) || []),
            rN(this, "exists", (e, t) => this.get(e).includes(t)),
            rN(this, "delete", (e, t) => {
              if (typeof t > "u") {
                this.map.delete(e);
                return;
              }
              if (!this.map.has(e)) return;
              let r = this.get(e);
              if (!this.exists(e, t)) return;
              let i = r.filter((e) => e !== t);
              if (!i.length) {
                this.map.delete(e);
                return;
              }
              this.map.set(e, i);
            }),
            rN(this, "clear", () => {
              this.map.clear();
            });
        }
        get topics() {
          return Array.from(this.map.keys());
        }
      }
      var rP = Object.defineProperty,
        rO = Object.defineProperties,
        rk = Object.getOwnPropertyDescriptors,
        rR = Object.getOwnPropertySymbols,
        rD = Object.prototype.hasOwnProperty,
        rM = Object.prototype.propertyIsEnumerable,
        rU = (e, t, r) =>
          t in e
            ? rP(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        rL = (e, t) => {
          for (var r in t || (t = {})) rD.call(t, r) && rU(e, r, t[r]);
          if (rR) for (var r of rR(t)) rM.call(t, r) && rU(e, r, t[r]);
          return e;
        },
        rB = (e, t) => rO(e, rk(t)),
        rj = (e, t, r) => rU(e, "symbol" != typeof t ? t + "" : t, r);
      class rF extends ee {
        constructor(e, t) {
          super(e, t),
            (this.relayer = e),
            (this.logger = t),
            rj(this, "subscriptions", new Map()),
            rj(this, "topicMap", new rT()),
            rj(this, "events", new s.EventEmitter()),
            rj(this, "name", "subscription"),
            rj(this, "version", "0.3"),
            rj(this, "pending", new Map()),
            rj(this, "cached", []),
            rj(this, "initialized", !1),
            rj(this, "storagePrefix", eH),
            rj(this, "subscribeTimeout", (0, a.toMiliseconds)(a.ONE_MINUTE)),
            rj(
              this,
              "initialSubscribeTimeout",
              (0, a.toMiliseconds)(15 * a.ONE_SECOND)
            ),
            rj(this, "clientId"),
            rj(this, "batchSubscribeTopicsLimit", 500),
            rj(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                this.registerEventListeners(),
                await this.restore()),
                (this.initialized = !0);
            }),
            rj(this, "subscribe", async (e, t) => {
              this.isInitialized(),
                this.logger.debug("Subscribing Topic"),
                this.logger.trace({
                  type: "method",
                  method: "subscribe",
                  params: { topic: e, opts: t },
                });
              try {
                let r = (0, eu.n6V)(t),
                  i = { topic: e, relay: r, transportType: t?.transportType };
                this.pending.set(e, i);
                let s = await this.rpcSubscribe(e, r, t);
                return (
                  "string" == typeof s &&
                    (this.onSubscribe(s, i),
                    this.logger.debug("Successfully Subscribed Topic"),
                    this.logger.trace({
                      type: "method",
                      method: "subscribe",
                      params: { topic: e, opts: t },
                    })),
                  s
                );
              } catch (e) {
                throw (
                  (this.logger.debug("Failed to Subscribe Topic"),
                  this.logger.error(e),
                  e)
                );
              }
            }),
            rj(this, "unsubscribe", async (e, t) => {
              this.isInitialized(),
                "u" > typeof t?.id
                  ? await this.unsubscribeById(e, t.id, t)
                  : await this.unsubscribeByTopic(e, t);
            }),
            rj(
              this,
              "isSubscribed",
              (e) =>
                new Promise((t) => {
                  t(this.topicMap.topics.includes(e));
                })
            ),
            rj(
              this,
              "isKnownTopic",
              (e) =>
                new Promise((t) => {
                  t(
                    this.topicMap.topics.includes(e) ||
                      this.pending.has(e) ||
                      this.cached.some((t) => t.topic === e)
                  );
                })
            ),
            rj(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            rj(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            rj(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            rj(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            rj(this, "start", async () => {
              await this.onConnect();
            }),
            rj(this, "stop", async () => {
              await this.onDisconnect();
            }),
            rj(this, "restart", async () => {
              await this.restore(), await this.onRestart();
            }),
            rj(this, "checkPending", async () => {
              if (
                0 === this.pending.size &&
                (!this.initialized || !this.relayer.connected)
              )
                return;
              let e = [];
              this.pending.forEach((t) => {
                e.push(t);
              }),
                await this.batchSubscribe(e);
            }),
            rj(this, "registerEventListeners", () => {
              this.relayer.core.heartbeat.on(d.pulse, async () => {
                await this.checkPending();
              }),
                this.events.on(e3.created, async (e) => {
                  let t = e3.created;
                  this.logger.info(`Emitting ${t}`),
                    this.logger.debug({ type: "event", event: t, data: e }),
                    await this.persist();
                }),
                this.events.on(e3.deleted, async (e) => {
                  let t = e3.deleted;
                  this.logger.info(`Emitting ${t}`),
                    this.logger.debug({ type: "event", event: t, data: e }),
                    await this.persist();
                });
            }),
            (this.relayer = e),
            (this.logger = (0, F.U5)(t, this.name)),
            (this.clientId = "");
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.relayer.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get length() {
          return this.subscriptions.size;
        }
        get ids() {
          return Array.from(this.subscriptions.keys());
        }
        get values() {
          return Array.from(this.subscriptions.values());
        }
        get topics() {
          return this.topicMap.topics;
        }
        get hasAnyTopics() {
          return (
            this.topicMap.topics.length > 0 ||
            this.pending.size > 0 ||
            this.cached.length > 0 ||
            this.subscriptions.size > 0
          );
        }
        hasSubscription(e, t) {
          let r = !1;
          try {
            r = this.getSubscription(e).topic === t;
          } catch {}
          return r;
        }
        reset() {
          (this.cached = []), (this.initialized = !0);
        }
        onDisable() {
          (this.cached = this.values),
            this.subscriptions.clear(),
            this.topicMap.clear();
        }
        async unsubscribeByTopic(e, t) {
          let r = this.topicMap.get(e);
          await Promise.all(
            r.map(async (r) => await this.unsubscribeById(e, r, t))
          );
        }
        async unsubscribeById(e, t, r) {
          this.logger.debug("Unsubscribing Topic"),
            this.logger.trace({
              type: "method",
              method: "unsubscribe",
              params: { topic: e, id: t, opts: r },
            });
          try {
            let i = (0, eu.n6V)(r);
            await this.restartToComplete({ topic: e, id: t, relay: i }),
              await this.rpcUnsubscribe(e, t, i);
            let s = (0, eu.Hjj)("USER_DISCONNECTED", `${this.name}, ${e}`);
            await this.onUnsubscribe(e, t, s),
              this.logger.debug("Successfully Unsubscribed Topic"),
              this.logger.trace({
                type: "method",
                method: "unsubscribe",
                params: { topic: e, id: t, opts: r },
              });
          } catch (e) {
            throw (
              (this.logger.debug("Failed to Unsubscribe Topic"),
              this.logger.error(e),
              e)
            );
          }
        }
        async rpcSubscribe(e, t, r) {
          var i;
          (r && r?.transportType !== e0.relay) ||
            (await this.restartToComplete({ topic: e, id: e, relay: t }));
          let s = {
            method: (0, eu.aa1)(t.protocol).subscribe,
            params: { topic: e },
          };
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: s,
            });
          let n = null == (i = r?.internal) ? void 0 : i.throwOnFailedPublish;
          try {
            let t = await this.getSubscriptionId(e);
            if (r?.transportType === e0.link_mode)
              return (
                setTimeout(() => {
                  (this.relayer.connected || this.relayer.connecting) &&
                    this.relayer.request(s).catch((e) => this.logger.warn(e));
                }, (0, a.toMiliseconds)(a.ONE_SECOND)),
                t
              );
            let i = new Promise(async (t) => {
                let r = (i) => {
                  i.topic === e &&
                    (this.events.removeListener(e3.created, r), t(i.id));
                };
                this.events.on(e3.created, r);
                try {
                  let i = await (0, eu.K3g)(
                    new Promise((e, t) => {
                      this.relayer
                        .request(s)
                        .catch((e) => {
                          this.logger.warn(e, e?.message), t(e);
                        })
                        .then(e);
                    }),
                    this.initialSubscribeTimeout,
                    `Subscribing to ${e} failed, please try again`
                  );
                  this.events.removeListener(e3.created, r), t(i);
                } catch {}
              }),
              o = await (0, eu.K3g)(
                i,
                this.subscribeTimeout,
                `Subscribing to ${e} failed, please try again`
              );
            if (!o && n)
              throw Error(`Subscribing to ${e} failed, please try again`);
            return o ? t : null;
          } catch (e) {
            if (
              (this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
              this.relayer.events.emit(eZ.connection_stalled),
              n)
            )
              throw e;
          }
          return null;
        }
        async rpcBatchSubscribe(e) {
          if (!e.length) return;
          let t = e[0].relay,
            r = {
              method: (0, eu.aa1)(t.protocol).batchSubscribe,
              params: { topics: e.map((e) => e.topic) },
            };
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: r,
            });
          try {
            await await (0, eu.K3g)(
              new Promise((e) => {
                this.relayer
                  .request(r)
                  .catch((e) => this.logger.warn(e))
                  .then(e);
              }),
              this.subscribeTimeout,
              "rpcBatchSubscribe failed, please try again"
            );
          } catch {
            this.relayer.events.emit(eZ.connection_stalled);
          }
        }
        async rpcBatchFetchMessages(e) {
          let t;
          if (!e.length) return;
          let r = e[0].relay,
            i = {
              method: (0, eu.aa1)(r.protocol).batchFetchMessages,
              params: { topics: e.map((e) => e.topic) },
            };
          this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: i,
            });
          try {
            t = await await (0, eu.K3g)(
              new Promise((e, t) => {
                this.relayer
                  .request(i)
                  .catch((e) => {
                    this.logger.warn(e), t(e);
                  })
                  .then(e);
              }),
              this.subscribeTimeout,
              "rpcBatchFetchMessages failed, please try again"
            );
          } catch {
            this.relayer.events.emit(eZ.connection_stalled);
          }
          return t;
        }
        rpcUnsubscribe(e, t, r) {
          let i = {
            method: (0, eu.aa1)(r.protocol).unsubscribe,
            params: { topic: e, id: t },
          };
          return (
            this.logger.debug("Outgoing Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "outgoing",
              request: i,
            }),
            this.relayer.request(i)
          );
        }
        onSubscribe(e, t) {
          this.setSubscription(e, rB(rL({}, t), { id: e })),
            this.pending.delete(t.topic);
        }
        onBatchSubscribe(e) {
          e.length &&
            e.forEach((e) => {
              this.setSubscription(e.id, rL({}, e)),
                this.pending.delete(e.topic);
            });
        }
        async onUnsubscribe(e, t, r) {
          this.events.removeAllListeners(t),
            this.hasSubscription(t, e) && this.deleteSubscription(t, r),
            await this.relayer.messages.del(e);
        }
        async setRelayerSubscriptions(e) {
          await this.relayer.core.storage.setItem(this.storageKey, e);
        }
        async getRelayerSubscriptions() {
          return await this.relayer.core.storage.getItem(this.storageKey);
        }
        setSubscription(e, t) {
          this.logger.debug("Setting subscription"),
            this.logger.trace({
              type: "method",
              method: "setSubscription",
              id: e,
              subscription: t,
            }),
            this.addSubscription(e, t);
        }
        addSubscription(e, t) {
          this.subscriptions.set(e, rL({}, t)),
            this.topicMap.set(t.topic, e),
            this.events.emit(e3.created, t);
        }
        getSubscription(e) {
          this.logger.debug("Getting subscription"),
            this.logger.trace({
              type: "method",
              method: "getSubscription",
              id: e,
            });
          let t = this.subscriptions.get(e);
          if (!t) {
            let { message: t } = (0, eu.GuA)(
              "NO_MATCHING_KEY",
              `${this.name}: ${e}`
            );
            throw Error(t);
          }
          return t;
        }
        deleteSubscription(e, t) {
          this.logger.debug("Deleting subscription"),
            this.logger.trace({
              type: "method",
              method: "deleteSubscription",
              id: e,
              reason: t,
            });
          let r = this.getSubscription(e);
          this.subscriptions.delete(e),
            this.topicMap.delete(r.topic, e),
            this.events.emit(e3.deleted, rB(rL({}, r), { reason: t }));
        }
        async persist() {
          await this.setRelayerSubscriptions(this.values),
            this.events.emit(e3.sync);
        }
        async onRestart() {
          if (this.cached.length) {
            let e = [...this.cached],
              t = Math.ceil(
                this.cached.length / this.batchSubscribeTopicsLimit
              );
            for (let r = 0; r < t; r++) {
              let t = e.splice(0, this.batchSubscribeTopicsLimit);
              await this.batchSubscribe(t);
            }
          }
          this.events.emit(e3.resubscribed);
        }
        async restore() {
          try {
            let e = await this.getRelayerSubscriptions();
            if (typeof e > "u" || !e.length) return;
            if (this.subscriptions.size) {
              let { message: e } = (0, eu.GuA)(
                "RESTORE_WILL_OVERRIDE",
                this.name
              );
              throw (
                (this.logger.error(e),
                this.logger.error(
                  `${this.name}: ${JSON.stringify(this.values)}`
                ),
                Error(e))
              );
            }
            (this.cached = e),
              this.logger.debug(
                `Successfully Restored subscriptions for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                subscriptions: this.values,
              });
          } catch (e) {
            this.logger.debug(
              `Failed to Restore subscriptions for ${this.name}`
            ),
              this.logger.error(e);
          }
        }
        async batchSubscribe(e) {
          e.length &&
            (await this.rpcBatchSubscribe(e),
            this.onBatchSubscribe(
              await Promise.all(
                e.map(async (e) =>
                  rB(rL({}, e), { id: await this.getSubscriptionId(e.topic) })
                )
              )
            ));
        }
        async batchFetchMessages(e) {
          if (!e.length) return;
          this.logger.trace(
            `Fetching batch messages for ${e.length} subscriptions`
          );
          let t = await this.rpcBatchFetchMessages(e);
          t &&
            t.messages &&
            (await (0, eu.yy4)((0, a.toMiliseconds)(a.ONE_SECOND)),
            await this.relayer.handleBatchMessageEvents(t.messages));
        }
        async onConnect() {
          await this.restart(), this.reset();
        }
        onDisconnect() {
          this.onDisable();
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = (0, eu.GuA)("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        async restartToComplete(e) {
          this.relayer.connected ||
            this.relayer.connecting ||
            (this.cached.push(e), await this.relayer.transportOpen());
        }
        async getClientId() {
          return (
            this.clientId ||
              (this.clientId = await this.relayer.core.crypto.getClientId()),
            this.clientId
          );
        }
        async getSubscriptionId(e) {
          return (0, eu.ALl)(e + (await this.getClientId()));
        }
      }
      var r$ = Object.defineProperty,
        rz = Object.getOwnPropertySymbols,
        rW = Object.prototype.hasOwnProperty,
        rH = Object.prototype.propertyIsEnumerable,
        rq = (e, t, r) =>
          t in e
            ? r$(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        rV = (e, t) => {
          for (var r in t || (t = {})) rW.call(t, r) && rq(e, r, t[r]);
          if (rz) for (var r of rz(t)) rH.call(t, r) && rq(e, r, t[r]);
          return e;
        },
        rK = (e, t, r) => rq(e, "symbol" != typeof t ? t + "" : t, r);
      class rG extends Z {
        constructor(e) {
          super(e),
            rK(this, "protocol", "wc"),
            rK(this, "version", 2),
            rK(this, "core"),
            rK(this, "logger"),
            rK(this, "events", new s.EventEmitter()),
            rK(this, "provider"),
            rK(this, "messages"),
            rK(this, "subscriber"),
            rK(this, "publisher"),
            rK(this, "name", "relayer"),
            rK(this, "transportExplicitlyClosed", !1),
            rK(this, "initialized", !1),
            rK(this, "connectionAttemptInProgress", !1),
            rK(this, "relayUrl"),
            rK(this, "projectId"),
            rK(this, "packageName"),
            rK(this, "bundleId"),
            rK(this, "hasExperiencedNetworkDisruption", !1),
            rK(this, "pingTimeout"),
            rK(
              this,
              "heartBeatTimeout",
              (0, a.toMiliseconds)(a.THIRTY_SECONDS + a.FIVE_SECONDS)
            ),
            rK(this, "reconnectTimeout"),
            rK(this, "connectPromise"),
            rK(this, "reconnectInProgress", !1),
            rK(this, "requestsInFlight", []),
            rK(this, "connectTimeout", (0, a.toMiliseconds)(15 * a.ONE_SECOND)),
            rK(this, "request", async (e) => {
              var t, r;
              this.logger.debug("Publishing Request Payload");
              let i = e.id || eA().toString();
              await this.toEstablishConnection();
              try {
                this.logger.trace(
                  {
                    id: i,
                    method: e.method,
                    topic: null == (t = e.params) ? void 0 : t.topic,
                  },
                  "relayer.request - publishing..."
                );
                let s = `${i}:${
                  (null == (r = e.params) ? void 0 : r.tag) || ""
                }`;
                this.requestsInFlight.push(s);
                let n = await this.provider.request(e);
                return (
                  (this.requestsInFlight = this.requestsInFlight.filter(
                    (e) => e !== s
                  )),
                  n
                );
              } catch (e) {
                throw (this.logger.debug(`Failed to Publish Request: ${i}`), e);
              }
            }),
            rK(this, "resetPingTimeout", () => {
              (0, eu.Lln)() &&
                (clearTimeout(this.pingTimeout),
                (this.pingTimeout = setTimeout(() => {
                  var e, t, r, i;
                  try {
                    this.logger.debug(
                      {},
                      "pingTimeout: Connection stalled, terminating..."
                    ),
                      null ==
                        (i =
                          null ==
                          (r =
                            null ==
                            (t =
                              null == (e = this.provider)
                                ? void 0
                                : e.connection)
                              ? void 0
                              : t.socket)
                            ? void 0
                            : r.terminate) || i.call(r);
                  } catch (e) {
                    this.logger.warn(e, e?.message);
                  }
                }, this.heartBeatTimeout)));
            }),
            rK(this, "onPayloadHandler", (e) => {
              this.onProviderPayload(e), this.resetPingTimeout();
            }),
            rK(this, "onConnectHandler", () => {
              this.logger.warn({}, "Relayer connected \uD83D\uDEDC"),
                this.startPingTimeout(),
                this.events.emit(eZ.connect);
            }),
            rK(this, "onDisconnectHandler", () => {
              this.logger.warn({}, "Relayer disconnected \uD83D\uDED1"),
                (this.requestsInFlight = []),
                this.onProviderDisconnect();
            }),
            rK(this, "onProviderErrorHandler", (e) => {
              this.logger.fatal(`Fatal socket error: ${e.message}`),
                this.events.emit(eZ.error, e),
                this.logger.fatal(
                  "Fatal socket error received, closing transport"
                ),
                this.transportClose();
            }),
            rK(this, "registerProviderListeners", () => {
              this.provider.on(eJ.payload, this.onPayloadHandler),
                this.provider.on(eJ.connect, this.onConnectHandler),
                this.provider.on(eJ.disconnect, this.onDisconnectHandler),
                this.provider.on(eJ.error, this.onProviderErrorHandler);
            }),
            (this.core = e.core),
            (this.logger =
              "u" > typeof e.logger && "string" != typeof e.logger
                ? (0, F.U5)(e.logger, this.name)
                : (0, F.h6)((0, F.iP)({ level: e.logger || "error" }))),
            (this.messages = new rp(this.logger, e.core)),
            (this.subscriber = new rF(this, this.logger)),
            (this.publisher = new rI(this, this.logger)),
            (this.relayUrl = e?.relayUrl || eQ),
            (this.projectId = e.projectId),
            (0, eu.m01)()
              ? (this.packageName = (0, eu.R7U)())
              : (0, eu.aRZ)() && (this.bundleId = (0, eu.R7U)()),
            (this.provider = {});
        }
        async init() {
          if (
            (this.logger.trace("Initialized"),
            this.registerEventListeners(),
            await Promise.all([this.messages.init(), this.subscriber.init()]),
            (this.initialized = !0),
            this.subscriber.hasAnyTopics)
          )
            try {
              await this.transportOpen();
            } catch (e) {
              this.logger.warn(e, e?.message);
            }
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        get connected() {
          var e, t, r;
          return (
            (null ==
            (r =
              null == (t = null == (e = this.provider) ? void 0 : e.connection)
                ? void 0
                : t.socket)
              ? void 0
              : r.readyState) === 1
          );
        }
        get connecting() {
          var e, t, r;
          return (
            (null ==
            (r =
              null == (t = null == (e = this.provider) ? void 0 : e.connection)
                ? void 0
                : t.socket)
              ? void 0
              : r.readyState) === 0 || void 0 !== this.connectPromise
          );
        }
        async publish(e, t, r) {
          this.isInitialized(),
            await this.publisher.publish(e, t, r),
            await this.recordMessageEvent(
              {
                topic: e,
                message: t,
                publishedAt: Date.now(),
                transportType: e0.relay,
              },
              e1.outbound
            );
        }
        async subscribe(e, t) {
          var r, i, s;
          this.isInitialized(),
            (null != t && t.transportType && t?.transportType !== "relay") ||
              (await this.toEstablishConnection());
          let n =
              typeof (null == (r = t?.internal)
                ? void 0
                : r.throwOnFailedPublish) > "u" ||
              (null == (i = t?.internal) ? void 0 : i.throwOnFailedPublish),
            a =
              (null == (s = this.subscriber.topicMap.get(e)) ? void 0 : s[0]) ||
              "",
            o,
            c = (t) => {
              t.topic === e && (this.subscriber.off(e3.created, c), o());
            };
          return (
            await Promise.all([
              new Promise((e) => {
                (o = e), this.subscriber.on(e3.created, c);
              }),
              new Promise(async (r, i) => {
                (a =
                  (await this.subscriber
                    .subscribe(
                      e,
                      rV({ internal: { throwOnFailedPublish: n } }, t)
                    )
                    .catch((e) => {
                      n && i(e);
                    })) || a),
                  r();
              }),
            ]),
            a
          );
        }
        async unsubscribe(e, t) {
          this.isInitialized(), await this.subscriber.unsubscribe(e, t);
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async transportDisconnect() {
          this.provider.disconnect &&
          (this.hasExperiencedNetworkDisruption || this.connected)
            ? await (0, eu.K3g)(
                this.provider.disconnect(),
                2e3,
                "provider.disconnect()"
              ).catch(() => this.onProviderDisconnect())
            : this.onProviderDisconnect();
        }
        async transportClose() {
          (this.transportExplicitlyClosed = !0),
            await this.transportDisconnect();
        }
        async transportOpen(e) {
          if (!this.subscriber.hasAnyTopics) {
            this.logger.warn(
              "Starting WS connection skipped because the client has no topics to work with."
            );
            return;
          }
          if (
            (this.connectPromise
              ? (this.logger.debug(
                  {},
                  "Waiting for existing connection attempt to resolve..."
                ),
                await this.connectPromise,
                this.logger.debug({}, "Existing connection attempt resolved"))
              : ((this.connectPromise = new Promise(async (t, r) => {
                  await this.connect(e)
                    .then(t)
                    .catch(r)
                    .finally(() => {
                      this.connectPromise = void 0;
                    });
                })),
                await this.connectPromise),
            !this.connected)
          )
            throw Error(
              `Couldn't establish socket connection to the relay server: ${this.relayUrl}`
            );
        }
        async restartTransport(e) {
          this.logger.debug({}, "Restarting transport..."),
            this.connectionAttemptInProgress ||
              ((this.relayUrl = e || this.relayUrl),
              await this.confirmOnlineStateOrThrow(),
              await this.transportClose(),
              await this.transportOpen());
        }
        async confirmOnlineStateOrThrow() {
          if (!(await (0, eu.sc7)()))
            throw Error(
              "No internet connection detected. Please restart your network and try again."
            );
        }
        async handleBatchMessageEvents(e) {
          if (e?.length === 0) {
            this.logger.trace("Batch message events is empty. Ignoring...");
            return;
          }
          let t = e.sort((e, t) => e.publishedAt - t.publishedAt);
          for (let e of (this.logger.debug(
            `Batch of ${t.length} message events sorted`
          ),
          t))
            try {
              await this.onMessageEvent(e);
            } catch (e) {
              this.logger.warn(
                e,
                "Error while processing batch message event: " + e?.message
              );
            }
          this.logger.trace(`Batch of ${t.length} message events processed`);
        }
        async onLinkMessageEvent(e, t) {
          let { topic: r } = e;
          if (!t.sessionExists) {
            let e = (0, eu.Xw0)(a.FIVE_MINUTES);
            await this.core.pairing.pairings.set(r, {
              topic: r,
              expiry: e,
              relay: { protocol: "irn" },
              active: !1,
            });
          }
          this.events.emit(eZ.message, e),
            await this.recordMessageEvent(e, e1.inbound);
        }
        async connect(e) {
          await this.confirmOnlineStateOrThrow(),
            e &&
              e !== this.relayUrl &&
              ((this.relayUrl = e), await this.transportDisconnect()),
            (this.connectionAttemptInProgress = !0),
            (this.transportExplicitlyClosed = !1);
          let t = 1;
          for (; t < 6; ) {
            try {
              if (this.transportExplicitlyClosed) break;
              this.logger.debug(
                {},
                `Connecting to ${this.relayUrl}, attempt: ${t}...`
              ),
                await this.createProvider(),
                await new Promise(async (e, t) => {
                  let r = () => {
                    t(
                      Error("Connection interrupted while trying to subscribe")
                    );
                  };
                  this.provider.once(eJ.disconnect, r),
                    await (0, eu.K3g)(
                      new Promise((e, t) => {
                        this.provider.connect().then(e).catch(t);
                      }),
                      this.connectTimeout,
                      `Socket stalled when trying to connect to ${this.relayUrl}`
                    )
                      .catch((e) => {
                        t(e);
                      })
                      .finally(() => {
                        this.provider.off(eJ.disconnect, r),
                          clearTimeout(this.reconnectTimeout);
                      }),
                    await new Promise(async (e, t) => {
                      let r = () => {
                        t(
                          Error(
                            "Connection interrupted while trying to subscribe"
                          )
                        );
                      };
                      this.provider.once(eJ.disconnect, r),
                        await this.subscriber
                          .start()
                          .then(e)
                          .catch(t)
                          .finally(() => {
                            this.provider.off(eJ.disconnect, r);
                          });
                    }),
                    (this.hasExperiencedNetworkDisruption = !1),
                    e();
                });
            } catch (e) {
              await this.subscriber.stop(),
                this.logger.warn({}, e.message),
                (this.hasExperiencedNetworkDisruption = !0);
            } finally {
              this.connectionAttemptInProgress = !1;
            }
            if (this.connected) {
              this.logger.debug(
                {},
                `Connected to ${this.relayUrl} successfully on attempt: ${t}`
              );
              break;
            }
            await new Promise((e) => setTimeout(e, (0, a.toMiliseconds)(+t))),
              t++;
          }
        }
        startPingTimeout() {
          var e, t, r, i, s;
          if ((0, eu.Lln)())
            try {
              null !=
                (t = null == (e = this.provider) ? void 0 : e.connection) &&
                t.socket &&
                (null ==
                  (s =
                    null ==
                    (i = null == (r = this.provider) ? void 0 : r.connection)
                      ? void 0
                      : i.socket) ||
                  s.on("ping", () => {
                    this.resetPingTimeout();
                  })),
                this.resetPingTimeout();
            } catch (e) {
              this.logger.warn(e, e?.message);
            }
        }
        async createProvider() {
          this.provider.connection && this.unregisterProviderListeners();
          let e = await this.core.crypto.signJWT(this.relayUrl);
          (this.provider = new eU(
            new eF(
              (0, eu.jUZ)({
                sdkVersion: eX,
                protocol: this.protocol,
                version: this.version,
                relayUrl: this.relayUrl,
                projectId: this.projectId,
                auth: e,
                useOnCloseEvent: !0,
                bundleId: this.bundleId,
                packageName: this.packageName,
              })
            )
          )),
            this.registerProviderListeners();
        }
        async recordMessageEvent(e, t) {
          let { topic: r, message: i } = e;
          await this.messages.set(r, i, t);
        }
        async shouldIgnoreMessageEvent(e) {
          let { topic: t, message: r } = e;
          if (!r || 0 === r.length)
            return this.logger.warn(`Ignoring invalid/empty message: ${r}`), !0;
          if (!(await this.subscriber.isKnownTopic(t)))
            return (
              this.logger.warn(`Ignoring message for unknown topic ${t}`), !0
            );
          let i = this.messages.has(t, r);
          return i && this.logger.warn(`Ignoring duplicate message: ${r}`), i;
        }
        async onProviderPayload(e) {
          if (
            (this.logger.debug("Incoming Relay Payload"),
            this.logger.trace({
              type: "payload",
              direction: "incoming",
              payload: e,
            }),
            ek(e))
          ) {
            if (!e.method.endsWith("_subscription")) return;
            let t = e.params,
              { topic: r, message: i, publishedAt: s, attestation: n } = t.data,
              a = {
                topic: r,
                message: i,
                publishedAt: s,
                transportType: e0.relay,
                attestation: n,
              };
            this.logger.debug("Emitting Relayer Payload"),
              this.logger.trace(rV({ type: "event", event: t.id }, a)),
              this.events.emit(t.id, a),
              await this.acknowledgePayload(e),
              await this.onMessageEvent(a);
          } else eR(e) && this.events.emit(eZ.message_ack, e);
        }
        async onMessageEvent(e) {
          (await this.shouldIgnoreMessageEvent(e)) ||
            (await this.recordMessageEvent(e, e1.inbound),
            this.events.emit(eZ.message, e));
        }
        async acknowledgePayload(e) {
          let t = e_(e.id, !0);
          await this.provider.connection.send(t);
        }
        unregisterProviderListeners() {
          this.provider.off(eJ.payload, this.onPayloadHandler),
            this.provider.off(eJ.connect, this.onConnectHandler),
            this.provider.off(eJ.disconnect, this.onDisconnectHandler),
            this.provider.off(eJ.error, this.onProviderErrorHandler),
            clearTimeout(this.pingTimeout);
        }
        async registerEventListeners() {
          let e = await (0, eu.sc7)();
          (0, eu.uym)(async (t) => {
            e !== t &&
              ((e = t),
              t
                ? await this.transportOpen().catch((e) =>
                    this.logger.error(e, e?.message)
                  )
                : ((this.hasExperiencedNetworkDisruption = !0),
                  await this.transportDisconnect(),
                  (this.transportExplicitlyClosed = !1)));
          });
        }
        async onProviderDisconnect() {
          clearTimeout(this.pingTimeout),
            this.events.emit(eZ.disconnect),
            (this.connectionAttemptInProgress = !1),
            !this.reconnectInProgress &&
              ((this.reconnectInProgress = !0),
              await this.subscriber.stop(),
              this.subscriber.hasAnyTopics &&
                (this.transportExplicitlyClosed ||
                  (this.reconnectTimeout = setTimeout(async () => {
                    await this.transportOpen().catch((e) =>
                      this.logger.error(e, e?.message)
                    ),
                      (this.reconnectTimeout = void 0),
                      (this.reconnectInProgress = !1);
                  }, (0, a.toMiliseconds)(0.1)))));
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = (0, eu.GuA)("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        async toEstablishConnection() {
          await this.confirmOnlineStateOrThrow(),
            this.connected || (await this.connect());
        }
      }
      function rY() {}
      function rQ(e) {
        if (!e || "object" != typeof e) return !1;
        let t = Object.getPrototypeOf(e);
        return (
          (null === t ||
            t === Object.prototype ||
            null === Object.getPrototypeOf(t)) &&
          "[object Object]" === Object.prototype.toString.call(e)
        );
      }
      function rZ(e) {
        return Object.getOwnPropertySymbols(e).filter((t) =>
          Object.prototype.propertyIsEnumerable.call(e, t)
        );
      }
      function rJ(e) {
        return null == e
          ? void 0 === e
            ? "[object Undefined]"
            : "[object Null]"
          : Object.prototype.toString.call(e);
      }
      let rX = "[object Arguments]",
        r0 = "[object Object]";
      var r1 = Object.defineProperty,
        r2 = Object.getOwnPropertySymbols,
        r3 = Object.prototype.hasOwnProperty,
        r5 = Object.prototype.propertyIsEnumerable,
        r8 = (e, t, r) =>
          t in e
            ? r1(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        r6 = (e, t) => {
          for (var r in t || (t = {})) r3.call(t, r) && r8(e, r, t[r]);
          if (r2) for (var r of r2(t)) r5.call(t, r) && r8(e, r, t[r]);
          return e;
        },
        r4 = (e, t, r) => r8(e, "symbol" != typeof t ? t + "" : t, r);
      class r9 extends J {
        constructor(e, t, r, i = eH, s) {
          super(e, t, r, i),
            (this.core = e),
            (this.logger = t),
            (this.name = r),
            r4(this, "map", new Map()),
            r4(this, "version", "0.3"),
            r4(this, "cached", []),
            r4(this, "initialized", !1),
            r4(this, "getKey"),
            r4(this, "storagePrefix", eH),
            r4(this, "recentlyDeleted", []),
            r4(this, "recentlyDeletedLimit", 200),
            r4(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                await this.restore(),
                this.cached.forEach((e) => {
                  this.getKey && null !== e && !(0, eu.b07)(e)
                    ? this.map.set(this.getKey(e), e)
                    : (0, eu.CTo)(e)
                    ? this.map.set(e.id, e)
                    : (0, eu.mr0)(e) && this.map.set(e.topic, e);
                }),
                (this.cached = []),
                (this.initialized = !0));
            }),
            r4(this, "set", async (e, t) => {
              this.isInitialized(),
                this.map.has(e)
                  ? await this.update(e, t)
                  : (this.logger.debug("Setting value"),
                    this.logger.trace({
                      type: "method",
                      method: "set",
                      key: e,
                      value: t,
                    }),
                    this.map.set(e, t),
                    await this.persist());
            }),
            r4(
              this,
              "get",
              (e) => (
                this.isInitialized(),
                this.logger.debug("Getting value"),
                this.logger.trace({ type: "method", method: "get", key: e }),
                this.getData(e)
              )
            ),
            r4(
              this,
              "getAll",
              (e) => (
                this.isInitialized(),
                e
                  ? this.values.filter((t) =>
                      Object.keys(e).every((r) => {
                        var i;
                        return (
                          (i = t[r]),
                          (function e(t, r, i, s, n, a, o) {
                            let c = o(t, r, i, s, n, a);
                            if (void 0 !== c) return c;
                            if (typeof t == typeof r)
                              switch (typeof t) {
                                case "bigint":
                                case "string":
                                case "boolean":
                                case "symbol":
                                case "undefined":
                                case "function":
                                  return t === r;
                                case "number":
                                  return t === r || Object.is(t, r);
                              }
                            return (function t(r, i, s, n) {
                              if (Object.is(r, i)) return !0;
                              let a = rJ(r),
                                o = rJ(i);
                              if (
                                (a === rX && (a = r0),
                                o === rX && (o = r0),
                                a !== o)
                              )
                                return !1;
                              switch (a) {
                                case "[object String]":
                                  return r.toString() === i.toString();
                                case "[object Number]": {
                                  let e = r.valueOf(),
                                    t = i.valueOf();
                                  return (
                                    e === t ||
                                    (Number.isNaN(e) && Number.isNaN(t))
                                  );
                                }
                                case "[object Boolean]":
                                case "[object Date]":
                                case "[object Symbol]":
                                  return Object.is(r.valueOf(), i.valueOf());
                                case "[object RegExp]":
                                  return (
                                    r.source === i.source && r.flags === i.flags
                                  );
                                case "[object Function]":
                                  return r === i;
                              }
                              let c = (s = s ?? new Map()).get(r),
                                l = s.get(i);
                              if (null != c && null != l) return c === i;
                              s.set(r, i), s.set(i, r);
                              try {
                                switch (a) {
                                  case "[object Map]":
                                    if (r.size !== i.size) return !1;
                                    for (let [t, a] of r.entries())
                                      if (
                                        !i.has(t) ||
                                        !e(a, i.get(t), t, r, i, s, n)
                                      )
                                        return !1;
                                    return !0;
                                  case "[object Set]": {
                                    if (r.size !== i.size) return !1;
                                    let t = Array.from(r.values()),
                                      a = Array.from(i.values());
                                    for (let o = 0; o < t.length; o++) {
                                      let c = t[o],
                                        l = a.findIndex((t) =>
                                          e(c, t, void 0, r, i, s, n)
                                        );
                                      if (-1 === l) return !1;
                                      a.splice(l, 1);
                                    }
                                    return !0;
                                  }
                                  case "[object Array]":
                                  case "[object Uint8Array]":
                                  case "[object Uint8ClampedArray]":
                                  case "[object Uint16Array]":
                                  case "[object Uint32Array]":
                                  case "[object BigUint64Array]":
                                  case "[object Int8Array]":
                                  case "[object Int16Array]":
                                  case "[object Int32Array]":
                                  case "[object BigInt64Array]":
                                  case "[object Float32Array]":
                                  case "[object Float64Array]":
                                    if (
                                      ("u" > typeof ez &&
                                        ez.isBuffer(r) !== ez.isBuffer(i)) ||
                                      r.length !== i.length
                                    )
                                      return !1;
                                    for (let t = 0; t < r.length; t++)
                                      if (!e(r[t], i[t], t, r, i, s, n))
                                        return !1;
                                    return !0;
                                  case "[object ArrayBuffer]":
                                    return (
                                      r.byteLength === i.byteLength &&
                                      t(
                                        new Uint8Array(r),
                                        new Uint8Array(i),
                                        s,
                                        n
                                      )
                                    );
                                  case "[object DataView]":
                                    return (
                                      r.byteLength === i.byteLength &&
                                      r.byteOffset === i.byteOffset &&
                                      t(
                                        new Uint8Array(r),
                                        new Uint8Array(i),
                                        s,
                                        n
                                      )
                                    );
                                  case "[object Error]":
                                    return (
                                      r.name === i.name &&
                                      r.message === i.message
                                    );
                                  case r0: {
                                    if (
                                      !(
                                        t(r.constructor, i.constructor, s, n) ||
                                        (rQ(r) && rQ(i))
                                      )
                                    )
                                      return !1;
                                    let a = [...Object.keys(r), ...rZ(r)],
                                      o = [...Object.keys(i), ...rZ(i)];
                                    if (a.length !== o.length) return !1;
                                    for (let t = 0; t < a.length; t++) {
                                      let o = a[t],
                                        c = r[o];
                                      if (!Object.hasOwn(i, o)) return !1;
                                      let l = i[o];
                                      if (!e(c, l, o, r, i, s, n)) return !1;
                                    }
                                    return !0;
                                  }
                                  default:
                                    return !1;
                                }
                              } finally {
                                s.delete(r), s.delete(i);
                              }
                            })(t, r, a, o);
                          })(i, e[r], void 0, void 0, void 0, void 0, rY)
                        );
                      })
                    )
                  : this.values
              )
            ),
            r4(this, "update", async (e, t) => {
              this.isInitialized(),
                this.logger.debug("Updating value"),
                this.logger.trace({
                  type: "method",
                  method: "update",
                  key: e,
                  update: t,
                });
              let r = r6(r6({}, this.getData(e)), t);
              this.map.set(e, r), await this.persist();
            }),
            r4(this, "delete", async (e, t) => {
              this.isInitialized(),
                this.map.has(e) &&
                  (this.logger.debug("Deleting value"),
                  this.logger.trace({
                    type: "method",
                    method: "delete",
                    key: e,
                    reason: t,
                  }),
                  this.map.delete(e),
                  this.addToRecentlyDeleted(e),
                  await this.persist());
            }),
            (this.logger = (0, F.U5)(t, this.name)),
            (this.storagePrefix = i),
            (this.getKey = s);
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get length() {
          return this.map.size;
        }
        get keys() {
          return Array.from(this.map.keys());
        }
        get values() {
          return Array.from(this.map.values());
        }
        addToRecentlyDeleted(e) {
          this.recentlyDeleted.push(e),
            this.recentlyDeleted.length >= this.recentlyDeletedLimit &&
              this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
        }
        async setDataStore(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getDataStore() {
          return await this.core.storage.getItem(this.storageKey);
        }
        getData(e) {
          let t = this.map.get(e);
          if (!t) {
            if (this.recentlyDeleted.includes(e)) {
              let { message: t } = (0, eu.GuA)(
                "MISSING_OR_INVALID",
                `Record was recently deleted - ${this.name}: ${e}`
              );
              throw (this.logger.error(t), Error(t));
            }
            let { message: t } = (0, eu.GuA)(
              "NO_MATCHING_KEY",
              `${this.name}: ${e}`
            );
            throw (this.logger.error(t), Error(t));
          }
          return t;
        }
        async persist() {
          await this.setDataStore(this.values);
        }
        async restore() {
          try {
            let e = await this.getDataStore();
            if (typeof e > "u" || !e.length) return;
            if (this.map.size) {
              let { message: e } = (0, eu.GuA)(
                "RESTORE_WILL_OVERRIDE",
                this.name
              );
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(`Successfully Restored value for ${this.name}`),
              this.logger.trace({
                type: "method",
                method: "restore",
                value: this.values,
              });
          } catch (e) {
            this.logger.debug(`Failed to Restore value for ${this.name}`),
              this.logger.error(e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = (0, eu.GuA)("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var r7 = Object.defineProperty,
        ie = (e, t, r) =>
          t in e
            ? r7(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        it = (e, t, r) => ie(e, "symbol" != typeof t ? t + "" : t, r);
      class ir {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            it(this, "name", "pairing"),
            it(this, "version", "0.3"),
            it(this, "events", new (n())()),
            it(this, "pairings"),
            it(this, "initialized", !1),
            it(this, "storagePrefix", eH),
            it(this, "ignoredPayloadTypes", [eu.Lp_]),
            it(this, "registeredMethods", []),
            it(this, "init", async () => {
              this.initialized ||
                (await this.pairings.init(),
                await this.cleanup(),
                this.registerRelayerEvents(),
                this.registerExpirerEvents(),
                (this.initialized = !0),
                this.logger.trace("Initialized"));
            }),
            it(this, "register", ({ methods: e }) => {
              this.isInitialized(),
                (this.registeredMethods = [
                  ...new Set([...this.registeredMethods, ...e]),
                ]);
            }),
            it(this, "create", async (e) => {
              this.isInitialized();
              let t = (0, eu.two)(),
                r = await this.core.crypto.setSymKey(t),
                i = (0, eu.Xw0)(a.FIVE_MINUTES),
                s = { protocol: "irn" },
                n = {
                  topic: r,
                  expiry: i,
                  relay: s,
                  active: !1,
                  methods: e?.methods,
                },
                o = (0, eu.QJh)({
                  protocol: this.core.protocol,
                  version: this.core.version,
                  topic: r,
                  symKey: t,
                  relay: s,
                  expiryTimestamp: i,
                  methods: e?.methods,
                });
              return (
                this.events.emit(e8.create, n),
                this.core.expirer.set(r, i),
                await this.pairings.set(r, n),
                await this.core.relayer.subscribe(r, {
                  transportType: e?.transportType,
                }),
                { topic: r, uri: o }
              );
            }),
            it(this, "pair", async (e) => {
              let t;
              this.isInitialized();
              let r = this.core.eventClient.createEvent({
                properties: { topic: e?.uri, trace: [tt.pairing_started] },
              });
              this.isValidPair(e, r);
              let {
                topic: i,
                symKey: s,
                relay: n,
                expiryTimestamp: o,
                methods: c,
              } = (0, eu.wYp)(e.uri);
              if (
                ((r.props.properties.topic = i),
                r.addTrace(tt.pairing_uri_validation_success),
                r.addTrace(tt.pairing_uri_not_expired),
                this.pairings.keys.includes(i))
              ) {
                if (
                  ((t = this.pairings.get(i)),
                  r.addTrace(tt.existing_pairing),
                  t.active)
                )
                  throw (
                    (r.setError(tr.active_pairing_already_exists),
                    Error(
                      `Pairing already exists: ${i}. Please try again with a new connection URI.`
                    ))
                  );
                r.addTrace(tt.pairing_not_expired);
              }
              let l = o || (0, eu.Xw0)(a.FIVE_MINUTES),
                d = { topic: i, relay: n, expiry: l, active: !1, methods: c };
              this.core.expirer.set(i, l),
                await this.pairings.set(i, d),
                r.addTrace(tt.store_new_pairing),
                e.activatePairing && (await this.activate({ topic: i })),
                this.events.emit(e8.create, d),
                r.addTrace(tt.emit_inactive_pairing),
                this.core.crypto.keychain.has(i) ||
                  (await this.core.crypto.setSymKey(s, i)),
                r.addTrace(tt.subscribing_pairing_topic);
              try {
                await this.core.relayer.confirmOnlineStateOrThrow();
              } catch {
                r.setError(tr.no_internet_connection);
              }
              try {
                await this.core.relayer.subscribe(i, { relay: n });
              } catch (e) {
                throw (r.setError(tr.subscribe_pairing_topic_failure), e);
              }
              return r.addTrace(tt.subscribe_pairing_topic_success), d;
            }),
            it(this, "activate", async ({ topic: e }) => {
              this.isInitialized();
              let t = (0, eu.Xw0)(a.FIVE_MINUTES);
              this.core.expirer.set(e, t),
                await this.pairings.update(e, { active: !0, expiry: t });
            }),
            it(this, "ping", async (e) => {
              this.isInitialized(),
                await this.isValidPing(e),
                this.logger.warn(
                  "ping() is deprecated and will be removed in the next major release."
                );
              let { topic: t } = e;
              if (this.pairings.keys.includes(t)) {
                let e = await this.sendRequest(t, "wc_pairingPing", {}),
                  { done: r, resolve: i, reject: s } = (0, eu.Wx8)();
                this.events.once(
                  (0, eu.hEn)("pairing_ping", e),
                  ({ error: e }) => {
                    e ? s(e) : i();
                  }
                ),
                  await r();
              }
            }),
            it(this, "updateExpiry", async ({ topic: e, expiry: t }) => {
              this.isInitialized(),
                await this.pairings.update(e, { expiry: t });
            }),
            it(this, "updateMetadata", async ({ topic: e, metadata: t }) => {
              this.isInitialized(),
                await this.pairings.update(e, { peerMetadata: t });
            }),
            it(
              this,
              "getPairings",
              () => (this.isInitialized(), this.pairings.values)
            ),
            it(this, "disconnect", async (e) => {
              this.isInitialized(), await this.isValidDisconnect(e);
              let { topic: t } = e;
              this.pairings.keys.includes(t) &&
                (await this.sendRequest(
                  t,
                  "wc_pairingDelete",
                  (0, eu.Hjj)("USER_DISCONNECTED")
                ),
                await this.deletePairing(t));
            }),
            it(this, "formatUriFromPairing", (e) => {
              this.isInitialized();
              let { topic: t, relay: r, expiry: i, methods: s } = e,
                n = this.core.crypto.keychain.get(t);
              return (0, eu.QJh)({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: t,
                symKey: n,
                relay: r,
                expiryTimestamp: i,
                methods: s,
              });
            }),
            it(this, "sendRequest", async (e, t, r) => {
              let i = eE(t, r),
                s = await this.core.crypto.encode(e, i),
                n = e5[t].req;
              return (
                this.core.history.set(e, i),
                this.core.relayer.publish(e, s, n),
                i.id
              );
            }),
            it(this, "sendResult", async (e, t, r) => {
              let i = e_(e, r),
                s = await this.core.crypto.encode(t, i),
                n = e5[(await this.core.history.get(t, e)).request.method].res;
              await this.core.relayer.publish(t, s, n),
                await this.core.history.resolve(i);
            }),
            it(this, "sendError", async (e, t, r) => {
              let i = eC(e, r),
                s = await this.core.crypto.encode(t, i),
                n = (await this.core.history.get(t, e)).request.method,
                a = e5[n] ? e5[n].res : e5.unregistered_method.res;
              await this.core.relayer.publish(t, s, a),
                await this.core.history.resolve(i);
            }),
            it(this, "deletePairing", async (e, t) => {
              await this.core.relayer.unsubscribe(e),
                await Promise.all([
                  this.pairings.delete(e, (0, eu.Hjj)("USER_DISCONNECTED")),
                  this.core.crypto.deleteSymKey(e),
                  t ? Promise.resolve() : this.core.expirer.del(e),
                ]);
            }),
            it(this, "cleanup", async () => {
              let e = this.pairings
                .getAll()
                .filter((e) => (0, eu._dF)(e.expiry));
              await Promise.all(e.map((e) => this.deletePairing(e.topic)));
            }),
            it(this, "onRelayEventRequest", async (e) => {
              let { topic: t, payload: r } = e;
              switch (r.method) {
                case "wc_pairingPing":
                  return await this.onPairingPingRequest(t, r);
                case "wc_pairingDelete":
                  return await this.onPairingDeleteRequest(t, r);
                default:
                  return await this.onUnknownRpcMethodRequest(t, r);
              }
            }),
            it(this, "onRelayEventResponse", async (e) => {
              let { topic: t, payload: r } = e,
                i = (await this.core.history.get(t, r.id)).request.method;
              return "wc_pairingPing" === i
                ? this.onPairingPingResponse(t, r)
                : this.onUnknownRpcMethodResponse(i);
            }),
            it(this, "onPairingPingRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidPing({ topic: e }),
                  await this.sendResult(r, e, !0),
                  this.events.emit(e8.ping, { id: r, topic: e });
              } catch (t) {
                await this.sendError(r, e, t), this.logger.error(t);
              }
            }),
            it(this, "onPairingPingResponse", (e, t) => {
              let { id: r } = t;
              setTimeout(() => {
                eD(t)
                  ? this.events.emit((0, eu.hEn)("pairing_ping", r), {})
                  : eM(t) &&
                    this.events.emit((0, eu.hEn)("pairing_ping", r), {
                      error: t.error,
                    });
              }, 500);
            }),
            it(this, "onPairingDeleteRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidDisconnect({ topic: e }),
                  await this.deletePairing(e),
                  this.events.emit(e8.delete, { id: r, topic: e });
              } catch (t) {
                await this.sendError(r, e, t), this.logger.error(t);
              }
            }),
            it(this, "onUnknownRpcMethodRequest", async (e, t) => {
              let { id: r, method: i } = t;
              try {
                if (this.registeredMethods.includes(i)) return;
                let t = (0, eu.Hjj)("WC_METHOD_UNSUPPORTED", i);
                await this.sendError(r, e, t), this.logger.error(t);
              } catch (t) {
                await this.sendError(r, e, t), this.logger.error(t);
              }
            }),
            it(this, "onUnknownRpcMethodResponse", (e) => {
              this.registeredMethods.includes(e) ||
                this.logger.error((0, eu.Hjj)("WC_METHOD_UNSUPPORTED", e));
            }),
            it(this, "isValidPair", (e, t) => {
              var r;
              if (!(0, eu.TeY)(e)) {
                let { message: r } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `pair() params: ${e}`
                );
                throw (t.setError(tr.malformed_pairing_uri), Error(r));
              }
              if (!(0, eu.AYU)(e.uri)) {
                let { message: r } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `pair() uri: ${e.uri}`
                );
                throw (t.setError(tr.malformed_pairing_uri), Error(r));
              }
              let i = (0, eu.wYp)(e?.uri);
              if (!(null != (r = i?.relay) && r.protocol)) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  "pair() uri#relay-protocol"
                );
                throw (t.setError(tr.malformed_pairing_uri), Error(e));
              }
              if (!(null != i && i.symKey)) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  "pair() uri#symKey"
                );
                throw (t.setError(tr.malformed_pairing_uri), Error(e));
              }
              if (
                null != i &&
                i.expiryTimestamp &&
                (0, a.toMiliseconds)(i?.expiryTimestamp) < Date.now()
              ) {
                t.setError(tr.pairing_expired);
                let { message: e } = (0, eu.GuA)(
                  "EXPIRED",
                  "pair() URI has expired. Please try again with a new connection URI."
                );
                throw Error(e);
              }
            }),
            it(this, "isValidPing", async (e) => {
              if (!(0, eu.TeY)(e)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `ping() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidPairingTopic(t);
            }),
            it(this, "isValidDisconnect", async (e) => {
              if (!(0, eu.TeY)(e)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `disconnect() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidPairingTopic(t);
            }),
            it(this, "isValidPairingTopic", async (e) => {
              if (!(0, eu.Qhg)(e, !1)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `pairing topic should be a string: ${e}`
                );
                throw Error(t);
              }
              if (!this.pairings.keys.includes(e)) {
                let { message: t } = (0, eu.GuA)(
                  "NO_MATCHING_KEY",
                  `pairing topic doesn't exist: ${e}`
                );
                throw Error(t);
              }
              if ((0, eu._dF)(this.pairings.get(e).expiry)) {
                await this.deletePairing(e);
                let { message: t } = (0, eu.GuA)(
                  "EXPIRED",
                  `pairing topic: ${e}`
                );
                throw Error(t);
              }
            }),
            (this.core = e),
            (this.logger = (0, F.U5)(t, this.name)),
            (this.pairings = new r9(
              this.core,
              this.logger,
              this.name,
              this.storagePrefix
            ));
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = (0, eu.GuA)("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        registerRelayerEvents() {
          this.core.relayer.on(eZ.message, async (e) => {
            let { topic: t, message: r, transportType: i } = e;
            if (
              this.pairings.keys.includes(t) &&
              i !== e0.link_mode &&
              !this.ignoredPayloadTypes.includes(
                this.core.crypto.getPayloadType(r)
              )
            )
              try {
                let e = await this.core.crypto.decode(t, r);
                ek(e)
                  ? (this.core.history.set(t, e),
                    await this.onRelayEventRequest({ topic: t, payload: e }))
                  : eR(e) &&
                    (await this.core.history.resolve(e),
                    await this.onRelayEventResponse({ topic: t, payload: e }),
                    this.core.history.delete(t, e.id)),
                  await this.core.relayer.messages.ack(t, r);
              } catch (e) {
                this.logger.error(e);
              }
          });
        }
        registerExpirerEvents() {
          this.core.expirer.on(e4.expired, async (e) => {
            let { topic: t } = (0, eu.c82)(e.target);
            t &&
              this.pairings.keys.includes(t) &&
              (await this.deletePairing(t, !0),
              this.events.emit(e8.expire, { topic: t }));
          });
        }
      }
      var ii = Object.defineProperty,
        is = (e, t, r) =>
          t in e
            ? ii(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ia = (e, t, r) => is(e, "symbol" != typeof t ? t + "" : t, r);
      class io extends G {
        constructor(e, t) {
          super(e, t),
            (this.core = e),
            (this.logger = t),
            ia(this, "records", new Map()),
            ia(this, "events", new s.EventEmitter()),
            ia(this, "name", "history"),
            ia(this, "version", "0.3"),
            ia(this, "cached", []),
            ia(this, "initialized", !1),
            ia(this, "storagePrefix", eH),
            ia(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                await this.restore(),
                this.cached.forEach((e) => this.records.set(e.id, e)),
                (this.cached = []),
                this.registerEventListeners(),
                (this.initialized = !0));
            }),
            ia(this, "set", (e, t, r) => {
              if (
                (this.isInitialized(),
                this.logger.debug("Setting JSON-RPC request history record"),
                this.logger.trace({
                  type: "method",
                  method: "set",
                  topic: e,
                  request: t,
                  chainId: r,
                }),
                this.records.has(t.id))
              )
                return;
              let i = {
                id: t.id,
                topic: e,
                request: { method: t.method, params: t.params || null },
                chainId: r,
                expiry: (0, eu.Xw0)(a.THIRTY_DAYS),
              };
              this.records.set(i.id, i),
                this.persist(),
                this.events.emit(e6.created, i);
            }),
            ia(this, "resolve", async (e) => {
              if (
                (this.isInitialized(),
                this.logger.debug("Updating JSON-RPC response history record"),
                this.logger.trace({
                  type: "method",
                  method: "update",
                  response: e,
                }),
                !this.records.has(e.id))
              )
                return;
              let t = await this.getRecord(e.id);
              typeof t.response > "u" &&
                ((t.response = eM(e)
                  ? { error: e.error }
                  : { result: e.result }),
                this.records.set(t.id, t),
                this.persist(),
                this.events.emit(e6.updated, t));
            }),
            ia(
              this,
              "get",
              async (e, t) => (
                this.isInitialized(),
                this.logger.debug("Getting record"),
                this.logger.trace({
                  type: "method",
                  method: "get",
                  topic: e,
                  id: t,
                }),
                await this.getRecord(t)
              )
            ),
            ia(this, "delete", (e, t) => {
              this.isInitialized(),
                this.logger.debug("Deleting record"),
                this.logger.trace({ type: "method", method: "delete", id: t }),
                this.values.forEach((r) => {
                  r.topic !== e ||
                    ("u" > typeof t && r.id !== t) ||
                    (this.records.delete(r.id),
                    this.events.emit(e6.deleted, r));
                }),
                this.persist();
            }),
            ia(
              this,
              "exists",
              async (e, t) => (
                this.isInitialized(),
                !!this.records.has(t) && (await this.getRecord(t)).topic === e
              )
            ),
            ia(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            ia(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            ia(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            ia(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.logger = (0, F.U5)(t, this.name));
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get size() {
          return this.records.size;
        }
        get keys() {
          return Array.from(this.records.keys());
        }
        get values() {
          return Array.from(this.records.values());
        }
        get pending() {
          let e = [];
          return (
            this.values.forEach((t) => {
              if ("u" > typeof t.response) return;
              let r = {
                topic: t.topic,
                request: eE(t.request.method, t.request.params, t.id),
                chainId: t.chainId,
              };
              return e.push(r);
            }),
            e
          );
        }
        async setJsonRpcRecords(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getJsonRpcRecords() {
          return await this.core.storage.getItem(this.storageKey);
        }
        getRecord(e) {
          this.isInitialized();
          let t = this.records.get(e);
          if (!t) {
            let { message: t } = (0, eu.GuA)(
              "NO_MATCHING_KEY",
              `${this.name}: ${e}`
            );
            throw Error(t);
          }
          return t;
        }
        async persist() {
          await this.setJsonRpcRecords(this.values), this.events.emit(e6.sync);
        }
        async restore() {
          try {
            let e = await this.getJsonRpcRecords();
            if (typeof e > "u" || !e.length) return;
            if (this.records.size) {
              let { message: e } = (0, eu.GuA)(
                "RESTORE_WILL_OVERRIDE",
                this.name
              );
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(
                `Successfully Restored records for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                records: this.values,
              });
          } catch (e) {
            this.logger.debug(`Failed to Restore records for ${this.name}`),
              this.logger.error(e);
          }
        }
        registerEventListeners() {
          this.events.on(e6.created, (e) => {
            let t = e6.created;
            this.logger.info(`Emitting ${t}`),
              this.logger.debug({ type: "event", event: t, record: e });
          }),
            this.events.on(e6.updated, (e) => {
              let t = e6.updated;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, record: e });
            }),
            this.events.on(e6.deleted, (e) => {
              let t = e6.deleted;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, record: e });
            }),
            this.core.heartbeat.on(d.pulse, () => {
              this.cleanup();
            });
        }
        cleanup() {
          try {
            this.isInitialized();
            let e = !1;
            this.records.forEach((t) => {
              (0, a.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 &&
                (this.logger.info(`Deleting expired history log: ${t.id}`),
                this.records.delete(t.id),
                this.events.emit(e6.deleted, t, !1),
                (e = !0));
            }),
              e && this.persist();
          } catch (e) {
            this.logger.warn(e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = (0, eu.GuA)("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var ic = Object.defineProperty,
        il = (e, t, r) =>
          t in e
            ? ic(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        id = (e, t, r) => il(e, "symbol" != typeof t ? t + "" : t, r);
      class iu extends et {
        constructor(e, t) {
          super(e, t),
            (this.core = e),
            (this.logger = t),
            id(this, "expirations", new Map()),
            id(this, "events", new s.EventEmitter()),
            id(this, "name", "expirer"),
            id(this, "version", "0.3"),
            id(this, "cached", []),
            id(this, "initialized", !1),
            id(this, "storagePrefix", eH),
            id(this, "init", async () => {
              this.initialized ||
                (this.logger.trace("Initialized"),
                await this.restore(),
                this.cached.forEach((e) => this.expirations.set(e.target, e)),
                (this.cached = []),
                this.registerEventListeners(),
                (this.initialized = !0));
            }),
            id(this, "has", (e) => {
              try {
                let t = this.formatTarget(e);
                return "u" > typeof this.getExpiration(t);
              } catch {
                return !1;
              }
            }),
            id(this, "set", (e, t) => {
              this.isInitialized();
              let r = this.formatTarget(e),
                i = { target: r, expiry: t };
              this.expirations.set(r, i),
                this.checkExpiry(r, i),
                this.events.emit(e4.created, { target: r, expiration: i });
            }),
            id(this, "get", (e) => {
              this.isInitialized();
              let t = this.formatTarget(e);
              return this.getExpiration(t);
            }),
            id(this, "del", (e) => {
              if ((this.isInitialized(), this.has(e))) {
                let t = this.formatTarget(e),
                  r = this.getExpiration(t);
                this.expirations.delete(t),
                  this.events.emit(e4.deleted, { target: t, expiration: r });
              }
            }),
            id(this, "on", (e, t) => {
              this.events.on(e, t);
            }),
            id(this, "once", (e, t) => {
              this.events.once(e, t);
            }),
            id(this, "off", (e, t) => {
              this.events.off(e, t);
            }),
            id(this, "removeListener", (e, t) => {
              this.events.removeListener(e, t);
            }),
            (this.logger = (0, F.U5)(t, this.name));
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//" +
            this.name
          );
        }
        get length() {
          return this.expirations.size;
        }
        get keys() {
          return Array.from(this.expirations.keys());
        }
        get values() {
          return Array.from(this.expirations.values());
        }
        formatTarget(e) {
          if ("string" == typeof e) return (0, eu.ADD)(e);
          if ("number" == typeof e) return (0, eu.gOF)(e);
          let { message: t } = (0, eu.GuA)(
            "UNKNOWN_TYPE",
            `Target type: ${typeof e}`
          );
          throw Error(t);
        }
        async setExpirations(e) {
          await this.core.storage.setItem(this.storageKey, e);
        }
        async getExpirations() {
          return await this.core.storage.getItem(this.storageKey);
        }
        async persist() {
          await this.setExpirations(this.values), this.events.emit(e4.sync);
        }
        async restore() {
          try {
            let e = await this.getExpirations();
            if (typeof e > "u" || !e.length) return;
            if (this.expirations.size) {
              let { message: e } = (0, eu.GuA)(
                "RESTORE_WILL_OVERRIDE",
                this.name
              );
              throw (this.logger.error(e), Error(e));
            }
            (this.cached = e),
              this.logger.debug(
                `Successfully Restored expirations for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                expirations: this.values,
              });
          } catch (e) {
            this.logger.debug(`Failed to Restore expirations for ${this.name}`),
              this.logger.error(e);
          }
        }
        getExpiration(e) {
          let t = this.expirations.get(e);
          if (!t) {
            let { message: t } = (0, eu.GuA)(
              "NO_MATCHING_KEY",
              `${this.name}: ${e}`
            );
            throw (this.logger.warn(t), Error(t));
          }
          return t;
        }
        checkExpiry(e, t) {
          let { expiry: r } = t;
          (0, a.toMiliseconds)(r) - Date.now() <= 0 && this.expire(e, t);
        }
        expire(e, t) {
          this.expirations.delete(e),
            this.events.emit(e4.expired, { target: e, expiration: t });
        }
        checkExpirations() {
          this.core.relayer.connected &&
            this.expirations.forEach((e, t) => this.checkExpiry(t, e));
        }
        registerEventListeners() {
          this.core.heartbeat.on(d.pulse, () => this.checkExpirations()),
            this.events.on(e4.created, (e) => {
              let t = e4.created;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, data: e }),
                this.persist();
            }),
            this.events.on(e4.expired, (e) => {
              let t = e4.expired;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, data: e }),
                this.persist();
            }),
            this.events.on(e4.deleted, (e) => {
              let t = e4.deleted;
              this.logger.info(`Emitting ${t}`),
                this.logger.debug({ type: "event", event: t, data: e }),
                this.persist();
            });
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = (0, eu.GuA)("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
      }
      var ih = Object.defineProperty,
        ip = (e, t, r) =>
          t in e
            ? ih(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ig = (e, t, r) => ip(e, "symbol" != typeof t ? t + "" : t, r);
      class im extends er {
        constructor(e, t, r) {
          super(e, t, r),
            (this.core = e),
            (this.logger = t),
            (this.store = r),
            ig(this, "name", "verify-api"),
            ig(this, "abortController"),
            ig(this, "isDevEnv"),
            ig(this, "verifyUrlV3", e7),
            ig(this, "storagePrefix", eH),
            ig(this, "version", 2),
            ig(this, "publicKey"),
            ig(this, "fetchPromise"),
            ig(this, "init", async () => {
              var e;
              this.isDevEnv ||
                ((this.publicKey = await this.store.getItem(this.storeKey)),
                this.publicKey &&
                  (0, a.toMiliseconds)(
                    null == (e = this.publicKey) ? void 0 : e.expiresAt
                  ) < Date.now() &&
                  (this.logger.debug("verify v2 public key expired"),
                  await this.removePublicKey()));
            }),
            ig(this, "register", async (e) => {
              if (!(0, eu.BdH)() || this.isDevEnv) return;
              let t = window.location.origin,
                { id: r, decryptedId: i } = e,
                s = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${t}&id=${r}&decryptedId=${i}`;
              try {
                let e = (0, e$.getDocument)(),
                  t = this.startAbortTimer(5 * a.ONE_SECOND),
                  i = await new Promise((i, n) => {
                    let a = () => {
                      window.removeEventListener("message", c),
                        e.body.removeChild(o),
                        n("attestation aborted");
                    };
                    this.abortController.signal.addEventListener("abort", a);
                    let o = e.createElement("iframe");
                    (o.src = s),
                      (o.style.display = "none"),
                      o.addEventListener("error", a, {
                        signal: this.abortController.signal,
                      });
                    let c = (s) => {
                      if (s.data && "string" == typeof s.data)
                        try {
                          let n = JSON.parse(s.data);
                          if ("verify_attestation" === n.type) {
                            if ((0, ed.Cq)(n.attestation).payload.id !== r)
                              return;
                            clearInterval(t),
                              e.body.removeChild(o),
                              this.abortController.signal.removeEventListener(
                                "abort",
                                a
                              ),
                              window.removeEventListener("message", c),
                              i(null === n.attestation ? "" : n.attestation);
                          }
                        } catch (e) {
                          this.logger.warn(e);
                        }
                    };
                    e.body.appendChild(o),
                      window.addEventListener("message", c, {
                        signal: this.abortController.signal,
                      });
                  });
                return this.logger.debug("jwt attestation", i), i;
              } catch (e) {
                this.logger.warn(e);
              }
              return "";
            }),
            ig(this, "resolve", async (e) => {
              if (this.isDevEnv) return "";
              let { attestationId: t, hash: r, encryptedId: i } = e;
              if ("" === t) {
                this.logger.debug("resolve: attestationId is empty, skipping");
                return;
              }
              if (t) {
                if ((0, ed.Cq)(t).payload.id !== i) return;
                let e = await this.isValidJwtAttestation(t);
                if (e) {
                  if (!e.isVerified) {
                    this.logger.warn(
                      "resolve: jwt attestation: origin url not verified"
                    );
                    return;
                  }
                  return e;
                }
              }
              if (!r) return;
              let s = this.getVerifyUrl(e?.verifyUrl);
              return this.fetchAttestation(r, s);
            }),
            ig(this, "fetchAttestation", async (e, t) => {
              this.logger.debug(`resolving attestation: ${e} from url: ${t}`);
              let r = this.startAbortTimer(5 * a.ONE_SECOND),
                i = await fetch(`${t}/attestation/${e}?v2Supported=true`, {
                  signal: this.abortController.signal,
                });
              return (
                clearTimeout(r), 200 === i.status ? await i.json() : void 0
              );
            }),
            ig(this, "getVerifyUrl", (e) => {
              let t = e || e9;
              return (
                te.includes(t) ||
                  (this.logger.info(
                    `verify url: ${t}, not included in trusted list, assigning default: ${e9}`
                  ),
                  (t = e9)),
                t
              );
            }),
            ig(this, "fetchPublicKey", async () => {
              try {
                this.logger.debug(
                  `fetching public key from: ${this.verifyUrlV3}`
                );
                let e = this.startAbortTimer(a.FIVE_SECONDS),
                  t = await fetch(`${this.verifyUrlV3}/public-key`, {
                    signal: this.abortController.signal,
                  });
                return clearTimeout(e), await t.json();
              } catch (e) {
                this.logger.warn(e);
              }
            }),
            ig(this, "persistPublicKey", async (e) => {
              this.logger.debug("persisting public key to local storage", e),
                await this.store.setItem(this.storeKey, e),
                (this.publicKey = e);
            }),
            ig(this, "removePublicKey", async () => {
              this.logger.debug("removing verify v2 public key from storage"),
                await this.store.removeItem(this.storeKey),
                (this.publicKey = void 0);
            }),
            ig(this, "isValidJwtAttestation", async (e) => {
              let t = await this.getPublicKey();
              try {
                if (t) return this.validateAttestation(e, t);
              } catch (e) {
                this.logger.error(e),
                  this.logger.warn("error validating attestation");
              }
              let r = await this.fetchAndPersistPublicKey();
              try {
                if (r) return this.validateAttestation(e, r);
              } catch (e) {
                this.logger.error(e),
                  this.logger.warn("error validating attestation");
              }
            }),
            ig(this, "getPublicKey", async () =>
              this.publicKey
                ? this.publicKey
                : await this.fetchAndPersistPublicKey()
            ),
            ig(this, "fetchAndPersistPublicKey", async () => {
              if (this.fetchPromise)
                return await this.fetchPromise, this.publicKey;
              this.fetchPromise = new Promise(async (e) => {
                let t = await this.fetchPublicKey();
                t && (await this.persistPublicKey(t), e(t));
              });
              let e = await this.fetchPromise;
              return (this.fetchPromise = void 0), e;
            }),
            ig(this, "validateAttestation", (e, t) => {
              let r = (0, eu.U0i)(e, t.publicKey),
                i = {
                  hasExpired: (0, a.toMiliseconds)(r.exp) < Date.now(),
                  payload: r,
                };
              if (i.hasExpired)
                throw (
                  (this.logger.warn("resolve: jwt attestation expired"),
                  Error("JWT attestation expired"))
                );
              return {
                origin: i.payload.origin,
                isScam: i.payload.isScam,
                isVerified: i.payload.isVerified,
              };
            }),
            (this.logger = (0, F.U5)(t, this.name)),
            (this.abortController = new AbortController()),
            (this.isDevEnv = (0, eu.w8K)()),
            this.init();
        }
        get storeKey() {
          return (
            this.storagePrefix +
            this.version +
            this.core.customStoragePrefix +
            "//verify:public:key"
          );
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        startAbortTimer(e) {
          return (
            (this.abortController = new AbortController()),
            setTimeout(
              () => this.abortController.abort(),
              (0, a.toMiliseconds)(e)
            )
          );
        }
      }
      var ib = Object.defineProperty,
        iy = (e, t, r) =>
          t in e
            ? ib(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        iw = (e, t, r) => iy(e, "symbol" != typeof t ? t + "" : t, r);
      class iv extends ei {
        constructor(e, t) {
          super(e, t),
            (this.projectId = e),
            (this.logger = t),
            iw(this, "context", "echo"),
            iw(this, "registerDeviceToken", async (e) => {
              let {
                  clientId: t,
                  token: r,
                  notificationType: i,
                  enableEncrypted: s = !1,
                } = e,
                n = `https://echo.walletconnect.com/${this.projectId}/clients`;
              await fetch(n, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  client_id: t,
                  type: i,
                  token: r,
                  always_raw: s,
                }),
              });
            }),
            (this.logger = (0, F.U5)(t, this.context));
        }
      }
      var iA = Object.defineProperty,
        iE = Object.getOwnPropertySymbols,
        i_ = Object.prototype.hasOwnProperty,
        iC = Object.prototype.propertyIsEnumerable,
        iI = (e, t, r) =>
          t in e
            ? iA(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        iS = (e, t) => {
          for (var r in t || (t = {})) i_.call(t, r) && iI(e, r, t[r]);
          if (iE) for (var r of iE(t)) iC.call(t, r) && iI(e, r, t[r]);
          return e;
        },
        ix = (e, t, r) => iI(e, "symbol" != typeof t ? t + "" : t, r);
      class iN extends es {
        constructor(e, t, r = !0) {
          super(e, t, r),
            (this.core = e),
            (this.logger = t),
            ix(this, "context", "event-client"),
            ix(this, "storagePrefix", eH),
            ix(this, "storageVersion", 0.1),
            ix(this, "events", new Map()),
            ix(this, "shouldPersist", !1),
            ix(this, "init", async () => {
              if (!(0, eu.w8K)())
                try {
                  let e = {
                    eventId: (0, eu.gZm)(),
                    timestamp: Date.now(),
                    domain: this.getAppDomain(),
                    props: {
                      event: "INIT",
                      type: "",
                      properties: {
                        client_id: await this.core.crypto.getClientId(),
                        user_agent: (0, eu.ojD)(
                          this.core.relayer.protocol,
                          this.core.relayer.version,
                          eX
                        ),
                      },
                    },
                  };
                  await this.sendEvent([e]);
                } catch (e) {
                  this.logger.warn(e);
                }
            }),
            ix(this, "createEvent", (e) => {
              let {
                  event: t = "ERROR",
                  type: r = "",
                  properties: { topic: i, trace: s },
                } = e,
                n = (0, eu.gZm)(),
                a = this.core.projectId || "",
                o = iS(
                  {
                    eventId: n,
                    timestamp: Date.now(),
                    props: {
                      event: t,
                      type: r,
                      properties: { topic: i, trace: s },
                    },
                    bundleId: a,
                    domain: this.getAppDomain(),
                  },
                  this.setMethods(n)
                );
              return (
                this.telemetryEnabled &&
                  (this.events.set(n, o), (this.shouldPersist = !0)),
                o
              );
            }),
            ix(this, "getEvent", (e) => {
              let { eventId: t, topic: r } = e;
              if (t) return this.events.get(t);
              let i = Array.from(this.events.values()).find(
                (e) => e.props.properties.topic === r
              );
              if (i) return iS(iS({}, i), this.setMethods(i.eventId));
            }),
            ix(this, "deleteEvent", (e) => {
              let { eventId: t } = e;
              this.events.delete(t), (this.shouldPersist = !0);
            }),
            ix(this, "setEventListeners", () => {
              this.core.heartbeat.on(d.pulse, async () => {
                this.shouldPersist && (await this.persist()),
                  this.events.forEach((e) => {
                    (0, a.fromMiliseconds)(Date.now()) -
                      (0, a.fromMiliseconds)(e.timestamp) >
                      86400 &&
                      (this.events.delete(e.eventId),
                      (this.shouldPersist = !0));
                  });
              });
            }),
            ix(this, "setMethods", (e) => ({
              addTrace: (t) => this.addTrace(e, t),
              setError: (t) => this.setError(e, t),
            })),
            ix(this, "addTrace", (e, t) => {
              let r = this.events.get(e);
              r &&
                (r.props.properties.trace.push(t),
                this.events.set(e, r),
                (this.shouldPersist = !0));
            }),
            ix(this, "setError", (e, t) => {
              let r = this.events.get(e);
              r &&
                ((r.props.type = t),
                (r.timestamp = Date.now()),
                this.events.set(e, r),
                (this.shouldPersist = !0));
            }),
            ix(this, "persist", async () => {
              await this.core.storage.setItem(
                this.storageKey,
                Array.from(this.events.values())
              ),
                (this.shouldPersist = !1);
            }),
            ix(this, "restore", async () => {
              try {
                let e =
                  (await this.core.storage.getItem(this.storageKey)) || [];
                if (!e.length) return;
                e.forEach((e) => {
                  this.events.set(
                    e.eventId,
                    iS(iS({}, e), this.setMethods(e.eventId))
                  );
                });
              } catch (e) {
                this.logger.warn(e);
              }
            }),
            ix(this, "submit", async () => {
              if (!this.telemetryEnabled || 0 === this.events.size) return;
              let e = [];
              for (let [t, r] of this.events) r.props.type && e.push(r);
              if (0 !== e.length)
                try {
                  if ((await this.sendEvent(e)).ok)
                    for (let t of e)
                      this.events.delete(t.eventId), (this.shouldPersist = !0);
                } catch (e) {
                  this.logger.warn(e);
                }
            }),
            ix(this, "sendEvent", async (e) => {
              let t = this.getAppDomain() ? "" : "&sp=desktop";
              return await fetch(
                `https://pulse.walletconnect.org/batch?projectId=${this.core.projectId}&st=events_sdk&sv=js-${eX}${t}`,
                { method: "POST", body: JSON.stringify(e) }
              );
            }),
            ix(this, "getAppDomain", () => (0, eu.lFF)().url),
            (this.logger = (0, F.U5)(t, this.context)),
            (this.telemetryEnabled = r),
            r
              ? this.restore().then(async () => {
                  await this.submit(), this.setEventListeners();
                })
              : this.persist();
        }
        get storageKey() {
          return (
            this.storagePrefix +
            this.storageVersion +
            this.core.customStoragePrefix +
            "//" +
            this.context
          );
        }
      }
      var iT = Object.defineProperty,
        iP = Object.getOwnPropertySymbols,
        iO = Object.prototype.hasOwnProperty,
        ik = Object.prototype.propertyIsEnumerable,
        iR = (e, t, r) =>
          t in e
            ? iT(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        iD = (e, t) => {
          for (var r in t || (t = {})) iO.call(t, r) && iR(e, r, t[r]);
          if (iP) for (var r of iP(t)) ik.call(t, r) && iR(e, r, t[r]);
          return e;
        },
        iM = (e, t, r) => iR(e, "symbol" != typeof t ? t + "" : t, r);
      class iU extends H {
        constructor(e) {
          var t;
          super(e),
            iM(this, "protocol", "wc"),
            iM(this, "version", 2),
            iM(this, "name", eW),
            iM(this, "relayUrl"),
            iM(this, "projectId"),
            iM(this, "customStoragePrefix"),
            iM(this, "events", new s.EventEmitter()),
            iM(this, "logger"),
            iM(this, "heartbeat"),
            iM(this, "relayer"),
            iM(this, "crypto"),
            iM(this, "storage"),
            iM(this, "history"),
            iM(this, "expirer"),
            iM(this, "pairing"),
            iM(this, "verify"),
            iM(this, "echoClient"),
            iM(this, "linkModeSupportedApps"),
            iM(this, "eventClient"),
            iM(this, "initialized", !1),
            iM(this, "logChunkController"),
            iM(this, "on", (e, t) => this.events.on(e, t)),
            iM(this, "once", (e, t) => this.events.once(e, t)),
            iM(this, "off", (e, t) => this.events.off(e, t)),
            iM(this, "removeListener", (e, t) =>
              this.events.removeListener(e, t)
            ),
            iM(
              this,
              "dispatchEnvelope",
              ({ topic: e, message: t, sessionExists: r }) => {
                if (!e || !t) return;
                let i = {
                  topic: e,
                  message: t,
                  publishedAt: Date.now(),
                  transportType: e0.link_mode,
                };
                this.relayer.onLinkMessageEvent(i, { sessionExists: r });
              }
            ),
            (this.projectId = e?.projectId),
            (this.relayUrl = e?.relayUrl || eQ),
            (this.customStoragePrefix =
              null != e && e.customStoragePrefix
                ? `:${e.customStoragePrefix}`
                : "");
          let r = (0, F.iP)({
              level:
                "string" == typeof e?.logger && e.logger ? e.logger : eq.logger,
              name: eW,
            }),
            { logger: i, chunkLoggerController: n } = (0, F.D5)({
              opts: r,
              maxSizeInBytes: e?.maxLogBlobSizeInBytes,
              loggerOverride: e?.logger,
            });
          (this.logChunkController = n),
            null != (t = this.logChunkController) &&
              t.downloadLogsBlobInBrowser &&
              (window.downloadLogsBlobInBrowser = async () => {
                var e, t;
                null != (e = this.logChunkController) &&
                  e.downloadLogsBlobInBrowser &&
                  (null == (t = this.logChunkController) ||
                    t.downloadLogsBlobInBrowser({
                      clientId: await this.crypto.getClientId(),
                    }));
              }),
            (this.logger = (0, F.U5)(i, this.name)),
            (this.heartbeat = new u()),
            (this.crypto = new ri(this, this.logger, e?.keychain)),
            (this.history = new io(this, this.logger)),
            (this.expirer = new iu(this, this.logger)),
            (this.storage =
              null != e && e.storage
                ? e.storage
                : new j(iD(iD({}, eV), e?.storageOptions))),
            (this.relayer = new rG({
              core: this,
              logger: this.logger,
              relayUrl: this.relayUrl,
              projectId: this.projectId,
            })),
            (this.pairing = new ir(this, this.logger)),
            (this.verify = new im(this, this.logger, this.storage)),
            (this.echoClient = new iv(this.projectId || "", this.logger)),
            (this.linkModeSupportedApps = []),
            (this.eventClient = new iN(this, this.logger, e?.telemetryEnabled));
        }
        static async init(e) {
          let t = new iU(e);
          await t.initialize();
          let r = await t.crypto.getClientId();
          return await t.storage.setItem("WALLETCONNECT_CLIENT_ID", r), t;
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        async start() {
          this.initialized || (await this.initialize());
        }
        async getLogsBlob() {
          var e;
          return null == (e = this.logChunkController)
            ? void 0
            : e.logsToBlob({ clientId: await this.crypto.getClientId() });
        }
        async addLinkModeSupportedApp(e) {
          this.linkModeSupportedApps.includes(e) ||
            (this.linkModeSupportedApps.push(e),
            await this.storage.setItem(e2, this.linkModeSupportedApps));
        }
        async initialize() {
          this.logger.trace("Initialized");
          try {
            await this.crypto.init(),
              await this.history.init(),
              await this.expirer.init(),
              await this.relayer.init(),
              await this.heartbeat.init(),
              await this.pairing.init(),
              (this.linkModeSupportedApps =
                (await this.storage.getItem(e2)) || []),
              (this.initialized = !0),
              this.logger.info("Core Initialization Success");
          } catch (e) {
            throw (
              (this.logger.warn(
                `Core Initialization Failure at epoch ${Date.now()}`,
                e
              ),
              this.logger.error(e.message),
              e)
            );
          }
        }
      }
      let iL = "client",
        iB = `wc@2:${iL}:`,
        ij = { name: iL, logger: "error" },
        iF = "WALLETCONNECT_DEEPLINK_CHOICE",
        i$ = "Proposal expired",
        iz = a.SEVEN_DAYS,
        iW = {
          wc_sessionPropose: {
            req: { ttl: a.FIVE_MINUTES, prompt: !0, tag: 1100 },
            res: { ttl: a.FIVE_MINUTES, prompt: !1, tag: 1101 },
            reject: { ttl: a.FIVE_MINUTES, prompt: !1, tag: 1120 },
            autoReject: { ttl: a.FIVE_MINUTES, prompt: !1, tag: 1121 },
          },
          wc_sessionSettle: {
            req: { ttl: a.FIVE_MINUTES, prompt: !1, tag: 1102 },
            res: { ttl: a.FIVE_MINUTES, prompt: !1, tag: 1103 },
          },
          wc_sessionUpdate: {
            req: { ttl: a.ONE_DAY, prompt: !1, tag: 1104 },
            res: { ttl: a.ONE_DAY, prompt: !1, tag: 1105 },
          },
          wc_sessionExtend: {
            req: { ttl: a.ONE_DAY, prompt: !1, tag: 1106 },
            res: { ttl: a.ONE_DAY, prompt: !1, tag: 1107 },
          },
          wc_sessionRequest: {
            req: { ttl: a.FIVE_MINUTES, prompt: !0, tag: 1108 },
            res: { ttl: a.FIVE_MINUTES, prompt: !1, tag: 1109 },
          },
          wc_sessionEvent: {
            req: { ttl: a.FIVE_MINUTES, prompt: !0, tag: 1110 },
            res: { ttl: a.FIVE_MINUTES, prompt: !1, tag: 1111 },
          },
          wc_sessionDelete: {
            req: { ttl: a.ONE_DAY, prompt: !1, tag: 1112 },
            res: { ttl: a.ONE_DAY, prompt: !1, tag: 1113 },
          },
          wc_sessionPing: {
            req: { ttl: a.ONE_DAY, prompt: !1, tag: 1114 },
            res: { ttl: a.ONE_DAY, prompt: !1, tag: 1115 },
          },
          wc_sessionAuthenticate: {
            req: { ttl: a.ONE_HOUR, prompt: !0, tag: 1116 },
            res: { ttl: a.ONE_HOUR, prompt: !1, tag: 1117 },
            reject: { ttl: a.FIVE_MINUTES, prompt: !1, tag: 1118 },
            autoReject: { ttl: a.FIVE_MINUTES, prompt: !1, tag: 1119 },
          },
        },
        iH = { min: a.FIVE_MINUTES, max: a.SEVEN_DAYS },
        iq = { idle: "IDLE", active: "ACTIVE" },
        iV = {
          eth_sendTransaction: { key: "" },
          eth_sendRawTransaction: { key: "" },
          wallet_sendCalls: { key: "" },
          solana_signTransaction: { key: "signature" },
          solana_signAllTransactions: { key: "transactions" },
          solana_signAndSendTransaction: { key: "signature" },
        },
        iK = [
          "wc_sessionPropose",
          "wc_sessionRequest",
          "wc_authRequest",
          "wc_sessionAuthenticate",
        ],
        iG = "wc@1.5:auth:",
        iY = `${iG}:PUB_KEY`;
      var iQ = Object.defineProperty,
        iZ = Object.defineProperties,
        iJ = Object.getOwnPropertyDescriptors,
        iX = Object.getOwnPropertySymbols,
        i0 = Object.prototype.hasOwnProperty,
        i1 = Object.prototype.propertyIsEnumerable,
        i2 = (e, t, r) =>
          t in e
            ? iQ(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        i3 = (e, t) => {
          for (var r in t || (t = {})) i0.call(t, r) && i2(e, r, t[r]);
          if (iX) for (var r of iX(t)) i1.call(t, r) && i2(e, r, t[r]);
          return e;
        },
        i5 = (e, t) => iZ(e, iJ(t)),
        i8 = (e, t, r) => i2(e, "symbol" != typeof t ? t + "" : t, r);
      class i6 extends el {
        constructor(e) {
          super(e),
            i8(this, "name", "engine"),
            i8(this, "events", new (n())()),
            i8(this, "initialized", !1),
            i8(this, "requestQueue", { state: iq.idle, queue: [] }),
            i8(this, "sessionRequestQueue", { state: iq.idle, queue: [] }),
            i8(this, "requestQueueDelay", a.ONE_SECOND),
            i8(this, "expectedPairingMethodMap", new Map()),
            i8(this, "recentlyDeletedMap", new Map()),
            i8(this, "recentlyDeletedLimit", 200),
            i8(this, "relayMessageCache", []),
            i8(this, "pendingSessions", new Map()),
            i8(this, "init", async () => {
              this.initialized ||
                (await this.cleanup(),
                this.registerRelayerEvents(),
                this.registerExpirerEvents(),
                this.registerPairingEvents(),
                await this.registerLinkModeListeners(),
                this.client.core.pairing.register({ methods: Object.keys(iW) }),
                (this.initialized = !0),
                setTimeout(async () => {
                  await this.processPendingMessageEvents(),
                    (this.sessionRequestQueue.queue =
                      this.getPendingSessionRequests()),
                    this.processSessionRequestQueue();
                }, (0, a.toMiliseconds)(this.requestQueueDelay)));
            }),
            i8(this, "connect", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              let t = i5(i3({}, e), {
                requiredNamespaces: e.requiredNamespaces || {},
                optionalNamespaces: e.optionalNamespaces || {},
              });
              await this.isValidConnect(t);
              let {
                  pairingTopic: r,
                  requiredNamespaces: i,
                  optionalNamespaces: s,
                  sessionProperties: n,
                  scopedProperties: o,
                  relays: c,
                } = t,
                l = r,
                d,
                u = !1;
              try {
                if (l) {
                  let e = this.client.core.pairing.pairings.get(l);
                  this.client.logger.warn(
                    "connect() with existing pairing topic is deprecated and will be removed in the next major release."
                  ),
                    (u = e.active);
                }
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `connect() -> pairing.get(${l}) failed`
                  ),
                  e)
                );
              }
              if (!l || !u) {
                let { topic: e, uri: t } =
                  await this.client.core.pairing.create();
                (l = e), (d = t);
              }
              if (!l) {
                let { message: e } = (0, eu.GuA)(
                  "NO_MATCHING_KEY",
                  `connect() pairing topic: ${l}`
                );
                throw Error(e);
              }
              let h = await this.client.core.crypto.generateKeyPair(),
                f = iW.wc_sessionPropose.req.ttl || a.FIVE_MINUTES,
                p = (0, eu.Xw0)(f),
                g = i5(
                  i3(
                    i3(
                      {
                        requiredNamespaces: i,
                        optionalNamespaces: s,
                        relays: c ?? [{ protocol: "irn" }],
                        proposer: {
                          publicKey: h,
                          metadata: this.client.metadata,
                        },
                        expiryTimestamp: p,
                        pairingTopic: l,
                      },
                      n && { sessionProperties: n }
                    ),
                    o && { scopedProperties: o }
                  ),
                  { id: ev() }
                ),
                m = (0, eu.hEn)("session_connect", g.id),
                { reject: b, resolve: y, done: w } = (0, eu.Wx8)(f, i$),
                v = ({ id: e }) => {
                  e === g.id &&
                    (this.client.events.off("proposal_expire", v),
                    this.pendingSessions.delete(g.id),
                    this.events.emit(m, { error: { message: i$, code: 0 } }));
                };
              return (
                this.client.events.on("proposal_expire", v),
                this.events.once(m, ({ error: e, session: t }) => {
                  this.client.events.off("proposal_expire", v),
                    e ? b(e) : t && y(t);
                }),
                await this.sendRequest({
                  topic: l,
                  method: "wc_sessionPropose",
                  params: g,
                  throwOnFailedPublish: !0,
                  clientRpcId: g.id,
                }),
                await this.setProposal(g.id, g),
                { uri: d, approval: w }
              );
            }),
            i8(this, "pair", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                return await this.client.core.pairing.pair(e);
              } catch (e) {
                throw (this.client.logger.error("pair() failed"), e);
              }
            }),
            i8(this, "approve", async (e) => {
              var t, r, i;
              let s = this.client.core.eventClient.createEvent({
                properties: {
                  topic: null == (t = e?.id) ? void 0 : t.toString(),
                  trace: [ti.session_approve_started],
                },
              });
              try {
                this.isInitialized(), await this.confirmOnlineStateOrThrow();
              } catch (e) {
                throw (s.setError(ts.no_internet_connection), e);
              }
              try {
                await this.isValidProposalId(e?.id);
              } catch (t) {
                throw (
                  (this.client.logger.error(
                    `approve() -> proposal.get(${e?.id}) failed`
                  ),
                  s.setError(ts.proposal_not_found),
                  t)
                );
              }
              try {
                await this.isValidApprove(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "approve() -> isValidApprove() failed"
                  ),
                  s.setError(ts.session_approve_namespace_validation_failure),
                  e)
                );
              }
              let {
                  id: n,
                  relayProtocol: a,
                  namespaces: o,
                  sessionProperties: c,
                  scopedProperties: l,
                  sessionConfig: d,
                } = e,
                u = this.client.proposal.get(n);
              this.client.core.eventClient.deleteEvent({ eventId: s.eventId });
              let {
                  pairingTopic: h,
                  proposer: f,
                  requiredNamespaces: p,
                  optionalNamespaces: g,
                } = u,
                m =
                  null == (r = this.client.core.eventClient)
                    ? void 0
                    : r.getEvent({ topic: h });
              m ||
                (m =
                  null == (i = this.client.core.eventClient)
                    ? void 0
                    : i.createEvent({
                        type: ti.session_approve_started,
                        properties: {
                          topic: h,
                          trace: [
                            ti.session_approve_started,
                            ti.session_namespaces_validation_success,
                          ],
                        },
                      }));
              let b = await this.client.core.crypto.generateKeyPair(),
                y = f.publicKey,
                w = await this.client.core.crypto.generateSharedKey(b, y),
                v = i3(
                  i3(
                    i3(
                      {
                        relay: { protocol: a ?? "irn" },
                        namespaces: o,
                        controller: {
                          publicKey: b,
                          metadata: this.client.metadata,
                        },
                        expiry: (0, eu.Xw0)(iz),
                      },
                      c && { sessionProperties: c }
                    ),
                    l && { scopedProperties: l }
                  ),
                  d && { sessionConfig: d }
                ),
                A = e0.relay;
              m.addTrace(ti.subscribing_session_topic);
              try {
                await this.client.core.relayer.subscribe(w, {
                  transportType: A,
                });
              } catch (e) {
                throw (m.setError(ts.subscribe_session_topic_failure), e);
              }
              m.addTrace(ti.subscribe_session_topic_success);
              let E = i5(i3({}, v), {
                topic: w,
                requiredNamespaces: p,
                optionalNamespaces: g,
                pairingTopic: h,
                acknowledged: !1,
                self: v.controller,
                peer: { publicKey: f.publicKey, metadata: f.metadata },
                controller: b,
                transportType: e0.relay,
              });
              await this.client.session.set(w, E), m.addTrace(ti.store_session);
              try {
                m.addTrace(ti.publishing_session_settle),
                  await this.sendRequest({
                    topic: w,
                    method: "wc_sessionSettle",
                    params: v,
                    throwOnFailedPublish: !0,
                  }).catch((e) => {
                    throw (m?.setError(ts.session_settle_publish_failure), e);
                  }),
                  m.addTrace(ti.session_settle_publish_success),
                  m.addTrace(ti.publishing_session_approve),
                  await this.sendResult({
                    id: n,
                    topic: h,
                    result: {
                      relay: { protocol: a ?? "irn" },
                      responderPublicKey: b,
                    },
                    throwOnFailedPublish: !0,
                  }).catch((e) => {
                    throw (m?.setError(ts.session_approve_publish_failure), e);
                  }),
                  m.addTrace(ti.session_approve_publish_success);
              } catch (e) {
                throw (
                  (this.client.logger.error(e),
                  this.client.session.delete(
                    w,
                    (0, eu.Hjj)("USER_DISCONNECTED")
                  ),
                  await this.client.core.relayer.unsubscribe(w),
                  e)
                );
              }
              return (
                this.client.core.eventClient.deleteEvent({
                  eventId: m.eventId,
                }),
                await this.client.core.pairing.updateMetadata({
                  topic: h,
                  metadata: f.metadata,
                }),
                await this.client.proposal.delete(
                  n,
                  (0, eu.Hjj)("USER_DISCONNECTED")
                ),
                await this.client.core.pairing.activate({ topic: h }),
                await this.setExpiry(w, (0, eu.Xw0)(iz)),
                {
                  topic: w,
                  acknowledged: () =>
                    Promise.resolve(this.client.session.get(w)),
                }
              );
            }),
            i8(this, "reject", async (e) => {
              let t;
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidReject(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "reject() -> isValidReject() failed"
                  ),
                  e)
                );
              }
              let { id: r, reason: i } = e;
              try {
                t = this.client.proposal.get(r).pairingTopic;
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `reject() -> proposal.get(${r}) failed`
                  ),
                  e)
                );
              }
              t &&
                (await this.sendError({
                  id: r,
                  topic: t,
                  error: i,
                  rpcOpts: iW.wc_sessionPropose.reject,
                }),
                await this.client.proposal.delete(
                  r,
                  (0, eu.Hjj)("USER_DISCONNECTED")
                ));
            }),
            i8(this, "update", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidUpdate(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "update() -> isValidUpdate() failed"
                  ),
                  e)
                );
              }
              let { topic: t, namespaces: r } = e,
                { done: i, resolve: s, reject: n } = (0, eu.Wx8)(),
                a = ev(),
                o = eA().toString(),
                c = this.client.session.get(t).namespaces;
              return (
                this.events.once(
                  (0, eu.hEn)("session_update", a),
                  ({ error: e }) => {
                    e ? n(e) : s();
                  }
                ),
                await this.client.session.update(t, { namespaces: r }),
                await this.sendRequest({
                  topic: t,
                  method: "wc_sessionUpdate",
                  params: { namespaces: r },
                  throwOnFailedPublish: !0,
                  clientRpcId: a,
                  relayRpcId: o,
                }).catch((e) => {
                  this.client.logger.error(e),
                    this.client.session.update(t, { namespaces: c }),
                    n(e);
                }),
                { acknowledged: i }
              );
            }),
            i8(this, "extend", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidExtend(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "extend() -> isValidExtend() failed"
                  ),
                  e)
                );
              }
              let { topic: t } = e,
                r = ev(),
                { done: i, resolve: s, reject: n } = (0, eu.Wx8)();
              return (
                this.events.once(
                  (0, eu.hEn)("session_extend", r),
                  ({ error: e }) => {
                    e ? n(e) : s();
                  }
                ),
                await this.setExpiry(t, (0, eu.Xw0)(iz)),
                this.sendRequest({
                  topic: t,
                  method: "wc_sessionExtend",
                  params: {},
                  clientRpcId: r,
                  throwOnFailedPublish: !0,
                }).catch((e) => {
                  n(e);
                }),
                { acknowledged: i }
              );
            }),
            i8(this, "request", async (e) => {
              this.isInitialized();
              try {
                await this.isValidRequest(e);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    "request() -> isValidRequest() failed"
                  ),
                  e)
                );
              }
              let {
                  chainId: t,
                  request: r,
                  topic: i,
                  expiry: s = iW.wc_sessionRequest.req.ttl,
                } = e,
                n = this.client.session.get(i);
              n?.transportType === e0.relay &&
                (await this.confirmOnlineStateOrThrow());
              let a = ev(),
                o = eA().toString(),
                {
                  done: c,
                  resolve: l,
                  reject: d,
                } = (0, eu.Wx8)(s, "Request expired. Please try again.");
              this.events.once(
                (0, eu.hEn)("session_request", a),
                ({ error: e, result: t }) => {
                  e ? d(e) : l(t);
                }
              );
              let u = "wc_sessionRequest",
                h = this.getAppLinkIfEnabled(n.peer.metadata, n.transportType);
              if (h)
                return (
                  await this.sendRequest({
                    clientRpcId: a,
                    relayRpcId: o,
                    topic: i,
                    method: u,
                    params: {
                      request: i5(i3({}, r), {
                        expiryTimestamp: (0, eu.Xw0)(s),
                      }),
                      chainId: t,
                    },
                    expiry: s,
                    throwOnFailedPublish: !0,
                    appLink: h,
                  }).catch((e) => d(e)),
                  this.client.events.emit("session_request_sent", {
                    topic: i,
                    request: r,
                    chainId: t,
                    id: a,
                  }),
                  await c()
                );
              let f = {
                  request: i5(i3({}, r), { expiryTimestamp: (0, eu.Xw0)(s) }),
                  chainId: t,
                },
                p = this.shouldSetTVF(u, f);
              return await Promise.all([
                new Promise(async (e) => {
                  await this.sendRequest(
                    i3(
                      {
                        clientRpcId: a,
                        relayRpcId: o,
                        topic: i,
                        method: u,
                        params: f,
                        expiry: s,
                        throwOnFailedPublish: !0,
                      },
                      p && { tvf: this.getTVFParams(a, f) }
                    )
                  ).catch((e) => d(e)),
                    this.client.events.emit("session_request_sent", {
                      topic: i,
                      request: r,
                      chainId: t,
                      id: a,
                    }),
                    e();
                }),
                new Promise(async (e) => {
                  var t;
                  if (!(null != (t = n.sessionConfig) && t.disableDeepLink)) {
                    let e = await (0, eu.jTh)(this.client.core.storage, iF);
                    await (0, eu.n3s)({ id: a, topic: i, wcDeepLink: e });
                  }
                  e();
                }),
                c(),
              ]).then((e) => e[2]);
            }),
            i8(this, "respond", async (e) => {
              this.isInitialized(), await this.isValidRespond(e);
              let { topic: t, response: r } = e,
                { id: i } = r,
                s = this.client.session.get(t);
              s.transportType === e0.relay &&
                (await this.confirmOnlineStateOrThrow());
              let n = this.getAppLinkIfEnabled(
                s.peer.metadata,
                s.transportType
              );
              eD(r)
                ? await this.sendResult({
                    id: i,
                    topic: t,
                    result: r.result,
                    throwOnFailedPublish: !0,
                    appLink: n,
                  })
                : eM(r) &&
                  (await this.sendError({
                    id: i,
                    topic: t,
                    error: r.error,
                    appLink: n,
                  })),
                this.cleanupAfterResponse(e);
            }),
            i8(this, "ping", async (e) => {
              this.isInitialized(), await this.confirmOnlineStateOrThrow();
              try {
                await this.isValidPing(e);
              } catch (e) {
                throw (
                  (this.client.logger.error("ping() -> isValidPing() failed"),
                  e)
                );
              }
              let { topic: t } = e;
              if (this.client.session.keys.includes(t)) {
                let e = ev(),
                  r = eA().toString(),
                  { done: i, resolve: s, reject: n } = (0, eu.Wx8)();
                this.events.once(
                  (0, eu.hEn)("session_ping", e),
                  ({ error: e }) => {
                    e ? n(e) : s();
                  }
                ),
                  await Promise.all([
                    this.sendRequest({
                      topic: t,
                      method: "wc_sessionPing",
                      params: {},
                      throwOnFailedPublish: !0,
                      clientRpcId: e,
                      relayRpcId: r,
                    }),
                    i(),
                  ]);
              } else
                this.client.core.pairing.pairings.keys.includes(t) &&
                  (this.client.logger.warn(
                    "ping() on pairing topic is deprecated and will be removed in the next major release."
                  ),
                  await this.client.core.pairing.ping({ topic: t }));
            }),
            i8(this, "emit", async (e) => {
              this.isInitialized(),
                await this.confirmOnlineStateOrThrow(),
                await this.isValidEmit(e);
              let { topic: t, event: r, chainId: i } = e,
                s = eA().toString(),
                n = ev();
              await this.sendRequest({
                topic: t,
                method: "wc_sessionEvent",
                params: { event: r, chainId: i },
                throwOnFailedPublish: !0,
                relayRpcId: s,
                clientRpcId: n,
              });
            }),
            i8(this, "disconnect", async (e) => {
              this.isInitialized(),
                await this.confirmOnlineStateOrThrow(),
                await this.isValidDisconnect(e);
              let { topic: t } = e;
              if (this.client.session.keys.includes(t))
                await this.sendRequest({
                  topic: t,
                  method: "wc_sessionDelete",
                  params: (0, eu.Hjj)("USER_DISCONNECTED"),
                  throwOnFailedPublish: !0,
                }),
                  await this.deleteSession({ topic: t, emitEvent: !1 });
              else if (this.client.core.pairing.pairings.keys.includes(t))
                await this.client.core.pairing.disconnect({ topic: t });
              else {
                let { message: e } = (0, eu.GuA)(
                  "MISMATCHED_TOPIC",
                  `Session or pairing topic not found: ${t}`
                );
                throw Error(e);
              }
            }),
            i8(
              this,
              "find",
              (e) => (
                this.isInitialized(),
                this.client.session.getAll().filter((t) => (0, eu.HNf)(t, e))
              )
            ),
            i8(this, "getPendingSessionRequests", () =>
              this.client.pendingRequest.getAll()
            ),
            i8(this, "authenticate", async (e, t) => {
              var r;
              let i;
              this.isInitialized(), this.isValidAuthenticate(e);
              let s =
                  t &&
                  this.client.core.linkModeSupportedApps.includes(t) &&
                  (null == (r = this.client.metadata.redirect)
                    ? void 0
                    : r.linkMode),
                n = s ? e0.link_mode : e0.relay;
              n === e0.relay && (await this.confirmOnlineStateOrThrow());
              let {
                  chains: a,
                  statement: o = "",
                  uri: c,
                  domain: l,
                  nonce: d,
                  type: u,
                  exp: h,
                  nbf: f,
                  methods: p = [],
                  expiry: g,
                } = e,
                m = [...(e.resources || [])],
                { topic: b, uri: y } = await this.client.core.pairing.create({
                  methods: ["wc_sessionAuthenticate"],
                  transportType: n,
                });
              this.client.logger.info({
                message: "Generated new pairing",
                pairing: { topic: b, uri: y },
              });
              let w = await this.client.core.crypto.generateKeyPair(),
                v = (0, eu.EN$)(w);
              if (
                (await Promise.all([
                  this.client.auth.authKeys.set(iY, {
                    responseTopic: v,
                    publicKey: w,
                  }),
                  this.client.auth.pairingTopics.set(v, {
                    topic: v,
                    pairingTopic: b,
                  }),
                ]),
                await this.client.core.relayer.subscribe(v, {
                  transportType: n,
                }),
                this.client.logger.info(
                  `sending request to new pairing topic: ${b}`
                ),
                p.length > 0)
              ) {
                let { namespace: e } = (0, eu._Yb)(a[0]),
                  t = (0, eu.e8_)(e, "request", p);
                (0, eu.VBM)(m) && (t = (0, eu.hVC)(t, m.pop())), m.push(t);
              }
              let A =
                  g && g > iW.wc_sessionAuthenticate.req.ttl
                    ? g
                    : iW.wc_sessionAuthenticate.req.ttl,
                E = {
                  authPayload: {
                    type: u ?? "caip122",
                    chains: a,
                    statement: o,
                    aud: c,
                    domain: l,
                    version: "1",
                    nonce: d,
                    iat: new Date().toISOString(),
                    exp: h,
                    nbf: f,
                    resources: m,
                  },
                  requester: { publicKey: w, metadata: this.client.metadata },
                  expiryTimestamp: (0, eu.Xw0)(A),
                },
                _ = {
                  requiredNamespaces: {},
                  optionalNamespaces: {
                    eip155: {
                      chains: a,
                      methods: [...new Set(["personal_sign", ...p])],
                      events: ["chainChanged", "accountsChanged"],
                    },
                  },
                  relays: [{ protocol: "irn" }],
                  pairingTopic: b,
                  proposer: { publicKey: w, metadata: this.client.metadata },
                  expiryTimestamp: (0, eu.Xw0)(iW.wc_sessionPropose.req.ttl),
                  id: ev(),
                },
                {
                  done: C,
                  resolve: I,
                  reject: S,
                } = (0, eu.Wx8)(A, "Request expired"),
                x = ev(),
                N = (0, eu.hEn)("session_connect", _.id),
                T = (0, eu.hEn)("session_request", x),
                P = async ({ error: e, session: t }) => {
                  this.events.off(T, O), e ? S(e) : t && I({ session: t });
                },
                O = async (e) => {
                  var r, i, s;
                  let a;
                  if (
                    (await this.deletePendingAuthRequest(x, {
                      message: "fulfilled",
                      code: 0,
                    }),
                    e.error)
                  ) {
                    let t = (0, eu.Hjj)(
                      "WC_METHOD_UNSUPPORTED",
                      "wc_sessionAuthenticate"
                    );
                    return e.error.code === t.code
                      ? void 0
                      : (this.events.off(N, P), S(e.error.message));
                  }
                  await this.deleteProposal(_.id), this.events.off(N, P);
                  let { cacaos: o, responder: c } = e.result,
                    l = [],
                    d = [];
                  for (let e of o) {
                    (await (0, eu.IjX)({
                      cacao: e,
                      projectId: this.client.core.projectId,
                    })) ||
                      (this.client.logger.error(
                        e,
                        "Signature verification failed"
                      ),
                      S(
                        (0, eu.Hjj)(
                          "SESSION_SETTLEMENT_FAILED",
                          "Signature verification failed"
                        )
                      ));
                    let { p: t } = e,
                      r = (0, eu.VBM)(t.resources),
                      i = [(0, eu.xkc)(t.iss)],
                      s = (0, eu.q_h)(t.iss);
                    if (r) {
                      let e = (0, eu.sc_)(r),
                        t = (0, eu.WWN)(r);
                      l.push(...e), i.push(...t);
                    }
                    for (let e of i) d.push(`${e}:${s}`);
                  }
                  let u = await this.client.core.crypto.generateSharedKey(
                    w,
                    c.publicKey
                  );
                  l.length > 0 &&
                    ((a = {
                      topic: u,
                      acknowledged: !0,
                      self: { publicKey: w, metadata: this.client.metadata },
                      peer: c,
                      controller: c.publicKey,
                      expiry: (0, eu.Xw0)(iz),
                      requiredNamespaces: {},
                      optionalNamespaces: {},
                      relay: { protocol: "irn" },
                      pairingTopic: b,
                      namespaces: (0, eu.Van)([...new Set(l)], [...new Set(d)]),
                      transportType: n,
                    }),
                    await this.client.core.relayer.subscribe(u, {
                      transportType: n,
                    }),
                    await this.client.session.set(u, a),
                    b &&
                      (await this.client.core.pairing.updateMetadata({
                        topic: b,
                        metadata: c.metadata,
                      })),
                    (a = this.client.session.get(u))),
                    null != (r = this.client.metadata.redirect) &&
                      r.linkMode &&
                      null != (i = c.metadata.redirect) &&
                      i.linkMode &&
                      null != (s = c.metadata.redirect) &&
                      s.universal &&
                      t &&
                      (this.client.core.addLinkModeSupportedApp(
                        c.metadata.redirect.universal
                      ),
                      this.client.session.update(u, {
                        transportType: e0.link_mode,
                      })),
                    I({ auths: o, session: a });
                };
              this.events.once(N, P), this.events.once(T, O);
              try {
                if (s) {
                  let e = eE("wc_sessionAuthenticate", E, x);
                  this.client.core.history.set(b, e);
                  let r = await this.client.core.crypto.encode("", e, {
                    type: eu.EHS,
                    encoding: eu.Pa8,
                  });
                  i = (0, eu.$Bq)(t, b, r);
                } else
                  await Promise.all([
                    this.sendRequest({
                      topic: b,
                      method: "wc_sessionAuthenticate",
                      params: E,
                      expiry: e.expiry,
                      throwOnFailedPublish: !0,
                      clientRpcId: x,
                    }),
                    this.sendRequest({
                      topic: b,
                      method: "wc_sessionPropose",
                      params: _,
                      expiry: iW.wc_sessionPropose.req.ttl,
                      throwOnFailedPublish: !0,
                      clientRpcId: _.id,
                    }),
                  ]);
              } catch (e) {
                throw (this.events.off(N, P), this.events.off(T, O), e);
              }
              return (
                await this.setProposal(_.id, _),
                await this.setAuthRequest(x, {
                  request: i5(i3({}, E), { verifyContext: {} }),
                  pairingTopic: b,
                  transportType: n,
                }),
                { uri: i ?? y, response: C }
              );
            }),
            i8(this, "approveSessionAuthenticate", async (e) => {
              let t;
              let { id: r, auths: i } = e,
                s = this.client.core.eventClient.createEvent({
                  properties: {
                    topic: r.toString(),
                    trace: [tn.authenticated_session_approve_started],
                  },
                });
              try {
                this.isInitialized();
              } catch (e) {
                throw (s.setError(ta.no_internet_connection), e);
              }
              let n = this.getPendingAuthRequest(r);
              if (!n)
                throw (
                  (s.setError(
                    ta.authenticated_session_pending_request_not_found
                  ),
                  Error(`Could not find pending auth request with id ${r}`))
                );
              let a = n.transportType || e0.relay;
              a === e0.relay && (await this.confirmOnlineStateOrThrow());
              let o = n.requester.publicKey,
                c = await this.client.core.crypto.generateKeyPair(),
                l = (0, eu.EN$)(o),
                d = { type: eu.Lp_, receiverPublicKey: o, senderPublicKey: c },
                u = [],
                h = [];
              for (let e of i) {
                if (
                  !(await (0, eu.IjX)({
                    cacao: e,
                    projectId: this.client.core.projectId,
                  }))
                ) {
                  s.setError(ta.invalid_cacao);
                  let e = (0, eu.Hjj)(
                    "SESSION_SETTLEMENT_FAILED",
                    "Signature verification failed"
                  );
                  throw (
                    (await this.sendError({
                      id: r,
                      topic: l,
                      error: e,
                      encodeOpts: d,
                    }),
                    Error(e.message))
                  );
                }
                s.addTrace(tn.cacaos_verified);
                let { p: t } = e,
                  i = (0, eu.VBM)(t.resources),
                  n = [(0, eu.xkc)(t.iss)],
                  a = (0, eu.q_h)(t.iss);
                if (i) {
                  let e = (0, eu.sc_)(i),
                    t = (0, eu.WWN)(i);
                  u.push(...e), n.push(...t);
                }
                for (let e of n) h.push(`${e}:${a}`);
              }
              let f = await this.client.core.crypto.generateSharedKey(c, o);
              if (
                (s.addTrace(tn.create_authenticated_session_topic),
                u?.length > 0)
              ) {
                (t = {
                  topic: f,
                  acknowledged: !0,
                  self: { publicKey: c, metadata: this.client.metadata },
                  peer: { publicKey: o, metadata: n.requester.metadata },
                  controller: o,
                  expiry: (0, eu.Xw0)(iz),
                  authentication: i,
                  requiredNamespaces: {},
                  optionalNamespaces: {},
                  relay: { protocol: "irn" },
                  pairingTopic: n.pairingTopic,
                  namespaces: (0, eu.Van)([...new Set(u)], [...new Set(h)]),
                  transportType: a,
                }),
                  s.addTrace(tn.subscribing_authenticated_session_topic);
                try {
                  await this.client.core.relayer.subscribe(f, {
                    transportType: a,
                  });
                } catch (e) {
                  throw (
                    (s.setError(
                      ta.subscribe_authenticated_session_topic_failure
                    ),
                    e)
                  );
                }
                s.addTrace(tn.subscribe_authenticated_session_topic_success),
                  await this.client.session.set(f, t),
                  s.addTrace(tn.store_authenticated_session),
                  await this.client.core.pairing.updateMetadata({
                    topic: n.pairingTopic,
                    metadata: n.requester.metadata,
                  });
              }
              s.addTrace(tn.publishing_authenticated_session_approve);
              try {
                await this.sendResult({
                  topic: l,
                  id: r,
                  result: {
                    cacaos: i,
                    responder: { publicKey: c, metadata: this.client.metadata },
                  },
                  encodeOpts: d,
                  throwOnFailedPublish: !0,
                  appLink: this.getAppLinkIfEnabled(n.requester.metadata, a),
                });
              } catch (e) {
                throw (
                  (s.setError(ta.authenticated_session_approve_publish_failure),
                  e)
                );
              }
              return (
                await this.client.auth.requests.delete(r, {
                  message: "fulfilled",
                  code: 0,
                }),
                await this.client.core.pairing.activate({
                  topic: n.pairingTopic,
                }),
                this.client.core.eventClient.deleteEvent({
                  eventId: s.eventId,
                }),
                { session: t }
              );
            }),
            i8(this, "rejectSessionAuthenticate", async (e) => {
              this.isInitialized();
              let { id: t, reason: r } = e,
                i = this.getPendingAuthRequest(t);
              if (!i)
                throw Error(`Could not find pending auth request with id ${t}`);
              i.transportType === e0.relay &&
                (await this.confirmOnlineStateOrThrow());
              let s = i.requester.publicKey,
                n = await this.client.core.crypto.generateKeyPair(),
                a = (0, eu.EN$)(s),
                o = { type: eu.Lp_, receiverPublicKey: s, senderPublicKey: n };
              await this.sendError({
                id: t,
                topic: a,
                error: r,
                encodeOpts: o,
                rpcOpts: iW.wc_sessionAuthenticate.reject,
                appLink: this.getAppLinkIfEnabled(
                  i.requester.metadata,
                  i.transportType
                ),
              }),
                await this.client.auth.requests.delete(t, {
                  message: "rejected",
                  code: 0,
                }),
                await this.client.proposal.delete(
                  t,
                  (0, eu.Hjj)("USER_DISCONNECTED")
                );
            }),
            i8(this, "formatAuthMessage", (e) => {
              this.isInitialized();
              let { request: t, iss: r } = e;
              return (0, eu.hwK)(t, r);
            }),
            i8(this, "processRelayMessageCache", () => {
              setTimeout(async () => {
                if (0 !== this.relayMessageCache.length)
                  for (; this.relayMessageCache.length > 0; )
                    try {
                      let e = this.relayMessageCache.shift();
                      e && (await this.onRelayMessage(e));
                    } catch (e) {
                      this.client.logger.error(e);
                    }
              }, 50);
            }),
            i8(this, "cleanupDuplicatePairings", async (e) => {
              if (e.pairingTopic)
                try {
                  let t = this.client.core.pairing.pairings.get(e.pairingTopic),
                    r = this.client.core.pairing.pairings
                      .getAll()
                      .filter((r) => {
                        var i, s;
                        return (
                          (null == (i = r.peerMetadata) ? void 0 : i.url) &&
                          (null == (s = r.peerMetadata) ? void 0 : s.url) ===
                            e.peer.metadata.url &&
                          r.topic &&
                          r.topic !== t.topic
                        );
                      });
                  if (0 === r.length) return;
                  this.client.logger.info(
                    `Cleaning up ${r.length} duplicate pairing(s)`
                  ),
                    await Promise.all(
                      r.map((e) =>
                        this.client.core.pairing.disconnect({ topic: e.topic })
                      )
                    ),
                    this.client.logger.info(
                      "Duplicate pairings clean up finished"
                    );
                } catch (e) {
                  this.client.logger.error(e);
                }
            }),
            i8(this, "deleteSession", async (e) => {
              var t;
              let {
                  topic: r,
                  expirerHasDeleted: i = !1,
                  emitEvent: s = !0,
                  id: n = 0,
                } = e,
                { self: a } = this.client.session.get(r);
              await this.client.core.relayer.unsubscribe(r),
                await this.client.session.delete(
                  r,
                  (0, eu.Hjj)("USER_DISCONNECTED")
                ),
                this.addToRecentlyDeleted(r, "session"),
                this.client.core.crypto.keychain.has(a.publicKey) &&
                  (await this.client.core.crypto.deleteKeyPair(a.publicKey)),
                this.client.core.crypto.keychain.has(r) &&
                  (await this.client.core.crypto.deleteSymKey(r)),
                i || this.client.core.expirer.del(r),
                this.client.core.storage
                  .removeItem(iF)
                  .catch((e) => this.client.logger.warn(e)),
                this.getPendingSessionRequests().forEach((e) => {
                  e.topic === r &&
                    this.deletePendingSessionRequest(
                      e.id,
                      (0, eu.Hjj)("USER_DISCONNECTED")
                    );
                }),
                r ===
                  (null == (t = this.sessionRequestQueue.queue[0])
                    ? void 0
                    : t.topic) && (this.sessionRequestQueue.state = iq.idle),
                s &&
                  this.client.events.emit("session_delete", {
                    id: n,
                    topic: r,
                  });
            }),
            i8(this, "deleteProposal", async (e, t) => {
              if (t)
                try {
                  let t = this.client.proposal.get(e),
                    r = this.client.core.eventClient.getEvent({
                      topic: t.pairingTopic,
                    });
                  r?.setError(ts.proposal_expired);
                } catch {}
              await Promise.all([
                this.client.proposal.delete(
                  e,
                  (0, eu.Hjj)("USER_DISCONNECTED")
                ),
                t ? Promise.resolve() : this.client.core.expirer.del(e),
              ]),
                this.addToRecentlyDeleted(e, "proposal");
            }),
            i8(this, "deletePendingSessionRequest", async (e, t, r = !1) => {
              await Promise.all([
                this.client.pendingRequest.delete(e, t),
                r ? Promise.resolve() : this.client.core.expirer.del(e),
              ]),
                this.addToRecentlyDeleted(e, "request"),
                (this.sessionRequestQueue.queue =
                  this.sessionRequestQueue.queue.filter((t) => t.id !== e)),
                r &&
                  ((this.sessionRequestQueue.state = iq.idle),
                  this.client.events.emit("session_request_expire", { id: e }));
            }),
            i8(this, "deletePendingAuthRequest", async (e, t, r = !1) => {
              await Promise.all([
                this.client.auth.requests.delete(e, t),
                r ? Promise.resolve() : this.client.core.expirer.del(e),
              ]);
            }),
            i8(this, "setExpiry", async (e, t) => {
              this.client.session.keys.includes(e) &&
                (this.client.core.expirer.set(e, t),
                await this.client.session.update(e, { expiry: t }));
            }),
            i8(this, "setProposal", async (e, t) => {
              this.client.core.expirer.set(
                e,
                (0, eu.Xw0)(iW.wc_sessionPropose.req.ttl)
              ),
                await this.client.proposal.set(e, t);
            }),
            i8(this, "setAuthRequest", async (e, t) => {
              let {
                request: r,
                pairingTopic: i,
                transportType: s = e0.relay,
              } = t;
              this.client.core.expirer.set(e, r.expiryTimestamp),
                await this.client.auth.requests.set(e, {
                  authPayload: r.authPayload,
                  requester: r.requester,
                  expiryTimestamp: r.expiryTimestamp,
                  id: e,
                  pairingTopic: i,
                  verifyContext: r.verifyContext,
                  transportType: s,
                });
            }),
            i8(this, "setPendingSessionRequest", async (e) => {
              let { id: t, topic: r, params: i, verifyContext: s } = e,
                n =
                  i.request.expiryTimestamp ||
                  (0, eu.Xw0)(iW.wc_sessionRequest.req.ttl);
              this.client.core.expirer.set(t, n),
                await this.client.pendingRequest.set(t, {
                  id: t,
                  topic: r,
                  params: i,
                  verifyContext: s,
                });
            }),
            i8(this, "sendRequest", async (e) => {
              let t, i;
              let {
                  topic: s,
                  method: n,
                  params: a,
                  expiry: o,
                  relayRpcId: c,
                  clientRpcId: l,
                  throwOnFailedPublish: d,
                  appLink: u,
                  tvf: h,
                } = e,
                f = eE(n, a, l),
                p = !!u;
              try {
                let e = p ? eu.Pa8 : eu.EWt;
                t = await this.client.core.crypto.encode(s, f, { encoding: e });
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendRequest() -> core.crypto.encode() for topic ${s} failed`
                  ),
                  e)
                );
              }
              if (iK.includes(n)) {
                let e = (0, eu.ALl)(JSON.stringify(f)),
                  r = (0, eu.ALl)(t);
                i = await this.client.core.verify.register({
                  id: r,
                  decryptedId: e,
                });
              }
              let g = iW[n].req;
              if (
                ((g.attestation = i),
                o && (g.ttl = o),
                c && (g.id = c),
                this.client.core.history.set(s, f),
                p)
              ) {
                let e = (0, eu.$Bq)(u, s, t);
                await r.g.Linking.openURL(e, this.client.name);
              } else {
                let e = iW[n].req;
                o && (e.ttl = o),
                  c && (e.id = c),
                  (e.tvf = i5(i3({}, h), { correlationId: f.id })),
                  d
                    ? ((e.internal = i5(i3({}, e.internal), {
                        throwOnFailedPublish: !0,
                      })),
                      await this.client.core.relayer.publish(s, t, e))
                    : this.client.core.relayer
                        .publish(s, t, e)
                        .catch((e) => this.client.logger.error(e));
              }
              return f.id;
            }),
            i8(this, "sendResult", async (e) => {
              let t, i, s;
              let {
                  id: n,
                  topic: a,
                  result: o,
                  throwOnFailedPublish: c,
                  encodeOpts: l,
                  appLink: d,
                } = e,
                u = e_(n, o),
                h = d && "u" > typeof (null == r.g ? void 0 : r.g.Linking);
              try {
                let e = h ? eu.Pa8 : eu.EWt;
                t = await this.client.core.crypto.encode(
                  a,
                  u,
                  i5(i3({}, l || {}), { encoding: e })
                );
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendResult() -> core.crypto.encode() for topic ${a} failed`
                  ),
                  e)
                );
              }
              try {
                let e = (i = await this.client.core.history.get(a, n)).request;
                try {
                  this.shouldSetTVF(e.method, e.params) &&
                    (s = this.getTVFParams(n, e.params, o));
                } catch (e) {
                  this.client.logger.warn(
                    "sendResult() -> getTVFParams() failed",
                    e
                  );
                }
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `sendResult() -> history.get(${a}, ${n}) failed`
                  ),
                  e)
                );
              }
              if (h) {
                let e = (0, eu.$Bq)(d, a, t);
                await r.g.Linking.openURL(e, this.client.name);
              } else {
                let e = iW[i.request.method].res;
                (e.tvf = i5(i3({}, s), { correlationId: n })),
                  c
                    ? ((e.internal = i5(i3({}, e.internal), {
                        throwOnFailedPublish: !0,
                      })),
                      await this.client.core.relayer.publish(a, t, e))
                    : this.client.core.relayer
                        .publish(a, t, e)
                        .catch((e) => this.client.logger.error(e));
              }
              await this.client.core.history.resolve(u);
            }),
            i8(this, "sendError", async (e) => {
              let t, i;
              let {
                  id: s,
                  topic: n,
                  error: a,
                  encodeOpts: o,
                  rpcOpts: c,
                  appLink: l,
                } = e,
                d = eC(s, a),
                u = l && "u" > typeof (null == r.g ? void 0 : r.g.Linking);
              try {
                let e = u ? eu.Pa8 : eu.EWt;
                t = await this.client.core.crypto.encode(
                  n,
                  d,
                  i5(i3({}, o || {}), { encoding: e })
                );
              } catch (e) {
                throw (
                  (await this.cleanup(),
                  this.client.logger.error(
                    `sendError() -> core.crypto.encode() for topic ${n} failed`
                  ),
                  e)
                );
              }
              try {
                i = await this.client.core.history.get(n, s);
              } catch (e) {
                throw (
                  (this.client.logger.error(
                    `sendError() -> history.get(${n}, ${s}) failed`
                  ),
                  e)
                );
              }
              if (u) {
                let e = (0, eu.$Bq)(l, n, t);
                await r.g.Linking.openURL(e, this.client.name);
              } else {
                let e = i.request.method,
                  r = c || iW[e].res;
                this.client.core.relayer.publish(n, t, r);
              }
              await this.client.core.history.resolve(d);
            }),
            i8(this, "cleanup", async () => {
              let e = [],
                t = [];
              this.client.session.getAll().forEach((t) => {
                let r = !1;
                (0, eu._dF)(t.expiry) && (r = !0),
                  this.client.core.crypto.keychain.has(t.topic) || (r = !0),
                  r && e.push(t.topic);
              }),
                this.client.proposal.getAll().forEach((e) => {
                  (0, eu._dF)(e.expiryTimestamp) && t.push(e.id);
                }),
                await Promise.all([
                  ...e.map((e) => this.deleteSession({ topic: e })),
                  ...t.map((e) => this.deleteProposal(e)),
                ]);
            }),
            i8(this, "onProviderMessageEvent", async (e) => {
              !this.initialized || this.relayMessageCache.length > 0
                ? this.relayMessageCache.push(e)
                : await this.onRelayMessage(e);
            }),
            i8(this, "onRelayEventRequest", async (e) => {
              this.requestQueue.queue.push(e),
                await this.processRequestsQueue();
            }),
            i8(this, "processRequestsQueue", async () => {
              if (this.requestQueue.state === iq.active) {
                this.client.logger.info(
                  "Request queue already active, skipping..."
                );
                return;
              }
              for (
                this.client.logger.info(
                  `Request queue starting with ${this.requestQueue.queue.length} requests`
                );
                this.requestQueue.queue.length > 0;

              ) {
                this.requestQueue.state = iq.active;
                let e = this.requestQueue.queue.shift();
                if (e)
                  try {
                    await this.processRequest(e);
                  } catch (e) {
                    this.client.logger.warn(e);
                  }
              }
              this.requestQueue.state = iq.idle;
            }),
            i8(this, "processRequest", async (e) => {
              let {
                  topic: t,
                  payload: r,
                  attestation: i,
                  transportType: s,
                  encryptedId: n,
                } = e,
                a = r.method;
              if (
                !this.shouldIgnorePairingRequest({ topic: t, requestMethod: a })
              )
                switch (a) {
                  case "wc_sessionPropose":
                    return await this.onSessionProposeRequest({
                      topic: t,
                      payload: r,
                      attestation: i,
                      encryptedId: n,
                    });
                  case "wc_sessionSettle":
                    return await this.onSessionSettleRequest(t, r);
                  case "wc_sessionUpdate":
                    return await this.onSessionUpdateRequest(t, r);
                  case "wc_sessionExtend":
                    return await this.onSessionExtendRequest(t, r);
                  case "wc_sessionPing":
                    return await this.onSessionPingRequest(t, r);
                  case "wc_sessionDelete":
                    return await this.onSessionDeleteRequest(t, r);
                  case "wc_sessionRequest":
                    return await this.onSessionRequest({
                      topic: t,
                      payload: r,
                      attestation: i,
                      encryptedId: n,
                      transportType: s,
                    });
                  case "wc_sessionEvent":
                    return await this.onSessionEventRequest(t, r);
                  case "wc_sessionAuthenticate":
                    return await this.onSessionAuthenticateRequest({
                      topic: t,
                      payload: r,
                      attestation: i,
                      encryptedId: n,
                      transportType: s,
                    });
                  default:
                    return this.client.logger.info(
                      `Unsupported request method ${a}`
                    );
                }
            }),
            i8(this, "onRelayEventResponse", async (e) => {
              let { topic: t, payload: r, transportType: i } = e,
                s = (await this.client.core.history.get(t, r.id)).request
                  .method;
              switch (s) {
                case "wc_sessionPropose":
                  return this.onSessionProposeResponse(t, r, i);
                case "wc_sessionSettle":
                  return this.onSessionSettleResponse(t, r);
                case "wc_sessionUpdate":
                  return this.onSessionUpdateResponse(t, r);
                case "wc_sessionExtend":
                  return this.onSessionExtendResponse(t, r);
                case "wc_sessionPing":
                  return this.onSessionPingResponse(t, r);
                case "wc_sessionRequest":
                  return this.onSessionRequestResponse(t, r);
                case "wc_sessionAuthenticate":
                  return this.onSessionAuthenticateResponse(t, r);
                default:
                  return this.client.logger.info(
                    `Unsupported response method ${s}`
                  );
              }
            }),
            i8(this, "onRelayEventUnknownPayload", (e) => {
              let { topic: t } = e,
                { message: r } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`
                );
              throw Error(r);
            }),
            i8(this, "shouldIgnorePairingRequest", (e) => {
              let { topic: t, requestMethod: r } = e,
                i = this.expectedPairingMethodMap.get(t);
              return (
                !(!i || i.includes(r)) &&
                !!(
                  i.includes("wc_sessionAuthenticate") &&
                  this.client.events.listenerCount("session_authenticate") > 0
                )
              );
            }),
            i8(this, "onSessionProposeRequest", async (e) => {
              let { topic: t, payload: r, attestation: i, encryptedId: s } = e,
                { params: n, id: a } = r;
              try {
                let e = this.client.core.eventClient.getEvent({ topic: t });
                0 === this.client.events.listenerCount("session_proposal") &&
                  (console.warn("No listener for session_proposal event"),
                  e?.setError(tr.proposal_listener_not_found)),
                  this.isValidConnect(i3({}, r.params));
                let o =
                    n.expiryTimestamp ||
                    (0, eu.Xw0)(iW.wc_sessionPropose.req.ttl),
                  c = i3({ id: a, pairingTopic: t, expiryTimestamp: o }, n);
                await this.setProposal(a, c);
                let l = await this.getVerifyContext({
                  attestationId: i,
                  hash: (0, eu.ALl)(JSON.stringify(r)),
                  encryptedId: s,
                  metadata: c.proposer.metadata,
                });
                e?.addTrace(tt.emit_session_proposal),
                  this.client.events.emit("session_proposal", {
                    id: a,
                    params: c,
                    verifyContext: l,
                  });
              } catch (e) {
                await this.sendError({
                  id: a,
                  topic: t,
                  error: e,
                  rpcOpts: iW.wc_sessionPropose.autoReject,
                }),
                  this.client.logger.error(e);
              }
            }),
            i8(this, "onSessionProposeResponse", async (e, t, r) => {
              let { id: i } = t;
              if (eD(t)) {
                let { result: s } = t;
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  result: s,
                });
                let n = this.client.proposal.get(i);
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  proposal: n,
                });
                let a = n.proposer.publicKey;
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  selfPublicKey: a,
                });
                let o = s.responderPublicKey;
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  peerPublicKey: o,
                });
                let c = await this.client.core.crypto.generateSharedKey(a, o);
                this.pendingSessions.set(i, {
                  sessionTopic: c,
                  pairingTopic: e,
                  proposalId: i,
                  publicKey: a,
                });
                let l = await this.client.core.relayer.subscribe(c, {
                  transportType: r,
                });
                this.client.logger.trace({
                  type: "method",
                  method: "onSessionProposeResponse",
                  subscriptionId: l,
                }),
                  await this.client.core.pairing.activate({ topic: e });
              } else if (eM(t)) {
                await this.client.proposal.delete(
                  i,
                  (0, eu.Hjj)("USER_DISCONNECTED")
                );
                let e = (0, eu.hEn)("session_connect", i);
                if (0 === this.events.listenerCount(e))
                  throw Error(`emitting ${e} without any listeners, 954`);
                this.events.emit(e, { error: t.error });
              }
            }),
            i8(this, "onSessionSettleRequest", async (e, t) => {
              let { id: r, params: i } = t;
              try {
                this.isValidSessionSettleRequest(i);
                let {
                    relay: r,
                    controller: s,
                    expiry: n,
                    namespaces: a,
                    sessionProperties: o,
                    scopedProperties: c,
                    sessionConfig: l,
                  } = t.params,
                  d = [...this.pendingSessions.values()].find(
                    (t) => t.sessionTopic === e
                  );
                if (!d)
                  return this.client.logger.error(
                    `Pending session not found for topic ${e}`
                  );
                let u = this.client.proposal.get(d.proposalId),
                  h = i5(
                    i3(
                      i3(
                        i3(
                          {
                            topic: e,
                            relay: r,
                            expiry: n,
                            namespaces: a,
                            acknowledged: !0,
                            pairingTopic: d.pairingTopic,
                            requiredNamespaces: u.requiredNamespaces,
                            optionalNamespaces: u.optionalNamespaces,
                            controller: s.publicKey,
                            self: {
                              publicKey: d.publicKey,
                              metadata: this.client.metadata,
                            },
                            peer: {
                              publicKey: s.publicKey,
                              metadata: s.metadata,
                            },
                          },
                          o && { sessionProperties: o }
                        ),
                        c && { scopedProperties: c }
                      ),
                      l && { sessionConfig: l }
                    ),
                    { transportType: e0.relay }
                  );
                await this.client.session.set(h.topic, h),
                  await this.setExpiry(h.topic, h.expiry),
                  await this.client.core.pairing.updateMetadata({
                    topic: d.pairingTopic,
                    metadata: h.peer.metadata,
                  }),
                  this.client.events.emit("session_connect", { session: h }),
                  this.events.emit(
                    (0, eu.hEn)("session_connect", d.proposalId),
                    { session: h }
                  ),
                  this.pendingSessions.delete(d.proposalId),
                  this.deleteProposal(d.proposalId, !1),
                  this.cleanupDuplicatePairings(h),
                  await this.sendResult({
                    id: t.id,
                    topic: e,
                    result: !0,
                    throwOnFailedPublish: !0,
                  });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            i8(this, "onSessionSettleResponse", async (e, t) => {
              let { id: r } = t;
              eD(t)
                ? (await this.client.session.update(e, { acknowledged: !0 }),
                  this.events.emit((0, eu.hEn)("session_approve", r), {}))
                : eM(t) &&
                  (await this.client.session.delete(
                    e,
                    (0, eu.Hjj)("USER_DISCONNECTED")
                  ),
                  this.events.emit((0, eu.hEn)("session_approve", r), {
                    error: t.error,
                  }));
            }),
            i8(this, "onSessionUpdateRequest", async (e, t) => {
              let { params: r, id: i } = t;
              try {
                let t = `${e}_session_update`,
                  s = eu.nyL.get(t);
                if (s && this.isRequestOutOfSync(s, i)) {
                  this.client.logger.warn(
                    `Discarding out of sync request - ${i}`
                  ),
                    this.sendError({
                      id: i,
                      topic: e,
                      error: (0, eu.Hjj)("INVALID_UPDATE_REQUEST"),
                    });
                  return;
                }
                this.isValidUpdate(i3({ topic: e }, r));
                try {
                  eu.nyL.set(t, i),
                    await this.client.session.update(e, {
                      namespaces: r.namespaces,
                    }),
                    await this.sendResult({
                      id: i,
                      topic: e,
                      result: !0,
                      throwOnFailedPublish: !0,
                    });
                } catch (e) {
                  throw (eu.nyL.delete(t), e);
                }
                this.client.events.emit("session_update", {
                  id: i,
                  topic: e,
                  params: r,
                });
              } catch (t) {
                await this.sendError({ id: i, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            i8(
              this,
              "isRequestOutOfSync",
              (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)
            ),
            i8(this, "onSessionUpdateResponse", (e, t) => {
              let { id: r } = t,
                i = (0, eu.hEn)("session_update", r);
              if (0 === this.events.listenerCount(i))
                throw Error(`emitting ${i} without any listeners`);
              eD(t)
                ? this.events.emit((0, eu.hEn)("session_update", r), {})
                : eM(t) &&
                  this.events.emit((0, eu.hEn)("session_update", r), {
                    error: t.error,
                  });
            }),
            i8(this, "onSessionExtendRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidExtend({ topic: e }),
                  await this.setExpiry(e, (0, eu.Xw0)(iz)),
                  await this.sendResult({
                    id: r,
                    topic: e,
                    result: !0,
                    throwOnFailedPublish: !0,
                  }),
                  this.client.events.emit("session_extend", {
                    id: r,
                    topic: e,
                  });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            i8(this, "onSessionExtendResponse", (e, t) => {
              let { id: r } = t,
                i = (0, eu.hEn)("session_extend", r);
              if (0 === this.events.listenerCount(i))
                throw Error(`emitting ${i} without any listeners`);
              eD(t)
                ? this.events.emit((0, eu.hEn)("session_extend", r), {})
                : eM(t) &&
                  this.events.emit((0, eu.hEn)("session_extend", r), {
                    error: t.error,
                  });
            }),
            i8(this, "onSessionPingRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidPing({ topic: e }),
                  await this.sendResult({
                    id: r,
                    topic: e,
                    result: !0,
                    throwOnFailedPublish: !0,
                  }),
                  this.client.events.emit("session_ping", { id: r, topic: e });
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            i8(this, "onSessionPingResponse", (e, t) => {
              let { id: r } = t,
                i = (0, eu.hEn)("session_ping", r);
              setTimeout(() => {
                if (0 === this.events.listenerCount(i))
                  throw Error(`emitting ${i} without any listeners 2176`);
                eD(t)
                  ? this.events.emit((0, eu.hEn)("session_ping", r), {})
                  : eM(t) &&
                    this.events.emit((0, eu.hEn)("session_ping", r), {
                      error: t.error,
                    });
              }, 500);
            }),
            i8(this, "onSessionDeleteRequest", async (e, t) => {
              let { id: r } = t;
              try {
                this.isValidDisconnect({ topic: e, reason: t.params }),
                  Promise.all([
                    new Promise((t) => {
                      this.client.core.relayer.once(eZ.publish, async () => {
                        t(await this.deleteSession({ topic: e, id: r }));
                      });
                    }),
                    this.sendResult({
                      id: r,
                      topic: e,
                      result: !0,
                      throwOnFailedPublish: !0,
                    }),
                    this.cleanupPendingSentRequestsForTopic({
                      topic: e,
                      error: (0, eu.Hjj)("USER_DISCONNECTED"),
                    }),
                  ]).catch((e) => this.client.logger.error(e));
              } catch (e) {
                this.client.logger.error(e);
              }
            }),
            i8(this, "onSessionRequest", async (e) => {
              var t, r, i;
              let {
                  topic: s,
                  payload: n,
                  attestation: a,
                  encryptedId: o,
                  transportType: c,
                } = e,
                { id: l, params: d } = n;
              try {
                await this.isValidRequest(i3({ topic: s }, d));
                let e = this.client.session.get(s),
                  n = await this.getVerifyContext({
                    attestationId: a,
                    hash: (0, eu.ALl)(
                      JSON.stringify(eE("wc_sessionRequest", d, l))
                    ),
                    encryptedId: o,
                    metadata: e.peer.metadata,
                    transportType: c,
                  }),
                  u = { id: l, topic: s, params: d, verifyContext: n };
                await this.setPendingSessionRequest(u),
                  c === e0.link_mode &&
                    null != (t = e.peer.metadata.redirect) &&
                    t.universal &&
                    this.client.core.addLinkModeSupportedApp(
                      null == (r = e.peer.metadata.redirect)
                        ? void 0
                        : r.universal
                    ),
                  null != (i = this.client.signConfig) && i.disableRequestQueue
                    ? this.emitSessionRequest(u)
                    : (this.addSessionRequestToSessionRequestQueue(u),
                      this.processSessionRequestQueue());
              } catch (e) {
                await this.sendError({ id: l, topic: s, error: e }),
                  this.client.logger.error(e);
              }
            }),
            i8(this, "onSessionRequestResponse", (e, t) => {
              let { id: r } = t,
                i = (0, eu.hEn)("session_request", r);
              if (0 === this.events.listenerCount(i))
                throw Error(`emitting ${i} without any listeners`);
              eD(t)
                ? this.events.emit((0, eu.hEn)("session_request", r), {
                    result: t.result,
                  })
                : eM(t) &&
                  this.events.emit((0, eu.hEn)("session_request", r), {
                    error: t.error,
                  });
            }),
            i8(this, "onSessionEventRequest", async (e, t) => {
              let { id: r, params: i } = t;
              try {
                let t = `${e}_session_event_${i.event.name}`,
                  s = eu.nyL.get(t);
                if (s && this.isRequestOutOfSync(s, r)) {
                  this.client.logger.info(
                    `Discarding out of sync request - ${r}`
                  );
                  return;
                }
                this.isValidEmit(i3({ topic: e }, i)),
                  this.client.events.emit("session_event", {
                    id: r,
                    topic: e,
                    params: i,
                  }),
                  eu.nyL.set(t, r);
              } catch (t) {
                await this.sendError({ id: r, topic: e, error: t }),
                  this.client.logger.error(t);
              }
            }),
            i8(this, "onSessionAuthenticateResponse", (e, t) => {
              let { id: r } = t;
              this.client.logger.trace({
                type: "method",
                method: "onSessionAuthenticateResponse",
                topic: e,
                payload: t,
              }),
                eD(t)
                  ? this.events.emit((0, eu.hEn)("session_request", r), {
                      result: t.result,
                    })
                  : eM(t) &&
                    this.events.emit((0, eu.hEn)("session_request", r), {
                      error: t.error,
                    });
            }),
            i8(this, "onSessionAuthenticateRequest", async (e) => {
              var t;
              let {
                topic: r,
                payload: i,
                attestation: s,
                encryptedId: n,
                transportType: a,
              } = e;
              try {
                let {
                    requester: e,
                    authPayload: o,
                    expiryTimestamp: c,
                  } = i.params,
                  l = await this.getVerifyContext({
                    attestationId: s,
                    hash: (0, eu.ALl)(JSON.stringify(i)),
                    encryptedId: n,
                    metadata: e.metadata,
                    transportType: a,
                  }),
                  d = {
                    requester: e,
                    pairingTopic: r,
                    id: i.id,
                    authPayload: o,
                    verifyContext: l,
                    expiryTimestamp: c,
                  };
                await this.setAuthRequest(i.id, {
                  request: d,
                  pairingTopic: r,
                  transportType: a,
                }),
                  a === e0.link_mode &&
                    null != (t = e.metadata.redirect) &&
                    t.universal &&
                    this.client.core.addLinkModeSupportedApp(
                      e.metadata.redirect.universal
                    ),
                  this.client.events.emit("session_authenticate", {
                    topic: r,
                    params: i.params,
                    id: i.id,
                    verifyContext: l,
                  });
              } catch (o) {
                this.client.logger.error(o);
                let e = i.params.requester.publicKey,
                  t = await this.client.core.crypto.generateKeyPair(),
                  s = this.getAppLinkIfEnabled(i.params.requester.metadata, a),
                  n = {
                    type: eu.Lp_,
                    receiverPublicKey: e,
                    senderPublicKey: t,
                  };
                await this.sendError({
                  id: i.id,
                  topic: r,
                  error: o,
                  encodeOpts: n,
                  rpcOpts: iW.wc_sessionAuthenticate.autoReject,
                  appLink: s,
                });
              }
            }),
            i8(this, "addSessionRequestToSessionRequestQueue", (e) => {
              this.sessionRequestQueue.queue.push(e);
            }),
            i8(this, "cleanupAfterResponse", (e) => {
              this.deletePendingSessionRequest(e.response.id, {
                message: "fulfilled",
                code: 0,
              }),
                setTimeout(() => {
                  (this.sessionRequestQueue.state = iq.idle),
                    this.processSessionRequestQueue();
                }, (0, a.toMiliseconds)(this.requestQueueDelay));
            }),
            i8(
              this,
              "cleanupPendingSentRequestsForTopic",
              ({ topic: e, error: t }) => {
                let r = this.client.core.history.pending;
                r.length > 0 &&
                  r
                    .filter(
                      (t) =>
                        t.topic === e &&
                        "wc_sessionRequest" === t.request.method
                    )
                    .forEach((e) => {
                      let r = e.request.id,
                        i = (0, eu.hEn)("session_request", r);
                      if (0 === this.events.listenerCount(i))
                        throw Error(`emitting ${i} without any listeners`);
                      this.events.emit(
                        (0, eu.hEn)("session_request", e.request.id),
                        { error: t }
                      );
                    });
              }
            ),
            i8(this, "processSessionRequestQueue", () => {
              if (this.sessionRequestQueue.state === iq.active) {
                this.client.logger.info(
                  "session request queue is already active."
                );
                return;
              }
              let e = this.sessionRequestQueue.queue[0];
              if (!e) {
                this.client.logger.info("session request queue is empty.");
                return;
              }
              try {
                (this.sessionRequestQueue.state = iq.active),
                  this.emitSessionRequest(e);
              } catch (e) {
                this.client.logger.error(e);
              }
            }),
            i8(this, "emitSessionRequest", (e) => {
              this.client.events.emit("session_request", e);
            }),
            i8(this, "onPairingCreated", (e) => {
              if (
                (e.methods &&
                  this.expectedPairingMethodMap.set(e.topic, e.methods),
                e.active)
              )
                return;
              let t = this.client.proposal
                .getAll()
                .find((t) => t.pairingTopic === e.topic);
              t &&
                this.onSessionProposeRequest({
                  topic: e.topic,
                  payload: eE(
                    "wc_sessionPropose",
                    i5(i3({}, t), {
                      requiredNamespaces: t.requiredNamespaces,
                      optionalNamespaces: t.optionalNamespaces,
                      relays: t.relays,
                      proposer: t.proposer,
                      sessionProperties: t.sessionProperties,
                      scopedProperties: t.scopedProperties,
                    }),
                    t.id
                  ),
                });
            }),
            i8(this, "isValidConnect", async (e) => {
              if (!(0, eu.TeY)(e)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `connect() params: ${JSON.stringify(e)}`
                );
                throw Error(t);
              }
              let {
                pairingTopic: t,
                requiredNamespaces: r,
                optionalNamespaces: i,
                sessionProperties: s,
                scopedProperties: n,
                relays: a,
              } = e;
              if (
                ((0, eu.b07)(t) || (await this.isValidPairingTopic(t)),
                !(0, eu.V9G)(a, !0))
              ) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `connect() relays: ${a}`
                );
                throw Error(e);
              }
              if (
                ((0, eu.b07)(r) ||
                  0 === (0, eu.aF0)(r) ||
                  this.validateNamespaces(r, "requiredNamespaces"),
                (0, eu.b07)(i) ||
                  0 === (0, eu.aF0)(i) ||
                  this.validateNamespaces(i, "optionalNamespaces"),
                (0, eu.b07)(s) ||
                  this.validateSessionProps(s, "sessionProperties"),
                !(0, eu.b07)(n))
              ) {
                this.validateSessionProps(n, "scopedProperties");
                let e = Object.keys(r || {}).concat(Object.keys(i || {}));
                if (!Object.keys(n).every((t) => e.includes(t)))
                  throw Error(
                    `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(
                      n
                    )}, required/optional namespaces: ${JSON.stringify(e)}`
                  );
              }
            }),
            i8(this, "validateNamespaces", (e, t) => {
              let r = (0, eu.esh)(e, "connect()", t);
              if (r) throw Error(r.message);
            }),
            i8(this, "isValidApprove", async (e) => {
              if (!(0, eu.TeY)(e))
                throw Error(
                  (0, eu.GuA)("MISSING_OR_INVALID", `approve() params: ${e}`)
                    .message
                );
              let {
                id: t,
                namespaces: r,
                relayProtocol: i,
                sessionProperties: s,
                scopedProperties: n,
              } = e;
              this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
              let a = this.client.proposal.get(t),
                o = (0, eu.FiO)(r, "approve()");
              if (o) throw Error(o.message);
              let c = (0, eu.XqR)(a.requiredNamespaces, r, "approve()");
              if (c) throw Error(c.message);
              if (!(0, eu.Qhg)(i, !0)) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `approve() relayProtocol: ${i}`
                );
                throw Error(e);
              }
              if (
                ((0, eu.b07)(s) ||
                  this.validateSessionProps(s, "sessionProperties"),
                !(0, eu.b07)(n))
              ) {
                this.validateSessionProps(n, "scopedProperties");
                let e = new Set(Object.keys(r));
                if (!Object.keys(n).every((t) => e.has(t)))
                  throw Error(
                    `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(
                      n
                    )}, approved namespaces: ${Array.from(e).join(", ")}`
                  );
              }
            }),
            i8(this, "isValidReject", async (e) => {
              if (!(0, eu.TeY)(e)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `reject() params: ${e}`
                );
                throw Error(t);
              }
              let { id: t, reason: r } = e;
              if (
                (this.checkRecentlyDeleted(t),
                await this.isValidProposalId(t),
                !(0, eu.X3c)(r))
              ) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `reject() reason: ${JSON.stringify(r)}`
                );
                throw Error(e);
              }
            }),
            i8(this, "isValidSessionSettleRequest", (e) => {
              if (!(0, eu.TeY)(e)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `onSessionSettleRequest() params: ${e}`
                );
                throw Error(t);
              }
              let { relay: t, controller: r, namespaces: i, expiry: s } = e;
              if (!(0, eu.kuU)(t)) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  "onSessionSettleRequest() relay protocol should be a string"
                );
                throw Error(e);
              }
              let n = (0, eu.tk0)(r, "onSessionSettleRequest()");
              if (n) throw Error(n.message);
              let a = (0, eu.FiO)(i, "onSessionSettleRequest()");
              if (a) throw Error(a.message);
              if ((0, eu._dF)(s)) {
                let { message: e } = (0, eu.GuA)(
                  "EXPIRED",
                  "onSessionSettleRequest()"
                );
                throw Error(e);
              }
            }),
            i8(this, "isValidUpdate", async (e) => {
              if (!(0, eu.TeY)(e)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `update() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t, namespaces: r } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
              let i = this.client.session.get(t),
                s = (0, eu.FiO)(r, "update()");
              if (s) throw Error(s.message);
              let n = (0, eu.XqR)(i.requiredNamespaces, r, "update()");
              if (n) throw Error(n.message);
            }),
            i8(this, "isValidExtend", async (e) => {
              if (!(0, eu.TeY)(e)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `extend() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
            }),
            i8(this, "isValidRequest", async (e) => {
              if (!(0, eu.TeY)(e)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `request() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t, request: r, chainId: i, expiry: s } = e;
              this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
              let { namespaces: n } = this.client.session.get(t);
              if (!(0, eu.tLy)(n, i)) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `request() chainId: ${i}`
                );
                throw Error(e);
              }
              if (!(0, eu.iV1)(r)) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `request() ${JSON.stringify(r)}`
                );
                throw Error(e);
              }
              if (!(0, eu.oKp)(n, i, r.method)) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `request() method: ${r.method}`
                );
                throw Error(e);
              }
              if (s && !(0, eu.Hbs)(s, iH)) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `request() expiry: ${s}. Expiry must be a number (in seconds) between ${iH.min} and ${iH.max}`
                );
                throw Error(e);
              }
            }),
            i8(this, "isValidRespond", async (e) => {
              var t;
              if (!(0, eu.TeY)(e)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `respond() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: r, response: i } = e;
              try {
                await this.isValidSessionTopic(r);
              } catch (r) {
                throw (
                  (null != (t = e?.response) &&
                    t.id &&
                    this.cleanupAfterResponse(e),
                  r)
                );
              }
              if (!(0, eu.M8n)(i)) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `respond() response: ${JSON.stringify(i)}`
                );
                throw Error(e);
              }
            }),
            i8(this, "isValidPing", async (e) => {
              if (!(0, eu.TeY)(e)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `ping() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidSessionOrPairingTopic(t);
            }),
            i8(this, "isValidEmit", async (e) => {
              if (!(0, eu.TeY)(e)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `emit() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t, event: r, chainId: i } = e;
              await this.isValidSessionTopic(t);
              let { namespaces: s } = this.client.session.get(t);
              if (!(0, eu.tLy)(s, i)) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `emit() chainId: ${i}`
                );
                throw Error(e);
              }
              if (!(0, eu.FR8)(r) || !(0, eu.z2N)(s, i, r.name)) {
                let { message: e } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `emit() event: ${JSON.stringify(r)}`
                );
                throw Error(e);
              }
            }),
            i8(this, "isValidDisconnect", async (e) => {
              if (!(0, eu.TeY)(e)) {
                let { message: t } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `disconnect() params: ${e}`
                );
                throw Error(t);
              }
              let { topic: t } = e;
              await this.isValidSessionOrPairingTopic(t);
            }),
            i8(this, "isValidAuthenticate", (e) => {
              let { chains: t, uri: r, domain: i, nonce: s } = e;
              if (!Array.isArray(t) || 0 === t.length)
                throw Error("chains is required and must be a non-empty array");
              if (!(0, eu.Qhg)(r, !1)) throw Error("uri is required parameter");
              if (!(0, eu.Qhg)(i, !1))
                throw Error("domain is required parameter");
              if (!(0, eu.Qhg)(s, !1))
                throw Error("nonce is required parameter");
              if (
                [...new Set(t.map((e) => (0, eu._Yb)(e).namespace))].length > 1
              )
                throw Error(
                  "Multi-namespace requests are not supported. Please request single namespace only."
                );
              let { namespace: n } = (0, eu._Yb)(t[0]);
              if ("eip155" !== n)
                throw Error(
                  "Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains."
                );
            }),
            i8(this, "getVerifyContext", async (e) => {
              let {
                  attestationId: t,
                  hash: r,
                  encryptedId: i,
                  metadata: s,
                  transportType: n,
                } = e,
                a = {
                  verified: {
                    verifyUrl: s.verifyUrl || e9,
                    validation: "UNKNOWN",
                    origin: s.url || "",
                  },
                };
              try {
                if (n === e0.link_mode) {
                  let e = this.getAppLinkIfEnabled(s, n);
                  return (
                    (a.verified.validation =
                      e && new URL(e).origin === new URL(s.url).origin
                        ? "VALID"
                        : "INVALID"),
                    a
                  );
                }
                let e = await this.client.core.verify.resolve({
                  attestationId: t,
                  hash: r,
                  encryptedId: i,
                  verifyUrl: s.verifyUrl,
                });
                e &&
                  ((a.verified.origin = e.origin),
                  (a.verified.isScam = e.isScam),
                  (a.verified.validation =
                    e.origin === new URL(s.url).origin ? "VALID" : "INVALID"));
              } catch (e) {
                this.client.logger.warn(e);
              }
              return (
                this.client.logger.debug(
                  `Verify context: ${JSON.stringify(a)}`
                ),
                a
              );
            }),
            i8(this, "validateSessionProps", (e, t) => {
              Object.values(e).forEach((r, i) => {
                if (null == r) {
                  let { message: s } = (0, eu.GuA)(
                    "MISSING_OR_INVALID",
                    `${t} must contain an existing value for each key. Received: ${r} for key ${
                      Object.keys(e)[i]
                    }`
                  );
                  throw Error(s);
                }
              });
            }),
            i8(this, "getPendingAuthRequest", (e) => {
              let t = this.client.auth.requests.get(e);
              return "object" == typeof t ? t : void 0;
            }),
            i8(this, "addToRecentlyDeleted", (e, t) => {
              if (
                (this.recentlyDeletedMap.set(e, t),
                this.recentlyDeletedMap.size >= this.recentlyDeletedLimit)
              ) {
                let e = 0,
                  t = this.recentlyDeletedLimit / 2;
                for (let r of this.recentlyDeletedMap.keys()) {
                  if (e++ >= t) break;
                  this.recentlyDeletedMap.delete(r);
                }
              }
            }),
            i8(this, "checkRecentlyDeleted", (e) => {
              let t = this.recentlyDeletedMap.get(e);
              if (t) {
                let { message: r } = (0, eu.GuA)(
                  "MISSING_OR_INVALID",
                  `Record was recently deleted - ${t}: ${e}`
                );
                throw Error(r);
              }
            }),
            i8(this, "isLinkModeEnabled", (e, t) => {
              var i, s, n, a, o, c, l, d, u;
              return (
                !!e &&
                t === e0.link_mode &&
                (null ==
                (s = null == (i = this.client.metadata) ? void 0 : i.redirect)
                  ? void 0
                  : s.linkMode) === !0 &&
                (null ==
                (a = null == (n = this.client.metadata) ? void 0 : n.redirect)
                  ? void 0
                  : a.universal) !== void 0 &&
                (null ==
                (c = null == (o = this.client.metadata) ? void 0 : o.redirect)
                  ? void 0
                  : c.universal) !== "" &&
                (null == (l = e?.redirect) ? void 0 : l.universal) !== void 0 &&
                (null == (d = e?.redirect) ? void 0 : d.universal) !== "" &&
                (null == (u = e?.redirect) ? void 0 : u.linkMode) === !0 &&
                this.client.core.linkModeSupportedApps.includes(
                  e.redirect.universal
                ) &&
                "u" > typeof (null == r.g ? void 0 : r.g.Linking)
              );
            }),
            i8(this, "getAppLinkIfEnabled", (e, t) => {
              var r;
              return this.isLinkModeEnabled(e, t)
                ? null == (r = e?.redirect)
                  ? void 0
                  : r.universal
                : void 0;
            }),
            i8(this, "handleLinkModeMessage", ({ url: e }) => {
              if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
              let t = (0, eu.$hI)(e, "topic") || "",
                r = decodeURIComponent((0, eu.$hI)(e, "wc_ev") || ""),
                i = this.client.session.keys.includes(t);
              i &&
                this.client.session.update(t, { transportType: e0.link_mode }),
                this.client.core.dispatchEnvelope({
                  topic: t,
                  message: r,
                  sessionExists: i,
                });
            }),
            i8(this, "registerLinkModeListeners", async () => {
              var e;
              if (
                (0, eu.w8K)() ||
                ((0, eu.lVv)() &&
                  null != (e = this.client.metadata.redirect) &&
                  e.linkMode)
              ) {
                let e = null == r.g ? void 0 : r.g.Linking;
                if ("u" > typeof e) {
                  e.addEventListener(
                    "url",
                    this.handleLinkModeMessage,
                    this.client.name
                  );
                  let t = await e.getInitialURL();
                  t &&
                    setTimeout(() => {
                      this.handleLinkModeMessage({ url: t });
                    }, 50);
                }
              }
            }),
            i8(this, "shouldSetTVF", (e, t) => {
              if (!t || "wc_sessionRequest" !== e) return !1;
              let { request: r } = t;
              return Object.keys(iV).includes(r.method);
            }),
            i8(this, "getTVFParams", (e, t, r) => {
              var i, s;
              try {
                let n = t.request.method,
                  a = this.extractTxHashesFromResult(n, r);
                return i5(
                  i3(
                    { correlationId: e, rpcMethods: [n], chainId: t.chainId },
                    this.isValidContractData(t.request.params) && {
                      contractAddresses: [
                        null ==
                        (s = null == (i = t.request.params) ? void 0 : i[0])
                          ? void 0
                          : s.to,
                      ],
                    }
                  ),
                  { txHashes: a }
                );
              } catch (e) {
                this.client.logger.warn("Error getting TVF params", e);
              }
              return {};
            }),
            i8(this, "isValidContractData", (e) => {
              var t;
              if (!e) return !1;
              try {
                let r = e?.data || (null == (t = e?.[0]) ? void 0 : t.data);
                if (!r.startsWith("0x")) return !1;
                let i = r.slice(2);
                return !!/^[0-9a-fA-F]*$/.test(i) && i.length % 2 == 0;
              } catch {}
              return !1;
            }),
            i8(this, "extractTxHashesFromResult", (e, t) => {
              try {
                let r = iV[e];
                if ("string" == typeof t) return [t];
                let i = t[r.key];
                if ((0, eu.OP1)(i))
                  return "solana_signAllTransactions" === e
                    ? i.map((e) => (0, eu.PAk)(e))
                    : i;
                if ("string" == typeof i) return [i];
              } catch (e) {
                this.client.logger.warn(
                  "Error extracting tx hashes from result",
                  e
                );
              }
              return [];
            });
        }
        async processPendingMessageEvents() {
          try {
            let e = this.client.session.keys,
              t = this.client.core.relayer.messages.getWithoutAck(e);
            for (let [e, r] of Object.entries(t))
              for (let t of r)
                try {
                  await this.onProviderMessageEvent({
                    topic: e,
                    message: t,
                    publishedAt: Date.now(),
                  });
                } catch {
                  this.client.logger.warn(
                    `Error processing pending message event for topic: ${e}, message: ${t}`
                  );
                }
          } catch (e) {
            this.client.logger.warn("processPendingMessageEvents failed", e);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            let { message: e } = (0, eu.GuA)("NOT_INITIALIZED", this.name);
            throw Error(e);
          }
        }
        async confirmOnlineStateOrThrow() {
          await this.client.core.relayer.confirmOnlineStateOrThrow();
        }
        registerRelayerEvents() {
          this.client.core.relayer.on(eZ.message, (e) => {
            this.onProviderMessageEvent(e);
          });
        }
        async onRelayMessage(e) {
          let { topic: t, message: r, attestation: i, transportType: s } = e,
            { publicKey: n } = this.client.auth.authKeys.keys.includes(iY)
              ? this.client.auth.authKeys.get(iY)
              : { responseTopic: void 0, publicKey: void 0 };
          try {
            let e = await this.client.core.crypto.decode(t, r, {
              receiverPublicKey: n,
              encoding: s === e0.link_mode ? eu.Pa8 : eu.EWt,
            });
            ek(e)
              ? (this.client.core.history.set(t, e),
                await this.onRelayEventRequest({
                  topic: t,
                  payload: e,
                  attestation: i,
                  transportType: s,
                  encryptedId: (0, eu.ALl)(r),
                }))
              : eR(e)
              ? (await this.client.core.history.resolve(e),
                await this.onRelayEventResponse({
                  topic: t,
                  payload: e,
                  transportType: s,
                }),
                this.client.core.history.delete(t, e.id))
              : await this.onRelayEventUnknownPayload({
                  topic: t,
                  payload: e,
                  transportType: s,
                }),
              await this.client.core.relayer.messages.ack(t, r);
          } catch (e) {
            this.client.logger.error(e);
          }
        }
        registerExpirerEvents() {
          this.client.core.expirer.on(e4.expired, async (e) => {
            let { topic: t, id: r } = (0, eu.c82)(e.target);
            return r && this.client.pendingRequest.keys.includes(r)
              ? await this.deletePendingSessionRequest(
                  r,
                  (0, eu.GuA)("EXPIRED"),
                  !0
                )
              : r && this.client.auth.requests.keys.includes(r)
              ? await this.deletePendingAuthRequest(
                  r,
                  (0, eu.GuA)("EXPIRED"),
                  !0
                )
              : void (t
                  ? this.client.session.keys.includes(t) &&
                    (await this.deleteSession({
                      topic: t,
                      expirerHasDeleted: !0,
                    }),
                    this.client.events.emit("session_expire", { topic: t }))
                  : r &&
                    (await this.deleteProposal(r, !0),
                    this.client.events.emit("proposal_expire", { id: r })));
          });
        }
        registerPairingEvents() {
          this.client.core.pairing.events.on(e8.create, (e) =>
            this.onPairingCreated(e)
          ),
            this.client.core.pairing.events.on(e8.delete, (e) => {
              this.addToRecentlyDeleted(e.topic, "pairing");
            });
        }
        isValidPairingTopic(e) {
          if (!(0, eu.Qhg)(e, !1)) {
            let { message: t } = (0, eu.GuA)(
              "MISSING_OR_INVALID",
              `pairing topic should be a string: ${e}`
            );
            throw Error(t);
          }
          if (!this.client.core.pairing.pairings.keys.includes(e)) {
            let { message: t } = (0, eu.GuA)(
              "NO_MATCHING_KEY",
              `pairing topic doesn't exist: ${e}`
            );
            throw Error(t);
          }
          if ((0, eu._dF)(this.client.core.pairing.pairings.get(e).expiry)) {
            let { message: t } = (0, eu.GuA)("EXPIRED", `pairing topic: ${e}`);
            throw Error(t);
          }
        }
        async isValidSessionTopic(e) {
          if (!(0, eu.Qhg)(e, !1)) {
            let { message: t } = (0, eu.GuA)(
              "MISSING_OR_INVALID",
              `session topic should be a string: ${e}`
            );
            throw Error(t);
          }
          if (
            (this.checkRecentlyDeleted(e),
            !this.client.session.keys.includes(e))
          ) {
            let { message: t } = (0, eu.GuA)(
              "NO_MATCHING_KEY",
              `session topic doesn't exist: ${e}`
            );
            throw Error(t);
          }
          if ((0, eu._dF)(this.client.session.get(e).expiry)) {
            await this.deleteSession({ topic: e });
            let { message: t } = (0, eu.GuA)("EXPIRED", `session topic: ${e}`);
            throw Error(t);
          }
          if (!this.client.core.crypto.keychain.has(e)) {
            let { message: t } = (0, eu.GuA)(
              "MISSING_OR_INVALID",
              `session topic does not exist in keychain: ${e}`
            );
            throw (await this.deleteSession({ topic: e }), Error(t));
          }
        }
        async isValidSessionOrPairingTopic(e) {
          if (
            (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e))
          )
            await this.isValidSessionTopic(e);
          else if (this.client.core.pairing.pairings.keys.includes(e))
            this.isValidPairingTopic(e);
          else if ((0, eu.Qhg)(e, !1)) {
            let { message: t } = (0, eu.GuA)(
              "NO_MATCHING_KEY",
              `session or pairing topic doesn't exist: ${e}`
            );
            throw Error(t);
          } else {
            let { message: t } = (0, eu.GuA)(
              "MISSING_OR_INVALID",
              `session or pairing topic should be a string: ${e}`
            );
            throw Error(t);
          }
        }
        async isValidProposalId(e) {
          if (!(0, eu.Alu)(e)) {
            let { message: t } = (0, eu.GuA)(
              "MISSING_OR_INVALID",
              `proposal id should be a number: ${e}`
            );
            throw Error(t);
          }
          if (!this.client.proposal.keys.includes(e)) {
            let { message: t } = (0, eu.GuA)(
              "NO_MATCHING_KEY",
              `proposal id doesn't exist: ${e}`
            );
            throw Error(t);
          }
          if ((0, eu._dF)(this.client.proposal.get(e).expiryTimestamp)) {
            await this.deleteProposal(e);
            let { message: t } = (0, eu.GuA)("EXPIRED", `proposal id: ${e}`);
            throw Error(t);
          }
        }
      }
      class i4 extends r9 {
        constructor(e, t) {
          super(e, t, "proposal", iB), (this.core = e), (this.logger = t);
        }
      }
      class i9 extends r9 {
        constructor(e, t) {
          super(e, t, "session", iB), (this.core = e), (this.logger = t);
        }
      }
      class i7 extends r9 {
        constructor(e, t) {
          super(e, t, "request", iB, (e) => e.id),
            (this.core = e),
            (this.logger = t);
        }
      }
      class se extends r9 {
        constructor(e, t) {
          super(e, t, "authKeys", iG, () => iY),
            (this.core = e),
            (this.logger = t);
        }
      }
      class st extends r9 {
        constructor(e, t) {
          super(e, t, "pairingTopics", iG), (this.core = e), (this.logger = t);
        }
      }
      class sr extends r9 {
        constructor(e, t) {
          super(e, t, "requests", iG, (e) => e.id),
            (this.core = e),
            (this.logger = t);
        }
      }
      var si = Object.defineProperty,
        ss = (e, t, r) =>
          t in e
            ? si(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        sn = (e, t, r) => ss(e, "symbol" != typeof t ? t + "" : t, r);
      class sa {
        constructor(e, t) {
          (this.core = e),
            (this.logger = t),
            sn(this, "authKeys"),
            sn(this, "pairingTopics"),
            sn(this, "requests"),
            (this.authKeys = new se(this.core, this.logger)),
            (this.pairingTopics = new st(this.core, this.logger)),
            (this.requests = new sr(this.core, this.logger));
        }
        async init() {
          await this.authKeys.init(),
            await this.pairingTopics.init(),
            await this.requests.init();
        }
      }
      var so = Object.defineProperty,
        sc = (e, t, r) =>
          t in e
            ? so(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        sl = (e, t, r) => sc(e, "symbol" != typeof t ? t + "" : t, r);
      class sd extends ec {
        constructor(e) {
          super(e),
            sl(this, "protocol", "wc"),
            sl(this, "version", 2),
            sl(this, "name", ij.name),
            sl(this, "metadata"),
            sl(this, "core"),
            sl(this, "logger"),
            sl(this, "events", new s.EventEmitter()),
            sl(this, "engine"),
            sl(this, "session"),
            sl(this, "proposal"),
            sl(this, "pendingRequest"),
            sl(this, "auth"),
            sl(this, "signConfig"),
            sl(this, "on", (e, t) => this.events.on(e, t)),
            sl(this, "once", (e, t) => this.events.once(e, t)),
            sl(this, "off", (e, t) => this.events.off(e, t)),
            sl(this, "removeListener", (e, t) =>
              this.events.removeListener(e, t)
            ),
            sl(this, "removeAllListeners", (e) =>
              this.events.removeAllListeners(e)
            ),
            sl(this, "connect", async (e) => {
              try {
                return await this.engine.connect(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "pair", async (e) => {
              try {
                return await this.engine.pair(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "approve", async (e) => {
              try {
                return await this.engine.approve(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "reject", async (e) => {
              try {
                return await this.engine.reject(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "update", async (e) => {
              try {
                return await this.engine.update(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "extend", async (e) => {
              try {
                return await this.engine.extend(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "request", async (e) => {
              try {
                return await this.engine.request(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "respond", async (e) => {
              try {
                return await this.engine.respond(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "ping", async (e) => {
              try {
                return await this.engine.ping(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "emit", async (e) => {
              try {
                return await this.engine.emit(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "disconnect", async (e) => {
              try {
                return await this.engine.disconnect(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "find", (e) => {
              try {
                return this.engine.find(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "getPendingSessionRequests", () => {
              try {
                return this.engine.getPendingSessionRequests();
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "authenticate", async (e, t) => {
              try {
                return await this.engine.authenticate(e, t);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "formatAuthMessage", (e) => {
              try {
                return this.engine.formatAuthMessage(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "approveSessionAuthenticate", async (e) => {
              try {
                return await this.engine.approveSessionAuthenticate(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            sl(this, "rejectSessionAuthenticate", async (e) => {
              try {
                return await this.engine.rejectSessionAuthenticate(e);
              } catch (e) {
                throw (this.logger.error(e.message), e);
              }
            }),
            (this.name = e?.name || ij.name),
            (this.metadata = e?.metadata || (0, eu.lFF)()),
            (this.signConfig = e?.signConfig);
          let t =
            "u" > typeof e?.logger && "string" != typeof e?.logger
              ? e.logger
              : (0, F.h6)((0, F.iP)({ level: e?.logger || ij.logger }));
          (this.core = e?.core || new iU(e)),
            (this.logger = (0, F.U5)(t, this.name)),
            (this.session = new i9(this.core, this.logger)),
            (this.proposal = new i4(this.core, this.logger)),
            (this.pendingRequest = new i7(this.core, this.logger)),
            (this.engine = new i6(this)),
            (this.auth = new sa(this.core, this.logger));
        }
        static async init(e) {
          let t = new sd(e);
          return await t.initialize(), t;
        }
        get context() {
          return (0, F.oI)(this.logger);
        }
        get pairing() {
          return this.core.pairing.pairings;
        }
        async initialize() {
          this.logger.trace("Initialized");
          try {
            await this.core.start(),
              await this.session.init(),
              await this.proposal.init(),
              await this.pendingRequest.init(),
              await this.auth.init(),
              await this.engine.init(),
              this.logger.info("SignClient Initialization Success"),
              setTimeout(() => {
                this.engine.processRelayMessageCache();
              }, (0, a.toMiliseconds)(a.ONE_SECOND));
          } catch (e) {
            throw (
              (this.logger.info("SignClient Initialization Failure"),
              this.logger.error(e.message),
              e)
            );
          }
        }
      }
      var su = r(37370),
        sh = r.n(su),
        sf = Object.defineProperty,
        sp = Object.defineProperties,
        sg = Object.getOwnPropertyDescriptors,
        sm = Object.getOwnPropertySymbols,
        sb = Object.prototype.hasOwnProperty,
        sy = Object.prototype.propertyIsEnumerable,
        sw = (e, t, r) =>
          t in e
            ? sf(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        sv = (e, t) => {
          for (var r in t || (t = {})) sb.call(t, r) && sw(e, r, t[r]);
          if (sm) for (var r of sm(t)) sy.call(t, r) && sw(e, r, t[r]);
          return e;
        },
        sA = (e, t) => sp(e, sg(t));
      let sE = {
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
        },
        method: "POST",
      };
      class s_ {
        constructor(e, t = !1) {
          if (
            ((this.url = e),
            (this.disableProviderPing = t),
            (this.events = new s.EventEmitter()),
            (this.isAvailable = !1),
            (this.registering = !1),
            !eT(e))
          )
            throw Error(
              `Provided URL is not compatible with HTTP connection: ${e}`
            );
          (this.url = e), (this.disableProviderPing = t);
        }
        get connected() {
          return this.isAvailable;
        }
        get connecting() {
          return this.registering;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        async open(e = this.url) {
          await this.register(e);
        }
        async close() {
          if (!this.isAvailable) throw Error("Connection already closed");
          this.onClose();
        }
        async send(e) {
          this.isAvailable || (await this.register());
          try {
            let t = (0, P.h)(e),
              r = await (
                await sh()(this.url, sA(sv({}, sE), { body: t }))
              ).json();
            this.onPayload({ data: r });
          } catch (t) {
            this.onError(e.id, t);
          }
        }
        async register(e = this.url) {
          if (!eT(e))
            throw Error(
              `Provided URL is not compatible with HTTP connection: ${e}`
            );
          if (this.registering) {
            let e = this.events.getMaxListeners();
            return (
              (this.events.listenerCount("register_error") >= e ||
                this.events.listenerCount("open") >= e) &&
                this.events.setMaxListeners(e + 1),
              new Promise((e, t) => {
                this.events.once("register_error", (e) => {
                  this.resetMaxListeners(), t(e);
                }),
                  this.events.once("open", () => {
                    if (
                      (this.resetMaxListeners(), typeof this.isAvailable > "u")
                    )
                      return t(Error("HTTP connection is missing or invalid"));
                    e();
                  });
              })
            );
          }
          (this.url = e), (this.registering = !0);
          try {
            if (!this.disableProviderPing) {
              let t = (0, P.h)({
                id: 1,
                jsonrpc: "2.0",
                method: "test",
                params: [],
              });
              await sh()(e, sA(sv({}, sE), { body: t }));
            }
            this.onOpen();
          } catch (t) {
            let e = this.parseError(t);
            throw (this.events.emit("register_error", e), this.onClose(), e);
          }
        }
        onOpen() {
          (this.isAvailable = !0),
            (this.registering = !1),
            this.events.emit("open");
        }
        onClose() {
          (this.isAvailable = !1),
            (this.registering = !1),
            this.events.emit("close");
        }
        onPayload(e) {
          if (typeof e.data > "u") return;
          let t = "string" == typeof e.data ? (0, P.j)(e.data) : e.data;
          this.events.emit("payload", t);
        }
        onError(e, t) {
          let r = this.parseError(t),
            i = eC(e, r.message || r.toString());
          this.events.emit("payload", i);
        }
        parseError(e, t = this.url) {
          return ey(e, t, "HTTP");
        }
        resetMaxListeners() {
          this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10);
        }
      }
      var sC = r(81029).Buffer;
      let sI = "error",
        sS = "wc@2:universal_provider:",
        sx = "https://rpc.walletconnect.org/v1/",
        sN = "generic",
        sT = `${sx}bundler`,
        sP = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
      function sO() {}
      function sk(e) {
        return null == e || ("object" != typeof e && "function" != typeof e);
      }
      function sR(e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      }
      function sD(e) {
        return "object" == typeof e && null !== e;
      }
      function sM(e) {
        return Object.getOwnPropertySymbols(e).filter((t) =>
          Object.prototype.propertyIsEnumerable.call(e, t)
        );
      }
      function sU(e) {
        return null == e
          ? void 0 === e
            ? "[object Undefined]"
            : "[object Null]"
          : Object.prototype.toString.call(e);
      }
      let sL = "[object String]",
        sB = "[object Number]",
        sj = "[object Boolean]",
        sF = "[object Arguments]";
      function s$(e, t, r, i = new Map(), s) {
        let n = s?.(e, t, r, i);
        if (null != n) return n;
        if (sk(e)) return e;
        if (i.has(e)) return i.get(e);
        if (Array.isArray(e)) {
          let t = Array(e.length);
          i.set(e, t);
          for (let n = 0; n < e.length; n++) t[n] = s$(e[n], n, r, i, s);
          return (
            Object.hasOwn(e, "index") && (t.index = e.index),
            Object.hasOwn(e, "input") && (t.input = e.input),
            t
          );
        }
        if (e instanceof Date) return new Date(e.getTime());
        if (e instanceof RegExp) {
          let t = new RegExp(e.source, e.flags);
          return (t.lastIndex = e.lastIndex), t;
        }
        if (e instanceof Map) {
          let t = new Map();
          for (let [n, a] of (i.set(e, t), e)) t.set(n, s$(a, n, r, i, s));
          return t;
        }
        if (e instanceof Set) {
          let t = new Set();
          for (let n of (i.set(e, t), e)) t.add(s$(n, void 0, r, i, s));
          return t;
        }
        if ("u" > typeof sC && sC.isBuffer(e)) return e.subarray();
        if (sR(e)) {
          let t = new (Object.getPrototypeOf(e).constructor)(e.length);
          i.set(e, t);
          for (let n = 0; n < e.length; n++) t[n] = s$(e[n], n, r, i, s);
          return t;
        }
        if (
          e instanceof ArrayBuffer ||
          ("u" > typeof SharedArrayBuffer && e instanceof SharedArrayBuffer)
        )
          return e.slice(0);
        if (e instanceof DataView) {
          let t = new DataView(e.buffer.slice(0), e.byteOffset, e.byteLength);
          return i.set(e, t), sz(t, e, r, i, s), t;
        }
        if ("u" > typeof File && e instanceof File) {
          let t = new File([e], e.name, { type: e.type });
          return i.set(e, t), sz(t, e, r, i, s), t;
        }
        if (e instanceof Blob) {
          let t = new Blob([e], { type: e.type });
          return i.set(e, t), sz(t, e, r, i, s), t;
        }
        if (e instanceof Error) {
          let t = new e.constructor();
          return (
            i.set(e, t),
            (t.message = e.message),
            (t.name = e.name),
            (t.stack = e.stack),
            (t.cause = e.cause),
            sz(t, e, r, i, s),
            t
          );
        }
        if (
          "object" == typeof e &&
          (function (e) {
            switch (sU(e)) {
              case sF:
              case "[object Array]":
              case "[object ArrayBuffer]":
              case "[object DataView]":
              case sj:
              case "[object Date]":
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Map]":
              case sB:
              case "[object Object]":
              case "[object RegExp]":
              case "[object Set]":
              case sL:
              case "[object Symbol]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return !0;
              default:
                return !1;
            }
          })(e)
        ) {
          let t = Object.create(Object.getPrototypeOf(e));
          return i.set(e, t), sz(t, e, r, i, s), t;
        }
        return e;
      }
      function sz(e, t, r = e, i, s) {
        let n = [...Object.keys(t), ...sM(t)];
        for (let a = 0; a < n.length; a++) {
          let o = n[a],
            c = Object.getOwnPropertyDescriptor(e, o);
          (null == c || c.writable) && (e[o] = s$(t[o], o, r, i, s));
        }
      }
      function sW(e) {
        return s$(e, void 0, e, new Map(), (t, r, i, s) => {
          let n = void 0;
          if (null != n) return n;
          if ("object" == typeof e)
            switch (Object.prototype.toString.call(e)) {
              case sB:
              case sL:
              case sj: {
                let t = new e.constructor(e?.valueOf());
                return sz(t, e), t;
              }
              case sF: {
                let t = {};
                return (
                  sz(t, e),
                  (t.length = e.length),
                  (t[Symbol.iterator] = e[Symbol.iterator]),
                  t
                );
              }
              default:
                return;
            }
        });
      }
      function sH(e) {
        return (
          null !== e && "object" == typeof e && "[object Arguments]" === sU(e)
        );
      }
      var sq = Object.defineProperty,
        sV = Object.defineProperties,
        sK = Object.getOwnPropertyDescriptors,
        sG = Object.getOwnPropertySymbols,
        sY = Object.prototype.hasOwnProperty,
        sQ = Object.prototype.propertyIsEnumerable,
        sZ = (e, t, r) =>
          t in e
            ? sq(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        sJ = (e, t) => {
          for (var r in t || (t = {})) sY.call(t, r) && sZ(e, r, t[r]);
          if (sG) for (var r of sG(t)) sQ.call(t, r) && sZ(e, r, t[r]);
          return e;
        },
        sX = (e, t) => sV(e, sK(t));
      function s0(e, t, r) {
        var i;
        let s = (0, eu._Yb)(e);
        return (
          (null == (i = t.rpcMap) ? void 0 : i[s.reference]) ||
          `${sx}?chainId=${s.namespace}:${s.reference}&projectId=${r}`
        );
      }
      function s1(e) {
        return e.includes(":") ? e.split(":")[1] : e;
      }
      function s2(e) {
        return e.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
      }
      function s3(e = {}, t = {}) {
        return (function (e, ...t) {
          return (function (e, ...t) {
            let r = t.slice(0, -1),
              i = t[t.length - 1],
              s = e;
            for (let e = 0; e < r.length; e++)
              s = (function e(t, r, i, s) {
                if (
                  (sk(t) && (t = Object(t)), null == r || "object" != typeof r)
                )
                  return t;
                if (s.has(r))
                  return (function (e) {
                    if (sk(e)) return e;
                    if (
                      Array.isArray(e) ||
                      sR(e) ||
                      e instanceof ArrayBuffer ||
                      ("u" > typeof SharedArrayBuffer &&
                        e instanceof SharedArrayBuffer)
                    )
                      return e.slice(0);
                    let t = Object.getPrototypeOf(e),
                      r = t.constructor;
                    if (
                      e instanceof Date ||
                      e instanceof Map ||
                      e instanceof Set
                    )
                      return new r(e);
                    if (e instanceof RegExp) {
                      let t = new r(e);
                      return (t.lastIndex = e.lastIndex), t;
                    }
                    if (e instanceof DataView) return new r(e.buffer.slice(0));
                    if (e instanceof Error) {
                      let t = new r(e.message);
                      return (
                        (t.stack = e.stack),
                        (t.name = e.name),
                        (t.cause = e.cause),
                        t
                      );
                    }
                    return "u" > typeof File && e instanceof File
                      ? new r([e], e.name, {
                          type: e.type,
                          lastModified: e.lastModified,
                        })
                      : "object" == typeof e
                      ? Object.assign(Object.create(t), e)
                      : e;
                  })(s.get(r));
                if ((s.set(r, t), Array.isArray(r))) {
                  r = r.slice();
                  for (let e = 0; e < r.length; e++) r[e] = r[e] ?? void 0;
                }
                let n = [...Object.keys(r), ...sM(r)];
                for (let a = 0; a < n.length; a++) {
                  let o = n[a],
                    c = r[o],
                    l = t[o];
                  if (
                    (sH(c) && (c = { ...c }),
                    sH(l) && (l = { ...l }),
                    "u" > typeof sC && sC.isBuffer(c) && (c = sW(c)),
                    Array.isArray(c))
                  ) {
                    if ("object" == typeof l && null != l) {
                      let e = [],
                        t = Reflect.ownKeys(l);
                      for (let r = 0; r < t.length; r++) {
                        let i = t[r];
                        e[i] = l[i];
                      }
                      l = e;
                    } else l = [];
                  }
                  let d = i(l, c, o, t, r, s);
                  null != d
                    ? (t[o] = d)
                    : Array.isArray(c) || (sD(l) && sD(c))
                    ? (t[o] = e(l, c, i, s))
                    : null == l &&
                      (function (e) {
                        if ("object" != typeof e || null == e) return !1;
                        if (null === Object.getPrototypeOf(e)) return !0;
                        if (
                          "[object Object]" !==
                          Object.prototype.toString.call(e)
                        ) {
                          let t = e[Symbol.toStringTag];
                          return (
                            !!(
                              null != t &&
                              Object.getOwnPropertyDescriptor(
                                e,
                                Symbol.toStringTag
                              )?.writable
                            ) && e.toString() === `[object ${t}]`
                          );
                        }
                        let t = e;
                        for (; null !== Object.getPrototypeOf(t); )
                          t = Object.getPrototypeOf(t);
                        return Object.getPrototypeOf(e) === t;
                      })(c)
                    ? (t[o] = e({}, c, i, s))
                    : null == l && sR(c)
                    ? (t[o] = sW(c))
                    : (void 0 === l || void 0 !== c) && (t[o] = c);
                }
                return t;
              })(s, r[e], i, new Map());
            return s;
          })(e, ...t, sO);
        })(s5(e), s5(t));
      }
      function s5(e) {
        var t, r, i, s;
        let n = {};
        if (!(0, eu.aF0)(e)) return n;
        for (let [a, o] of Object.entries(e)) {
          let e = (0, eu.nWe)(a) ? [a] : o.chains,
            c = o.methods || [],
            l = o.events || [],
            d = o.rpcMap || {},
            u = (0, eu.kob)(a);
          n[u] = sX(sJ(sJ({}, n[u]), o), {
            chains: (0, eu.TRk)(e, null == (t = n[u]) ? void 0 : t.chains),
            methods: (0, eu.TRk)(c, null == (r = n[u]) ? void 0 : r.methods),
            events: (0, eu.TRk)(l, null == (i = n[u]) ? void 0 : i.events),
            rpcMap: sJ(sJ({}, d), null == (s = n[u]) ? void 0 : s.rpcMap),
          });
        }
        return n;
      }
      function s8(e) {
        return e.includes(":") ? e.split(":")[2] : e;
      }
      function s6(e) {
        let t = {};
        for (let [r, i] of Object.entries(e)) {
          let e = i.methods || [],
            s = i.events || [],
            n = i.accounts || [],
            a = (0, eu.nWe)(r) ? [r] : i.chains ? i.chains : s2(i.accounts);
          t[r] = { chains: a, methods: e, events: s, accounts: n };
        }
        return t;
      }
      function s4(e) {
        return "number" == typeof e
          ? e
          : e.includes("0x")
          ? parseInt(e, 16)
          : isNaN(Number((e = e.includes(":") ? e.split(":")[1] : e)))
          ? e
          : Number(e);
      }
      let s9 = {},
        s7 = (e) => s9[e],
        ne = (e, t) => {
          s9[e] = t;
        };
      var nt = Object.defineProperty,
        nr = (e, t, r) =>
          t in e
            ? nt(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ni = (e, t, r) => nr(e, "symbol" != typeof t ? t + "" : t, r);
      class ns {
        constructor(e) {
          ni(this, "name", "polkadot"),
            ni(this, "client"),
            ni(this, "httpProviders"),
            ni(this, "events"),
            ni(this, "namespace"),
            ni(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = s7("events")),
            (this.client = s7("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(sP.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(":")[1] === this.chainId.toString())
                .map((e) => e.split(":")[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = s1(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || s0(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new eU(new s_(r, s7("disableProviderPing")));
        }
      }
      var nn = Object.defineProperty,
        na = Object.defineProperties,
        no = Object.getOwnPropertyDescriptors,
        nc = Object.getOwnPropertySymbols,
        nl = Object.prototype.hasOwnProperty,
        nd = Object.prototype.propertyIsEnumerable,
        nu = (e, t, r) =>
          t in e
            ? nn(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        nh = (e, t) => {
          for (var r in t || (t = {})) nl.call(t, r) && nu(e, r, t[r]);
          if (nc) for (var r of nc(t)) nd.call(t, r) && nu(e, r, t[r]);
          return e;
        },
        nf = (e, t) => na(e, no(t)),
        np = (e, t, r) => nu(e, "symbol" != typeof t ? t + "" : t, r);
      class ng {
        constructor(e) {
          np(this, "name", "eip155"),
            np(this, "client"),
            np(this, "chainId"),
            np(this, "namespace"),
            np(this, "httpProviders"),
            np(this, "events"),
            (this.namespace = e.namespace),
            (this.events = s7("events")),
            (this.client = s7("client")),
            (this.httpProviders = this.createHttpProviders()),
            (this.chainId = parseInt(this.getDefaultChain()));
        }
        async request(e) {
          switch (e.request.method) {
            case "eth_requestAccounts":
            case "eth_accounts":
              return this.getAccounts();
            case "wallet_switchEthereumChain":
              return await this.handleSwitchChain(e);
            case "eth_chainId":
              return parseInt(this.getDefaultChain());
            case "wallet_getCapabilities":
              return await this.getCapabilities(e);
            case "wallet_getCallsStatus":
              return await this.getCallStatus(e);
          }
          return this.namespace.methods.includes(e.request.method)
            ? await this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(parseInt(e), t),
            (this.chainId = parseInt(e)),
            this.events.emit(sP.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId.toString();
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        createHttpProvider(e, t) {
          let r =
            t ||
            s0(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new eU(new s_(r, s7("disableProviderPing")));
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = parseInt(s1(t));
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        getHttpProvider() {
          let e = this.chainId,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        async handleSwitchChain(e) {
          var t, r;
          let i = e.request.params
              ? null == (t = e.request.params[0])
                ? void 0
                : t.chainId
              : "0x0",
            s = parseInt((i = i.startsWith("0x") ? i : `0x${i}`), 16);
          if (this.isChainApproved(s)) this.setDefaultChain(`${s}`);
          else if (
            this.namespace.methods.includes("wallet_switchEthereumChain")
          )
            await this.client.request({
              topic: e.topic,
              request: { method: e.request.method, params: [{ chainId: i }] },
              chainId: null == (r = this.namespace.chains) ? void 0 : r[0],
            }),
              this.setDefaultChain(`${s}`);
          else
            throw Error(
              `Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`
            );
          return null;
        }
        isChainApproved(e) {
          return this.namespace.chains.includes(`${this.name}:${e}`);
        }
        async getCapabilities(e) {
          var t, r, i;
          let s =
            null == (r = null == (t = e.request) ? void 0 : t.params)
              ? void 0
              : r[0];
          if (!s)
            throw Error(
              "Missing address parameter in `wallet_getCapabilities` request"
            );
          let n = this.client.session.get(e.topic),
            a =
              (null == (i = n?.sessionProperties) ? void 0 : i.capabilities) ||
              {};
          if (null != a && a[s]) return a?.[s];
          let o = await this.client.request(e);
          try {
            await this.client.session.update(e.topic, {
              sessionProperties: nf(nh({}, n.sessionProperties || {}), {
                capabilities: nf(nh({}, a || {}), { [s]: o }),
              }),
            });
          } catch (e) {
            console.warn("Failed to update session with capabilities", e);
          }
          return o;
        }
        async getCallStatus(e) {
          var t, r;
          let i = this.client.session.get(e.topic),
            s = null == (t = i.sessionProperties) ? void 0 : t.bundler_name;
          if (s) {
            let t = this.getBundlerUrl(e.chainId, s);
            try {
              return await this.getUserOperationReceipt(t, e);
            } catch (e) {
              console.warn("Failed to fetch call status from bundler", e, t);
            }
          }
          let n = null == (r = i.sessionProperties) ? void 0 : r.bundler_url;
          if (n)
            try {
              return await this.getUserOperationReceipt(n, e);
            } catch (e) {
              console.warn(
                "Failed to fetch call status from custom bundler",
                e,
                n
              );
            }
          if (this.namespace.methods.includes(e.request.method))
            return await this.client.request(e);
          throw Error("Fetching call status not approved by the wallet.");
        }
        async getUserOperationReceipt(e, t) {
          var r;
          let i = new URL(e),
            s = await fetch(i, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(
                eE("eth_getUserOperationReceipt", [
                  null == (r = t.request.params) ? void 0 : r[0],
                ])
              ),
            });
          if (!s.ok)
            throw Error(`Failed to fetch user operation receipt - ${s.status}`);
          return await s.json();
        }
        getBundlerUrl(e, t) {
          return `${sT}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`;
        }
      }
      var nm = Object.defineProperty,
        nb = (e, t, r) =>
          t in e
            ? nm(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        ny = (e, t, r) => nb(e, "symbol" != typeof t ? t + "" : t, r);
      class nw {
        constructor(e) {
          ny(this, "name", "solana"),
            ny(this, "client"),
            ny(this, "httpProviders"),
            ny(this, "events"),
            ny(this, "namespace"),
            ny(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = s7("events")),
            (this.client = s7("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(sP.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = s1(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || s0(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new eU(new s_(r, s7("disableProviderPing")));
        }
      }
      var nv = Object.defineProperty,
        nA = (e, t, r) =>
          t in e
            ? nv(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        nE = (e, t, r) => nA(e, "symbol" != typeof t ? t + "" : t, r);
      class n_ {
        constructor(e) {
          nE(this, "name", "cosmos"),
            nE(this, "client"),
            nE(this, "httpProviders"),
            nE(this, "events"),
            nE(this, "namespace"),
            nE(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = s7("events")),
            (this.client = s7("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(
              sP.DEFAULT_CHAIN_CHANGED,
              `${this.name}:${this.chainId}`
            );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = s1(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || s0(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new eU(new s_(r, s7("disableProviderPing")));
        }
      }
      var nC = Object.defineProperty,
        nI = (e, t, r) =>
          t in e
            ? nC(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        nS = (e, t, r) => nI(e, "symbol" != typeof t ? t + "" : t, r);
      class nx {
        constructor(e) {
          nS(this, "name", "algorand"),
            nS(this, "client"),
            nS(this, "httpProviders"),
            nS(this, "events"),
            nS(this, "namespace"),
            nS(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = s7("events")),
            (this.client = s7("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (!this.httpProviders[e]) {
            let r =
              t ||
              s0(
                `${this.name}:${e}`,
                this.namespace,
                this.client.core.projectId
              );
            if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r);
          }
          (this.chainId = e),
            this.events.emit(
              sP.DEFAULT_CHAIN_CHANGED,
              `${this.name}:${this.chainId}`
            );
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              e[t] = this.createHttpProvider(
                t,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || s0(e, this.namespace, this.client.core.projectId);
          return typeof r > "u"
            ? void 0
            : new eU(new s_(r, s7("disableProviderPing")));
        }
      }
      var nN = Object.defineProperty,
        nT = (e, t, r) =>
          t in e
            ? nN(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        nP = (e, t, r) => nT(e, "symbol" != typeof t ? t + "" : t, r);
      class nO {
        constructor(e) {
          nP(this, "name", "cip34"),
            nP(this, "client"),
            nP(this, "httpProviders"),
            nP(this, "events"),
            nP(this, "namespace"),
            nP(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = s7("events")),
            (this.client = s7("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(
              sP.DEFAULT_CHAIN_CHANGED,
              `${this.name}:${this.chainId}`
            );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              let r = this.getCardanoRPCUrl(t),
                i = s1(t);
              e[i] = this.createHttpProvider(i, r);
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        getCardanoRPCUrl(e) {
          let t = this.namespace.rpcMap;
          if (t) return t[e];
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || this.getCardanoRPCUrl(e);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new eU(new s_(r, s7("disableProviderPing")));
        }
      }
      var nk = Object.defineProperty,
        nR = (e, t, r) =>
          t in e
            ? nk(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        nD = (e, t, r) => nR(e, "symbol" != typeof t ? t + "" : t, r);
      class nM {
        constructor(e) {
          nD(this, "name", "elrond"),
            nD(this, "client"),
            nD(this, "httpProviders"),
            nD(this, "events"),
            nD(this, "namespace"),
            nD(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = s7("events")),
            (this.client = s7("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(sP.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = s1(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || s0(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new eU(new s_(r, s7("disableProviderPing")));
        }
      }
      var nU = Object.defineProperty,
        nL = (e, t, r) =>
          t in e
            ? nU(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        nB = (e, t, r) => nL(e, "symbol" != typeof t ? t + "" : t, r);
      class nj {
        constructor(e) {
          nB(this, "name", "multiversx"),
            nB(this, "client"),
            nB(this, "httpProviders"),
            nB(this, "events"),
            nB(this, "namespace"),
            nB(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = s7("events")),
            (this.client = s7("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(sP.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              let i = s1(t);
              e[i] = this.createHttpProvider(
                i,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || s0(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new eU(new s_(r, s7("disableProviderPing")));
        }
      }
      var nF = Object.defineProperty,
        n$ = (e, t, r) =>
          t in e
            ? nF(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        nz = (e, t, r) => n$(e, "symbol" != typeof t ? t + "" : t, r);
      class nW {
        constructor(e) {
          nz(this, "name", "near"),
            nz(this, "client"),
            nz(this, "httpProviders"),
            nz(this, "events"),
            nz(this, "namespace"),
            nz(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = s7("events")),
            (this.client = s7("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (((this.chainId = e), !this.httpProviders[e])) {
            let r = t || s0(`${this.name}:${e}`, this.namespace);
            if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r);
          }
          this.events.emit(
            sP.DEFAULT_CHAIN_CHANGED,
            `${this.name}:${this.chainId}`
          );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(":")[1] === this.chainId.toString())
                .map((e) => e.split(":")[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              var r;
              e[t] = this.createHttpProvider(
                t,
                null == (r = this.namespace.rpcMap) ? void 0 : r[t]
              );
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || s0(e, this.namespace);
          return typeof r > "u"
            ? void 0
            : new eU(new s_(r, s7("disableProviderPing")));
        }
      }
      var nH = Object.defineProperty,
        nq = (e, t, r) =>
          t in e
            ? nH(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        nV = (e, t, r) => nq(e, "symbol" != typeof t ? t + "" : t, r);
      class nK {
        constructor(e) {
          nV(this, "name", "tezos"),
            nV(this, "client"),
            nV(this, "httpProviders"),
            nV(this, "events"),
            nV(this, "namespace"),
            nV(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = s7("events")),
            (this.client = s7("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          this.namespace = Object.assign(this.namespace, e);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider().request(e.request);
        }
        setDefaultChain(e, t) {
          if (((this.chainId = e), !this.httpProviders[e])) {
            let r = t || s0(`${this.name}:${e}`, this.namespace);
            if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r);
          }
          this.events.emit(
            sP.DEFAULT_CHAIN_CHANGED,
            `${this.name}:${this.chainId}`
          );
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return (
            (e &&
              e
                .filter((e) => e.split(":")[1] === this.chainId.toString())
                .map((e) => e.split(":")[2])) ||
            []
          );
        }
        createHttpProviders() {
          let e = {};
          return (
            this.namespace.chains.forEach((t) => {
              e[t] = this.createHttpProvider(t);
            }),
            e
          );
        }
        getHttpProvider() {
          let e = `${this.name}:${this.chainId}`,
            t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || s0(e, this.namespace);
          return typeof r > "u" ? void 0 : new eU(new s_(r));
        }
      }
      var nG = Object.defineProperty,
        nY = (e, t, r) =>
          t in e
            ? nG(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        nQ = (e, t, r) => nY(e, "symbol" != typeof t ? t + "" : t, r);
      class nZ {
        constructor(e) {
          nQ(this, "name", sN),
            nQ(this, "client"),
            nQ(this, "httpProviders"),
            nQ(this, "events"),
            nQ(this, "namespace"),
            nQ(this, "chainId"),
            (this.namespace = e.namespace),
            (this.events = s7("events")),
            (this.client = s7("client")),
            (this.chainId = this.getDefaultChain()),
            (this.httpProviders = this.createHttpProviders());
        }
        updateNamespace(e) {
          (this.namespace.chains = [
            ...new Set((this.namespace.chains || []).concat(e.chains || [])),
          ]),
            (this.namespace.accounts = [
              ...new Set(
                (this.namespace.accounts || []).concat(e.accounts || [])
              ),
            ]),
            (this.namespace.methods = [
              ...new Set(
                (this.namespace.methods || []).concat(e.methods || [])
              ),
            ]),
            (this.namespace.events = [
              ...new Set((this.namespace.events || []).concat(e.events || [])),
            ]),
            (this.httpProviders = this.createHttpProviders());
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(e) {
          return this.namespace.methods.includes(e.request.method)
            ? this.client.request(e)
            : this.getHttpProvider(e.chainId).request(e.request);
        }
        setDefaultChain(e, t) {
          this.httpProviders[e] || this.setHttpProvider(e, t),
            (this.chainId = e),
            this.events.emit(sP.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
        }
        getDefaultChain() {
          if (this.chainId) return this.chainId;
          if (this.namespace.defaultChain) return this.namespace.defaultChain;
          let e = this.namespace.chains[0];
          if (!e) throw Error("ChainId not found");
          return e.split(":")[1];
        }
        getAccounts() {
          let e = this.namespace.accounts;
          return e
            ? [
                ...new Set(
                  e
                    .filter((e) => e.split(":")[1] === this.chainId.toString())
                    .map((e) => e.split(":")[2])
                ),
              ]
            : [];
        }
        createHttpProviders() {
          var e, t;
          let r = {};
          return (
            null == (t = null == (e = this.namespace) ? void 0 : e.accounts) ||
              t.forEach((e) => {
                let t = (0, eu._Yb)(e);
                r[`${t.namespace}:${t.reference}`] = this.createHttpProvider(e);
              }),
            r
          );
        }
        getHttpProvider(e) {
          let t = this.httpProviders[e];
          if (typeof t > "u")
            throw Error(`JSON-RPC provider for ${e} not found`);
          return t;
        }
        setHttpProvider(e, t) {
          let r = this.createHttpProvider(e, t);
          r && (this.httpProviders[e] = r);
        }
        createHttpProvider(e, t) {
          let r = t || s0(e, this.namespace, this.client.core.projectId);
          if (!r) throw Error(`No RPC url provided for chainId: ${e}`);
          return new eU(new s_(r, s7("disableProviderPing")));
        }
      }
      var nJ = Object.defineProperty,
        nX = Object.defineProperties,
        n0 = Object.getOwnPropertyDescriptors,
        n1 = Object.getOwnPropertySymbols,
        n2 = Object.prototype.hasOwnProperty,
        n3 = Object.prototype.propertyIsEnumerable,
        n5 = (e, t, r) =>
          t in e
            ? nJ(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        n8 = (e, t) => {
          for (var r in t || (t = {})) n2.call(t, r) && n5(e, r, t[r]);
          if (n1) for (var r of n1(t)) n3.call(t, r) && n5(e, r, t[r]);
          return e;
        },
        n6 = (e, t) => nX(e, n0(t)),
        n4 = (e, t, r) => n5(e, "symbol" != typeof t ? t + "" : t, r);
      class n9 {
        constructor(e) {
          n4(this, "client"),
            n4(this, "namespaces"),
            n4(this, "optionalNamespaces"),
            n4(this, "sessionProperties"),
            n4(this, "scopedProperties"),
            n4(this, "events", new (n())()),
            n4(this, "rpcProviders", {}),
            n4(this, "session"),
            n4(this, "providerOpts"),
            n4(this, "logger"),
            n4(this, "uri"),
            n4(this, "disableProviderPing", !1),
            (this.providerOpts = e),
            (this.logger =
              "u" > typeof e?.logger && "string" != typeof e?.logger
                ? e.logger
                : (0, F.h6)((0, F.iP)({ level: e?.logger || sI }))),
            (this.disableProviderPing = e?.disableProviderPing || !1);
        }
        static async init(e) {
          let t = new n9(e);
          return await t.initialize(), t;
        }
        async request(e, t, r) {
          let [i, s] = this.validateChain(t);
          if (!this.session)
            throw Error("Please call connect() before request()");
          return await this.getProvider(i).request({
            request: n8({}, e),
            chainId: `${i}:${s}`,
            topic: this.session.topic,
            expiry: r,
          });
        }
        sendAsync(e, t, r, i) {
          let s = new Date().getTime();
          this.request(e, r, i)
            .then((e) => t(null, e_(s, e)))
            .catch((e) => t(e, void 0));
        }
        async enable() {
          if (!this.client) throw Error("Sign Client not initialized");
          return (
            this.session ||
              (await this.connect({
                namespaces: this.namespaces,
                optionalNamespaces: this.optionalNamespaces,
                sessionProperties: this.sessionProperties,
                scopedProperties: this.scopedProperties,
              })),
            await this.requestAccounts()
          );
        }
        async disconnect() {
          var e;
          if (!this.session)
            throw Error("Please call connect() before enable()");
          await this.client.disconnect({
            topic: null == (e = this.session) ? void 0 : e.topic,
            reason: (0, eu.Hjj)("USER_DISCONNECTED"),
          }),
            await this.cleanup();
        }
        async connect(e) {
          if (!this.client) throw Error("Sign Client not initialized");
          if (
            (this.setNamespaces(e),
            await this.cleanupPendingPairings(),
            !e.skipPairing)
          )
            return await this.pair(e.pairingTopic);
        }
        async authenticate(e, t) {
          if (!this.client) throw Error("Sign Client not initialized");
          this.setNamespaces(e), await this.cleanupPendingPairings();
          let { uri: r, response: i } = await this.client.authenticate(e, t);
          r && ((this.uri = r), this.events.emit("display_uri", r));
          let s = await i();
          if (((this.session = s.session), this.session)) {
            let e = s6(this.session.namespaces);
            (this.namespaces = s3(this.namespaces, e)),
              await this.persist("namespaces", this.namespaces),
              this.onConnect();
          }
          return s;
        }
        on(e, t) {
          this.events.on(e, t);
        }
        once(e, t) {
          this.events.once(e, t);
        }
        removeListener(e, t) {
          this.events.removeListener(e, t);
        }
        off(e, t) {
          this.events.off(e, t);
        }
        get isWalletConnect() {
          return !0;
        }
        async pair(e) {
          let { uri: t, approval: r } = await this.client.connect({
            pairingTopic: e,
            requiredNamespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties,
          });
          t && ((this.uri = t), this.events.emit("display_uri", t));
          let i = await r();
          this.session = i;
          let s = s6(i.namespaces);
          return (
            (this.namespaces = s3(this.namespaces, s)),
            await this.persist("namespaces", this.namespaces),
            await this.persist("optionalNamespaces", this.optionalNamespaces),
            this.onConnect(),
            this.session
          );
        }
        setDefaultChain(e, t) {
          try {
            if (!this.session) return;
            let [r, i] = this.validateChain(e),
              s = this.getProvider(r);
            s.name === sN
              ? s.setDefaultChain(`${r}:${i}`, t)
              : s.setDefaultChain(i, t);
          } catch (e) {
            if (!/Please call connect/.test(e.message)) throw e;
          }
        }
        async cleanupPendingPairings(e = {}) {
          this.logger.info("Cleaning up inactive pairings...");
          let t = this.client.pairing.getAll();
          if ((0, eu.OP1)(t)) {
            for (let r of t)
              e.deletePairings
                ? this.client.core.expirer.set(r.topic, 0)
                : await this.client.core.relayer.subscriber.unsubscribe(
                    r.topic
                  );
            this.logger.info(`Inactive pairings cleared: ${t.length}`);
          }
        }
        abortPairingAttempt() {
          this.logger.warn(
            "abortPairingAttempt is deprecated. This is now a no-op."
          );
        }
        async checkStorage() {
          (this.namespaces = (await this.getFromStore("namespaces")) || {}),
            (this.optionalNamespaces =
              (await this.getFromStore("optionalNamespaces")) || {}),
            this.session && this.createProviders();
        }
        async initialize() {
          this.logger.trace("Initialized"),
            await this.createClient(),
            await this.checkStorage(),
            this.registerEventListeners();
        }
        async createClient() {
          var e, t;
          if (
            ((this.client =
              this.providerOpts.client ||
              (await sd.init({
                core: this.providerOpts.core,
                logger: this.providerOpts.logger || sI,
                relayUrl:
                  this.providerOpts.relayUrl || "wss://relay.walletconnect.org",
                projectId: this.providerOpts.projectId,
                metadata: this.providerOpts.metadata,
                storageOptions: this.providerOpts.storageOptions,
                storage: this.providerOpts.storage,
                name: this.providerOpts.name,
                customStoragePrefix: this.providerOpts.customStoragePrefix,
                telemetryEnabled: this.providerOpts.telemetryEnabled,
              }))),
            this.providerOpts.session)
          )
            try {
              this.session = this.client.session.get(
                this.providerOpts.session.topic
              );
            } catch (r) {
              throw (
                (this.logger.error("Failed to get session", r),
                Error(
                  `The provided session: ${
                    null ==
                    (t = null == (e = this.providerOpts) ? void 0 : e.session)
                      ? void 0
                      : t.topic
                  } doesn't exist in the Sign client`
                ))
              );
            }
          else {
            let e = this.client.session.getAll();
            this.session = e[0];
          }
          this.logger.trace("SignClient Initialized");
        }
        createProviders() {
          if (!this.client) throw Error("Sign Client not initialized");
          if (!this.session)
            throw Error(
              "Session not initialized. Please call connect() before enable()"
            );
          let e = [
            ...new Set(
              Object.keys(this.session.namespaces).map((e) => (0, eu.kob)(e))
            ),
          ];
          ne("client", this.client),
            ne("events", this.events),
            ne("disableProviderPing", this.disableProviderPing),
            e.forEach((e) => {
              if (!this.session) return;
              let t = (function (e, t) {
                  let r = Object.keys(t.namespaces).filter((t) =>
                    t.includes(e)
                  );
                  if (!r.length) return [];
                  let i = [];
                  return (
                    r.forEach((e) => {
                      let r = t.namespaces[e].accounts;
                      i.push(...r);
                    }),
                    i
                  );
                })(e, this.session),
                r = s2(t),
                i = n6(
                  n8({}, s3(this.namespaces, this.optionalNamespaces)[e]),
                  { accounts: t, chains: r }
                );
              switch (e) {
                case "eip155":
                  this.rpcProviders[e] = new ng({ namespace: i });
                  break;
                case "algorand":
                  this.rpcProviders[e] = new nx({ namespace: i });
                  break;
                case "solana":
                  this.rpcProviders[e] = new nw({ namespace: i });
                  break;
                case "cosmos":
                  this.rpcProviders[e] = new n_({ namespace: i });
                  break;
                case "polkadot":
                  this.rpcProviders[e] = new ns({ namespace: i });
                  break;
                case "cip34":
                  this.rpcProviders[e] = new nO({ namespace: i });
                  break;
                case "elrond":
                  this.rpcProviders[e] = new nM({ namespace: i });
                  break;
                case "multiversx":
                  this.rpcProviders[e] = new nj({ namespace: i });
                  break;
                case "near":
                  this.rpcProviders[e] = new nW({ namespace: i });
                  break;
                case "tezos":
                  this.rpcProviders[e] = new nK({ namespace: i });
                  break;
                default:
                  this.rpcProviders[sN]
                    ? this.rpcProviders[sN].updateNamespace(i)
                    : (this.rpcProviders[sN] = new nZ({ namespace: i }));
              }
            });
        }
        registerEventListeners() {
          if (typeof this.client > "u")
            throw Error("Sign Client is not initialized");
          this.client.on("session_ping", (e) => {
            var t;
            let { topic: r } = e;
            r === (null == (t = this.session) ? void 0 : t.topic) &&
              this.events.emit("session_ping", e);
          }),
            this.client.on("session_event", (e) => {
              var t;
              let { params: r, topic: i } = e;
              if (i !== (null == (t = this.session) ? void 0 : t.topic)) return;
              let { event: s } = r;
              if ("accountsChanged" === s.name) {
                let e = s.data;
                e &&
                  (0, eu.OP1)(e) &&
                  this.events.emit("accountsChanged", e.map(s8));
              } else if ("chainChanged" === s.name) {
                let e = r.chainId,
                  t = r.event.data,
                  i = (0, eu.kob)(e),
                  s = s4(e) !== s4(t) ? `${i}:${s4(t)}` : e;
                this.onChainChanged(s);
              } else this.events.emit(s.name, s.data);
              this.events.emit("session_event", e);
            }),
            this.client.on("session_update", ({ topic: e, params: t }) => {
              var r, i;
              if (e !== (null == (r = this.session) ? void 0 : r.topic)) return;
              let { namespaces: s } = t,
                n = null == (i = this.client) ? void 0 : i.session.get(e);
              (this.session = n6(n8({}, n), { namespaces: s })),
                this.onSessionUpdate(),
                this.events.emit("session_update", { topic: e, params: t });
            }),
            this.client.on("session_delete", async (e) => {
              var t;
              e.topic === (null == (t = this.session) ? void 0 : t.topic) &&
                (await this.cleanup(),
                this.events.emit("session_delete", e),
                this.events.emit(
                  "disconnect",
                  n6(n8({}, (0, eu.Hjj)("USER_DISCONNECTED")), {
                    data: e.topic,
                  })
                ));
            }),
            this.on(sP.DEFAULT_CHAIN_CHANGED, (e) => {
              this.onChainChanged(e, !0);
            });
        }
        getProvider(e) {
          return this.rpcProviders[e] || this.rpcProviders[sN];
        }
        onSessionUpdate() {
          Object.keys(this.rpcProviders).forEach((e) => {
            var t;
            this.getProvider(e).updateNamespace(
              null == (t = this.session) ? void 0 : t.namespaces[e]
            );
          });
        }
        setNamespaces(e) {
          let {
            namespaces: t,
            optionalNamespaces: r,
            sessionProperties: i,
            scopedProperties: s,
          } = e;
          t && Object.keys(t).length && (this.namespaces = t),
            r && Object.keys(r).length && (this.optionalNamespaces = r),
            (this.sessionProperties = i),
            (this.scopedProperties = s);
        }
        validateChain(e) {
          let [t, r] = e?.split(":") || ["", ""];
          if (!this.namespaces || !Object.keys(this.namespaces).length)
            return [t, r];
          if (
            t &&
            !Object.keys(this.namespaces || {})
              .map((e) => (0, eu.kob)(e))
              .includes(t)
          )
            throw Error(
              `Namespace '${t}' is not configured. Please call connect() first with namespace config.`
            );
          if (t && r) return [t, r];
          let i = (0, eu.kob)(Object.keys(this.namespaces)[0]),
            s = this.rpcProviders[i].getDefaultChain();
          return [i, s];
        }
        async requestAccounts() {
          let [e] = this.validateChain();
          return await this.getProvider(e).requestAccounts();
        }
        async onChainChanged(e, t = !1) {
          if (!this.namespaces) return;
          let [r, i] = this.validateChain(e);
          i &&
            (t || this.getProvider(r).setDefaultChain(i),
            this.namespaces[r]
              ? (this.namespaces[r].defaultChain = i)
              : this.namespaces[`${r}:${i}`]
              ? (this.namespaces[`${r}:${i}`].defaultChain = i)
              : (this.namespaces[`${r}:${i}`] = { defaultChain: i }),
            this.events.emit("chainChanged", i),
            await this.persist("namespaces", this.namespaces));
        }
        onConnect() {
          this.createProviders(),
            this.events.emit("connect", { session: this.session });
        }
        async cleanup() {
          (this.namespaces = void 0),
            (this.optionalNamespaces = void 0),
            (this.sessionProperties = void 0),
            await this.deleteFromStore("namespaces"),
            await this.deleteFromStore("optionalNamespaces"),
            await this.deleteFromStore("sessionProperties"),
            (this.session = void 0),
            await this.cleanupPendingPairings({ deletePairings: !0 }),
            await this.cleanupStorage();
        }
        async persist(e, t) {
          var r;
          let i = (null == (r = this.session) ? void 0 : r.topic) || "";
          await this.client.core.storage.setItem(`${sS}/${e}${i}`, t);
        }
        async getFromStore(e) {
          var t;
          let r = (null == (t = this.session) ? void 0 : t.topic) || "";
          return await this.client.core.storage.getItem(`${sS}/${e}${r}`);
        }
        async deleteFromStore(e) {
          var t;
          let r = (null == (t = this.session) ? void 0 : t.topic) || "";
          await this.client.core.storage.removeItem(`${sS}/${e}${r}`);
        }
        async cleanupStorage() {
          var e;
          try {
            if ((null == (e = this.client) ? void 0 : e.session.length) > 0)
              return;
            for (let e of await this.client.core.storage.getKeys())
              e.startsWith(sS) &&
                (await this.client.core.storage.removeItem(e));
          } catch (e) {
            this.logger.warn("Failed to cleanup storage", e);
          }
        }
      }
      let n7 = n9;
    },
    78140: (e, t, r) => {
      "use strict";
      async function i(e) {
        return new Promise((t) => setTimeout(t, e));
      }
      r.d(t, { u: () => i });
    },
    78239: (e, t, r) => {
      "use strict";
      var i = r(98392),
        s = r(3285),
        n = r(95119);
      (t.assert = s),
        (t.toArray = n.toArray),
        (t.zero2 = n.zero2),
        (t.toHex = n.toHex),
        (t.encode = n.encode),
        (t.getNAF = function (e, t, r) {
          var i = Array(Math.max(e.bitLength(), r) + 1);
          for (a = 0; a < i.length; a += 1) i[a] = 0;
          var s = 1 << (t + 1),
            n = e.clone();
          for (a = 0; a < i.length; a++) {
            var a,
              o,
              c = n.andln(s - 1);
            n.isOdd()
              ? ((o = c > (s >> 1) - 1 ? (s >> 1) - c : c), n.isubn(o))
              : (o = 0),
              (i[a] = o),
              n.iushrn(1);
          }
          return i;
        }),
        (t.getJSF = function (e, t) {
          var r = [[], []];
          (e = e.clone()), (t = t.clone());
          for (var i = 0, s = 0; e.cmpn(-i) > 0 || t.cmpn(-s) > 0; ) {
            var n,
              a,
              o,
              c = (e.andln(3) + i) & 3,
              l = (t.andln(3) + s) & 3;
            3 === c && (c = -1),
              3 === l && (l = -1),
              (a =
                (1 & c) == 0
                  ? 0
                  : (3 == (n = (e.andln(7) + i) & 7) || 5 === n) && 2 === l
                  ? -c
                  : c),
              r[0].push(a),
              (o =
                (1 & l) == 0
                  ? 0
                  : (3 == (n = (t.andln(7) + s) & 7) || 5 === n) && 2 === c
                  ? -l
                  : l),
              r[1].push(o),
              2 * i === a + 1 && (i = 1 - i),
              2 * s === o + 1 && (s = 1 - s),
              e.iushrn(1),
              t.iushrn(1);
          }
          return r;
        }),
        (t.cachedProperty = function (e, t, r) {
          var i = "_" + t;
          e.prototype[t] = function () {
            return void 0 !== this[i] ? this[i] : (this[i] = r.call(this));
          };
        }),
        (t.parseBytes = function (e) {
          return "string" == typeof e ? t.toArray(e, "hex") : e;
        }),
        (t.intFromLE = function (e) {
          return new i(e, "hex", "le");
        });
    },
    78710: (e, t, r) => {
      "use strict";
      r.d(t, {
        Ay: () => u,
        B4: () => c,
        P5: () => o,
        WM: () => l,
        im: () => d,
        lD: () => a,
      });
      let i = BigInt(0x100000000 - 1),
        s = BigInt(32);
      function n(e, t = !1) {
        return t
          ? { h: Number(e & i), l: Number((e >> s) & i) }
          : { h: 0 | Number((e >> s) & i), l: 0 | Number(e & i) };
      }
      function a(e, t = !1) {
        let r = new Uint32Array(e.length),
          i = new Uint32Array(e.length);
        for (let s = 0; s < e.length; s++) {
          let { h: a, l: o } = n(e[s], t);
          [r[s], i[s]] = [a, o];
        }
        return [r, i];
      }
      let o = (e, t, r) => (e << r) | (t >>> (32 - r)),
        c = (e, t, r) => (t << r) | (e >>> (32 - r)),
        l = (e, t, r) => (t << (r - 32)) | (e >>> (64 - r)),
        d = (e, t, r) => (e << (r - 32)) | (t >>> (64 - r)),
        u = {
          fromBig: n,
          split: a,
          toBig: (e, t) => (BigInt(e >>> 0) << s) | BigInt(t >>> 0),
          shrSH: (e, t, r) => e >>> r,
          shrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
          rotrSH: (e, t, r) => (e >>> r) | (t << (32 - r)),
          rotrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
          rotrBH: (e, t, r) => (e << (64 - r)) | (t >>> (r - 32)),
          rotrBL: (e, t, r) => (e >>> (r - 32)) | (t << (64 - r)),
          rotr32H: (e, t) => t,
          rotr32L: (e, t) => e,
          rotlSH: o,
          rotlSL: c,
          rotlBH: l,
          rotlBL: d,
          add: function (e, t, r, i) {
            let s = (t >>> 0) + (i >>> 0);
            return { h: (e + r + ((s / 0x100000000) | 0)) | 0, l: 0 | s };
          },
          add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),
          add3H: (e, t, r, i) => (t + r + i + ((e / 0x100000000) | 0)) | 0,
          add4L: (e, t, r, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0),
          add4H: (e, t, r, i, s) =>
            (t + r + i + s + ((e / 0x100000000) | 0)) | 0,
          add5H: (e, t, r, i, s, n) =>
            (t + r + i + s + n + ((e / 0x100000000) | 0)) | 0,
          add5L: (e, t, r, i, s) =>
            (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0) + (s >>> 0),
        };
    },
    79355: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => s });
      var i = r(30948);
      let s = {
        getCaipTokens(e) {
          if (!e) return;
          let t = {};
          return (
            Object.entries(e).forEach(([e, r]) => {
              t[`${i.o.EIP155}:${e}`] = r;
            }),
            t
          );
        },
        isLowerCaseMatch: (e, t) => e?.toLowerCase() === t?.toLowerCase(),
      };
    },
    79875: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => _ });
      var i = r(1220),
        s = r(98866),
        n = r(12182);
      let a = [
          {
            type: "function",
            name: "transfer",
            stateMutability: "nonpayable",
            inputs: [
              { name: "_to", type: "address" },
              { name: "_value", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bool" }],
          },
          {
            type: "function",
            name: "transferFrom",
            stateMutability: "nonpayable",
            inputs: [
              { name: "_from", type: "address" },
              { name: "_to", type: "address" },
              { name: "_value", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bool" }],
          },
        ],
        o = [
          {
            type: "function",
            name: "transfer",
            stateMutability: "nonpayable",
            inputs: [
              { name: "recipient", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [],
          },
          {
            type: "function",
            name: "transferFrom",
            stateMutability: "nonpayable",
            inputs: [
              { name: "sender", type: "address" },
              { name: "recipient", type: "address" },
              { name: "amount", type: "uint256" },
            ],
            outputs: [{ name: "", type: "bool" }],
          },
        ];
      var c = r(45553);
      let l = {
        getERC20Abi: (e) => (c.o.USDT_CONTRACT_ADDRESSES.includes(e) ? o : a),
      };
      var d = r(73537),
        u = r(28977),
        h = r(12319),
        f = r(58051),
        p = r(44826),
        g = r(73442),
        m = r(3824);
      let b = {
          createBalance(e, t) {
            let r = {
              name: e.metadata.name || "",
              symbol: e.metadata.symbol || "",
              decimals: e.metadata.decimals || 0,
              value: e.metadata.value || 0,
              price: e.metadata.price || 0,
              iconUrl: e.metadata.iconUrl || "",
            };
            return {
              name: r.name,
              symbol: r.symbol,
              chainId: t,
              address:
                "native" === e.address
                  ? void 0
                  : this.convertAddressToCAIP10Address(e.address, t),
              value: r.value,
              price: r.price,
              quantity: {
                decimals: r.decimals.toString(),
                numeric: this.convertHexToBalance({
                  hex: e.balance,
                  decimals: r.decimals,
                }),
              },
              iconUrl: r.iconUrl,
            };
          },
          convertHexToBalance: ({ hex: e, decimals: t }) =>
            (function (e, t) {
              let r = e.toString(),
                i = r.startsWith("-");
              i && (r = r.slice(1));
              let [s, n] = [
                (r = r.padStart(t, "0")).slice(0, r.length - t),
                r.slice(r.length - t),
              ];
              return (
                (n = n.replace(/(0+)$/, "")),
                `${i ? "-" : ""}${s || "0"}${n ? `.${n}` : ""}`
              );
            })(BigInt(e), t),
          convertAddressToCAIP10Address: (e, t) => `${t}:${e}`,
          createCAIP2ChainId: (e, t) => `${t}:${parseInt(e, 16)}`,
          getChainIdHexFromCAIP2ChainId(e) {
            let t = e.split(":");
            if (t.length < 2 || !t[1]) return "0x0";
            let r = parseInt(t[1], 10);
            return isNaN(r) ? "0x0" : `0x${r.toString(16)}`;
          },
          isWalletGetAssetsResponse(e) {
            return (
              "object" == typeof e &&
              null !== e &&
              Object.values(e).every(
                (e) => Array.isArray(e) && e.every((e) => this.isValidAsset(e))
              )
            );
          },
          isValidAsset: (e) =>
            "object" == typeof e &&
            null !== e &&
            "string" == typeof e.address &&
            "string" == typeof e.balance &&
            ("ERC20" === e.type || "NATIVE" === e.type) &&
            "object" == typeof e.metadata &&
            null !== e.metadata &&
            "string" == typeof e.metadata.name &&
            "string" == typeof e.metadata.symbol &&
            "number" == typeof e.metadata.decimals &&
            "number" == typeof e.metadata.price &&
            "string" == typeof e.metadata.iconUrl,
        },
        y = {
          async getMyTokensWithBalance(e) {
            let t = f.U.state.address,
              r = g.W.state.activeCaipNetwork;
            if (!t || !r) return [];
            if ("eip155" === r.chainNamespace) {
              let e = await this.getEIP155Balances(t, r);
              if (e) return this.filterLowQualityTokens(e);
            }
            let i = await p.T.getBalance(t, r.caipNetworkId, e);
            return this.filterLowQualityTokens(i.balances);
          },
          async getEIP155Balances(e, t) {
            try {
              let r = b.getChainIdHexFromCAIP2ChainId(t.caipNetworkId),
                i = await m.x.getCapabilities(e);
              if (!i?.[r]?.assetDiscovery?.supported) return null;
              let s = await m.x.walletGetAssets({
                account: e,
                chainFilter: [r],
              });
              if (!b.isWalletGetAssetsResponse(s)) return null;
              return (s[r] || []).map((e) =>
                b.createBalance(e, t.caipNetworkId)
              );
            } catch (e) {
              return null;
            }
          },
          filterLowQualityTokens: (e) =>
            e.filter((e) => "0" !== e.quantity.decimals),
          mapBalancesToSwapTokens: (e) =>
            e?.map((e) => ({
              ...e,
              address: e?.address
                ? e.address
                : g.W.getActiveNetworkTokenAddress(),
              decimals: parseInt(e.quantity.decimals, 10),
              logoUri: e.iconUrl,
              eip2612: !1,
            })) || [],
        };
      var w = r(70417),
        v = r(67869),
        A = r(65374);
      let E = (0, i.BX)({ tokenBalances: [], loading: !1 }),
        _ = {
          state: E,
          subscribe: (e) => (0, i.B1)(E, () => e(E)),
          subscribeKey: (e, t) => (0, s.u$)(E, e, t),
          setToken(e) {
            e && (E.token = (0, i.KR)(e));
          },
          setTokenAmount(e) {
            E.sendTokenAmount = e;
          },
          setReceiverAddress(e) {
            E.receiverAddress = e;
          },
          setReceiverProfileImageUrl(e) {
            E.receiverProfileImageUrl = e;
          },
          setReceiverProfileName(e) {
            E.receiverProfileName = e;
          },
          setGasPrice(e) {
            E.gasPrice = e;
          },
          setGasPriceInUsd(e) {
            E.gasPriceInUSD = e;
          },
          setNetworkBalanceInUsd(e) {
            E.networkBalanceInUSD = e;
          },
          setLoading(e) {
            E.loading = e;
          },
          sendToken() {
            switch (g.W.state.activeCaipNetwork?.chainNamespace) {
              case "eip155":
                this.sendEvmToken();
                return;
              case "solana":
                this.sendSolanaToken();
                return;
              default:
                throw Error("Unsupported chain");
            }
          },
          sendEvmToken() {
            this.state.token?.address &&
            this.state.sendTokenAmount &&
            this.state.receiverAddress
              ? (w.E.sendEvent({
                  type: "track",
                  event: "SEND_INITIATED",
                  properties: {
                    isSmartAccount:
                      f.U.state.preferredAccountType ===
                      d.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: this.state.token.address,
                    amount: this.state.sendTokenAmount,
                    network: g.W.state.activeCaipNetwork?.caipNetworkId || "",
                  },
                }),
                this.sendERC20Token({
                  receiverAddress: this.state.receiverAddress,
                  tokenAddress: this.state.token.address,
                  sendTokenAmount: this.state.sendTokenAmount,
                  decimals: this.state.token.quantity.decimals,
                }))
              : this.state.receiverAddress &&
                this.state.sendTokenAmount &&
                this.state.gasPrice &&
                this.state.token?.quantity.decimals &&
                (w.E.sendEvent({
                  type: "track",
                  event: "SEND_INITIATED",
                  properties: {
                    isSmartAccount:
                      f.U.state.preferredAccountType ===
                      d.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: this.state.token?.symbol,
                    amount: this.state.sendTokenAmount,
                    network: g.W.state.activeCaipNetwork?.caipNetworkId || "",
                  },
                }),
                this.sendNativeToken({
                  receiverAddress: this.state.receiverAddress,
                  sendTokenAmount: this.state.sendTokenAmount,
                  gasPrice: this.state.gasPrice,
                  decimals: this.state.token.quantity.decimals,
                }));
          },
          async fetchTokenBalance(e) {
            E.loading = !0;
            let t = g.W.state.activeCaipNetwork?.caipNetworkId,
              r = g.W.state.activeCaipNetwork?.chainNamespace,
              i = g.W.state.activeCaipAddress,
              s = i ? h.w.getPlainAddress(i) : void 0;
            if (
              E.lastRetry &&
              !h.w.isAllowedRetry(E.lastRetry, 30 * u.oU.ONE_SEC_MS)
            )
              return (E.loading = !1), [];
            try {
              if (s && t && r) {
                let e = await y.getMyTokensWithBalance();
                return (E.tokenBalances = e), (E.lastRetry = void 0), e;
              }
            } catch (t) {
              (E.lastRetry = Date.now()),
                e?.(t),
                A.P.showError("Token Balance Unavailable");
            } finally {
              E.loading = !1;
            }
            return [];
          },
          fetchNetworkBalance() {
            if (0 === E.tokenBalances.length) return;
            let e = y.mapBalancesToSwapTokens(E.tokenBalances);
            if (!e) return;
            let t = e.find(
              (e) => e.address === g.W.getActiveNetworkTokenAddress()
            );
            t &&
              (E.networkBalanceInUSD = t
                ? n.S.multiply(t.quantity.numeric, t.price).toString()
                : "0");
          },
          isInsufficientNetworkTokenForGas: (e, t) =>
            !!n.S.bigNumber(e).eq(0) ||
            n.S.bigNumber(n.S.bigNumber(t || "0")).gt(e),
          hasInsufficientGasFunds() {
            let e = !0;
            return (
              f.U.state.preferredAccountType ===
              d.Vl.ACCOUNT_TYPES.SMART_ACCOUNT
                ? (e = !1)
                : E.networkBalanceInUSD &&
                  (e = this.isInsufficientNetworkTokenForGas(
                    E.networkBalanceInUSD,
                    E.gasPriceInUSD
                  )),
              e
            );
          },
          async sendNativeToken(e) {
            v.I.pushTransactionStack({ view: "Account", goBack: !1 });
            let t = e.receiverAddress,
              r = f.U.state.address,
              i = m.x.parseUnits(
                e.sendTokenAmount.toString(),
                Number(e.decimals)
              );
            try {
              await m.x.sendTransaction({
                chainNamespace: "eip155",
                to: t,
                address: r,
                data: "0x",
                value: i ?? BigInt(0),
                gasPrice: e.gasPrice,
              }),
                A.P.showSuccess("Transaction started"),
                w.E.sendEvent({
                  type: "track",
                  event: "SEND_SUCCESS",
                  properties: {
                    isSmartAccount:
                      f.U.state.preferredAccountType ===
                      d.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                    token: this.state.token?.symbol || "",
                    amount: e.sendTokenAmount,
                    network: g.W.state.activeCaipNetwork?.caipNetworkId || "",
                  },
                }),
                this.resetSend();
            } catch (r) {
              console.error(
                "SendController:sendERC20Token - failed to send native token",
                r
              );
              let t = r instanceof Error ? r.message : "Unknown error";
              w.E.sendEvent({
                type: "track",
                event: "SEND_ERROR",
                properties: {
                  message: t,
                  isSmartAccount:
                    f.U.state.preferredAccountType ===
                    d.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: this.state.token?.symbol || "",
                  amount: e.sendTokenAmount,
                  network: g.W.state.activeCaipNetwork?.caipNetworkId || "",
                },
              }),
                A.P.showError("Something went wrong");
            }
          },
          async sendERC20Token(e) {
            v.I.pushTransactionStack({ view: "Account", goBack: !1 });
            let t = m.x.parseUnits(
              e.sendTokenAmount.toString(),
              Number(e.decimals)
            );
            try {
              if (
                f.U.state.address &&
                e.sendTokenAmount &&
                e.receiverAddress &&
                e.tokenAddress
              ) {
                let r = h.w.getPlainAddress(e.tokenAddress);
                await m.x.writeContract({
                  fromAddress: f.U.state.address,
                  tokenAddress: r,
                  args: [e.receiverAddress, t ?? BigInt(0)],
                  method: "transfer",
                  abi: l.getERC20Abi(r),
                  chainNamespace: "eip155",
                }),
                  A.P.showSuccess("Transaction started"),
                  this.resetSend();
              }
            } catch (r) {
              console.error(
                "SendController:sendERC20Token - failed to send erc20 token",
                r
              );
              let t = r instanceof Error ? r.message : "Unknown error";
              w.E.sendEvent({
                type: "track",
                event: "SEND_ERROR",
                properties: {
                  message: t,
                  isSmartAccount:
                    f.U.state.preferredAccountType ===
                    d.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                  token: this.state.token?.symbol || "",
                  amount: e.sendTokenAmount,
                  network: g.W.state.activeCaipNetwork?.caipNetworkId || "",
                },
              }),
                A.P.showError("Something went wrong");
            }
          },
          sendSolanaToken() {
            if (!this.state.sendTokenAmount || !this.state.receiverAddress) {
              A.P.showError("Please enter a valid amount and receiver address");
              return;
            }
            v.I.pushTransactionStack({ view: "Account", goBack: !1 }),
              m.x
                .sendTransaction({
                  chainNamespace: "solana",
                  to: this.state.receiverAddress,
                  value: this.state.sendTokenAmount,
                })
                .then(() => {
                  this.resetSend(), f.U.fetchTokenBalance();
                })
                .catch((e) => {
                  A.P.showError(
                    "Failed to send transaction. Please try again."
                  ),
                    console.error(
                      "SendController:sendToken - failed to send solana transaction",
                      e
                    );
                });
          },
          resetSend() {
            (E.token = void 0),
              (E.sendTokenAmount = void 0),
              (E.receiverAddress = void 0),
              (E.receiverProfileImageUrl = void 0),
              (E.receiverProfileName = void 0),
              (E.loading = !1),
              (E.tokenBalances = []);
          },
        };
    },
    80197: (e, t, r) => {
      "use strict";
      r.d(t, { B: () => s });
      var i = r(56538);
      function s(e) {
        return "function" === e.type
          ? `function ${e.name}(${(0, i.Q)(e.inputs)})${
              e.stateMutability && "nonpayable" !== e.stateMutability
                ? ` ${e.stateMutability}`
                : ""
            }${e.outputs?.length ? ` returns (${(0, i.Q)(e.outputs)})` : ""}`
          : "event" === e.type
          ? `event ${e.name}(${(0, i.Q)(e.inputs)})`
          : "error" === e.type
          ? `error ${e.name}(${(0, i.Q)(e.inputs)})`
          : "constructor" === e.type
          ? `constructor(${(0, i.Q)(e.inputs)})${
              "payable" === e.stateMutability ? " payable" : ""
            }`
          : "fallback" === e.type
          ? `fallback() external${
              "payable" === e.stateMutability ? " payable" : ""
            }`
          : "receive() external payable";
      }
    },
    80329: (e, t, r) => {
      "use strict";
      r.d(t, { S: () => o });
      var i = r(29143),
        s = r(60587),
        n = r(55563),
        a = r(34561);
      function o(e, t) {
        let r = (0, i.lY)((0, s.q)(e, { strict: !1 }) ? (0, n.ZJ)(e) : e);
        return "bytes" === (t || "hex") ? r : (0, a.nj)(r);
      }
    },
    80361: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ONE_YEAR =
          t.FOUR_WEEKS =
          t.THREE_WEEKS =
          t.TWO_WEEKS =
          t.ONE_WEEK =
          t.THIRTY_DAYS =
          t.SEVEN_DAYS =
          t.FIVE_DAYS =
          t.THREE_DAYS =
          t.ONE_DAY =
          t.TWENTY_FOUR_HOURS =
          t.TWELVE_HOURS =
          t.SIX_HOURS =
          t.THREE_HOURS =
          t.ONE_HOUR =
          t.SIXTY_MINUTES =
          t.THIRTY_MINUTES =
          t.TEN_MINUTES =
          t.FIVE_MINUTES =
          t.ONE_MINUTE =
          t.SIXTY_SECONDS =
          t.THIRTY_SECONDS =
          t.TEN_SECONDS =
          t.FIVE_SECONDS =
          t.ONE_SECOND =
            void 0),
        (t.ONE_SECOND = 1),
        (t.FIVE_SECONDS = 5),
        (t.TEN_SECONDS = 10),
        (t.THIRTY_SECONDS = 30),
        (t.SIXTY_SECONDS = 60),
        (t.ONE_MINUTE = t.SIXTY_SECONDS),
        (t.FIVE_MINUTES = 5 * t.ONE_MINUTE),
        (t.TEN_MINUTES = 10 * t.ONE_MINUTE),
        (t.THIRTY_MINUTES = 30 * t.ONE_MINUTE),
        (t.SIXTY_MINUTES = 60 * t.ONE_MINUTE),
        (t.ONE_HOUR = t.SIXTY_MINUTES),
        (t.THREE_HOURS = 3 * t.ONE_HOUR),
        (t.SIX_HOURS = 6 * t.ONE_HOUR),
        (t.TWELVE_HOURS = 12 * t.ONE_HOUR),
        (t.TWENTY_FOUR_HOURS = 24 * t.ONE_HOUR),
        (t.ONE_DAY = t.TWENTY_FOUR_HOURS),
        (t.THREE_DAYS = 3 * t.ONE_DAY),
        (t.FIVE_DAYS = 5 * t.ONE_DAY),
        (t.SEVEN_DAYS = 7 * t.ONE_DAY),
        (t.THIRTY_DAYS = 30 * t.ONE_DAY),
        (t.ONE_WEEK = t.SEVEN_DAYS),
        (t.TWO_WEEKS = 2 * t.ONE_WEEK),
        (t.THREE_WEEKS = 3 * t.ONE_WEEK),
        (t.FOUR_WEEKS = 4 * t.ONE_WEEK),
        (t.ONE_YEAR = 365 * t.ONE_DAY);
    },
    81029: (e, t, r) => {
      "use strict";
      let i = r(51746),
        s = r(55459),
        n =
          "function" == typeof Symbol && "function" == typeof Symbol.for
            ? Symbol.for("nodejs.util.inspect.custom")
            : null;
      function a(e) {
        if (e > 0x7fffffff)
          throw RangeError(
            'The value "' + e + '" is invalid for option "size"'
          );
        let t = new Uint8Array(e);
        return Object.setPrototypeOf(t, o.prototype), t;
      }
      function o(e, t, r) {
        if ("number" == typeof e) {
          if ("string" == typeof t)
            throw TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return d(e);
        }
        return c(e, t, r);
      }
      function c(e, t, r) {
        if ("string" == typeof e)
          return (function (e, t) {
            if (
              (("string" != typeof t || "" === t) && (t = "utf8"),
              !o.isEncoding(t))
            )
              throw TypeError("Unknown encoding: " + t);
            let r = 0 | p(e, t),
              i = a(r),
              s = i.write(e, t);
            return s !== r && (i = i.slice(0, s)), i;
          })(e, t);
        if (ArrayBuffer.isView(e))
          return (function (e) {
            if (L(e, Uint8Array)) {
              let t = new Uint8Array(e);
              return h(t.buffer, t.byteOffset, t.byteLength);
            }
            return u(e);
          })(e);
        if (null == e)
          throw TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
              typeof e
          );
        if (
          L(e, ArrayBuffer) ||
          (e && L(e.buffer, ArrayBuffer)) ||
          ("undefined" != typeof SharedArrayBuffer &&
            (L(e, SharedArrayBuffer) || (e && L(e.buffer, SharedArrayBuffer))))
        )
          return h(e, t, r);
        if ("number" == typeof e)
          throw TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        let i = e.valueOf && e.valueOf();
        if (null != i && i !== e) return o.from(i, t, r);
        let s = (function (e) {
          if (o.isBuffer(e)) {
            let t = 0 | f(e.length),
              r = a(t);
            return 0 === r.length || e.copy(r, 0, 0, t), r;
          }
          return void 0 !== e.length
            ? "number" != typeof e.length ||
              (function (e) {
                return e != e;
              })(e.length)
              ? a(0)
              : u(e)
            : "Buffer" === e.type && Array.isArray(e.data)
            ? u(e.data)
            : void 0;
        })(e);
        if (s) return s;
        if (
          "undefined" != typeof Symbol &&
          null != Symbol.toPrimitive &&
          "function" == typeof e[Symbol.toPrimitive]
        )
          return o.from(e[Symbol.toPrimitive]("string"), t, r);
        throw TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
            typeof e
        );
      }
      function l(e) {
        if ("number" != typeof e)
          throw TypeError('"size" argument must be of type number');
        if (e < 0)
          throw RangeError(
            'The value "' + e + '" is invalid for option "size"'
          );
      }
      function d(e) {
        return l(e), a(e < 0 ? 0 : 0 | f(e));
      }
      function u(e) {
        let t = e.length < 0 ? 0 : 0 | f(e.length),
          r = a(t);
        for (let i = 0; i < t; i += 1) r[i] = 255 & e[i];
        return r;
      }
      function h(e, t, r) {
        let i;
        if (t < 0 || e.byteLength < t)
          throw RangeError('"offset" is outside of buffer bounds');
        if (e.byteLength < t + (r || 0))
          throw RangeError('"length" is outside of buffer bounds');
        return (
          Object.setPrototypeOf(
            (i =
              void 0 === t && void 0 === r
                ? new Uint8Array(e)
                : void 0 === r
                ? new Uint8Array(e, t)
                : new Uint8Array(e, t, r)),
            o.prototype
          ),
          i
        );
      }
      function f(e) {
        if (e >= 0x7fffffff)
          throw RangeError(
            "Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes"
          );
        return 0 | e;
      }
      function p(e, t) {
        if (o.isBuffer(e)) return e.length;
        if (ArrayBuffer.isView(e) || L(e, ArrayBuffer)) return e.byteLength;
        if ("string" != typeof e)
          throw TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
              typeof e
          );
        let r = e.length,
          i = arguments.length > 2 && !0 === arguments[2];
        if (!i && 0 === r) return 0;
        let s = !1;
        for (;;)
          switch (t) {
            case "ascii":
            case "latin1":
            case "binary":
              return r;
            case "utf8":
            case "utf-8":
              return D(e).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * r;
            case "hex":
              return r >>> 1;
            case "base64":
              return M(e).length;
            default:
              if (s) return i ? -1 : D(e).length;
              (t = ("" + t).toLowerCase()), (s = !0);
          }
      }
      function g(e, t, r) {
        let s = !1;
        if (
          ((void 0 === t || t < 0) && (t = 0),
          t > this.length ||
            ((void 0 === r || r > this.length) && (r = this.length),
            r <= 0 || (r >>>= 0) <= (t >>>= 0)))
        )
          return "";
        for (e || (e = "utf8"); ; )
          switch (e) {
            case "hex":
              return (function (e, t, r) {
                let i = e.length;
                (!t || t < 0) && (t = 0), (!r || r < 0 || r > i) && (r = i);
                let s = "";
                for (let i = t; i < r; ++i) s += B[e[i]];
                return s;
              })(this, t, r);
            case "utf8":
            case "utf-8":
              return w(this, t, r);
            case "ascii":
              return (function (e, t, r) {
                let i = "";
                r = Math.min(e.length, r);
                for (let s = t; s < r; ++s)
                  i += String.fromCharCode(127 & e[s]);
                return i;
              })(this, t, r);
            case "latin1":
            case "binary":
              return (function (e, t, r) {
                let i = "";
                r = Math.min(e.length, r);
                for (let s = t; s < r; ++s) i += String.fromCharCode(e[s]);
                return i;
              })(this, t, r);
            case "base64":
              var n, a, o;
              return (
                (n = this),
                (a = t),
                (o = r),
                0 === a && o === n.length
                  ? i.fromByteArray(n)
                  : i.fromByteArray(n.slice(a, o))
              );
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return (function (e, t, r) {
                let i = e.slice(t, r),
                  s = "";
                for (let e = 0; e < i.length - 1; e += 2)
                  s += String.fromCharCode(i[e] + 256 * i[e + 1]);
                return s;
              })(this, t, r);
            default:
              if (s) throw TypeError("Unknown encoding: " + e);
              (e = (e + "").toLowerCase()), (s = !0);
          }
      }
      function m(e, t, r) {
        let i = e[t];
        (e[t] = e[r]), (e[r] = i);
      }
      function b(e, t, r, i, s) {
        var n;
        if (0 === e.length) return -1;
        if (
          ("string" == typeof r
            ? ((i = r), (r = 0))
            : r > 0x7fffffff
            ? (r = 0x7fffffff)
            : r < -0x80000000 && (r = -0x80000000),
          (n = r *= 1) != n && (r = s ? 0 : e.length - 1),
          r < 0 && (r = e.length + r),
          r >= e.length)
        ) {
          if (s) return -1;
          r = e.length - 1;
        } else if (r < 0) {
          if (!s) return -1;
          r = 0;
        }
        if (("string" == typeof t && (t = o.from(t, i)), o.isBuffer(t)))
          return 0 === t.length ? -1 : y(e, t, r, i, s);
        if ("number" == typeof t)
          return ((t &= 255), "function" == typeof Uint8Array.prototype.indexOf)
            ? s
              ? Uint8Array.prototype.indexOf.call(e, t, r)
              : Uint8Array.prototype.lastIndexOf.call(e, t, r)
            : y(e, [t], r, i, s);
        throw TypeError("val must be string, number or Buffer");
      }
      function y(e, t, r, i, s) {
        let n,
          a = 1,
          o = e.length,
          c = t.length;
        if (
          void 0 !== i &&
          ("ucs2" === (i = String(i).toLowerCase()) ||
            "ucs-2" === i ||
            "utf16le" === i ||
            "utf-16le" === i)
        ) {
          if (e.length < 2 || t.length < 2) return -1;
          (a = 2), (o /= 2), (c /= 2), (r /= 2);
        }
        function l(e, t) {
          return 1 === a ? e[t] : e.readUInt16BE(t * a);
        }
        if (s) {
          let i = -1;
          for (n = r; n < o; n++)
            if (l(e, n) === l(t, -1 === i ? 0 : n - i)) {
              if ((-1 === i && (i = n), n - i + 1 === c)) return i * a;
            } else -1 !== i && (n -= n - i), (i = -1);
        } else
          for (r + c > o && (r = o - c), n = r; n >= 0; n--) {
            let r = !0;
            for (let i = 0; i < c; i++)
              if (l(e, n + i) !== l(t, i)) {
                r = !1;
                break;
              }
            if (r) return n;
          }
        return -1;
      }
      function w(e, t, r) {
        r = Math.min(e.length, r);
        let i = [],
          s = t;
        for (; s < r; ) {
          let t = e[s],
            n = null,
            a = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
          if (s + a <= r) {
            let r, i, o, c;
            switch (a) {
              case 1:
                t < 128 && (n = t);
                break;
              case 2:
                (192 & (r = e[s + 1])) == 128 &&
                  (c = ((31 & t) << 6) | (63 & r)) > 127 &&
                  (n = c);
                break;
              case 3:
                (r = e[s + 1]),
                  (i = e[s + 2]),
                  (192 & r) == 128 &&
                    (192 & i) == 128 &&
                    (c = ((15 & t) << 12) | ((63 & r) << 6) | (63 & i)) >
                      2047 &&
                    (c < 55296 || c > 57343) &&
                    (n = c);
                break;
              case 4:
                (r = e[s + 1]),
                  (i = e[s + 2]),
                  (o = e[s + 3]),
                  (192 & r) == 128 &&
                    (192 & i) == 128 &&
                    (192 & o) == 128 &&
                    (c =
                      ((15 & t) << 18) |
                      ((63 & r) << 12) |
                      ((63 & i) << 6) |
                      (63 & o)) > 65535 &&
                    c < 1114112 &&
                    (n = c);
            }
          }
          null === n
            ? ((n = 65533), (a = 1))
            : n > 65535 &&
              ((n -= 65536),
              i.push(((n >>> 10) & 1023) | 55296),
              (n = 56320 | (1023 & n))),
            i.push(n),
            (s += a);
        }
        return (function (e) {
          let t = e.length;
          if (t <= 4096) return String.fromCharCode.apply(String, e);
          let r = "",
            i = 0;
          for (; i < t; )
            r += String.fromCharCode.apply(String, e.slice(i, (i += 4096)));
          return r;
        })(i);
      }
      function v(e, t, r) {
        if (e % 1 != 0 || e < 0) throw RangeError("offset is not uint");
        if (e + t > r)
          throw RangeError("Trying to access beyond buffer length");
      }
      function A(e, t, r, i, s, n) {
        if (!o.isBuffer(e))
          throw TypeError('"buffer" argument must be a Buffer instance');
        if (t > s || t < n)
          throw RangeError('"value" argument is out of bounds');
        if (r + i > e.length) throw RangeError("Index out of range");
      }
      function E(e, t, r, i, s) {
        P(t, i, s, e, r, 7);
        let n = Number(t & BigInt(0xffffffff));
        (e[r++] = n),
          (n >>= 8),
          (e[r++] = n),
          (n >>= 8),
          (e[r++] = n),
          (n >>= 8),
          (e[r++] = n);
        let a = Number((t >> BigInt(32)) & BigInt(0xffffffff));
        return (
          (e[r++] = a),
          (a >>= 8),
          (e[r++] = a),
          (a >>= 8),
          (e[r++] = a),
          (a >>= 8),
          (e[r++] = a),
          r
        );
      }
      function _(e, t, r, i, s) {
        P(t, i, s, e, r, 7);
        let n = Number(t & BigInt(0xffffffff));
        (e[r + 7] = n),
          (n >>= 8),
          (e[r + 6] = n),
          (n >>= 8),
          (e[r + 5] = n),
          (n >>= 8),
          (e[r + 4] = n);
        let a = Number((t >> BigInt(32)) & BigInt(0xffffffff));
        return (
          (e[r + 3] = a),
          (a >>= 8),
          (e[r + 2] = a),
          (a >>= 8),
          (e[r + 1] = a),
          (a >>= 8),
          (e[r] = a),
          r + 8
        );
      }
      function C(e, t, r, i, s, n) {
        if (r + i > e.length || r < 0) throw RangeError("Index out of range");
      }
      function I(e, t, r, i, n) {
        return (
          (t *= 1),
          (r >>>= 0),
          n || C(e, t, r, 4, 34028234663852886e22, -34028234663852886e22),
          s.write(e, t, r, i, 23, 4),
          r + 4
        );
      }
      function S(e, t, r, i, n) {
        return (
          (t *= 1),
          (r >>>= 0),
          n || C(e, t, r, 8, 17976931348623157e292, -17976931348623157e292),
          s.write(e, t, r, i, 52, 8),
          r + 8
        );
      }
      (t.Buffer = o),
        (t.SlowBuffer = function (e) {
          return +e != e && (e = 0), o.alloc(+e);
        }),
        (t.INSPECT_MAX_BYTES = 50),
        (t.kMaxLength = 0x7fffffff),
        (o.TYPED_ARRAY_SUPPORT = (function () {
          try {
            let e = new Uint8Array(1),
              t = {
                foo: function () {
                  return 42;
                },
              };
            return (
              Object.setPrototypeOf(t, Uint8Array.prototype),
              Object.setPrototypeOf(e, t),
              42 === e.foo()
            );
          } catch (e) {
            return !1;
          }
        })()),
        o.TYPED_ARRAY_SUPPORT ||
          "undefined" == typeof console ||
          "function" != typeof console.error ||
          console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          ),
        Object.defineProperty(o.prototype, "parent", {
          enumerable: !0,
          get: function () {
            if (o.isBuffer(this)) return this.buffer;
          },
        }),
        Object.defineProperty(o.prototype, "offset", {
          enumerable: !0,
          get: function () {
            if (o.isBuffer(this)) return this.byteOffset;
          },
        }),
        (o.poolSize = 8192),
        (o.from = function (e, t, r) {
          return c(e, t, r);
        }),
        Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(o, Uint8Array),
        (o.alloc = function (e, t, r) {
          return (l(e), e <= 0)
            ? a(e)
            : void 0 !== t
            ? "string" == typeof r
              ? a(e).fill(t, r)
              : a(e).fill(t)
            : a(e);
        }),
        (o.allocUnsafe = function (e) {
          return d(e);
        }),
        (o.allocUnsafeSlow = function (e) {
          return d(e);
        }),
        (o.isBuffer = function (e) {
          return null != e && !0 === e._isBuffer && e !== o.prototype;
        }),
        (o.compare = function (e, t) {
          if (
            (L(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
            L(t, Uint8Array) && (t = o.from(t, t.offset, t.byteLength)),
            !o.isBuffer(e) || !o.isBuffer(t))
          )
            throw TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
            );
          if (e === t) return 0;
          let r = e.length,
            i = t.length;
          for (let s = 0, n = Math.min(r, i); s < n; ++s)
            if (e[s] !== t[s]) {
              (r = e[s]), (i = t[s]);
              break;
            }
          return r < i ? -1 : +(i < r);
        }),
        (o.isEncoding = function (e) {
          switch (String(e).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }),
        (o.concat = function (e, t) {
          let r;
          if (!Array.isArray(e))
            throw TypeError('"list" argument must be an Array of Buffers');
          if (0 === e.length) return o.alloc(0);
          if (void 0 === t)
            for (r = 0, t = 0; r < e.length; ++r) t += e[r].length;
          let i = o.allocUnsafe(t),
            s = 0;
          for (r = 0; r < e.length; ++r) {
            let t = e[r];
            if (L(t, Uint8Array))
              s + t.length > i.length
                ? (o.isBuffer(t) || (t = o.from(t)), t.copy(i, s))
                : Uint8Array.prototype.set.call(i, t, s);
            else if (o.isBuffer(t)) t.copy(i, s);
            else throw TypeError('"list" argument must be an Array of Buffers');
            s += t.length;
          }
          return i;
        }),
        (o.byteLength = p),
        (o.prototype._isBuffer = !0),
        (o.prototype.swap16 = function () {
          let e = this.length;
          if (e % 2 != 0)
            throw RangeError("Buffer size must be a multiple of 16-bits");
          for (let t = 0; t < e; t += 2) m(this, t, t + 1);
          return this;
        }),
        (o.prototype.swap32 = function () {
          let e = this.length;
          if (e % 4 != 0)
            throw RangeError("Buffer size must be a multiple of 32-bits");
          for (let t = 0; t < e; t += 4)
            m(this, t, t + 3), m(this, t + 1, t + 2);
          return this;
        }),
        (o.prototype.swap64 = function () {
          let e = this.length;
          if (e % 8 != 0)
            throw RangeError("Buffer size must be a multiple of 64-bits");
          for (let t = 0; t < e; t += 8)
            m(this, t, t + 7),
              m(this, t + 1, t + 6),
              m(this, t + 2, t + 5),
              m(this, t + 3, t + 4);
          return this;
        }),
        (o.prototype.toString = function () {
          let e = this.length;
          return 0 === e
            ? ""
            : 0 == arguments.length
            ? w(this, 0, e)
            : g.apply(this, arguments);
        }),
        (o.prototype.toLocaleString = o.prototype.toString),
        (o.prototype.equals = function (e) {
          if (!o.isBuffer(e)) throw TypeError("Argument must be a Buffer");
          return this === e || 0 === o.compare(this, e);
        }),
        (o.prototype.inspect = function () {
          let e = "",
            r = t.INSPECT_MAX_BYTES;
          return (
            (e = this.toString("hex", 0, r)
              .replace(/(.{2})/g, "$1 ")
              .trim()),
            this.length > r && (e += " ... "),
            "<Buffer " + e + ">"
          );
        }),
        n && (o.prototype[n] = o.prototype.inspect),
        (o.prototype.compare = function (e, t, r, i, s) {
          if (
            (L(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
            !o.isBuffer(e))
          )
            throw TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                typeof e
            );
          if (
            (void 0 === t && (t = 0),
            void 0 === r && (r = e ? e.length : 0),
            void 0 === i && (i = 0),
            void 0 === s && (s = this.length),
            t < 0 || r > e.length || i < 0 || s > this.length)
          )
            throw RangeError("out of range index");
          if (i >= s && t >= r) return 0;
          if (i >= s) return -1;
          if (t >= r) return 1;
          if (((t >>>= 0), (r >>>= 0), (i >>>= 0), (s >>>= 0), this === e))
            return 0;
          let n = s - i,
            a = r - t,
            c = Math.min(n, a),
            l = this.slice(i, s),
            d = e.slice(t, r);
          for (let e = 0; e < c; ++e)
            if (l[e] !== d[e]) {
              (n = l[e]), (a = d[e]);
              break;
            }
          return n < a ? -1 : +(a < n);
        }),
        (o.prototype.includes = function (e, t, r) {
          return -1 !== this.indexOf(e, t, r);
        }),
        (o.prototype.indexOf = function (e, t, r) {
          return b(this, e, t, r, !0);
        }),
        (o.prototype.lastIndexOf = function (e, t, r) {
          return b(this, e, t, r, !1);
        }),
        (o.prototype.write = function (e, t, r, i) {
          var s, n, a, o, c, l, d, u;
          if (void 0 === t) (i = "utf8"), (r = this.length), (t = 0);
          else if (void 0 === r && "string" == typeof t)
            (i = t), (r = this.length), (t = 0);
          else if (isFinite(t))
            (t >>>= 0),
              isFinite(r)
                ? ((r >>>= 0), void 0 === i && (i = "utf8"))
                : ((i = r), (r = void 0));
          else
            throw Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          let h = this.length - t;
          if (
            ((void 0 === r || r > h) && (r = h),
            (e.length > 0 && (r < 0 || t < 0)) || t > this.length)
          )
            throw RangeError("Attempt to write outside buffer bounds");
          i || (i = "utf8");
          let f = !1;
          for (;;)
            switch (i) {
              case "hex":
                return (function (e, t, r, i) {
                  let s;
                  r = Number(r) || 0;
                  let n = e.length - r;
                  i ? (i = Number(i)) > n && (i = n) : (i = n);
                  let a = t.length;
                  for (i > a / 2 && (i = a / 2), s = 0; s < i; ++s) {
                    var o;
                    let i = parseInt(t.substr(2 * s, 2), 16);
                    if ((o = i) != o) break;
                    e[r + s] = i;
                  }
                  return s;
                })(this, e, t, r);
              case "utf8":
              case "utf-8":
                return (s = t), (n = r), U(D(e, this.length - s), this, s, n);
              case "ascii":
              case "latin1":
              case "binary":
                return (
                  (a = t),
                  (o = r),
                  U(
                    (function (e) {
                      let t = [];
                      for (let r = 0; r < e.length; ++r)
                        t.push(255 & e.charCodeAt(r));
                      return t;
                    })(e),
                    this,
                    a,
                    o
                  )
                );
              case "base64":
                return (c = t), (l = r), U(M(e), this, c, l);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return (
                  (d = t),
                  (u = r),
                  U(
                    (function (e, t) {
                      let r, i;
                      let s = [];
                      for (let n = 0; n < e.length && !((t -= 2) < 0); ++n)
                        (i = (r = e.charCodeAt(n)) >> 8),
                          s.push(r % 256),
                          s.push(i);
                      return s;
                    })(e, this.length - d),
                    this,
                    d,
                    u
                  )
                );
              default:
                if (f) throw TypeError("Unknown encoding: " + i);
                (i = ("" + i).toLowerCase()), (f = !0);
            }
        }),
        (o.prototype.toJSON = function () {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0),
          };
        }),
        (o.prototype.slice = function (e, t) {
          let r = this.length;
          (e = ~~e),
            (t = void 0 === t ? r : ~~t),
            e < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
            t < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
            t < e && (t = e);
          let i = this.subarray(e, t);
          return Object.setPrototypeOf(i, o.prototype), i;
        }),
        (o.prototype.readUintLE = o.prototype.readUIntLE =
          function (e, t, r) {
            (e >>>= 0), (t >>>= 0), r || v(e, t, this.length);
            let i = this[e],
              s = 1,
              n = 0;
            for (; ++n < t && (s *= 256); ) i += this[e + n] * s;
            return i;
          }),
        (o.prototype.readUintBE = o.prototype.readUIntBE =
          function (e, t, r) {
            (e >>>= 0), (t >>>= 0), r || v(e, t, this.length);
            let i = this[e + --t],
              s = 1;
            for (; t > 0 && (s *= 256); ) i += this[e + --t] * s;
            return i;
          }),
        (o.prototype.readUint8 = o.prototype.readUInt8 =
          function (e, t) {
            return (e >>>= 0), t || v(e, 1, this.length), this[e];
          }),
        (o.prototype.readUint16LE = o.prototype.readUInt16LE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 2, this.length),
              this[e] | (this[e + 1] << 8)
            );
          }),
        (o.prototype.readUint16BE = o.prototype.readUInt16BE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 2, this.length),
              (this[e] << 8) | this[e + 1]
            );
          }),
        (o.prototype.readUint32LE = o.prototype.readUInt32LE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 4, this.length),
              (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
                0x1000000 * this[e + 3]
            );
          }),
        (o.prototype.readUint32BE = o.prototype.readUInt32BE =
          function (e, t) {
            return (
              (e >>>= 0),
              t || v(e, 4, this.length),
              0x1000000 * this[e] +
                ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
            );
          }),
        (o.prototype.readBigUInt64LE = j(function (e) {
          O((e >>>= 0), "offset");
          let t = this[e],
            r = this[e + 7];
          (void 0 === t || void 0 === r) && k(e, this.length - 8);
          let i =
              t + 256 * this[++e] + 65536 * this[++e] + 0x1000000 * this[++e],
            s = this[++e] + 256 * this[++e] + 65536 * this[++e] + 0x1000000 * r;
          return BigInt(i) + (BigInt(s) << BigInt(32));
        })),
        (o.prototype.readBigUInt64BE = j(function (e) {
          O((e >>>= 0), "offset");
          let t = this[e],
            r = this[e + 7];
          (void 0 === t || void 0 === r) && k(e, this.length - 8);
          let i =
              0x1000000 * t + 65536 * this[++e] + 256 * this[++e] + this[++e],
            s = 0x1000000 * this[++e] + 65536 * this[++e] + 256 * this[++e] + r;
          return (BigInt(i) << BigInt(32)) + BigInt(s);
        })),
        (o.prototype.readIntLE = function (e, t, r) {
          (e >>>= 0), (t >>>= 0), r || v(e, t, this.length);
          let i = this[e],
            s = 1,
            n = 0;
          for (; ++n < t && (s *= 256); ) i += this[e + n] * s;
          return i >= (s *= 128) && (i -= Math.pow(2, 8 * t)), i;
        }),
        (o.prototype.readIntBE = function (e, t, r) {
          (e >>>= 0), (t >>>= 0), r || v(e, t, this.length);
          let i = t,
            s = 1,
            n = this[e + --i];
          for (; i > 0 && (s *= 256); ) n += this[e + --i] * s;
          return n >= (s *= 128) && (n -= Math.pow(2, 8 * t)), n;
        }),
        (o.prototype.readInt8 = function (e, t) {
          return ((e >>>= 0), t || v(e, 1, this.length), 128 & this[e])
            ? -((255 - this[e] + 1) * 1)
            : this[e];
        }),
        (o.prototype.readInt16LE = function (e, t) {
          (e >>>= 0), t || v(e, 2, this.length);
          let r = this[e] | (this[e + 1] << 8);
          return 32768 & r ? 0xffff0000 | r : r;
        }),
        (o.prototype.readInt16BE = function (e, t) {
          (e >>>= 0), t || v(e, 2, this.length);
          let r = this[e + 1] | (this[e] << 8);
          return 32768 & r ? 0xffff0000 | r : r;
        }),
        (o.prototype.readInt32LE = function (e, t) {
          return (
            (e >>>= 0),
            t || v(e, 4, this.length),
            this[e] |
              (this[e + 1] << 8) |
              (this[e + 2] << 16) |
              (this[e + 3] << 24)
          );
        }),
        (o.prototype.readInt32BE = function (e, t) {
          return (
            (e >>>= 0),
            t || v(e, 4, this.length),
            (this[e] << 24) |
              (this[e + 1] << 16) |
              (this[e + 2] << 8) |
              this[e + 3]
          );
        }),
        (o.prototype.readBigInt64LE = j(function (e) {
          O((e >>>= 0), "offset");
          let t = this[e],
            r = this[e + 7];
          return (
            (void 0 === t || void 0 === r) && k(e, this.length - 8),
            (BigInt(
              this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (r << 24)
            ) <<
              BigInt(32)) +
              BigInt(
                t + 256 * this[++e] + 65536 * this[++e] + 0x1000000 * this[++e]
              )
          );
        })),
        (o.prototype.readBigInt64BE = j(function (e) {
          O((e >>>= 0), "offset");
          let t = this[e],
            r = this[e + 7];
          return (
            (void 0 === t || void 0 === r) && k(e, this.length - 8),
            (BigInt(
              (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e]
            ) <<
              BigInt(32)) +
              BigInt(
                0x1000000 * this[++e] + 65536 * this[++e] + 256 * this[++e] + r
              )
          );
        })),
        (o.prototype.readFloatLE = function (e, t) {
          return (
            (e >>>= 0), t || v(e, 4, this.length), s.read(this, e, !0, 23, 4)
          );
        }),
        (o.prototype.readFloatBE = function (e, t) {
          return (
            (e >>>= 0), t || v(e, 4, this.length), s.read(this, e, !1, 23, 4)
          );
        }),
        (o.prototype.readDoubleLE = function (e, t) {
          return (
            (e >>>= 0), t || v(e, 8, this.length), s.read(this, e, !0, 52, 8)
          );
        }),
        (o.prototype.readDoubleBE = function (e, t) {
          return (
            (e >>>= 0), t || v(e, 8, this.length), s.read(this, e, !1, 52, 8)
          );
        }),
        (o.prototype.writeUintLE = o.prototype.writeUIntLE =
          function (e, t, r, i) {
            if (((e *= 1), (t >>>= 0), (r >>>= 0), !i)) {
              let i = Math.pow(2, 8 * r) - 1;
              A(this, e, t, r, i, 0);
            }
            let s = 1,
              n = 0;
            for (this[t] = 255 & e; ++n < r && (s *= 256); )
              this[t + n] = (e / s) & 255;
            return t + r;
          }),
        (o.prototype.writeUintBE = o.prototype.writeUIntBE =
          function (e, t, r, i) {
            if (((e *= 1), (t >>>= 0), (r >>>= 0), !i)) {
              let i = Math.pow(2, 8 * r) - 1;
              A(this, e, t, r, i, 0);
            }
            let s = r - 1,
              n = 1;
            for (this[t + s] = 255 & e; --s >= 0 && (n *= 256); )
              this[t + s] = (e / n) & 255;
            return t + r;
          }),
        (o.prototype.writeUint8 = o.prototype.writeUInt8 =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || A(this, e, t, 1, 255, 0),
              (this[t] = 255 & e),
              t + 1
            );
          }),
        (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || A(this, e, t, 2, 65535, 0),
              (this[t] = 255 & e),
              (this[t + 1] = e >>> 8),
              t + 2
            );
          }),
        (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || A(this, e, t, 2, 65535, 0),
              (this[t] = e >>> 8),
              (this[t + 1] = 255 & e),
              t + 2
            );
          }),
        (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || A(this, e, t, 4, 0xffffffff, 0),
              (this[t + 3] = e >>> 24),
              (this[t + 2] = e >>> 16),
              (this[t + 1] = e >>> 8),
              (this[t] = 255 & e),
              t + 4
            );
          }),
        (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
          function (e, t, r) {
            return (
              (e *= 1),
              (t >>>= 0),
              r || A(this, e, t, 4, 0xffffffff, 0),
              (this[t] = e >>> 24),
              (this[t + 1] = e >>> 16),
              (this[t + 2] = e >>> 8),
              (this[t + 3] = 255 & e),
              t + 4
            );
          }),
        (o.prototype.writeBigUInt64LE = j(function (e, t = 0) {
          return E(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
        })),
        (o.prototype.writeBigUInt64BE = j(function (e, t = 0) {
          return _(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
        })),
        (o.prototype.writeIntLE = function (e, t, r, i) {
          if (((e *= 1), (t >>>= 0), !i)) {
            let i = Math.pow(2, 8 * r - 1);
            A(this, e, t, r, i - 1, -i);
          }
          let s = 0,
            n = 1,
            a = 0;
          for (this[t] = 255 & e; ++s < r && (n *= 256); )
            e < 0 && 0 === a && 0 !== this[t + s - 1] && (a = 1),
              (this[t + s] = (((e / n) >> 0) - a) & 255);
          return t + r;
        }),
        (o.prototype.writeIntBE = function (e, t, r, i) {
          if (((e *= 1), (t >>>= 0), !i)) {
            let i = Math.pow(2, 8 * r - 1);
            A(this, e, t, r, i - 1, -i);
          }
          let s = r - 1,
            n = 1,
            a = 0;
          for (this[t + s] = 255 & e; --s >= 0 && (n *= 256); )
            e < 0 && 0 === a && 0 !== this[t + s + 1] && (a = 1),
              (this[t + s] = (((e / n) >> 0) - a) & 255);
          return t + r;
        }),
        (o.prototype.writeInt8 = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || A(this, e, t, 1, 127, -128),
            e < 0 && (e = 255 + e + 1),
            (this[t] = 255 & e),
            t + 1
          );
        }),
        (o.prototype.writeInt16LE = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || A(this, e, t, 2, 32767, -32768),
            (this[t] = 255 & e),
            (this[t + 1] = e >>> 8),
            t + 2
          );
        }),
        (o.prototype.writeInt16BE = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || A(this, e, t, 2, 32767, -32768),
            (this[t] = e >>> 8),
            (this[t + 1] = 255 & e),
            t + 2
          );
        }),
        (o.prototype.writeInt32LE = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || A(this, e, t, 4, 0x7fffffff, -0x80000000),
            (this[t] = 255 & e),
            (this[t + 1] = e >>> 8),
            (this[t + 2] = e >>> 16),
            (this[t + 3] = e >>> 24),
            t + 4
          );
        }),
        (o.prototype.writeInt32BE = function (e, t, r) {
          return (
            (e *= 1),
            (t >>>= 0),
            r || A(this, e, t, 4, 0x7fffffff, -0x80000000),
            e < 0 && (e = 0xffffffff + e + 1),
            (this[t] = e >>> 24),
            (this[t + 1] = e >>> 16),
            (this[t + 2] = e >>> 8),
            (this[t + 3] = 255 & e),
            t + 4
          );
        }),
        (o.prototype.writeBigInt64LE = j(function (e, t = 0) {
          return E(
            this,
            e,
            t,
            -BigInt("0x8000000000000000"),
            BigInt("0x7fffffffffffffff")
          );
        })),
        (o.prototype.writeBigInt64BE = j(function (e, t = 0) {
          return _(
            this,
            e,
            t,
            -BigInt("0x8000000000000000"),
            BigInt("0x7fffffffffffffff")
          );
        })),
        (o.prototype.writeFloatLE = function (e, t, r) {
          return I(this, e, t, !0, r);
        }),
        (o.prototype.writeFloatBE = function (e, t, r) {
          return I(this, e, t, !1, r);
        }),
        (o.prototype.writeDoubleLE = function (e, t, r) {
          return S(this, e, t, !0, r);
        }),
        (o.prototype.writeDoubleBE = function (e, t, r) {
          return S(this, e, t, !1, r);
        }),
        (o.prototype.copy = function (e, t, r, i) {
          if (!o.isBuffer(e)) throw TypeError("argument should be a Buffer");
          if (
            (r || (r = 0),
            i || 0 === i || (i = this.length),
            t >= e.length && (t = e.length),
            t || (t = 0),
            i > 0 && i < r && (i = r),
            i === r || 0 === e.length || 0 === this.length)
          )
            return 0;
          if (t < 0) throw RangeError("targetStart out of bounds");
          if (r < 0 || r >= this.length) throw RangeError("Index out of range");
          if (i < 0) throw RangeError("sourceEnd out of bounds");
          i > this.length && (i = this.length),
            e.length - t < i - r && (i = e.length - t + r);
          let s = i - r;
          return (
            this === e && "function" == typeof Uint8Array.prototype.copyWithin
              ? this.copyWithin(t, r, i)
              : Uint8Array.prototype.set.call(e, this.subarray(r, i), t),
            s
          );
        }),
        (o.prototype.fill = function (e, t, r, i) {
          let s;
          if ("string" == typeof e) {
            if (
              ("string" == typeof t
                ? ((i = t), (t = 0), (r = this.length))
                : "string" == typeof r && ((i = r), (r = this.length)),
              void 0 !== i && "string" != typeof i)
            )
              throw TypeError("encoding must be a string");
            if ("string" == typeof i && !o.isEncoding(i))
              throw TypeError("Unknown encoding: " + i);
            if (1 === e.length) {
              let t = e.charCodeAt(0);
              (("utf8" === i && t < 128) || "latin1" === i) && (e = t);
            }
          } else
            "number" == typeof e
              ? (e &= 255)
              : "boolean" == typeof e && (e = Number(e));
          if (t < 0 || this.length < t || this.length < r)
            throw RangeError("Out of range index");
          if (r <= t) return this;
          if (
            ((t >>>= 0),
            (r = void 0 === r ? this.length : r >>> 0),
            e || (e = 0),
            "number" == typeof e)
          )
            for (s = t; s < r; ++s) this[s] = e;
          else {
            let n = o.isBuffer(e) ? e : o.from(e, i),
              a = n.length;
            if (0 === a)
              throw TypeError(
                'The value "' + e + '" is invalid for argument "value"'
              );
            for (s = 0; s < r - t; ++s) this[s + t] = n[s % a];
          }
          return this;
        });
      let x = {};
      function N(e, t, r) {
        x[e] = class extends r {
          constructor() {
            super(),
              Object.defineProperty(this, "message", {
                value: t.apply(this, arguments),
                writable: !0,
                configurable: !0,
              }),
              (this.name = `${this.name} [${e}]`),
              this.stack,
              delete this.name;
          }
          get code() {
            return e;
          }
          set code(e) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: e,
              writable: !0,
            });
          }
          toString() {
            return `${this.name} [${e}]: ${this.message}`;
          }
        };
      }
      function T(e) {
        let t = "",
          r = e.length,
          i = +("-" === e[0]);
        for (; r >= i + 4; r -= 3) t = `_${e.slice(r - 3, r)}${t}`;
        return `${e.slice(0, r)}${t}`;
      }
      function P(e, t, r, i, s, n) {
        if (e > r || e < t) {
          let i;
          let s = "bigint" == typeof t ? "n" : "";
          throw (
            ((i =
              n > 3
                ? 0 === t || t === BigInt(0)
                  ? `>= 0${s} and < 2${s} ** ${(n + 1) * 8}${s}`
                  : `>= -(2${s} ** ${(n + 1) * 8 - 1}${s}) and < 2 ** ${
                      (n + 1) * 8 - 1
                    }${s}`
                : `>= ${t}${s} and <= ${r}${s}`),
            new x.ERR_OUT_OF_RANGE("value", i, e))
          );
        }
        O(s, "offset"),
          (void 0 === i[s] || void 0 === i[s + n]) && k(s, i.length - (n + 1));
      }
      function O(e, t) {
        if ("number" != typeof e)
          throw new x.ERR_INVALID_ARG_TYPE(t, "number", e);
      }
      function k(e, t, r) {
        if (Math.floor(e) !== e)
          throw (
            (O(e, r), new x.ERR_OUT_OF_RANGE(r || "offset", "an integer", e))
          );
        if (t < 0) throw new x.ERR_BUFFER_OUT_OF_BOUNDS();
        throw new x.ERR_OUT_OF_RANGE(
          r || "offset",
          `>= ${+!!r} and <= ${t}`,
          e
        );
      }
      N(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function (e) {
          return e
            ? `${e} is outside of buffer bounds`
            : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ),
        N(
          "ERR_INVALID_ARG_TYPE",
          function (e, t) {
            return `The "${e}" argument must be of type number. Received type ${typeof t}`;
          },
          TypeError
        ),
        N(
          "ERR_OUT_OF_RANGE",
          function (e, t, r) {
            let i = `The value of "${e}" is out of range.`,
              s = r;
            return (
              Number.isInteger(r) && Math.abs(r) > 0x100000000
                ? (s = T(String(r)))
                : "bigint" == typeof r &&
                  ((s = String(r)),
                  (r > BigInt(2) ** BigInt(32) ||
                    r < -(BigInt(2) ** BigInt(32))) &&
                    (s = T(s)),
                  (s += "n")),
              (i += ` It must be ${t}. Received ${s}`)
            );
          },
          RangeError
        );
      let R = /[^+/0-9A-Za-z-_]/g;
      function D(e, t) {
        let r;
        t = t || 1 / 0;
        let i = e.length,
          s = null,
          n = [];
        for (let a = 0; a < i; ++a) {
          if ((r = e.charCodeAt(a)) > 55295 && r < 57344) {
            if (!s) {
              if (r > 56319 || a + 1 === i) {
                (t -= 3) > -1 && n.push(239, 191, 189);
                continue;
              }
              s = r;
              continue;
            }
            if (r < 56320) {
              (t -= 3) > -1 && n.push(239, 191, 189), (s = r);
              continue;
            }
            r = (((s - 55296) << 10) | (r - 56320)) + 65536;
          } else s && (t -= 3) > -1 && n.push(239, 191, 189);
          if (((s = null), r < 128)) {
            if ((t -= 1) < 0) break;
            n.push(r);
          } else if (r < 2048) {
            if ((t -= 2) < 0) break;
            n.push((r >> 6) | 192, (63 & r) | 128);
          } else if (r < 65536) {
            if ((t -= 3) < 0) break;
            n.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (63 & r) | 128);
          } else if (r < 1114112) {
            if ((t -= 4) < 0) break;
            n.push(
              (r >> 18) | 240,
              ((r >> 12) & 63) | 128,
              ((r >> 6) & 63) | 128,
              (63 & r) | 128
            );
          } else throw Error("Invalid code point");
        }
        return n;
      }
      function M(e) {
        return i.toByteArray(
          (function (e) {
            if ((e = (e = e.split("=")[0]).trim().replace(R, "")).length < 2)
              return "";
            for (; e.length % 4 != 0; ) e += "=";
            return e;
          })(e)
        );
      }
      function U(e, t, r, i) {
        let s;
        for (s = 0; s < i && !(s + r >= t.length) && !(s >= e.length); ++s)
          t[s + r] = e[s];
        return s;
      }
      function L(e, t) {
        return (
          e instanceof t ||
          (null != e &&
            null != e.constructor &&
            null != e.constructor.name &&
            e.constructor.name === t.name)
        );
      }
      let B = (function () {
        let e = "0123456789abcdef",
          t = Array(256);
        for (let r = 0; r < 16; ++r) {
          let i = 16 * r;
          for (let s = 0; s < 16; ++s) t[i + s] = e[r] + e[s];
        }
        return t;
      })();
      function j(e) {
        return "undefined" == typeof BigInt ? F : e;
      }
      function F() {
        throw Error("BigInt not supported");
      }
    },
    81356: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "Image", {
          enumerable: !0,
          get: function () {
            return v;
          },
        });
      let i = r(28140),
        s = r(49417),
        n = r(95155),
        a = s._(r(12115)),
        o = i._(r(47650)),
        c = i._(r(74841)),
        l = r(75040),
        d = r(20821),
        u = r(33455);
      r(94781);
      let h = r(79862),
        f = i._(r(71124)),
        p = r(83011),
        g = {
          deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
          imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
          path: "/_next/image",
          loader: "default",
          dangerouslyAllowSVG: !0,
          unoptimized: !1,
        };
      function m(e, t, r, i, s, n, a) {
        let o = null == e ? void 0 : e.src;
        e &&
          e["data-loaded-src"] !== o &&
          ((e["data-loaded-src"] = o),
          ("decode" in e ? e.decode() : Promise.resolve())
            .catch(() => {})
            .then(() => {
              if (e.parentElement && e.isConnected) {
                if (("empty" !== t && s(!0), null == r ? void 0 : r.current)) {
                  let t = new Event("load");
                  Object.defineProperty(t, "target", {
                    writable: !1,
                    value: e,
                  });
                  let i = !1,
                    s = !1;
                  r.current({
                    ...t,
                    nativeEvent: t,
                    currentTarget: e,
                    target: e,
                    isDefaultPrevented: () => i,
                    isPropagationStopped: () => s,
                    persist: () => {},
                    preventDefault: () => {
                      (i = !0), t.preventDefault();
                    },
                    stopPropagation: () => {
                      (s = !0), t.stopPropagation();
                    },
                  });
                }
                (null == i ? void 0 : i.current) && i.current(e);
              }
            }));
      }
      function b(e) {
        return a.use ? { fetchPriority: e } : { fetchpriority: e };
      }
      let y = (0, a.forwardRef)((e, t) => {
        let {
            src: r,
            srcSet: i,
            sizes: s,
            height: o,
            width: c,
            decoding: l,
            className: d,
            style: u,
            fetchPriority: h,
            placeholder: f,
            loading: g,
            unoptimized: y,
            fill: w,
            onLoadRef: v,
            onLoadingCompleteRef: A,
            setBlurComplete: E,
            setShowAltText: _,
            sizesInput: C,
            onLoad: I,
            onError: S,
            ...x
          } = e,
          N = (0, a.useCallback)(
            (e) => {
              e && (S && (e.src = e.src), e.complete && m(e, f, v, A, E, y, C));
            },
            [r, f, v, A, E, S, y, C]
          ),
          T = (0, p.useMergedRef)(t, N);
        return (0, n.jsx)("img", {
          ...x,
          ...b(h),
          loading: g,
          width: c,
          height: o,
          decoding: l,
          "data-nimg": w ? "fill" : "1",
          className: d,
          style: u,
          sizes: s,
          srcSet: i,
          src: r,
          ref: T,
          onLoad: (e) => {
            m(e.currentTarget, f, v, A, E, y, C);
          },
          onError: (e) => {
            _(!0), "empty" !== f && E(!0), S && S(e);
          },
        });
      });
      function w(e) {
        let { isAppRouter: t, imgAttributes: r } = e,
          i = {
            as: "image",
            imageSrcSet: r.srcSet,
            imageSizes: r.sizes,
            crossOrigin: r.crossOrigin,
            referrerPolicy: r.referrerPolicy,
            ...b(r.fetchPriority),
          };
        return t && o.default.preload
          ? (o.default.preload(r.src, i), null)
          : (0, n.jsx)(c.default, {
              children: (0, n.jsx)(
                "link",
                { rel: "preload", href: r.srcSet ? void 0 : r.src, ...i },
                "__nimg-" + r.src + r.srcSet + r.sizes
              ),
            });
      }
      let v = (0, a.forwardRef)((e, t) => {
        let r = (0, a.useContext)(h.RouterContext),
          i = (0, a.useContext)(u.ImageConfigContext),
          s = (0, a.useMemo)(() => {
            var e;
            let t = g || i || d.imageConfigDefault,
              r = [...t.deviceSizes, ...t.imageSizes].sort((e, t) => e - t),
              s = t.deviceSizes.sort((e, t) => e - t),
              n = null == (e = t.qualities) ? void 0 : e.sort((e, t) => e - t);
            return { ...t, allSizes: r, deviceSizes: s, qualities: n };
          }, [i]),
          { onLoad: o, onLoadingComplete: c } = e,
          p = (0, a.useRef)(o);
        (0, a.useEffect)(() => {
          p.current = o;
        }, [o]);
        let m = (0, a.useRef)(c);
        (0, a.useEffect)(() => {
          m.current = c;
        }, [c]);
        let [b, v] = (0, a.useState)(!1),
          [A, E] = (0, a.useState)(!1),
          { props: _, meta: C } = (0, l.getImgProps)(e, {
            defaultLoader: f.default,
            imgConf: s,
            blurComplete: b,
            showAltText: A,
          });
        return (0, n.jsxs)(n.Fragment, {
          children: [
            (0, n.jsx)(y, {
              ..._,
              unoptimized: C.unoptimized,
              placeholder: C.placeholder,
              fill: C.fill,
              onLoadRef: p,
              onLoadingCompleteRef: m,
              setBlurComplete: v,
              setShowAltText: E,
              sizesInput: e.sizes,
              ref: t,
            }),
            C.priority
              ? (0, n.jsx)(w, { isAppRouter: !r, imgAttributes: _ })
              : null,
          ],
        });
      });
      ("function" == typeof t.default ||
        ("object" == typeof t.default && null !== t.default)) &&
        void 0 === t.default.__esModule &&
        (Object.defineProperty(t.default, "__esModule", { value: !0 }),
        Object.assign(t.default, t),
        (e.exports = t.default));
    },
    81452: (e, t) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ONE_THOUSAND = t.ONE_HUNDRED = void 0),
        (t.ONE_HUNDRED = 100),
        (t.ONE_THOUSAND = 1e3);
    },
    81701: (e, t, r) => {
      "use strict";
      r.d(t, { W: () => m });
      var i = r(1220),
        s = r(98866),
        n = r(12319),
        a = r(58051),
        o = r(72880),
        c = r(73442),
        l = r(3824),
        d = r(66254),
        u = r(70417),
        h = r(55480),
        f = r(6578),
        p = r(67869);
      let g = (0, i.BX)({
          loading: !1,
          loadingNamespaceMap: new Map(),
          open: !1,
          shake: !1,
          namespace: void 0,
        }),
        m = {
          state: g,
          subscribe: (e) => (0, i.B1)(g, () => e(g)),
          subscribeKey: (e, t) => (0, s.u$)(g, e, t),
          async open(e) {
            let t = "connected" === a.U.state.status;
            l.x.state.wcBasic
              ? o.N.prefetch({
                  fetchNetworkImages: !1,
                  fetchConnectorImages: !1,
                })
              : await o.N.prefetch({
                  fetchConnectorImages: !t,
                  fetchFeaturedWallets: !t,
                  fetchRecommendedWallets: !t,
                }),
              e?.namespace
                ? (await c.W.switchActiveNamespace(e.namespace),
                  m.setLoading(!0, e.namespace))
                : m.setLoading(!0),
              d.a.setFilterByNamespace(e?.namespace);
            let r = c.W.getAccountData(e?.namespace)?.caipAddress;
            c.W.state.noAdapters && !r
              ? n.w.isMobile()
                ? p.I.reset("AllWallets")
                : p.I.reset("ConnectingWalletConnectBasic")
              : e?.view
              ? p.I.reset(e.view)
              : r
              ? p.I.reset("Account")
              : p.I.reset("Connect"),
              (g.open = !0),
              f.z.set({ open: !0 }),
              u.E.sendEvent({
                type: "track",
                event: "MODAL_OPEN",
                properties: { connected: !!r },
              });
          },
          close() {
            let e = h.H.state.enableEmbedded,
              t = !!c.W.state.activeCaipAddress;
            g.open &&
              u.E.sendEvent({
                type: "track",
                event: "MODAL_CLOSE",
                properties: { connected: t },
              }),
              (g.open = !1),
              m.clearLoading(),
              e
                ? t
                  ? p.I.replace("Account")
                  : p.I.push("Connect")
                : f.z.set({ open: !1 }),
              l.x.resetUri();
          },
          setLoading(e, t) {
            t && g.loadingNamespaceMap.set(t, e),
              (g.loading = e),
              f.z.set({ loading: e });
          },
          clearLoading() {
            g.loadingNamespaceMap.clear(), (g.loading = !1);
          },
          shake() {
            !g.shake &&
              ((g.shake = !0),
              setTimeout(() => {
                g.shake = !1;
              }, 500));
          },
        };
    },
    82965: (e, t, r) => {
      "use strict";
      var i = r(98392),
        s = r(17891),
        n = r(78239),
        a = r(13798),
        o = r(66725),
        c = n.assert,
        l = r(87094),
        d = r(70083);
      function u(e) {
        if (!(this instanceof u)) return new u(e);
        "string" == typeof e &&
          (c(Object.prototype.hasOwnProperty.call(a, e), "Unknown curve " + e),
          (e = a[e])),
          e instanceof a.PresetCurve && (e = { curve: e }),
          (this.curve = e.curve.curve),
          (this.n = this.curve.n),
          (this.nh = this.n.ushrn(1)),
          (this.g = this.curve.g),
          (this.g = e.curve.g),
          this.g.precompute(e.curve.n.bitLength() + 1),
          (this.hash = e.hash || e.curve.hash);
      }
      (e.exports = u),
        (u.prototype.keyPair = function (e) {
          return new l(this, e);
        }),
        (u.prototype.keyFromPrivate = function (e, t) {
          return l.fromPrivate(this, e, t);
        }),
        (u.prototype.keyFromPublic = function (e, t) {
          return l.fromPublic(this, e, t);
        }),
        (u.prototype.genKeyPair = function (e) {
          e || (e = {});
          for (
            var t = new s({
                hash: this.hash,
                pers: e.pers,
                persEnc: e.persEnc || "utf8",
                entropy: e.entropy || o(this.hash.hmacStrength),
                entropyEnc: (e.entropy && e.entropyEnc) || "utf8",
                nonce: this.n.toArray(),
              }),
              r = this.n.byteLength(),
              n = this.n.sub(new i(2));
            ;

          ) {
            var a = new i(t.generate(r));
            if (!(a.cmp(n) > 0)) return a.iaddn(1), this.keyFromPrivate(a);
          }
        }),
        (u.prototype._truncateToN = function (e, t, r) {
          if (i.isBN(e) || "number" == typeof e)
            s = (e = new i(e, 16)).byteLength();
          else if ("object" == typeof e) (s = e.length), (e = new i(e, 16));
          else {
            var s,
              n = e.toString();
            (s = (n.length + 1) >>> 1), (e = new i(n, 16));
          }
          "number" != typeof r && (r = 8 * s);
          var a = r - this.n.bitLength();
          return (a > 0 && (e = e.ushrn(a)), !t && e.cmp(this.n) >= 0)
            ? e.sub(this.n)
            : e;
        }),
        (u.prototype.sign = function (e, t, r, n) {
          if (
            ("object" == typeof r && ((n = r), (r = null)),
            n || (n = {}),
            "string" != typeof e && "number" != typeof e && !i.isBN(e))
          ) {
            c(
              "object" == typeof e && e && "number" == typeof e.length,
              "Expected message to be an array-like, a hex string, or a BN instance"
            ),
              c(e.length >>> 0 === e.length);
            for (var a = 0; a < e.length; a++) c((255 & e[a]) === e[a]);
          }
          (t = this.keyFromPrivate(t, r)),
            c(
              !(e = this._truncateToN(e, !1, n.msgBitLength)).isNeg(),
              "Can not sign a negative message"
            );
          var o = this.n.byteLength(),
            l = t.getPrivate().toArray("be", o),
            u = e.toArray("be", o);
          c(new i(u).eq(e), "Can not sign message");
          for (
            var h = new s({
                hash: this.hash,
                entropy: l,
                nonce: u,
                pers: n.pers,
                persEnc: n.persEnc || "utf8",
              }),
              f = this.n.sub(new i(1)),
              p = 0;
            ;
            p++
          ) {
            var g = n.k ? n.k(p) : new i(h.generate(this.n.byteLength()));
            if (
              !(0 >= (g = this._truncateToN(g, !0)).cmpn(1) || g.cmp(f) >= 0)
            ) {
              var m = this.g.mul(g);
              if (!m.isInfinity()) {
                var b = m.getX(),
                  y = b.umod(this.n);
                if (0 !== y.cmpn(0)) {
                  var w = g.invm(this.n).mul(y.mul(t.getPrivate()).iadd(e));
                  if (0 !== (w = w.umod(this.n)).cmpn(0)) {
                    var v = +!!m.getY().isOdd() | (2 * (0 !== b.cmp(y)));
                    return (
                      n.canonical &&
                        w.cmp(this.nh) > 0 &&
                        ((w = this.n.sub(w)), (v ^= 1)),
                      new d({ r: y, s: w, recoveryParam: v })
                    );
                  }
                }
              }
            }
          }
        }),
        (u.prototype.verify = function (e, t, r, i, s) {
          s || (s = {}),
            (e = this._truncateToN(e, !1, s.msgBitLength)),
            (r = this.keyFromPublic(r, i));
          var n,
            a = (t = new d(t, "hex")).r,
            o = t.s;
          if (
            0 > a.cmpn(1) ||
            a.cmp(this.n) >= 0 ||
            0 > o.cmpn(1) ||
            o.cmp(this.n) >= 0
          )
            return !1;
          var c = o.invm(this.n),
            l = c.mul(e).umod(this.n),
            u = c.mul(a).umod(this.n);
          return this.curve._maxwellTrick
            ? !(n = this.g.jmulAdd(l, r.getPublic(), u)).isInfinity() &&
                n.eqXToP(a)
            : !(n = this.g.mulAdd(l, r.getPublic(), u)).isInfinity() &&
                0 === n.getX().umod(this.n).cmp(a);
        }),
        (u.prototype.recoverPubKey = function (e, t, r, s) {
          c((3 & r) === r, "The recovery param is more than two bits"),
            (t = new d(t, s));
          var n = this.n,
            a = new i(e),
            o = t.r,
            l = t.s,
            u = 1 & r,
            h = r >> 1;
          if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && h)
            throw Error("Unable to find sencond key candinate");
          o = h
            ? this.curve.pointFromX(o.add(this.curve.n), u)
            : this.curve.pointFromX(o, u);
          var f = t.r.invm(n),
            p = n.sub(a).mul(f).umod(n),
            g = l.mul(f).umod(n);
          return this.g.mulAdd(p, o, g);
        }),
        (u.prototype.getKeyRecoveryParam = function (e, t, r, i) {
          if (null !== (t = new d(t, i)).recoveryParam) return t.recoveryParam;
          for (var s, n = 0; n < 4; n++) {
            try {
              s = this.recoverPubKey(e, t, n);
            } catch (e) {
              continue;
            }
            if (s.eq(r)) return n;
          }
          throw Error("Unable to find valid recovery factor");
        });
    },
    83011: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "useMergedRef", {
          enumerable: !0,
          get: function () {
            return s;
          },
        });
      let i = r(12115);
      function s(e, t) {
        let r = (0, i.useRef)(null),
          s = (0, i.useRef)(null);
        return (0, i.useCallback)(
          (i) => {
            if (null === i) {
              let e = r.current;
              e && ((r.current = null), e());
              let t = s.current;
              t && ((s.current = null), t());
            } else e && (r.current = n(e, i)), t && (s.current = n(t, i));
          },
          [e, t]
        );
      }
      function n(e, t) {
        if ("function" != typeof e)
          return (
            (e.current = t),
            () => {
              e.current = null;
            }
          );
        {
          let r = e(t);
          return "function" == typeof r ? r : () => e(null);
        }
      }
      ("function" == typeof t.default ||
        ("object" == typeof t.default && null !== t.default)) &&
        void 0 === t.default.__esModule &&
        (Object.defineProperty(t.default, "__esModule", { value: !0 }),
        Object.assign(t.default, t),
        (e.exports = t.default));
    },
    83176: (e, t, r) => {
      "use strict";
      var i = r(98392),
        s = r(43770),
        n = r(92963),
        a = r(78239);
      function o(e) {
        n.call(this, "mont", e),
          (this.a = new i(e.a, 16).toRed(this.red)),
          (this.b = new i(e.b, 16).toRed(this.red)),
          (this.i4 = new i(4).toRed(this.red).redInvm()),
          (this.two = new i(2).toRed(this.red)),
          (this.a24 = this.i4.redMul(this.a.redAdd(this.two)));
      }
      function c(e, t, r) {
        n.BasePoint.call(this, e, "projective"),
          null === t && null === r
            ? ((this.x = this.curve.one), (this.z = this.curve.zero))
            : ((this.x = new i(t, 16)),
              (this.z = new i(r, 16)),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.z.red || (this.z = this.z.toRed(this.curve.red)));
      }
      s(o, n),
        (e.exports = o),
        (o.prototype.validate = function (e) {
          var t = e.normalize().x,
            r = t.redSqr(),
            i = r.redMul(t).redAdd(r.redMul(this.a)).redAdd(t);
          return 0 === i.redSqrt().redSqr().cmp(i);
        }),
        s(c, n.BasePoint),
        (o.prototype.decodePoint = function (e, t) {
          return this.point(a.toArray(e, t), 1);
        }),
        (o.prototype.point = function (e, t) {
          return new c(this, e, t);
        }),
        (o.prototype.pointFromJSON = function (e) {
          return c.fromJSON(this, e);
        }),
        (c.prototype.precompute = function () {}),
        (c.prototype._encode = function () {
          return this.getX().toArray("be", this.curve.p.byteLength());
        }),
        (c.fromJSON = function (e, t) {
          return new c(e, t[0], t[1] || e.one);
        }),
        (c.prototype.inspect = function () {
          return this.isInfinity()
            ? "<EC Point Infinity>"
            : "<EC Point x: " +
                this.x.fromRed().toString(16, 2) +
                " z: " +
                this.z.fromRed().toString(16, 2) +
                ">";
        }),
        (c.prototype.isInfinity = function () {
          return 0 === this.z.cmpn(0);
        }),
        (c.prototype.dbl = function () {
          var e = this.x.redAdd(this.z).redSqr(),
            t = this.x.redSub(this.z).redSqr(),
            r = e.redSub(t),
            i = e.redMul(t),
            s = r.redMul(t.redAdd(this.curve.a24.redMul(r)));
          return this.curve.point(i, s);
        }),
        (c.prototype.add = function () {
          throw Error("Not supported on Montgomery curve");
        }),
        (c.prototype.diffAdd = function (e, t) {
          var r = this.x.redAdd(this.z),
            i = this.x.redSub(this.z),
            s = e.x.redAdd(e.z),
            n = e.x.redSub(e.z).redMul(r),
            a = s.redMul(i),
            o = t.z.redMul(n.redAdd(a).redSqr()),
            c = t.x.redMul(n.redISub(a).redSqr());
          return this.curve.point(o, c);
        }),
        (c.prototype.mul = function (e) {
          for (
            var t = e.clone(),
              r = this,
              i = this.curve.point(null, null),
              s = [];
            0 !== t.cmpn(0);
            t.iushrn(1)
          )
            s.push(t.andln(1));
          for (var n = s.length - 1; n >= 0; n--)
            0 === s[n]
              ? ((r = r.diffAdd(i, this)), (i = i.dbl()))
              : ((i = r.diffAdd(i, this)), (r = r.dbl()));
          return i;
        }),
        (c.prototype.mulAdd = function () {
          throw Error("Not supported on Montgomery curve");
        }),
        (c.prototype.jumlAdd = function () {
          throw Error("Not supported on Montgomery curve");
        }),
        (c.prototype.eq = function (e) {
          return 0 === this.getX().cmp(e.getX());
        }),
        (c.prototype.normalize = function () {
          return (
            (this.x = this.x.redMul(this.z.redInvm())),
            (this.z = this.curve.one),
            this
          );
        }),
        (c.prototype.getX = function () {
          return this.normalize(), this.x.fromRed();
        });
    },
    83881: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { v: () => rw });
      var s,
        n,
        a,
        o,
        c = r(45553),
        l = r(73537),
        d = r(17389);
      !(function (e) {
        (e.assertEqual = (e) => e),
          (e.assertIs = function (e) {}),
          (e.assertNever = function (e) {
            throw Error();
          }),
          (e.arrayToEnum = (e) => {
            let t = {};
            for (let r of e) t[r] = r;
            return t;
          }),
          (e.getValidEnumValues = (t) => {
            let r = e.objectKeys(t).filter((e) => "number" != typeof t[t[e]]),
              i = {};
            for (let e of r) i[e] = t[e];
            return e.objectValues(i);
          }),
          (e.objectValues = (t) =>
            e.objectKeys(t).map(function (e) {
              return t[e];
            })),
          (e.objectKeys =
            "function" == typeof Object.keys
              ? (e) => Object.keys(e)
              : (e) => {
                  let t = [];
                  for (let r in e)
                    Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
                  return t;
                }),
          (e.find = (e, t) => {
            for (let r of e) if (t(r)) return r;
          }),
          (e.isInteger =
            "function" == typeof Number.isInteger
              ? (e) => Number.isInteger(e)
              : (e) =>
                  "number" == typeof e && isFinite(e) && Math.floor(e) === e),
          (e.joinValues = function (e, t = " | ") {
            return e.map((e) => ("string" == typeof e ? `'${e}'` : e)).join(t);
          }),
          (e.jsonStringifyReplacer = (e, t) =>
            "bigint" == typeof t ? t.toString() : t);
      })(s || (s = {})),
        ((n || (n = {})).mergeShapes = (e, t) => ({ ...e, ...t }));
      let u = s.arrayToEnum([
          "string",
          "nan",
          "number",
          "integer",
          "float",
          "boolean",
          "date",
          "bigint",
          "symbol",
          "function",
          "undefined",
          "null",
          "array",
          "object",
          "unknown",
          "promise",
          "void",
          "never",
          "map",
          "set",
        ]),
        h = (e) => {
          switch (typeof e) {
            case "undefined":
              return u.undefined;
            case "string":
              return u.string;
            case "number":
              return isNaN(e) ? u.nan : u.number;
            case "boolean":
              return u.boolean;
            case "function":
              return u.function;
            case "bigint":
              return u.bigint;
            case "symbol":
              return u.symbol;
            case "object":
              if (Array.isArray(e)) return u.array;
              if (null === e) return u.null;
              if (
                e.then &&
                "function" == typeof e.then &&
                e.catch &&
                "function" == typeof e.catch
              )
                return u.promise;
              if ("undefined" != typeof Map && e instanceof Map) return u.map;
              if ("undefined" != typeof Set && e instanceof Set) return u.set;
              if ("undefined" != typeof Date && e instanceof Date)
                return u.date;
              return u.object;
            default:
              return u.unknown;
          }
        },
        f = s.arrayToEnum([
          "invalid_type",
          "invalid_literal",
          "custom",
          "invalid_union",
          "invalid_union_discriminator",
          "invalid_enum_value",
          "unrecognized_keys",
          "invalid_arguments",
          "invalid_return_type",
          "invalid_date",
          "invalid_string",
          "too_small",
          "too_big",
          "invalid_intersection_types",
          "not_multiple_of",
          "not_finite",
        ]);
      class p extends Error {
        constructor(e) {
          super(),
            (this.issues = []),
            (this.addIssue = (e) => {
              this.issues = [...this.issues, e];
            }),
            (this.addIssues = (e = []) => {
              this.issues = [...this.issues, ...e];
            });
          let t = new.target.prototype;
          Object.setPrototypeOf
            ? Object.setPrototypeOf(this, t)
            : (this.__proto__ = t),
            (this.name = "ZodError"),
            (this.issues = e);
        }
        get errors() {
          return this.issues;
        }
        format(e) {
          let t =
              e ||
              function (e) {
                return e.message;
              },
            r = { _errors: [] },
            i = (e) => {
              for (let s of e.issues)
                if ("invalid_union" === s.code) s.unionErrors.map(i);
                else if ("invalid_return_type" === s.code) i(s.returnTypeError);
                else if ("invalid_arguments" === s.code) i(s.argumentsError);
                else if (0 === s.path.length) r._errors.push(t(s));
                else {
                  let e = r,
                    i = 0;
                  for (; i < s.path.length; ) {
                    let r = s.path[i];
                    i === s.path.length - 1
                      ? ((e[r] = e[r] || { _errors: [] }),
                        e[r]._errors.push(t(s)))
                      : (e[r] = e[r] || { _errors: [] }),
                      (e = e[r]),
                      i++;
                  }
                }
            };
          return i(this), r;
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, s.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return 0 === this.issues.length;
        }
        flatten(e = (e) => e.message) {
          let t = {},
            r = [];
          for (let i of this.issues)
            i.path.length > 0
              ? ((t[i.path[0]] = t[i.path[0]] || []), t[i.path[0]].push(e(i)))
              : r.push(e(i));
          return { formErrors: r, fieldErrors: t };
        }
        get formErrors() {
          return this.flatten();
        }
      }
      p.create = (e) => new p(e);
      let g = (e, t) => {
          let r;
          switch (e.code) {
            case f.invalid_type:
              r =
                e.received === u.undefined
                  ? "Required"
                  : `Expected ${e.expected}, received ${e.received}`;
              break;
            case f.invalid_literal:
              r = `Invalid literal value, expected ${JSON.stringify(
                e.expected,
                s.jsonStringifyReplacer
              )}`;
              break;
            case f.unrecognized_keys:
              r = `Unrecognized key(s) in object: ${s.joinValues(
                e.keys,
                ", "
              )}`;
              break;
            case f.invalid_union:
              r = "Invalid input";
              break;
            case f.invalid_union_discriminator:
              r = `Invalid discriminator value. Expected ${s.joinValues(
                e.options
              )}`;
              break;
            case f.invalid_enum_value:
              r = `Invalid enum value. Expected ${s.joinValues(
                e.options
              )}, received '${e.received}'`;
              break;
            case f.invalid_arguments:
              r = "Invalid function arguments";
              break;
            case f.invalid_return_type:
              r = "Invalid function return type";
              break;
            case f.invalid_date:
              r = "Invalid date";
              break;
            case f.invalid_string:
              "object" == typeof e.validation
                ? "includes" in e.validation
                  ? ((r = `Invalid input: must include "${e.validation.includes}"`),
                    "number" == typeof e.validation.position &&
                      (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`))
                  : "startsWith" in e.validation
                  ? (r = `Invalid input: must start with "${e.validation.startsWith}"`)
                  : "endsWith" in e.validation
                  ? (r = `Invalid input: must end with "${e.validation.endsWith}"`)
                  : s.assertNever(e.validation)
                : (r =
                    "regex" !== e.validation
                      ? `Invalid ${e.validation}`
                      : "Invalid");
              break;
            case f.too_small:
              r =
                "array" === e.type
                  ? `Array must contain ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "at least"
                        : "more than"
                    } ${e.minimum} element(s)`
                  : "string" === e.type
                  ? `String must contain ${
                      e.exact ? "exactly" : e.inclusive ? "at least" : "over"
                    } ${e.minimum} character(s)`
                  : "number" === e.type
                  ? `Number must be ${
                      e.exact
                        ? "exactly equal to "
                        : e.inclusive
                        ? "greater than or equal to "
                        : "greater than "
                    }${e.minimum}`
                  : "date" === e.type
                  ? `Date must be ${
                      e.exact
                        ? "exactly equal to "
                        : e.inclusive
                        ? "greater than or equal to "
                        : "greater than "
                    }${new Date(Number(e.minimum))}`
                  : "Invalid input";
              break;
            case f.too_big:
              r =
                "array" === e.type
                  ? `Array must contain ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "at most"
                        : "less than"
                    } ${e.maximum} element(s)`
                  : "string" === e.type
                  ? `String must contain ${
                      e.exact ? "exactly" : e.inclusive ? "at most" : "under"
                    } ${e.maximum} character(s)`
                  : "number" === e.type
                  ? `Number must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "less than or equal to"
                        : "less than"
                    } ${e.maximum}`
                  : "bigint" === e.type
                  ? `BigInt must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "less than or equal to"
                        : "less than"
                    } ${e.maximum}`
                  : "date" === e.type
                  ? `Date must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "smaller than or equal to"
                        : "smaller than"
                    } ${new Date(Number(e.maximum))}`
                  : "Invalid input";
              break;
            case f.custom:
              r = "Invalid input";
              break;
            case f.invalid_intersection_types:
              r = "Intersection results could not be merged";
              break;
            case f.not_multiple_of:
              r = `Number must be a multiple of ${e.multipleOf}`;
              break;
            case f.not_finite:
              r = "Number must be finite";
              break;
            default:
              (r = t.defaultError), s.assertNever(e);
          }
          return { message: r };
        },
        m = g;
      function b() {
        return m;
      }
      let y = (e) => {
        let { data: t, path: r, errorMaps: i, issueData: s } = e,
          n = [...r, ...(s.path || [])],
          a = { ...s, path: n },
          o = "";
        for (let e of i
          .filter((e) => !!e)
          .slice()
          .reverse())
          o = e(a, { data: t, defaultError: o }).message;
        return { ...s, path: n, message: s.message || o };
      };
      function w(e, t) {
        let r = y({
          issueData: t,
          data: e.data,
          path: e.path,
          errorMaps: [
            e.common.contextualErrorMap,
            e.schemaErrorMap,
            b(),
            g,
          ].filter((e) => !!e),
        });
        e.common.issues.push(r);
      }
      class v {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          "valid" === this.value && (this.value = "dirty");
        }
        abort() {
          "aborted" !== this.value && (this.value = "aborted");
        }
        static mergeArray(e, t) {
          let r = [];
          for (let i of t) {
            if ("aborted" === i.status) return A;
            "dirty" === i.status && e.dirty(), r.push(i.value);
          }
          return { status: e.value, value: r };
        }
        static async mergeObjectAsync(e, t) {
          let r = [];
          for (let e of t) r.push({ key: await e.key, value: await e.value });
          return v.mergeObjectSync(e, r);
        }
        static mergeObjectSync(e, t) {
          let r = {};
          for (let i of t) {
            let { key: t, value: s } = i;
            if ("aborted" === t.status || "aborted" === s.status) return A;
            "dirty" === t.status && e.dirty(),
              "dirty" === s.status && e.dirty(),
              "__proto__" !== t.value &&
                (void 0 !== s.value || i.alwaysSet) &&
                (r[t.value] = s.value);
          }
          return { status: e.value, value: r };
        }
      }
      let A = Object.freeze({ status: "aborted" }),
        E = (e) => ({ status: "dirty", value: e }),
        _ = (e) => ({ status: "valid", value: e }),
        C = (e) => "aborted" === e.status,
        I = (e) => "dirty" === e.status,
        S = (e) => "valid" === e.status,
        x = (e) => "undefined" != typeof Promise && e instanceof Promise;
      !(function (e) {
        (e.errToObj = (e) => ("string" == typeof e ? { message: e } : e || {})),
          (e.toString = (e) =>
            "string" == typeof e ? e : null == e ? void 0 : e.message);
      })(a || (a = {}));
      class N {
        constructor(e, t, r, i) {
          (this._cachedPath = []),
            (this.parent = e),
            (this.data = t),
            (this._path = r),
            (this._key = i);
        }
        get path() {
          return (
            this._cachedPath.length ||
              (this._key instanceof Array
                ? this._cachedPath.push(...this._path, ...this._key)
                : this._cachedPath.push(...this._path, this._key)),
            this._cachedPath
          );
        }
      }
      let T = (e, t) => {
        if (S(t)) return { success: !0, data: t.value };
        if (!e.common.issues.length)
          throw Error("Validation failed but no issues detected.");
        return {
          success: !1,
          get error() {
            if (this._error) return this._error;
            let t = new p(e.common.issues);
            return (this._error = t), this._error;
          },
        };
      };
      function P(e) {
        if (!e) return {};
        let {
          errorMap: t,
          invalid_type_error: r,
          required_error: i,
          description: s,
        } = e;
        if (t && (r || i))
          throw Error(
            'Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.'
          );
        return t
          ? { errorMap: t, description: s }
          : {
              errorMap: (e, t) =>
                "invalid_type" !== e.code
                  ? { message: t.defaultError }
                  : void 0 === t.data
                  ? { message: null != i ? i : t.defaultError }
                  : { message: null != r ? r : t.defaultError },
              description: s,
            };
      }
      class O {
        constructor(e) {
          (this.spa = this.safeParseAsync),
            (this._def = e),
            (this.parse = this.parse.bind(this)),
            (this.safeParse = this.safeParse.bind(this)),
            (this.parseAsync = this.parseAsync.bind(this)),
            (this.safeParseAsync = this.safeParseAsync.bind(this)),
            (this.spa = this.spa.bind(this)),
            (this.refine = this.refine.bind(this)),
            (this.refinement = this.refinement.bind(this)),
            (this.superRefine = this.superRefine.bind(this)),
            (this.optional = this.optional.bind(this)),
            (this.nullable = this.nullable.bind(this)),
            (this.nullish = this.nullish.bind(this)),
            (this.array = this.array.bind(this)),
            (this.promise = this.promise.bind(this)),
            (this.or = this.or.bind(this)),
            (this.and = this.and.bind(this)),
            (this.transform = this.transform.bind(this)),
            (this.brand = this.brand.bind(this)),
            (this.default = this.default.bind(this)),
            (this.catch = this.catch.bind(this)),
            (this.describe = this.describe.bind(this)),
            (this.pipe = this.pipe.bind(this)),
            (this.readonly = this.readonly.bind(this)),
            (this.isNullable = this.isNullable.bind(this)),
            (this.isOptional = this.isOptional.bind(this));
        }
        get description() {
          return this._def.description;
        }
        _getType(e) {
          return h(e.data);
        }
        _getOrReturnCtx(e, t) {
          return (
            t || {
              common: e.parent.common,
              data: e.data,
              parsedType: h(e.data),
              schemaErrorMap: this._def.errorMap,
              path: e.path,
              parent: e.parent,
            }
          );
        }
        _processInputParams(e) {
          return {
            status: new v(),
            ctx: {
              common: e.parent.common,
              data: e.data,
              parsedType: h(e.data),
              schemaErrorMap: this._def.errorMap,
              path: e.path,
              parent: e.parent,
            },
          };
        }
        _parseSync(e) {
          let t = this._parse(e);
          if (x(t)) throw Error("Synchronous parse encountered promise.");
          return t;
        }
        _parseAsync(e) {
          return Promise.resolve(this._parse(e));
        }
        parse(e, t) {
          let r = this.safeParse(e, t);
          if (r.success) return r.data;
          throw r.error;
        }
        safeParse(e, t) {
          var r;
          let i = {
              common: {
                issues: [],
                async:
                  null !== (r = null == t ? void 0 : t.async) &&
                  void 0 !== r &&
                  r,
                contextualErrorMap: null == t ? void 0 : t.errorMap,
              },
              path: (null == t ? void 0 : t.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data: e,
              parsedType: h(e),
            },
            s = this._parseSync({ data: e, path: i.path, parent: i });
          return T(i, s);
        }
        async parseAsync(e, t) {
          let r = await this.safeParseAsync(e, t);
          if (r.success) return r.data;
          throw r.error;
        }
        async safeParseAsync(e, t) {
          let r = {
              common: {
                issues: [],
                contextualErrorMap: null == t ? void 0 : t.errorMap,
                async: !0,
              },
              path: (null == t ? void 0 : t.path) || [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data: e,
              parsedType: h(e),
            },
            i = this._parse({ data: e, path: r.path, parent: r });
          return T(r, await (x(i) ? i : Promise.resolve(i)));
        }
        refine(e, t) {
          let r = (e) =>
            "string" == typeof t || void 0 === t
              ? { message: t }
              : "function" == typeof t
              ? t(e)
              : t;
          return this._refinement((t, i) => {
            let s = e(t),
              n = () => i.addIssue({ code: f.custom, ...r(t) });
            return "undefined" != typeof Promise && s instanceof Promise
              ? s.then((e) => !!e || (n(), !1))
              : !!s || (n(), !1);
          });
        }
        refinement(e, t) {
          return this._refinement(
            (r, i) =>
              !!e(r) || (i.addIssue("function" == typeof t ? t(r, i) : t), !1)
          );
        }
        _refinement(e) {
          return new eg({
            schema: this,
            typeName: o.ZodEffects,
            effect: { type: "refinement", refinement: e },
          });
        }
        superRefine(e) {
          return this._refinement(e);
        }
        optional() {
          return em.create(this, this._def);
        }
        nullable() {
          return eb.create(this, this._def);
        }
        nullish() {
          return this.nullable().optional();
        }
        array() {
          return J.create(this, this._def);
        }
        promise() {
          return ep.create(this, this._def);
        }
        or(e) {
          return ee.create([this, e], this._def);
        }
        and(e) {
          return ei.create(this, e, this._def);
        }
        transform(e) {
          return new eg({
            ...P(this._def),
            schema: this,
            typeName: o.ZodEffects,
            effect: { type: "transform", transform: e },
          });
        }
        default(e) {
          return new ey({
            ...P(this._def),
            innerType: this,
            defaultValue: "function" == typeof e ? e : () => e,
            typeName: o.ZodDefault,
          });
        }
        brand() {
          return new eE({
            typeName: o.ZodBranded,
            type: this,
            ...P(this._def),
          });
        }
        catch(e) {
          return new ew({
            ...P(this._def),
            innerType: this,
            catchValue: "function" == typeof e ? e : () => e,
            typeName: o.ZodCatch,
          });
        }
        describe(e) {
          return new this.constructor({ ...this._def, description: e });
        }
        pipe(e) {
          return e_.create(this, e);
        }
        readonly() {
          return eC.create(this);
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      }
      let k = /^c[^\s-]{8,}$/i,
        R = /^[a-z][a-z0-9]*$/,
        D = /^[0-9A-HJKMNP-TV-Z]{26}$/,
        M =
          /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
        U =
          /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
        L =
          /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
        B =
          /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
        j = (e) =>
          e.precision
            ? e.offset
              ? RegExp(
                  `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
                )
              : RegExp(
                  `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`
                )
            : 0 === e.precision
            ? e.offset
              ? RegExp(
                  "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$"
                )
              : RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$")
            : e.offset
            ? RegExp(
                "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$"
              )
            : RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
      class F extends O {
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = String(e.data)),
            this._getType(e) !== u.string)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.string,
                received: t.parsedType,
              }),
              A
            );
          }
          let r = new v();
          for (let o of this._def.checks)
            if ("min" === o.kind)
              e.data.length < o.value &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_small,
                  minimum: o.value,
                  type: "string",
                  inclusive: !0,
                  exact: !1,
                  message: o.message,
                }),
                r.dirty());
            else if ("max" === o.kind)
              e.data.length > o.value &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_big,
                  maximum: o.value,
                  type: "string",
                  inclusive: !0,
                  exact: !1,
                  message: o.message,
                }),
                r.dirty());
            else if ("length" === o.kind) {
              let i = e.data.length > o.value,
                s = e.data.length < o.value;
              (i || s) &&
                ((t = this._getOrReturnCtx(e, t)),
                i
                  ? w(t, {
                      code: f.too_big,
                      maximum: o.value,
                      type: "string",
                      inclusive: !0,
                      exact: !0,
                      message: o.message,
                    })
                  : s &&
                    w(t, {
                      code: f.too_small,
                      minimum: o.value,
                      type: "string",
                      inclusive: !0,
                      exact: !0,
                      message: o.message,
                    }),
                r.dirty());
            } else if ("email" === o.kind)
              U.test(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  validation: "email",
                  code: f.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("emoji" === o.kind)
              i ||
                (i = RegExp(
                  "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
                  "u"
                )),
                i.test(e.data) ||
                  (w((t = this._getOrReturnCtx(e, t)), {
                    validation: "emoji",
                    code: f.invalid_string,
                    message: o.message,
                  }),
                  r.dirty());
            else if ("uuid" === o.kind)
              M.test(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  validation: "uuid",
                  code: f.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("cuid" === o.kind)
              k.test(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  validation: "cuid",
                  code: f.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("cuid2" === o.kind)
              R.test(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  validation: "cuid2",
                  code: f.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("ulid" === o.kind)
              D.test(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  validation: "ulid",
                  code: f.invalid_string,
                  message: o.message,
                }),
                r.dirty());
            else if ("url" === o.kind)
              try {
                new URL(e.data);
              } catch (i) {
                w((t = this._getOrReturnCtx(e, t)), {
                  validation: "url",
                  code: f.invalid_string,
                  message: o.message,
                }),
                  r.dirty();
              }
            else if ("regex" === o.kind)
              (o.regex.lastIndex = 0),
                o.regex.test(e.data) ||
                  (w((t = this._getOrReturnCtx(e, t)), {
                    validation: "regex",
                    code: f.invalid_string,
                    message: o.message,
                  }),
                  r.dirty());
            else if ("trim" === o.kind) e.data = e.data.trim();
            else if ("includes" === o.kind)
              e.data.includes(o.value, o.position) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_string,
                  validation: { includes: o.value, position: o.position },
                  message: o.message,
                }),
                r.dirty());
            else if ("toLowerCase" === o.kind) e.data = e.data.toLowerCase();
            else if ("toUpperCase" === o.kind) e.data = e.data.toUpperCase();
            else if ("startsWith" === o.kind)
              e.data.startsWith(o.value) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_string,
                  validation: { startsWith: o.value },
                  message: o.message,
                }),
                r.dirty());
            else if ("endsWith" === o.kind)
              e.data.endsWith(o.value) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_string,
                  validation: { endsWith: o.value },
                  message: o.message,
                }),
                r.dirty());
            else if ("datetime" === o.kind)
              j(o).test(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_string,
                  validation: "datetime",
                  message: o.message,
                }),
                r.dirty());
            else if ("ip" === o.kind) {
              var n, a;
              (n = e.data),
                !(
                  (("v4" === (a = o.version) || !a) && L.test(n)) ||
                  (("v6" === a || !a) && B.test(n))
                ) &&
                  (w((t = this._getOrReturnCtx(e, t)), {
                    validation: "ip",
                    code: f.invalid_string,
                    message: o.message,
                  }),
                  r.dirty());
            } else s.assertNever(o);
          return { status: r.value, value: e.data };
        }
        _regex(e, t, r) {
          return this.refinement((t) => e.test(t), {
            validation: t,
            code: f.invalid_string,
            ...a.errToObj(r),
          });
        }
        _addCheck(e) {
          return new F({ ...this._def, checks: [...this._def.checks, e] });
        }
        email(e) {
          return this._addCheck({ kind: "email", ...a.errToObj(e) });
        }
        url(e) {
          return this._addCheck({ kind: "url", ...a.errToObj(e) });
        }
        emoji(e) {
          return this._addCheck({ kind: "emoji", ...a.errToObj(e) });
        }
        uuid(e) {
          return this._addCheck({ kind: "uuid", ...a.errToObj(e) });
        }
        cuid(e) {
          return this._addCheck({ kind: "cuid", ...a.errToObj(e) });
        }
        cuid2(e) {
          return this._addCheck({ kind: "cuid2", ...a.errToObj(e) });
        }
        ulid(e) {
          return this._addCheck({ kind: "ulid", ...a.errToObj(e) });
        }
        ip(e) {
          return this._addCheck({ kind: "ip", ...a.errToObj(e) });
        }
        datetime(e) {
          var t;
          return "string" == typeof e
            ? this._addCheck({
                kind: "datetime",
                precision: null,
                offset: !1,
                message: e,
              })
            : this._addCheck({
                kind: "datetime",
                precision:
                  void 0 === (null == e ? void 0 : e.precision)
                    ? null
                    : null == e
                    ? void 0
                    : e.precision,
                offset:
                  null !== (t = null == e ? void 0 : e.offset) &&
                  void 0 !== t &&
                  t,
                ...a.errToObj(null == e ? void 0 : e.message),
              });
        }
        regex(e, t) {
          return this._addCheck({ kind: "regex", regex: e, ...a.errToObj(t) });
        }
        includes(e, t) {
          return this._addCheck({
            kind: "includes",
            value: e,
            position: null == t ? void 0 : t.position,
            ...a.errToObj(null == t ? void 0 : t.message),
          });
        }
        startsWith(e, t) {
          return this._addCheck({
            kind: "startsWith",
            value: e,
            ...a.errToObj(t),
          });
        }
        endsWith(e, t) {
          return this._addCheck({
            kind: "endsWith",
            value: e,
            ...a.errToObj(t),
          });
        }
        min(e, t) {
          return this._addCheck({ kind: "min", value: e, ...a.errToObj(t) });
        }
        max(e, t) {
          return this._addCheck({ kind: "max", value: e, ...a.errToObj(t) });
        }
        length(e, t) {
          return this._addCheck({ kind: "length", value: e, ...a.errToObj(t) });
        }
        nonempty(e) {
          return this.min(1, a.errToObj(e));
        }
        trim() {
          return new F({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
          });
        }
        toLowerCase() {
          return new F({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
          });
        }
        toUpperCase() {
          return new F({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
          });
        }
        get isDatetime() {
          return !!this._def.checks.find((e) => "datetime" === e.kind);
        }
        get isEmail() {
          return !!this._def.checks.find((e) => "email" === e.kind);
        }
        get isURL() {
          return !!this._def.checks.find((e) => "url" === e.kind);
        }
        get isEmoji() {
          return !!this._def.checks.find((e) => "emoji" === e.kind);
        }
        get isUUID() {
          return !!this._def.checks.find((e) => "uuid" === e.kind);
        }
        get isCUID() {
          return !!this._def.checks.find((e) => "cuid" === e.kind);
        }
        get isCUID2() {
          return !!this._def.checks.find((e) => "cuid2" === e.kind);
        }
        get isULID() {
          return !!this._def.checks.find((e) => "ulid" === e.kind);
        }
        get isIP() {
          return !!this._def.checks.find((e) => "ip" === e.kind);
        }
        get minLength() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxLength() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
      }
      F.create = (e) => {
        var t;
        return new F({
          checks: [],
          typeName: o.ZodString,
          coerce:
            null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t,
          ...P(e),
        });
      };
      class $ extends O {
        constructor() {
          super(...arguments),
            (this.min = this.gte),
            (this.max = this.lte),
            (this.step = this.multipleOf);
        }
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = Number(e.data)),
            this._getType(e) !== u.number)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.number,
                received: t.parsedType,
              }),
              A
            );
          }
          let r = new v();
          for (let i of this._def.checks)
            "int" === i.kind
              ? s.isInteger(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: i.message,
                }),
                r.dirty())
              : "min" === i.kind
              ? (i.inclusive ? e.data < i.value : e.data <= i.value) &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_small,
                  minimum: i.value,
                  type: "number",
                  inclusive: i.inclusive,
                  exact: !1,
                  message: i.message,
                }),
                r.dirty())
              : "max" === i.kind
              ? (i.inclusive ? e.data > i.value : e.data >= i.value) &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_big,
                  maximum: i.value,
                  type: "number",
                  inclusive: i.inclusive,
                  exact: !1,
                  message: i.message,
                }),
                r.dirty())
              : "multipleOf" === i.kind
              ? 0 !==
                  (function (e, t) {
                    let r = (e.toString().split(".")[1] || "").length,
                      i = (t.toString().split(".")[1] || "").length,
                      s = r > i ? r : i;
                    return (
                      (parseInt(e.toFixed(s).replace(".", "")) %
                        parseInt(t.toFixed(s).replace(".", ""))) /
                      Math.pow(10, s)
                    );
                  })(e.data, i.value) &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.not_multiple_of,
                  multipleOf: i.value,
                  message: i.message,
                }),
                r.dirty())
              : "finite" === i.kind
              ? Number.isFinite(e.data) ||
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.not_finite,
                  message: i.message,
                }),
                r.dirty())
              : s.assertNever(i);
          return { status: r.value, value: e.data };
        }
        gte(e, t) {
          return this.setLimit("min", e, !0, a.toString(t));
        }
        gt(e, t) {
          return this.setLimit("min", e, !1, a.toString(t));
        }
        lte(e, t) {
          return this.setLimit("max", e, !0, a.toString(t));
        }
        lt(e, t) {
          return this.setLimit("max", e, !1, a.toString(t));
        }
        setLimit(e, t, r, i) {
          return new $({
            ...this._def,
            checks: [
              ...this._def.checks,
              { kind: e, value: t, inclusive: r, message: a.toString(i) },
            ],
          });
        }
        _addCheck(e) {
          return new $({ ...this._def, checks: [...this._def.checks, e] });
        }
        int(e) {
          return this._addCheck({ kind: "int", message: a.toString(e) });
        }
        positive(e) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: a.toString(e),
          });
        }
        negative(e) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: a.toString(e),
          });
        }
        nonpositive(e) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: a.toString(e),
          });
        }
        nonnegative(e) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: a.toString(e),
          });
        }
        multipleOf(e, t) {
          return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: a.toString(t),
          });
        }
        finite(e) {
          return this._addCheck({ kind: "finite", message: a.toString(e) });
        }
        safe(e) {
          return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: a.toString(e),
          })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: a.toString(e),
          });
        }
        get minValue() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxValue() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
        get isInt() {
          return !!this._def.checks.find(
            (e) =>
              "int" === e.kind ||
              ("multipleOf" === e.kind && s.isInteger(e.value))
          );
        }
        get isFinite() {
          let e = null,
            t = null;
          for (let r of this._def.checks) {
            if (
              "finite" === r.kind ||
              "int" === r.kind ||
              "multipleOf" === r.kind
            )
              return !0;
            "min" === r.kind
              ? (null === t || r.value > t) && (t = r.value)
              : "max" === r.kind &&
                (null === e || r.value < e) &&
                (e = r.value);
          }
          return Number.isFinite(t) && Number.isFinite(e);
        }
      }
      $.create = (e) =>
        new $({
          checks: [],
          typeName: o.ZodNumber,
          coerce: (null == e ? void 0 : e.coerce) || !1,
          ...P(e),
        });
      class z extends O {
        constructor() {
          super(...arguments), (this.min = this.gte), (this.max = this.lte);
        }
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = BigInt(e.data)),
            this._getType(e) !== u.bigint)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.bigint,
                received: t.parsedType,
              }),
              A
            );
          }
          let r = new v();
          for (let i of this._def.checks)
            "min" === i.kind
              ? (i.inclusive ? e.data < i.value : e.data <= i.value) &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_small,
                  type: "bigint",
                  minimum: i.value,
                  inclusive: i.inclusive,
                  message: i.message,
                }),
                r.dirty())
              : "max" === i.kind
              ? (i.inclusive ? e.data > i.value : e.data >= i.value) &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_big,
                  type: "bigint",
                  maximum: i.value,
                  inclusive: i.inclusive,
                  message: i.message,
                }),
                r.dirty())
              : "multipleOf" === i.kind
              ? e.data % i.value !== BigInt(0) &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.not_multiple_of,
                  multipleOf: i.value,
                  message: i.message,
                }),
                r.dirty())
              : s.assertNever(i);
          return { status: r.value, value: e.data };
        }
        gte(e, t) {
          return this.setLimit("min", e, !0, a.toString(t));
        }
        gt(e, t) {
          return this.setLimit("min", e, !1, a.toString(t));
        }
        lte(e, t) {
          return this.setLimit("max", e, !0, a.toString(t));
        }
        lt(e, t) {
          return this.setLimit("max", e, !1, a.toString(t));
        }
        setLimit(e, t, r, i) {
          return new z({
            ...this._def,
            checks: [
              ...this._def.checks,
              { kind: e, value: t, inclusive: r, message: a.toString(i) },
            ],
          });
        }
        _addCheck(e) {
          return new z({ ...this._def, checks: [...this._def.checks, e] });
        }
        positive(e) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: a.toString(e),
          });
        }
        negative(e) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: a.toString(e),
          });
        }
        nonpositive(e) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: a.toString(e),
          });
        }
        nonnegative(e) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: a.toString(e),
          });
        }
        multipleOf(e, t) {
          return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: a.toString(t),
          });
        }
        get minValue() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxValue() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
      }
      z.create = (e) => {
        var t;
        return new z({
          checks: [],
          typeName: o.ZodBigInt,
          coerce:
            null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t,
          ...P(e),
        });
      };
      class W extends O {
        _parse(e) {
          if (
            (this._def.coerce && (e.data = !!e.data),
            this._getType(e) !== u.boolean)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.boolean,
                received: t.parsedType,
              }),
              A
            );
          }
          return _(e.data);
        }
      }
      W.create = (e) =>
        new W({
          typeName: o.ZodBoolean,
          coerce: (null == e ? void 0 : e.coerce) || !1,
          ...P(e),
        });
      class H extends O {
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = new Date(e.data)),
            this._getType(e) !== u.date)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.date,
                received: t.parsedType,
              }),
              A
            );
          }
          if (isNaN(e.data.getTime()))
            return w(this._getOrReturnCtx(e), { code: f.invalid_date }), A;
          let r = new v();
          for (let i of this._def.checks)
            "min" === i.kind
              ? e.data.getTime() < i.value &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_small,
                  message: i.message,
                  inclusive: !0,
                  exact: !1,
                  minimum: i.value,
                  type: "date",
                }),
                r.dirty())
              : "max" === i.kind
              ? e.data.getTime() > i.value &&
                (w((t = this._getOrReturnCtx(e, t)), {
                  code: f.too_big,
                  message: i.message,
                  inclusive: !0,
                  exact: !1,
                  maximum: i.value,
                  type: "date",
                }),
                r.dirty())
              : s.assertNever(i);
          return { status: r.value, value: new Date(e.data.getTime()) };
        }
        _addCheck(e) {
          return new H({ ...this._def, checks: [...this._def.checks, e] });
        }
        min(e, t) {
          return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: a.toString(t),
          });
        }
        max(e, t) {
          return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: a.toString(t),
          });
        }
        get minDate() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return null != e ? new Date(e) : null;
        }
        get maxDate() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return null != e ? new Date(e) : null;
        }
      }
      H.create = (e) =>
        new H({
          checks: [],
          coerce: (null == e ? void 0 : e.coerce) || !1,
          typeName: o.ZodDate,
          ...P(e),
        });
      class q extends O {
        _parse(e) {
          if (this._getType(e) !== u.symbol) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.symbol,
                received: t.parsedType,
              }),
              A
            );
          }
          return _(e.data);
        }
      }
      q.create = (e) => new q({ typeName: o.ZodSymbol, ...P(e) });
      class V extends O {
        _parse(e) {
          if (this._getType(e) !== u.undefined) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.undefined,
                received: t.parsedType,
              }),
              A
            );
          }
          return _(e.data);
        }
      }
      V.create = (e) => new V({ typeName: o.ZodUndefined, ...P(e) });
      class K extends O {
        _parse(e) {
          if (this._getType(e) !== u.null) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.null,
                received: t.parsedType,
              }),
              A
            );
          }
          return _(e.data);
        }
      }
      K.create = (e) => new K({ typeName: o.ZodNull, ...P(e) });
      class G extends O {
        constructor() {
          super(...arguments), (this._any = !0);
        }
        _parse(e) {
          return _(e.data);
        }
      }
      G.create = (e) => new G({ typeName: o.ZodAny, ...P(e) });
      class Y extends O {
        constructor() {
          super(...arguments), (this._unknown = !0);
        }
        _parse(e) {
          return _(e.data);
        }
      }
      Y.create = (e) => new Y({ typeName: o.ZodUnknown, ...P(e) });
      class Q extends O {
        _parse(e) {
          let t = this._getOrReturnCtx(e);
          return (
            w(t, {
              code: f.invalid_type,
              expected: u.never,
              received: t.parsedType,
            }),
            A
          );
        }
      }
      Q.create = (e) => new Q({ typeName: o.ZodNever, ...P(e) });
      class Z extends O {
        _parse(e) {
          if (this._getType(e) !== u.undefined) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.void,
                received: t.parsedType,
              }),
              A
            );
          }
          return _(e.data);
        }
      }
      Z.create = (e) => new Z({ typeName: o.ZodVoid, ...P(e) });
      class J extends O {
        _parse(e) {
          let { ctx: t, status: r } = this._processInputParams(e),
            i = this._def;
          if (t.parsedType !== u.array)
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.array,
                received: t.parsedType,
              }),
              A
            );
          if (null !== i.exactLength) {
            let e = t.data.length > i.exactLength.value,
              s = t.data.length < i.exactLength.value;
            (e || s) &&
              (w(t, {
                code: e ? f.too_big : f.too_small,
                minimum: s ? i.exactLength.value : void 0,
                maximum: e ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message,
              }),
              r.dirty());
          }
          if (
            (null !== i.minLength &&
              t.data.length < i.minLength.value &&
              (w(t, {
                code: f.too_small,
                minimum: i.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.minLength.message,
              }),
              r.dirty()),
            null !== i.maxLength &&
              t.data.length > i.maxLength.value &&
              (w(t, {
                code: f.too_big,
                maximum: i.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.maxLength.message,
              }),
              r.dirty()),
            t.common.async)
          )
            return Promise.all(
              [...t.data].map((e, r) =>
                i.type._parseAsync(new N(t, e, t.path, r))
              )
            ).then((e) => v.mergeArray(r, e));
          let s = [...t.data].map((e, r) =>
            i.type._parseSync(new N(t, e, t.path, r))
          );
          return v.mergeArray(r, s);
        }
        get element() {
          return this._def.type;
        }
        min(e, t) {
          return new J({
            ...this._def,
            minLength: { value: e, message: a.toString(t) },
          });
        }
        max(e, t) {
          return new J({
            ...this._def,
            maxLength: { value: e, message: a.toString(t) },
          });
        }
        length(e, t) {
          return new J({
            ...this._def,
            exactLength: { value: e, message: a.toString(t) },
          });
        }
        nonempty(e) {
          return this.min(1, e);
        }
      }
      J.create = (e, t) =>
        new J({
          type: e,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: o.ZodArray,
          ...P(t),
        });
      class X extends O {
        constructor() {
          super(...arguments),
            (this._cached = null),
            (this.nonstrict = this.passthrough),
            (this.augment = this.extend);
        }
        _getCached() {
          if (null !== this._cached) return this._cached;
          let e = this._def.shape(),
            t = s.objectKeys(e);
          return (this._cached = { shape: e, keys: t });
        }
        _parse(e) {
          if (this._getType(e) !== u.object) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.object,
                received: t.parsedType,
              }),
              A
            );
          }
          let { status: t, ctx: r } = this._processInputParams(e),
            { shape: i, keys: s } = this._getCached(),
            n = [];
          if (
            !(
              this._def.catchall instanceof Q &&
              "strip" === this._def.unknownKeys
            )
          )
            for (let e in r.data) s.includes(e) || n.push(e);
          let a = [];
          for (let e of s) {
            let t = i[e],
              s = r.data[e];
            a.push({
              key: { status: "valid", value: e },
              value: t._parse(new N(r, s, r.path, e)),
              alwaysSet: e in r.data,
            });
          }
          if (this._def.catchall instanceof Q) {
            let e = this._def.unknownKeys;
            if ("passthrough" === e)
              for (let e of n)
                a.push({
                  key: { status: "valid", value: e },
                  value: { status: "valid", value: r.data[e] },
                });
            else if ("strict" === e)
              n.length > 0 &&
                (w(r, { code: f.unrecognized_keys, keys: n }), t.dirty());
            else if ("strip" === e);
            else
              throw Error(
                "Internal ZodObject error: invalid unknownKeys value."
              );
          } else {
            let e = this._def.catchall;
            for (let t of n) {
              let i = r.data[t];
              a.push({
                key: { status: "valid", value: t },
                value: e._parse(new N(r, i, r.path, t)),
                alwaysSet: t in r.data,
              });
            }
          }
          return r.common.async
            ? Promise.resolve()
                .then(async () => {
                  let e = [];
                  for (let t of a) {
                    let r = await t.key;
                    e.push({
                      key: r,
                      value: await t.value,
                      alwaysSet: t.alwaysSet,
                    });
                  }
                  return e;
                })
                .then((e) => v.mergeObjectSync(t, e))
            : v.mergeObjectSync(t, a);
        }
        get shape() {
          return this._def.shape();
        }
        strict(e) {
          return (
            a.errToObj,
            new X({
              ...this._def,
              unknownKeys: "strict",
              ...(void 0 !== e
                ? {
                    errorMap: (t, r) => {
                      var i, s, n, o;
                      let c =
                        null !==
                          (n =
                            null === (s = (i = this._def).errorMap) ||
                            void 0 === s
                              ? void 0
                              : s.call(i, t, r).message) && void 0 !== n
                          ? n
                          : r.defaultError;
                      return "unrecognized_keys" === t.code
                        ? {
                            message:
                              null !== (o = a.errToObj(e).message) &&
                              void 0 !== o
                                ? o
                                : c,
                          }
                        : { message: c };
                    },
                  }
                : {}),
            })
          );
        }
        strip() {
          return new X({ ...this._def, unknownKeys: "strip" });
        }
        passthrough() {
          return new X({ ...this._def, unknownKeys: "passthrough" });
        }
        extend(e) {
          return new X({
            ...this._def,
            shape: () => ({ ...this._def.shape(), ...e }),
          });
        }
        merge(e) {
          return new X({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
            typeName: o.ZodObject,
          });
        }
        setKey(e, t) {
          return this.augment({ [e]: t });
        }
        catchall(e) {
          return new X({ ...this._def, catchall: e });
        }
        pick(e) {
          let t = {};
          return (
            s.objectKeys(e).forEach((r) => {
              e[r] && this.shape[r] && (t[r] = this.shape[r]);
            }),
            new X({ ...this._def, shape: () => t })
          );
        }
        omit(e) {
          let t = {};
          return (
            s.objectKeys(this.shape).forEach((r) => {
              e[r] || (t[r] = this.shape[r]);
            }),
            new X({ ...this._def, shape: () => t })
          );
        }
        deepPartial() {
          return (function e(t) {
            if (t instanceof X) {
              let r = {};
              for (let i in t.shape) {
                let s = t.shape[i];
                r[i] = em.create(e(s));
              }
              return new X({ ...t._def, shape: () => r });
            }
            if (t instanceof J) return new J({ ...t._def, type: e(t.element) });
            if (t instanceof em) return em.create(e(t.unwrap()));
            if (t instanceof eb) return eb.create(e(t.unwrap()));
            if (t instanceof es) return es.create(t.items.map((t) => e(t)));
            else return t;
          })(this);
        }
        partial(e) {
          let t = {};
          return (
            s.objectKeys(this.shape).forEach((r) => {
              let i = this.shape[r];
              e && !e[r] ? (t[r] = i) : (t[r] = i.optional());
            }),
            new X({ ...this._def, shape: () => t })
          );
        }
        required(e) {
          let t = {};
          return (
            s.objectKeys(this.shape).forEach((r) => {
              if (e && !e[r]) t[r] = this.shape[r];
              else {
                let e = this.shape[r];
                for (; e instanceof em; ) e = e._def.innerType;
                t[r] = e;
              }
            }),
            new X({ ...this._def, shape: () => t })
          );
        }
        keyof() {
          return eu(s.objectKeys(this.shape));
        }
      }
      (X.create = (e, t) =>
        new X({
          shape: () => e,
          unknownKeys: "strip",
          catchall: Q.create(),
          typeName: o.ZodObject,
          ...P(t),
        })),
        (X.strictCreate = (e, t) =>
          new X({
            shape: () => e,
            unknownKeys: "strict",
            catchall: Q.create(),
            typeName: o.ZodObject,
            ...P(t),
          })),
        (X.lazycreate = (e, t) =>
          new X({
            shape: e,
            unknownKeys: "strip",
            catchall: Q.create(),
            typeName: o.ZodObject,
            ...P(t),
          }));
      class ee extends O {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = this._def.options;
          if (t.common.async)
            return Promise.all(
              r.map(async (e) => {
                let r = {
                  ...t,
                  common: { ...t.common, issues: [] },
                  parent: null,
                };
                return {
                  result: await e._parseAsync({
                    data: t.data,
                    path: t.path,
                    parent: r,
                  }),
                  ctx: r,
                };
              })
            ).then(function (e) {
              for (let t of e) if ("valid" === t.result.status) return t.result;
              for (let r of e)
                if ("dirty" === r.result.status)
                  return t.common.issues.push(...r.ctx.common.issues), r.result;
              let r = e.map((e) => new p(e.ctx.common.issues));
              return w(t, { code: f.invalid_union, unionErrors: r }), A;
            });
          {
            let e;
            let i = [];
            for (let s of r) {
              let r = {
                  ...t,
                  common: { ...t.common, issues: [] },
                  parent: null,
                },
                n = s._parseSync({ data: t.data, path: t.path, parent: r });
              if ("valid" === n.status) return n;
              "dirty" !== n.status || e || (e = { result: n, ctx: r }),
                r.common.issues.length && i.push(r.common.issues);
            }
            if (e)
              return t.common.issues.push(...e.ctx.common.issues), e.result;
            let s = i.map((e) => new p(e));
            return w(t, { code: f.invalid_union, unionErrors: s }), A;
          }
        }
        get options() {
          return this._def.options;
        }
      }
      ee.create = (e, t) =>
        new ee({ options: e, typeName: o.ZodUnion, ...P(t) });
      let et = (e) => {
        if (e instanceof el) return et(e.schema);
        if (e instanceof eg) return et(e.innerType());
        if (e instanceof ed) return [e.value];
        if (e instanceof eh) return e.options;
        if (e instanceof ef) return Object.keys(e.enum);
        else if (e instanceof ey) return et(e._def.innerType);
        else if (e instanceof V) return [void 0];
        else if (e instanceof K) return [null];
        else return null;
      };
      class er extends O {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          if (t.parsedType !== u.object)
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.object,
                received: t.parsedType,
              }),
              A
            );
          let r = this.discriminator,
            i = t.data[r],
            s = this.optionsMap.get(i);
          return s
            ? t.common.async
              ? s._parseAsync({ data: t.data, path: t.path, parent: t })
              : s._parseSync({ data: t.data, path: t.path, parent: t })
            : (w(t, {
                code: f.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [r],
              }),
              A);
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get options() {
          return this._def.options;
        }
        get optionsMap() {
          return this._def.optionsMap;
        }
        static create(e, t, r) {
          let i = new Map();
          for (let r of t) {
            let t = et(r.shape[e]);
            if (!t)
              throw Error(
                `A discriminator value for key \`${e}\` could not be extracted from all schema options`
              );
            for (let s of t) {
              if (i.has(s))
                throw Error(
                  `Discriminator property ${String(
                    e
                  )} has duplicate value ${String(s)}`
                );
              i.set(s, r);
            }
          }
          return new er({
            typeName: o.ZodDiscriminatedUnion,
            discriminator: e,
            options: t,
            optionsMap: i,
            ...P(r),
          });
        }
      }
      class ei extends O {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e),
            i = (e, i) => {
              if (C(e) || C(i)) return A;
              let n = (function e(t, r) {
                let i = h(t),
                  n = h(r);
                if (t === r) return { valid: !0, data: t };
                if (i === u.object && n === u.object) {
                  let i = s.objectKeys(r),
                    n = s.objectKeys(t).filter((e) => -1 !== i.indexOf(e)),
                    a = { ...t, ...r };
                  for (let i of n) {
                    let s = e(t[i], r[i]);
                    if (!s.valid) return { valid: !1 };
                    a[i] = s.data;
                  }
                  return { valid: !0, data: a };
                }
                if (i === u.array && n === u.array) {
                  if (t.length !== r.length) return { valid: !1 };
                  let i = [];
                  for (let s = 0; s < t.length; s++) {
                    let n = e(t[s], r[s]);
                    if (!n.valid) return { valid: !1 };
                    i.push(n.data);
                  }
                  return { valid: !0, data: i };
                }
                if (i === u.date && n === u.date && +t == +r)
                  return { valid: !0, data: t };
                return { valid: !1 };
              })(e.value, i.value);
              return n.valid
                ? ((I(e) || I(i)) && t.dirty(),
                  { status: t.value, value: n.data })
                : (w(r, { code: f.invalid_intersection_types }), A);
            };
          return r.common.async
            ? Promise.all([
                this._def.left._parseAsync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                }),
                this._def.right._parseAsync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                }),
              ]).then(([e, t]) => i(e, t))
            : i(
                this._def.left._parseSync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                }),
                this._def.right._parseSync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                })
              );
        }
      }
      ei.create = (e, t, r) =>
        new ei({ left: e, right: t, typeName: o.ZodIntersection, ...P(r) });
      class es extends O {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== u.array)
            return (
              w(r, {
                code: f.invalid_type,
                expected: u.array,
                received: r.parsedType,
              }),
              A
            );
          if (r.data.length < this._def.items.length)
            return (
              w(r, {
                code: f.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array",
              }),
              A
            );
          !this._def.rest &&
            r.data.length > this._def.items.length &&
            (w(r, {
              code: f.too_big,
              maximum: this._def.items.length,
              inclusive: !0,
              exact: !1,
              type: "array",
            }),
            t.dirty());
          let i = [...r.data]
            .map((e, t) => {
              let i = this._def.items[t] || this._def.rest;
              return i ? i._parse(new N(r, e, r.path, t)) : null;
            })
            .filter((e) => !!e);
          return r.common.async
            ? Promise.all(i).then((e) => v.mergeArray(t, e))
            : v.mergeArray(t, i);
        }
        get items() {
          return this._def.items;
        }
        rest(e) {
          return new es({ ...this._def, rest: e });
        }
      }
      es.create = (e, t) => {
        if (!Array.isArray(e))
          throw Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new es({ items: e, typeName: o.ZodTuple, rest: null, ...P(t) });
      };
      class en extends O {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== u.object)
            return (
              w(r, {
                code: f.invalid_type,
                expected: u.object,
                received: r.parsedType,
              }),
              A
            );
          let i = [],
            s = this._def.keyType,
            n = this._def.valueType;
          for (let e in r.data)
            i.push({
              key: s._parse(new N(r, e, r.path, e)),
              value: n._parse(new N(r, r.data[e], r.path, e)),
            });
          return r.common.async
            ? v.mergeObjectAsync(t, i)
            : v.mergeObjectSync(t, i);
        }
        get element() {
          return this._def.valueType;
        }
        static create(e, t, r) {
          return new en(
            t instanceof O
              ? { keyType: e, valueType: t, typeName: o.ZodRecord, ...P(r) }
              : {
                  keyType: F.create(),
                  valueType: e,
                  typeName: o.ZodRecord,
                  ...P(t),
                }
          );
        }
      }
      class ea extends O {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== u.map)
            return (
              w(r, {
                code: f.invalid_type,
                expected: u.map,
                received: r.parsedType,
              }),
              A
            );
          let i = this._def.keyType,
            s = this._def.valueType,
            n = [...r.data.entries()].map(([e, t], n) => ({
              key: i._parse(new N(r, e, r.path, [n, "key"])),
              value: s._parse(new N(r, t, r.path, [n, "value"])),
            }));
          if (r.common.async) {
            let e = new Map();
            return Promise.resolve().then(async () => {
              for (let r of n) {
                let i = await r.key,
                  s = await r.value;
                if ("aborted" === i.status || "aborted" === s.status) return A;
                ("dirty" === i.status || "dirty" === s.status) && t.dirty(),
                  e.set(i.value, s.value);
              }
              return { status: t.value, value: e };
            });
          }
          {
            let e = new Map();
            for (let r of n) {
              let i = r.key,
                s = r.value;
              if ("aborted" === i.status || "aborted" === s.status) return A;
              ("dirty" === i.status || "dirty" === s.status) && t.dirty(),
                e.set(i.value, s.value);
            }
            return { status: t.value, value: e };
          }
        }
      }
      ea.create = (e, t, r) =>
        new ea({ valueType: t, keyType: e, typeName: o.ZodMap, ...P(r) });
      class eo extends O {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== u.set)
            return (
              w(r, {
                code: f.invalid_type,
                expected: u.set,
                received: r.parsedType,
              }),
              A
            );
          let i = this._def;
          null !== i.minSize &&
            r.data.size < i.minSize.value &&
            (w(r, {
              code: f.too_small,
              minimum: i.minSize.value,
              type: "set",
              inclusive: !0,
              exact: !1,
              message: i.minSize.message,
            }),
            t.dirty()),
            null !== i.maxSize &&
              r.data.size > i.maxSize.value &&
              (w(r, {
                code: f.too_big,
                maximum: i.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: i.maxSize.message,
              }),
              t.dirty());
          let s = this._def.valueType;
          function n(e) {
            let r = new Set();
            for (let i of e) {
              if ("aborted" === i.status) return A;
              "dirty" === i.status && t.dirty(), r.add(i.value);
            }
            return { status: t.value, value: r };
          }
          let a = [...r.data.values()].map((e, t) =>
            s._parse(new N(r, e, r.path, t))
          );
          return r.common.async ? Promise.all(a).then((e) => n(e)) : n(a);
        }
        min(e, t) {
          return new eo({
            ...this._def,
            minSize: { value: e, message: a.toString(t) },
          });
        }
        max(e, t) {
          return new eo({
            ...this._def,
            maxSize: { value: e, message: a.toString(t) },
          });
        }
        size(e, t) {
          return this.min(e, t).max(e, t);
        }
        nonempty(e) {
          return this.min(1, e);
        }
      }
      eo.create = (e, t) =>
        new eo({
          valueType: e,
          minSize: null,
          maxSize: null,
          typeName: o.ZodSet,
          ...P(t),
        });
      class ec extends O {
        constructor() {
          super(...arguments), (this.validate = this.implement);
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          if (t.parsedType !== u.function)
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.function,
                received: t.parsedType,
              }),
              A
            );
          function r(e, r) {
            return y({
              data: e,
              path: t.path,
              errorMaps: [
                t.common.contextualErrorMap,
                t.schemaErrorMap,
                b(),
                g,
              ].filter((e) => !!e),
              issueData: { code: f.invalid_arguments, argumentsError: r },
            });
          }
          function i(e, r) {
            return y({
              data: e,
              path: t.path,
              errorMaps: [
                t.common.contextualErrorMap,
                t.schemaErrorMap,
                b(),
                g,
              ].filter((e) => !!e),
              issueData: { code: f.invalid_return_type, returnTypeError: r },
            });
          }
          let s = { errorMap: t.common.contextualErrorMap },
            n = t.data;
          if (this._def.returns instanceof ep) {
            let e = this;
            return _(async function (...t) {
              let a = new p([]),
                o = await e._def.args.parseAsync(t, s).catch((e) => {
                  throw (a.addIssue(r(t, e)), a);
                }),
                c = await Reflect.apply(n, this, o);
              return await e._def.returns._def.type
                .parseAsync(c, s)
                .catch((e) => {
                  throw (a.addIssue(i(c, e)), a);
                });
            });
          }
          {
            let e = this;
            return _(function (...t) {
              let a = e._def.args.safeParse(t, s);
              if (!a.success) throw new p([r(t, a.error)]);
              let o = Reflect.apply(n, this, a.data),
                c = e._def.returns.safeParse(o, s);
              if (!c.success) throw new p([i(o, c.error)]);
              return c.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...e) {
          return new ec({ ...this._def, args: es.create(e).rest(Y.create()) });
        }
        returns(e) {
          return new ec({ ...this._def, returns: e });
        }
        implement(e) {
          return this.parse(e);
        }
        strictImplement(e) {
          return this.parse(e);
        }
        static create(e, t, r) {
          return new ec({
            args: e || es.create([]).rest(Y.create()),
            returns: t || Y.create(),
            typeName: o.ZodFunction,
            ...P(r),
          });
        }
      }
      class el extends O {
        get schema() {
          return this._def.getter();
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          return this._def
            .getter()
            ._parse({ data: t.data, path: t.path, parent: t });
        }
      }
      el.create = (e, t) => new el({ getter: e, typeName: o.ZodLazy, ...P(t) });
      class ed extends O {
        _parse(e) {
          if (e.data !== this._def.value) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                received: t.data,
                code: f.invalid_literal,
                expected: this._def.value,
              }),
              A
            );
          }
          return { status: "valid", value: e.data };
        }
        get value() {
          return this._def.value;
        }
      }
      function eu(e, t) {
        return new eh({ values: e, typeName: o.ZodEnum, ...P(t) });
      }
      ed.create = (e, t) =>
        new ed({ value: e, typeName: o.ZodLiteral, ...P(t) });
      class eh extends O {
        _parse(e) {
          if ("string" != typeof e.data) {
            let t = this._getOrReturnCtx(e),
              r = this._def.values;
            return (
              w(t, {
                expected: s.joinValues(r),
                received: t.parsedType,
                code: f.invalid_type,
              }),
              A
            );
          }
          if (-1 === this._def.values.indexOf(e.data)) {
            let t = this._getOrReturnCtx(e),
              r = this._def.values;
            return (
              w(t, {
                received: t.data,
                code: f.invalid_enum_value,
                options: r,
              }),
              A
            );
          }
          return _(e.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        get Values() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        get Enum() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        extract(e) {
          return eh.create(e);
        }
        exclude(e) {
          return eh.create(this.options.filter((t) => !e.includes(t)));
        }
      }
      eh.create = eu;
      class ef extends O {
        _parse(e) {
          let t = s.getValidEnumValues(this._def.values),
            r = this._getOrReturnCtx(e);
          if (r.parsedType !== u.string && r.parsedType !== u.number) {
            let e = s.objectValues(t);
            return (
              w(r, {
                expected: s.joinValues(e),
                received: r.parsedType,
                code: f.invalid_type,
              }),
              A
            );
          }
          if (-1 === t.indexOf(e.data)) {
            let e = s.objectValues(t);
            return (
              w(r, {
                received: r.data,
                code: f.invalid_enum_value,
                options: e,
              }),
              A
            );
          }
          return _(e.data);
        }
        get enum() {
          return this._def.values;
        }
      }
      ef.create = (e, t) =>
        new ef({ values: e, typeName: o.ZodNativeEnum, ...P(t) });
      class ep extends O {
        unwrap() {
          return this._def.type;
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          return t.parsedType !== u.promise && !1 === t.common.async
            ? (w(t, {
                code: f.invalid_type,
                expected: u.promise,
                received: t.parsedType,
              }),
              A)
            : _(
                (t.parsedType === u.promise
                  ? t.data
                  : Promise.resolve(t.data)
                ).then((e) =>
                  this._def.type.parseAsync(e, {
                    path: t.path,
                    errorMap: t.common.contextualErrorMap,
                  })
                )
              );
        }
      }
      ep.create = (e, t) =>
        new ep({ type: e, typeName: o.ZodPromise, ...P(t) });
      class eg extends O {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === o.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e),
            i = this._def.effect || null,
            n = {
              addIssue: (e) => {
                w(r, e), e.fatal ? t.abort() : t.dirty();
              },
              get path() {
                return r.path;
              },
            };
          if (((n.addIssue = n.addIssue.bind(n)), "preprocess" === i.type)) {
            let e = i.transform(r.data, n);
            return r.common.issues.length
              ? { status: "dirty", value: r.data }
              : r.common.async
              ? Promise.resolve(e).then((e) =>
                  this._def.schema._parseAsync({
                    data: e,
                    path: r.path,
                    parent: r,
                  })
                )
              : this._def.schema._parseSync({
                  data: e,
                  path: r.path,
                  parent: r,
                });
          }
          if ("refinement" === i.type) {
            let e = (e) => {
              let t = i.refinement(e, n);
              if (r.common.async) return Promise.resolve(t);
              if (t instanceof Promise)
                throw Error(
                  "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
                );
              return e;
            };
            if (!1 !== r.common.async)
              return this._def.schema
                ._parseAsync({ data: r.data, path: r.path, parent: r })
                .then((r) =>
                  "aborted" === r.status
                    ? A
                    : ("dirty" === r.status && t.dirty(),
                      e(r.value).then(() => ({
                        status: t.value,
                        value: r.value,
                      })))
                );
            {
              let i = this._def.schema._parseSync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              return "aborted" === i.status
                ? A
                : ("dirty" === i.status && t.dirty(),
                  e(i.value),
                  { status: t.value, value: i.value });
            }
          }
          if ("transform" === i.type) {
            if (!1 !== r.common.async)
              return this._def.schema
                ._parseAsync({ data: r.data, path: r.path, parent: r })
                .then((e) =>
                  S(e)
                    ? Promise.resolve(i.transform(e.value, n)).then((e) => ({
                        status: t.value,
                        value: e,
                      }))
                    : e
                );
            {
              let e = this._def.schema._parseSync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              if (!S(e)) return e;
              let s = i.transform(e.value, n);
              if (s instanceof Promise)
                throw Error(
                  "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
                );
              return { status: t.value, value: s };
            }
          }
          s.assertNever(i);
        }
      }
      (eg.create = (e, t, r) =>
        new eg({ schema: e, typeName: o.ZodEffects, effect: t, ...P(r) })),
        (eg.createWithPreprocess = (e, t, r) =>
          new eg({
            schema: t,
            effect: { type: "preprocess", transform: e },
            typeName: o.ZodEffects,
            ...P(r),
          }));
      class em extends O {
        _parse(e) {
          return this._getType(e) === u.undefined
            ? _(void 0)
            : this._def.innerType._parse(e);
        }
        unwrap() {
          return this._def.innerType;
        }
      }
      em.create = (e, t) =>
        new em({ innerType: e, typeName: o.ZodOptional, ...P(t) });
      class eb extends O {
        _parse(e) {
          return this._getType(e) === u.null
            ? _(null)
            : this._def.innerType._parse(e);
        }
        unwrap() {
          return this._def.innerType;
        }
      }
      eb.create = (e, t) =>
        new eb({ innerType: e, typeName: o.ZodNullable, ...P(t) });
      class ey extends O {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = t.data;
          return (
            t.parsedType === u.undefined && (r = this._def.defaultValue()),
            this._def.innerType._parse({ data: r, path: t.path, parent: t })
          );
        }
        removeDefault() {
          return this._def.innerType;
        }
      }
      ey.create = (e, t) =>
        new ey({
          innerType: e,
          typeName: o.ZodDefault,
          defaultValue:
            "function" == typeof t.default ? t.default : () => t.default,
          ...P(t),
        });
      class ew extends O {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = { ...t, common: { ...t.common, issues: [] } },
            i = this._def.innerType._parse({
              data: r.data,
              path: r.path,
              parent: { ...r },
            });
          return x(i)
            ? i.then((e) => ({
                status: "valid",
                value:
                  "valid" === e.status
                    ? e.value
                    : this._def.catchValue({
                        get error() {
                          return new p(r.common.issues);
                        },
                        input: r.data,
                      }),
              }))
            : {
                status: "valid",
                value:
                  "valid" === i.status
                    ? i.value
                    : this._def.catchValue({
                        get error() {
                          return new p(r.common.issues);
                        },
                        input: r.data,
                      }),
              };
        }
        removeCatch() {
          return this._def.innerType;
        }
      }
      ew.create = (e, t) =>
        new ew({
          innerType: e,
          typeName: o.ZodCatch,
          catchValue: "function" == typeof t.catch ? t.catch : () => t.catch,
          ...P(t),
        });
      class ev extends O {
        _parse(e) {
          if (this._getType(e) !== u.nan) {
            let t = this._getOrReturnCtx(e);
            return (
              w(t, {
                code: f.invalid_type,
                expected: u.nan,
                received: t.parsedType,
              }),
              A
            );
          }
          return { status: "valid", value: e.data };
        }
      }
      ev.create = (e) => new ev({ typeName: o.ZodNaN, ...P(e) });
      let eA = Symbol("zod_brand");
      class eE extends O {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = t.data;
          return this._def.type._parse({ data: r, path: t.path, parent: t });
        }
        unwrap() {
          return this._def.type;
        }
      }
      class e_ extends O {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.common.async)
            return (async () => {
              let e = await this._def.in._parseAsync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              return "aborted" === e.status
                ? A
                : "dirty" === e.status
                ? (t.dirty(), E(e.value))
                : this._def.out._parseAsync({
                    data: e.value,
                    path: r.path,
                    parent: r,
                  });
            })();
          {
            let e = this._def.in._parseSync({
              data: r.data,
              path: r.path,
              parent: r,
            });
            return "aborted" === e.status
              ? A
              : "dirty" === e.status
              ? (t.dirty(), { status: "dirty", value: e.value })
              : this._def.out._parseSync({
                  data: e.value,
                  path: r.path,
                  parent: r,
                });
          }
        }
        static create(e, t) {
          return new e_({ in: e, out: t, typeName: o.ZodPipeline });
        }
      }
      class eC extends O {
        _parse(e) {
          let t = this._def.innerType._parse(e);
          return S(t) && (t.value = Object.freeze(t.value)), t;
        }
      }
      eC.create = (e, t) =>
        new eC({ innerType: e, typeName: o.ZodReadonly, ...P(t) });
      let eI = (e, t = {}, r) =>
          e
            ? G.create().superRefine((i, s) => {
                var n, a;
                if (!e(i)) {
                  let e =
                      "function" == typeof t
                        ? t(i)
                        : "string" == typeof t
                        ? { message: t }
                        : t,
                    o =
                      null ===
                        (a = null !== (n = e.fatal) && void 0 !== n ? n : r) ||
                      void 0 === a ||
                      a,
                    c = "string" == typeof e ? { message: e } : e;
                  s.addIssue({ code: "custom", ...c, fatal: o });
                }
              })
            : G.create(),
        eS = { object: X.lazycreate };
      !(function (e) {
        (e.ZodString = "ZodString"),
          (e.ZodNumber = "ZodNumber"),
          (e.ZodNaN = "ZodNaN"),
          (e.ZodBigInt = "ZodBigInt"),
          (e.ZodBoolean = "ZodBoolean"),
          (e.ZodDate = "ZodDate"),
          (e.ZodSymbol = "ZodSymbol"),
          (e.ZodUndefined = "ZodUndefined"),
          (e.ZodNull = "ZodNull"),
          (e.ZodAny = "ZodAny"),
          (e.ZodUnknown = "ZodUnknown"),
          (e.ZodNever = "ZodNever"),
          (e.ZodVoid = "ZodVoid"),
          (e.ZodArray = "ZodArray"),
          (e.ZodObject = "ZodObject"),
          (e.ZodUnion = "ZodUnion"),
          (e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
          (e.ZodIntersection = "ZodIntersection"),
          (e.ZodTuple = "ZodTuple"),
          (e.ZodRecord = "ZodRecord"),
          (e.ZodMap = "ZodMap"),
          (e.ZodSet = "ZodSet"),
          (e.ZodFunction = "ZodFunction"),
          (e.ZodLazy = "ZodLazy"),
          (e.ZodLiteral = "ZodLiteral"),
          (e.ZodEnum = "ZodEnum"),
          (e.ZodEffects = "ZodEffects"),
          (e.ZodNativeEnum = "ZodNativeEnum"),
          (e.ZodOptional = "ZodOptional"),
          (e.ZodNullable = "ZodNullable"),
          (e.ZodDefault = "ZodDefault"),
          (e.ZodCatch = "ZodCatch"),
          (e.ZodPromise = "ZodPromise"),
          (e.ZodBranded = "ZodBranded"),
          (e.ZodPipeline = "ZodPipeline"),
          (e.ZodReadonly = "ZodReadonly");
      })(o || (o = {}));
      let ex = F.create,
        eN = $.create,
        eT = ev.create,
        eP = z.create,
        eO = W.create,
        ek = H.create,
        eR = q.create,
        eD = V.create,
        eM = K.create,
        eU = G.create,
        eL = Y.create,
        eB = Q.create,
        ej = Z.create,
        eF = J.create,
        e$ = X.create,
        ez = X.strictCreate,
        eW = ee.create,
        eH = er.create,
        eq = ei.create,
        eV = es.create,
        eK = en.create,
        eG = ea.create,
        eY = eo.create,
        eQ = ec.create,
        eZ = el.create,
        eJ = ed.create,
        eX = eh.create,
        e0 = ef.create,
        e1 = ep.create,
        e2 = eg.create,
        e3 = em.create,
        e5 = eb.create,
        e8 = eg.createWithPreprocess,
        e6 = e_.create;
      var e4 = Object.freeze({
        __proto__: null,
        defaultErrorMap: g,
        setErrorMap: function (e) {
          m = e;
        },
        getErrorMap: b,
        makeIssue: y,
        EMPTY_PATH: [],
        addIssueToContext: w,
        ParseStatus: v,
        INVALID: A,
        DIRTY: E,
        OK: _,
        isAborted: C,
        isDirty: I,
        isValid: S,
        isAsync: x,
        get util() {
          return s;
        },
        get objectUtil() {
          return n;
        },
        ZodParsedType: u,
        getParsedType: h,
        ZodType: O,
        ZodString: F,
        ZodNumber: $,
        ZodBigInt: z,
        ZodBoolean: W,
        ZodDate: H,
        ZodSymbol: q,
        ZodUndefined: V,
        ZodNull: K,
        ZodAny: G,
        ZodUnknown: Y,
        ZodNever: Q,
        ZodVoid: Z,
        ZodArray: J,
        ZodObject: X,
        ZodUnion: ee,
        ZodDiscriminatedUnion: er,
        ZodIntersection: ei,
        ZodTuple: es,
        ZodRecord: en,
        ZodMap: ea,
        ZodSet: eo,
        ZodFunction: ec,
        ZodLazy: el,
        ZodLiteral: ed,
        ZodEnum: eh,
        ZodNativeEnum: ef,
        ZodPromise: ep,
        ZodEffects: eg,
        ZodTransformer: eg,
        ZodOptional: em,
        ZodNullable: eb,
        ZodDefault: ey,
        ZodCatch: ew,
        ZodNaN: ev,
        BRAND: eA,
        ZodBranded: eE,
        ZodPipeline: e_,
        ZodReadonly: eC,
        custom: eI,
        Schema: O,
        ZodSchema: O,
        late: eS,
        get ZodFirstPartyTypeKind() {
          return o;
        },
        coerce: {
          string: (e) => F.create({ ...e, coerce: !0 }),
          number: (e) => $.create({ ...e, coerce: !0 }),
          boolean: (e) => W.create({ ...e, coerce: !0 }),
          bigint: (e) => z.create({ ...e, coerce: !0 }),
          date: (e) => H.create({ ...e, coerce: !0 }),
        },
        any: eU,
        array: eF,
        bigint: eP,
        boolean: eO,
        date: ek,
        discriminatedUnion: eH,
        effect: e2,
        enum: eX,
        function: eQ,
        instanceof: (e, t = { message: `Input not instance of ${e.name}` }) =>
          eI((t) => t instanceof e, t),
        intersection: eq,
        lazy: eZ,
        literal: eJ,
        map: eG,
        nan: eT,
        nativeEnum: e0,
        never: eB,
        null: eM,
        nullable: e5,
        number: eN,
        object: e$,
        oboolean: () => eO().optional(),
        onumber: () => eN().optional(),
        optional: e3,
        ostring: () => ex().optional(),
        pipeline: e6,
        preprocess: e8,
        promise: e1,
        record: eK,
        set: eY,
        strictObject: ez,
        string: ex,
        symbol: eR,
        transformer: e2,
        tuple: eV,
        undefined: eD,
        union: eW,
        unknown: eL,
        void: ej,
        NEVER: A,
        ZodIssueCode: f,
        quotelessJson: (e) =>
          JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"),
        ZodError: p,
      });
      let e9 = e4.object({ message: e4.string() });
      function e7(e) {
        return e4.literal(l.s1[e]);
      }
      e4.object({
        accessList: e4.array(e4.string()),
        blockHash: e4.string().nullable(),
        blockNumber: e4.string().nullable(),
        chainId: e4.string().or(e4.number()),
        from: e4.string(),
        gas: e4.string(),
        hash: e4.string(),
        input: e4.string().nullable(),
        maxFeePerGas: e4.string(),
        maxPriorityFeePerGas: e4.string(),
        nonce: e4.string(),
        r: e4.string(),
        s: e4.string(),
        to: e4.string(),
        transactionIndex: e4.string().nullable(),
        type: e4.string(),
        v: e4.string(),
        value: e4.string(),
      });
      let te = e4.object({ chainId: e4.string().or(e4.number()) }),
        tt = e4.object({ email: e4.string().email() }),
        tr = e4.object({ otp: e4.string() }),
        ti = e4.object({ uri: e4.string() }),
        ts = e4.object({
          chainId: e4.optional(e4.string().or(e4.number())),
          preferredAccountType: e4.optional(e4.string()),
        }),
        tn = e4.object({
          provider: e4.enum([
            "google",
            "github",
            "apple",
            "facebook",
            "x",
            "discord",
          ]),
        }),
        ta = e4.object({ email: e4.string().email() }),
        to = e4.object({ otp: e4.string() }),
        tc = e4.object({ otp: e4.string() }),
        tl = e4.object({
          themeMode: e4.optional(e4.enum(["light", "dark"])),
          themeVariables: e4.optional(
            e4.record(e4.string(), e4.string().or(e4.number()))
          ),
          w3mThemeVariables: e4.optional(e4.record(e4.string(), e4.string())),
        }),
        td = e4.object({
          metadata: e4
            .object({
              name: e4.string(),
              description: e4.string(),
              url: e4.string(),
              icons: e4.array(e4.string()),
            })
            .optional(),
          sdkVersion: e4.string().optional(),
          sdkType: e4.string().optional(),
          projectId: e4.string(),
        }),
        tu = e4.object({ type: e4.string() }),
        th = e4.object({
          action: e4.enum(["VERIFY_DEVICE", "VERIFY_OTP", "CONNECT"]),
        }),
        tf = e4.object({ url: e4.string() }),
        tp = e4.object({ userName: e4.string() }),
        tg = e4.object({
          email: e4.string().optional().nullable(),
          address: e4.string(),
          chainId: e4.string().or(e4.number()),
          accounts: e4
            .array(
              e4.object({
                address: e4.string(),
                type: e4.enum([
                  l.Vl.ACCOUNT_TYPES.EOA,
                  l.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                ]),
              })
            )
            .optional(),
          userName: e4.string().optional().nullable(),
        }),
        tm = e4.object({
          action: e4.enum(["VERIFY_PRIMARY_OTP", "VERIFY_SECONDARY_OTP"]),
        }),
        tb = e4.object({
          email: e4.string().email().optional().nullable(),
          address: e4.string(),
          chainId: e4.string().or(e4.number()),
          smartAccountDeployed: e4.optional(e4.boolean()),
          accounts: e4
            .array(
              e4.object({
                address: e4.string(),
                type: e4.enum([
                  l.Vl.ACCOUNT_TYPES.EOA,
                  l.Vl.ACCOUNT_TYPES.SMART_ACCOUNT,
                ]),
              })
            )
            .optional(),
          preferredAccountType: e4.optional(e4.string()),
        }),
        ty = e4.object({ uri: e4.string() }),
        tw = e4.object({ isConnected: e4.boolean() }),
        tv = e4.object({ chainId: e4.string().or(e4.number()) }),
        tA = e4.object({ chainId: e4.string().or(e4.number()) }),
        tE = e4.object({ newEmail: e4.string().email() }),
        t_ = e4.object({ smartAccountEnabledNetworks: e4.array(e4.number()) });
      e4.object({ address: e4.string(), isDeployed: e4.boolean() });
      let tC = e4.object({ version: e4.string().optional() }),
        tI = e4.object({ type: e4.string(), address: e4.string() }),
        tS = e4.any(),
        tx = e4.object({ method: e4.literal("eth_accounts") }),
        tN = e4.object({ method: e4.literal("eth_blockNumber") }),
        tT = e4.object({
          method: e4.literal("eth_call"),
          params: e4.array(e4.any()),
        }),
        tP = e4.object({ method: e4.literal("eth_chainId") }),
        tO = e4.object({
          method: e4.literal("eth_estimateGas"),
          params: e4.array(e4.any()),
        }),
        tk = e4.object({
          method: e4.literal("eth_feeHistory"),
          params: e4.array(e4.any()),
        }),
        tR = e4.object({ method: e4.literal("eth_gasPrice") }),
        tD = e4.object({
          method: e4.literal("eth_getAccount"),
          params: e4.array(e4.any()),
        }),
        tM = e4.object({
          method: e4.literal("eth_getBalance"),
          params: e4.array(e4.any()),
        }),
        tU = e4.object({
          method: e4.literal("eth_getBlockByHash"),
          params: e4.array(e4.any()),
        }),
        tL = e4.object({
          method: e4.literal("eth_getBlockByNumber"),
          params: e4.array(e4.any()),
        }),
        tB = e4.object({
          method: e4.literal("eth_getBlockReceipts"),
          params: e4.array(e4.any()),
        }),
        tj = e4.object({
          method: e4.literal("eth_getBlockTransactionCountByHash"),
          params: e4.array(e4.any()),
        }),
        tF = e4.object({
          method: e4.literal("eth_getBlockTransactionCountByNumber"),
          params: e4.array(e4.any()),
        }),
        t$ = e4.object({
          method: e4.literal("eth_getCode"),
          params: e4.array(e4.any()),
        }),
        tz = e4.object({
          method: e4.literal("eth_getFilterChanges"),
          params: e4.array(e4.any()),
        }),
        tW = e4.object({
          method: e4.literal("eth_getFilterLogs"),
          params: e4.array(e4.any()),
        }),
        tH = e4.object({
          method: e4.literal("eth_getLogs"),
          params: e4.array(e4.any()),
        }),
        tq = e4.object({
          method: e4.literal("eth_getProof"),
          params: e4.array(e4.any()),
        }),
        tV = e4.object({
          method: e4.literal("eth_getStorageAt"),
          params: e4.array(e4.any()),
        }),
        tK = e4.object({
          method: e4.literal("eth_getTransactionByBlockHashAndIndex"),
          params: e4.array(e4.any()),
        }),
        tG = e4.object({
          method: e4.literal("eth_getTransactionByBlockNumberAndIndex"),
          params: e4.array(e4.any()),
        }),
        tY = e4.object({
          method: e4.literal("eth_getTransactionByHash"),
          params: e4.array(e4.any()),
        }),
        tQ = e4.object({
          method: e4.literal("eth_getTransactionCount"),
          params: e4.array(e4.any()),
        }),
        tZ = e4.object({
          method: e4.literal("eth_getTransactionReceipt"),
          params: e4.array(e4.any()),
        }),
        tJ = e4.object({
          method: e4.literal("eth_getUncleCountByBlockHash"),
          params: e4.array(e4.any()),
        }),
        tX = e4.object({
          method: e4.literal("eth_getUncleCountByBlockNumber"),
          params: e4.array(e4.any()),
        }),
        t0 = e4.object({ method: e4.literal("eth_maxPriorityFeePerGas") }),
        t1 = e4.object({ method: e4.literal("eth_newBlockFilter") }),
        t2 = e4.object({
          method: e4.literal("eth_newFilter"),
          params: e4.array(e4.any()),
        }),
        t3 = e4.object({
          method: e4.literal("eth_newPendingTransactionFilter"),
        }),
        t5 = e4.object({
          method: e4.literal("eth_sendRawTransaction"),
          params: e4.array(e4.any()),
        }),
        t8 = e4.object({
          method: e4.literal("eth_syncing"),
          params: e4.array(e4.any()),
        }),
        t6 = e4.object({
          method: e4.literal("eth_uninstallFilter"),
          params: e4.array(e4.any()),
        }),
        t4 = e4.object({
          method: e4.literal("personal_sign"),
          params: e4.array(e4.any()),
        }),
        t9 = e4.object({
          method: e4.literal("eth_signTypedData_v4"),
          params: e4.array(e4.any()),
        }),
        t7 = e4.object({
          method: e4.literal("eth_sendTransaction"),
          params: e4.array(e4.any()),
        }),
        re = e4.object({
          method: e4.literal("solana_signMessage"),
          params: e4.object({ message: e4.string(), pubkey: e4.string() }),
        }),
        rt = e4.object({
          method: e4.literal("solana_signTransaction"),
          params: e4.object({ transaction: e4.string() }),
        }),
        rr = e4.object({
          method: e4.literal("solana_signAllTransactions"),
          params: e4.object({ transactions: e4.array(e4.string()) }),
        }),
        ri = e4.object({
          method: e4.literal("solana_signAndSendTransaction"),
          params: e4.object({
            transaction: e4.string(),
            options: e4
              .object({
                skipPreflight: e4.boolean().optional(),
                preflightCommitment: e4
                  .enum([
                    "processed",
                    "confirmed",
                    "finalized",
                    "recent",
                    "single",
                    "singleGossip",
                    "root",
                    "max",
                  ])
                  .optional(),
                maxRetries: e4.number().optional(),
                minContextSlot: e4.number().optional(),
              })
              .optional(),
          }),
        }),
        rs = e4.object({
          method: e4.literal("wallet_sendCalls"),
          params: e4.array(
            e4.object({
              chainId: e4.string().or(e4.number()).optional(),
              from: e4.string().optional(),
              version: e4.string().optional(),
              capabilities: e4.any().optional(),
              calls: e4.array(
                e4.object({
                  to: e4.string().startsWith("0x"),
                  data: e4.string().startsWith("0x").optional(),
                  value: e4.string().optional(),
                })
              ),
            })
          ),
        }),
        rn = e4.object({
          method: e4.literal("wallet_getCallsStatus"),
          params: e4.array(e4.string()),
        }),
        ra = e4.object({ method: e4.literal("wallet_getCapabilities") }),
        ro = e4.object({
          method: e4.literal("wallet_grantPermissions"),
          params: e4.array(e4.any()),
        }),
        rc = e4.object({
          method: e4.literal("wallet_revokePermissions"),
          params: e4.any(),
        }),
        rl = e4.object({
          method: e4.literal("wallet_getAssets"),
          params: e4.any(),
        }),
        rd = e4.object({ token: e4.string() }),
        ru = e4.object({ id: e4.string().optional() }),
        rh = {
          appEvent: ru
            .extend({ type: e7("APP_SWITCH_NETWORK"), payload: te })
            .or(ru.extend({ type: e7("APP_CONNECT_EMAIL"), payload: tt }))
            .or(ru.extend({ type: e7("APP_CONNECT_DEVICE") }))
            .or(ru.extend({ type: e7("APP_CONNECT_OTP"), payload: tr }))
            .or(ru.extend({ type: e7("APP_CONNECT_SOCIAL"), payload: ti }))
            .or(ru.extend({ type: e7("APP_GET_FARCASTER_URI") }))
            .or(ru.extend({ type: e7("APP_CONNECT_FARCASTER") }))
            .or(
              ru.extend({ type: e7("APP_GET_USER"), payload: e4.optional(ts) })
            )
            .or(
              ru.extend({
                type: e7("APP_GET_SOCIAL_REDIRECT_URI"),
                payload: tn,
              })
            )
            .or(ru.extend({ type: e7("APP_SIGN_OUT") }))
            .or(
              ru.extend({
                type: e7("APP_IS_CONNECTED"),
                payload: e4.optional(rd),
              })
            )
            .or(ru.extend({ type: e7("APP_GET_CHAIN_ID") }))
            .or(
              ru.extend({ type: e7("APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS") })
            )
            .or(ru.extend({ type: e7("APP_INIT_SMART_ACCOUNT") }))
            .or(
              ru.extend({ type: e7("APP_SET_PREFERRED_ACCOUNT"), payload: tu })
            )
            .or(
              ru.extend({
                type: e7("APP_RPC_REQUEST"),
                payload: t4
                  .or(rl)
                  .or(tx)
                  .or(tN)
                  .or(tT)
                  .or(tP)
                  .or(tO)
                  .or(tk)
                  .or(tR)
                  .or(tD)
                  .or(tM)
                  .or(tU)
                  .or(tL)
                  .or(tB)
                  .or(tj)
                  .or(tF)
                  .or(t$)
                  .or(tz)
                  .or(tW)
                  .or(tH)
                  .or(tq)
                  .or(tV)
                  .or(tK)
                  .or(tG)
                  .or(tY)
                  .or(tQ)
                  .or(tZ)
                  .or(tJ)
                  .or(tX)
                  .or(t0)
                  .or(t1)
                  .or(t2)
                  .or(t3)
                  .or(t5)
                  .or(t8)
                  .or(t6)
                  .or(t4)
                  .or(t9)
                  .or(t7)
                  .or(re)
                  .or(rt)
                  .or(rr)
                  .or(ri)
                  .or(rn)
                  .or(rs)
                  .or(ra)
                  .or(ro)
                  .or(rc),
              })
            )
            .or(ru.extend({ type: e7("APP_UPDATE_EMAIL"), payload: ta }))
            .or(
              ru.extend({
                type: e7("APP_UPDATE_EMAIL_PRIMARY_OTP"),
                payload: to,
              })
            )
            .or(
              ru.extend({
                type: e7("APP_UPDATE_EMAIL_SECONDARY_OTP"),
                payload: tc,
              })
            )
            .or(ru.extend({ type: e7("APP_SYNC_THEME"), payload: tl }))
            .or(ru.extend({ type: e7("APP_SYNC_DAPP_DATA"), payload: td }))
            .or(ru.extend({ type: e7("APP_RELOAD") })),
          frameEvent: ru
            .extend({ type: e7("FRAME_SWITCH_NETWORK_ERROR"), payload: e9 })
            .or(
              ru.extend({
                type: e7("FRAME_SWITCH_NETWORK_SUCCESS"),
                payload: tA,
              })
            )
            .or(
              ru.extend({
                type: e7("FRAME_CONNECT_EMAIL_SUCCESS"),
                payload: th,
              })
            )
            .or(
              ru.extend({ type: e7("FRAME_CONNECT_EMAIL_ERROR"), payload: e9 })
            )
            .or(
              ru.extend({
                type: e7("FRAME_GET_FARCASTER_URI_SUCCESS"),
                payload: tf,
              })
            )
            .or(
              ru.extend({
                type: e7("FRAME_GET_FARCASTER_URI_ERROR"),
                payload: e9,
              })
            )
            .or(
              ru.extend({
                type: e7("FRAME_CONNECT_FARCASTER_SUCCESS"),
                payload: tp,
              })
            )
            .or(
              ru.extend({
                type: e7("FRAME_CONNECT_FARCASTER_ERROR"),
                payload: e9,
              })
            )
            .or(ru.extend({ type: e7("FRAME_CONNECT_OTP_ERROR"), payload: e9 }))
            .or(ru.extend({ type: e7("FRAME_CONNECT_OTP_SUCCESS") }))
            .or(
              ru.extend({ type: e7("FRAME_CONNECT_DEVICE_ERROR"), payload: e9 })
            )
            .or(ru.extend({ type: e7("FRAME_CONNECT_DEVICE_SUCCESS") }))
            .or(
              ru.extend({
                type: e7("FRAME_CONNECT_SOCIAL_SUCCESS"),
                payload: tg,
              })
            )
            .or(
              ru.extend({ type: e7("FRAME_CONNECT_SOCIAL_ERROR"), payload: e9 })
            )
            .or(ru.extend({ type: e7("FRAME_GET_USER_ERROR"), payload: e9 }))
            .or(ru.extend({ type: e7("FRAME_GET_USER_SUCCESS"), payload: tb }))
            .or(
              ru.extend({
                type: e7("FRAME_GET_SOCIAL_REDIRECT_URI_ERROR"),
                payload: e9,
              })
            )
            .or(
              ru.extend({
                type: e7("FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS"),
                payload: ty,
              })
            )
            .or(ru.extend({ type: e7("FRAME_SIGN_OUT_ERROR"), payload: e9 }))
            .or(ru.extend({ type: e7("FRAME_SIGN_OUT_SUCCESS") }))
            .or(
              ru.extend({ type: e7("FRAME_IS_CONNECTED_ERROR"), payload: e9 })
            )
            .or(
              ru.extend({ type: e7("FRAME_IS_CONNECTED_SUCCESS"), payload: tw })
            )
            .or(
              ru.extend({ type: e7("FRAME_GET_CHAIN_ID_ERROR"), payload: e9 })
            )
            .or(
              ru.extend({ type: e7("FRAME_GET_CHAIN_ID_SUCCESS"), payload: tv })
            )
            .or(ru.extend({ type: e7("FRAME_RPC_REQUEST_ERROR"), payload: e9 }))
            .or(
              ru.extend({ type: e7("FRAME_RPC_REQUEST_SUCCESS"), payload: tS })
            )
            .or(ru.extend({ type: e7("FRAME_SESSION_UPDATE"), payload: rd }))
            .or(
              ru.extend({ type: e7("FRAME_UPDATE_EMAIL_ERROR"), payload: e9 })
            )
            .or(
              ru.extend({ type: e7("FRAME_UPDATE_EMAIL_SUCCESS"), payload: tm })
            )
            .or(
              ru.extend({
                type: e7("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"),
                payload: e9,
              })
            )
            .or(
              ru.extend({ type: e7("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS") })
            )
            .or(
              ru.extend({
                type: e7("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"),
                payload: e9,
              })
            )
            .or(
              ru.extend({
                type: e7("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
                payload: tE,
              })
            )
            .or(ru.extend({ type: e7("FRAME_SYNC_THEME_ERROR"), payload: e9 }))
            .or(ru.extend({ type: e7("FRAME_SYNC_THEME_SUCCESS") }))
            .or(
              ru.extend({ type: e7("FRAME_SYNC_DAPP_DATA_ERROR"), payload: e9 })
            )
            .or(ru.extend({ type: e7("FRAME_SYNC_DAPP_DATA_SUCCESS") }))
            .or(
              ru.extend({
                type: e7("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS"),
                payload: t_,
              })
            )
            .or(
              ru.extend({
                type: e7("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR"),
                payload: e9,
              })
            )
            .or(
              ru.extend({
                type: e7("FRAME_INIT_SMART_ACCOUNT_ERROR"),
                payload: e9,
              })
            )
            .or(
              ru.extend({
                type: e7("FRAME_SET_PREFERRED_ACCOUNT_SUCCESS"),
                payload: tI,
              })
            )
            .or(
              ru.extend({
                type: e7("FRAME_SET_PREFERRED_ACCOUNT_ERROR"),
                payload: e9,
              })
            )
            .or(ru.extend({ type: e7("FRAME_READY"), payload: tC }))
            .or(ru.extend({ type: e7("FRAME_RELOAD_ERROR"), payload: e9 }))
            .or(ru.extend({ type: e7("FRAME_RELOAD_SUCCESS") })),
        };
      function rf(e, t = {}) {
        return "string" == typeof t?.type && t?.type?.includes(e);
      }
      class rp {
        constructor({
          projectId: e,
          isAppClient: t = !1,
          chainId: r = "eip155:1",
          enableLogger: i = !0,
        }) {
          if (
            ((this.iframe = null),
            (this.rpcUrl = c.o.BLOCKCHAIN_API_RPC_URL),
            (this.initFrame = () => {
              let e = document.getElementById("w3m-iframe");
              this.iframe && !e && document.body.appendChild(this.iframe);
            }),
            (this.events = {
              registerFrameEventHandler: (e, t, r) => {
                function i({ data: r }) {
                  if (!rf(l.s1.FRAME_EVENT_KEY, r)) return;
                  let s = rh.frameEvent.parse(r);
                  s.id === e &&
                    (t(s), window.removeEventListener("message", i));
                }
                d.Q.isClient &&
                  (window.addEventListener("message", i),
                  r.addEventListener("abort", () => {
                    window.removeEventListener("message", i);
                  }));
              },
              onFrameEvent: (e) => {
                d.Q.isClient &&
                  window.addEventListener("message", ({ data: t }) => {
                    rf(l.s1.FRAME_EVENT_KEY, t) && e(rh.frameEvent.parse(t));
                  });
              },
              onAppEvent: (e) => {
                d.Q.isClient &&
                  window.addEventListener("message", ({ data: t }) => {
                    rf(l.s1.APP_EVENT_KEY, t) && e(rh.appEvent.parse(t));
                  });
              },
              postAppEvent: (e) => {
                if (d.Q.isClient) {
                  if (!this.iframe?.contentWindow)
                    throw Error("W3mFrame: iframe is not set");
                  rh.appEvent.parse(e),
                    this.iframe.contentWindow.postMessage(e, "*");
                }
              },
              postFrameEvent: (e) => {
                if (d.Q.isClient) {
                  if (!parent) throw Error("W3mFrame: parent is not set");
                  rh.frameEvent.parse(e), parent.postMessage(e, "*");
                }
              },
            }),
            (this.projectId = e),
            (this.frameLoadPromise = new Promise((e, t) => {
              this.frameLoadPromiseResolver = { resolve: e, reject: t };
            })),
            t &&
              ((this.frameLoadPromise = new Promise((e, t) => {
                this.frameLoadPromiseResolver = { resolve: e, reject: t };
              })),
              d.Q.isClient))
          ) {
            let t = document.createElement("iframe");
            (t.id = "w3m-iframe"),
              (t.src = `${l.hy}?projectId=${e}&chainId=${r}&version=${l.gS}&enableLogger=${i}`),
              (t.name = "w3m-secure-iframe"),
              (t.style.position = "fixed"),
              (t.style.zIndex = "999999"),
              (t.style.display = "none"),
              (t.style.animationDelay = "0s, 50ms"),
              (t.style.borderBottomLeftRadius =
                "clamp(0px, var(--wui-border-radius-l), 44px)"),
              (t.style.borderBottomRightRadius =
                "clamp(0px, var(--wui-border-radius-l), 44px)"),
              (this.iframe = t),
              (this.iframe.onerror = () => {
                this.frameLoadPromiseResolver?.reject(
                  "Unable to load email login dependency"
                );
              }),
              this.events.onFrameEvent((e) => {
                "@w3m-frame/READY" === e.type &&
                  this.frameLoadPromiseResolver?.resolve(void 0);
              });
          }
        }
        get networks() {
          return Object.assign(
            {},
            ...[
              "eip155:1",
              "eip155:5",
              "eip155:11155111",
              "eip155:10",
              "eip155:420",
              "eip155:42161",
              "eip155:421613",
              "eip155:137",
              "eip155:80001",
              "eip155:42220",
              "eip155:1313161554",
              "eip155:1313161555",
              "eip155:56",
              "eip155:97",
              "eip155:43114",
              "eip155:43113",
              "eip155:324",
              "eip155:280",
              "eip155:100",
              "eip155:8453",
              "eip155:84531",
              "eip155:84532",
              "eip155:7777777",
              "eip155:999",
              "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
              "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
              "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
            ].map((e) => ({
              [e]: {
                rpcUrl: `${this.rpcUrl}/v1/?chainId=${e}&projectId=${this.projectId}`,
                chainId: e,
              },
            }))
          );
        }
      }
      var rg = r(71018);
      class rm {
        constructor(e) {
          let t = (0, rg.iP)({ level: l.OH }),
            { logger: r, chunkLoggerController: i } = (0, rg.D5)({ opts: t });
          (this.logger = (0, rg.U5)(r, this.constructor.name)),
            (this.chunkLoggerController = i),
            "undefined" != typeof window &&
              this.chunkLoggerController?.downloadLogsBlobInBrowser &&
              (window.downloadAppKitLogsBlob ||
                (window.downloadAppKitLogsBlob = {}),
              (window.downloadAppKitLogsBlob.sdk = () => {
                this.chunkLoggerController?.downloadLogsBlobInBrowser &&
                  this.chunkLoggerController.downloadLogsBlobInBrowser({
                    projectId: e,
                  });
              }));
        }
      }
      var rb = r(22669);
      class ry {
        constructor({
          projectId: e,
          chainId: t,
          enableLogger: r = !0,
          onTimeout: i,
        }) {
          (this.openRpcRequests = []),
            r && (this.w3mLogger = new rm(e)),
            (this.w3mFrame = new rp({
              projectId: e,
              isAppClient: !0,
              chainId: t,
              enableLogger: r,
            })),
            (this.onTimeout = i),
            this.getLoginEmailUsed() && this.w3mFrame.initFrame(),
            (this.initPromise = new Promise((e) => {
              this.w3mFrame.events.onFrameEvent((t) => {
                t.type === l.s1.FRAME_READY &&
                  ((this.initPromise = void 0), e());
              });
            }));
        }
        async init() {
          this.w3mFrame.initFrame(),
            this.initPromise && (await this.initPromise);
        }
        getLoginEmailUsed() {
          return !!rb.o.get(l.s1.EMAIL_LOGIN_USED_KEY);
        }
        getEmail() {
          return rb.o.get(l.s1.EMAIL);
        }
        getUsername() {
          return rb.o.get(l.s1.SOCIAL_USERNAME);
        }
        async reload() {
          try {
            this.w3mFrame.initFrame(),
              await this.appEvent({ type: l.s1.APP_RELOAD });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error reloading iframe"
              ),
              e)
            );
          }
        }
        async connectEmail(e) {
          try {
            d.Q.checkIfAllowedToTriggerEmail(), this.w3mFrame.initFrame();
            let t = await this.appEvent({
              type: l.s1.APP_CONNECT_EMAIL,
              payload: e,
            });
            return this.setNewLastEmailLoginTime(), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting email"
              ),
              e)
            );
          }
        }
        async connectDevice() {
          try {
            return this.appEvent({ type: l.s1.APP_CONNECT_DEVICE });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting device"
              ),
              e)
            );
          }
        }
        async connectOtp(e) {
          try {
            return this.appEvent({ type: l.s1.APP_CONNECT_OTP, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting otp"
              ),
              e)
            );
          }
        }
        async isConnected() {
          try {
            if (!this.getLoginEmailUsed()) return { isConnected: !1 };
            let e = await this.appEvent({ type: l.s1.APP_IS_CONNECTED });
            return e.isConnected || this.deleteAuthLoginCache(), e;
          } catch (e) {
            throw (
              (this.deleteAuthLoginCache(),
              this.w3mLogger?.logger.error(
                { error: e },
                "Error checking connection"
              ),
              e)
            );
          }
        }
        async getChainId() {
          try {
            let e = await this.appEvent({ type: l.s1.APP_GET_CHAIN_ID });
            return this.setLastUsedChainId(e.chainId), e;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error getting chain id"
              ),
              e)
            );
          }
        }
        async getSocialRedirectUri(e) {
          try {
            return (
              this.w3mFrame.initFrame(),
              this.appEvent({
                type: l.s1.APP_GET_SOCIAL_REDIRECT_URI,
                payload: e,
              })
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error getting social redirect uri"
              ),
              e)
            );
          }
        }
        async updateEmail(e) {
          try {
            let t = await this.appEvent({
              type: l.s1.APP_UPDATE_EMAIL,
              payload: e,
            });
            return this.setNewLastEmailLoginTime(), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error updating email"
              ),
              e)
            );
          }
        }
        async updateEmailPrimaryOtp(e) {
          try {
            return this.appEvent({
              type: l.s1.APP_UPDATE_EMAIL_PRIMARY_OTP,
              payload: e,
            });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error updating email primary otp"
              ),
              e)
            );
          }
        }
        async updateEmailSecondaryOtp(e) {
          try {
            let t = await this.appEvent({
              type: l.s1.APP_UPDATE_EMAIL_SECONDARY_OTP,
              payload: e,
            });
            return this.setLoginSuccess(t.newEmail), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error updating email secondary otp"
              ),
              e)
            );
          }
        }
        async syncTheme(e) {
          try {
            return this.appEvent({ type: l.s1.APP_SYNC_THEME, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error syncing theme"
              ),
              e)
            );
          }
        }
        async syncDappData(e) {
          try {
            return this.appEvent({ type: l.s1.APP_SYNC_DAPP_DATA, payload: e });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error syncing dapp data"
              ),
              e)
            );
          }
        }
        async getSmartAccountEnabledNetworks() {
          try {
            let e = await this.appEvent({
              type: l.s1.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS,
            });
            return (
              this.persistSmartAccountEnabledNetworks(
                e.smartAccountEnabledNetworks
              ),
              e
            );
          } catch (e) {
            throw (
              (this.persistSmartAccountEnabledNetworks([]),
              this.w3mLogger?.logger.error(
                { error: e },
                "Error getting smart account enabled networks"
              ),
              e)
            );
          }
        }
        async setPreferredAccount(e) {
          try {
            return this.appEvent({
              type: l.s1.APP_SET_PREFERRED_ACCOUNT,
              payload: { type: e },
            });
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error setting preferred account"
              ),
              e)
            );
          }
        }
        async connect(e) {
          try {
            let t = e?.chainId || this.getLastUsedChainId() || 1,
              r = await this.appEvent({
                type: l.s1.APP_GET_USER,
                payload: { ...e, chainId: t },
              });
            return (
              this.setLoginSuccess(r.email),
              this.setLastUsedChainId(r.chainId),
              (this.user = r),
              r
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error({ error: e }, "Error connecting"),
              e)
            );
          }
        }
        async getUser(e) {
          try {
            let t = e?.chainId || this.getLastUsedChainId() || 1,
              r = await this.appEvent({
                type: l.s1.APP_GET_USER,
                payload: { ...e, chainId: t },
              });
            return (this.user = r), r;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error({ error: e }, "Error connecting"),
              e)
            );
          }
        }
        async connectSocial(e) {
          try {
            this.w3mFrame.initFrame();
            let t = await this.appEvent({
              type: l.s1.APP_CONNECT_SOCIAL,
              payload: { uri: e },
            });
            return t.userName && this.setSocialLoginSuccess(t.userName), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting social"
              ),
              e)
            );
          }
        }
        async getFarcasterUri() {
          try {
            return (
              this.w3mFrame.initFrame(),
              await this.appEvent({ type: l.s1.APP_GET_FARCASTER_URI })
            );
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error getting farcaster uri"
              ),
              e)
            );
          }
        }
        async connectFarcaster() {
          try {
            let e = await this.appEvent({ type: l.s1.APP_CONNECT_FARCASTER });
            return e.userName && this.setSocialLoginSuccess(e.userName), e;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error connecting farcaster"
              ),
              e)
            );
          }
        }
        async switchNetwork(e) {
          try {
            let t = await this.appEvent({
              type: l.s1.APP_SWITCH_NETWORK,
              payload: { chainId: e },
            });
            return this.setLastUsedChainId(t.chainId), t;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error switching network"
              ),
              e)
            );
          }
        }
        async disconnect() {
          try {
            let e = await this.appEvent({ type: l.s1.APP_SIGN_OUT });
            return this.deleteAuthLoginCache(), e;
          } catch (e) {
            throw (
              (this.w3mLogger?.logger.error(
                { error: e },
                "Error disconnecting"
              ),
              e)
            );
          }
        }
        async request(e) {
          try {
            if (l.Vl.GET_CHAIN_ID === e.method)
              return this.getLastUsedChainId();
            this.rpcRequestHandler?.(e);
            let t = await this.appEvent({
              type: l.s1.APP_RPC_REQUEST,
              payload: e,
            });
            return this.rpcSuccessHandler?.(t, e), t;
          } catch (t) {
            throw (
              (this.rpcErrorHandler?.(t, e),
              this.w3mLogger?.logger.error({ error: t }, "Error requesting"),
              t)
            );
          }
        }
        onRpcRequest(e) {
          this.rpcRequestHandler = e;
        }
        onRpcSuccess(e) {
          this.rpcSuccessHandler = e;
        }
        onRpcError(e) {
          this.rpcErrorHandler = e;
        }
        onIsConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === l.s1.FRAME_IS_CONNECTED_SUCCESS &&
              t.payload.isConnected &&
              e();
          });
        }
        onNotConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === l.s1.FRAME_IS_CONNECTED_ERROR && e(),
              t.type !== l.s1.FRAME_IS_CONNECTED_SUCCESS ||
                t.payload.isConnected ||
                e();
          });
        }
        onConnect(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === l.s1.FRAME_GET_USER_SUCCESS && e(t.payload);
          });
        }
        onSocialConnected(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === l.s1.FRAME_CONNECT_SOCIAL_SUCCESS && e(t.payload);
          });
        }
        async getCapabilities() {
          try {
            return (
              (await this.request({ method: "wallet_getCapabilities" })) || {}
            );
          } catch {
            return {};
          }
        }
        onSetPreferredAccount(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === l.s1.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS
              ? e(t.payload)
              : t.type === l.s1.FRAME_SET_PREFERRED_ACCOUNT_ERROR &&
                e({ type: l.Vl.ACCOUNT_TYPES.EOA });
          });
        }
        onGetSmartAccountEnabledNetworks(e) {
          this.w3mFrame.events.onFrameEvent((t) => {
            t.type === l.s1.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS
              ? e(t.payload.smartAccountEnabledNetworks)
              : t.type ===
                  l.s1.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR && e([]);
          });
        }
        getAvailableChainIds() {
          return Object.keys(this.w3mFrame.networks);
        }
        rejectRpcRequests() {
          try {
            this.openRpcRequests.forEach(
              ({ abortController: e, method: t }) => {
                l.Vl.SAFE_RPC_METHODS.includes(t) || e.abort();
              }
            ),
              (this.openRpcRequests = []);
          } catch (e) {
            this.w3mLogger?.logger.error(
              { error: e },
              "Error aborting RPC request"
            );
          }
        }
        async appEvent(e) {
          let t;
          function r(e) {
            return e.replace("@w3m-app/", "");
          }
          await this.w3mFrame.frameLoadPromise;
          let i = new AbortController(),
            s = r(e.type);
          return (
            [
              l.s1.APP_CONNECT_EMAIL,
              l.s1.APP_CONNECT_DEVICE,
              l.s1.APP_CONNECT_OTP,
              l.s1.APP_CONNECT_SOCIAL,
              l.s1.APP_GET_SOCIAL_REDIRECT_URI,
            ]
              .map(r)
              .includes(s) &&
              (t = setTimeout(() => {
                this.onTimeout?.(), i.abort();
              }, 3e4)),
            new Promise((r, n) => {
              let a = Math.random().toString(36).substring(7);
              this.w3mLogger?.logger.info?.(
                { event: e, id: a },
                "Sending app event"
              ),
                this.w3mFrame.events.postAppEvent({ ...e, id: a }),
                "RPC_REQUEST" === s &&
                  (this.openRpcRequests = [
                    ...this.openRpcRequests,
                    { ...e.payload, abortController: i },
                  ]),
                i.signal.addEventListener("abort", () => {
                  "RPC_REQUEST" === s
                    ? n(Error("Request was aborted"))
                    : "GET_FARCASTER_URI" !== s &&
                      n(Error("Something went wrong"));
                }),
                this.w3mFrame.events.registerFrameEventHandler(
                  a,
                  (e) => {
                    var i, o;
                    return (
                      (i = e),
                      (o = this.w3mLogger),
                      void (
                        i.id === a &&
                        (o?.logger.info?.(
                          { framEvent: i, id: a },
                          "Received frame response"
                        ),
                        i.type === `@w3m-frame/${s}_SUCCESS`
                          ? (t && clearTimeout(t),
                            "payload" in i && r(i.payload),
                            r(void 0))
                          : i.type === `@w3m-frame/${s}_ERROR` &&
                            (t && clearTimeout(t),
                            "payload" in i &&
                              n(
                                Error(i.payload?.message || "An error occurred")
                              ),
                            n(Error("An error occurred"))))
                      )
                    );
                  },
                  i.signal
                );
            })
          );
        }
        setNewLastEmailLoginTime() {
          rb.o.set(l.s1.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
        }
        setSocialLoginSuccess(e) {
          rb.o.set(l.s1.SOCIAL_USERNAME, e);
        }
        setLoginSuccess(e) {
          e && rb.o.set(l.s1.EMAIL, e),
            rb.o.set(l.s1.EMAIL_LOGIN_USED_KEY, "true"),
            rb.o.delete(l.s1.LAST_EMAIL_LOGIN_TIME);
        }
        deleteAuthLoginCache() {
          rb.o.delete(l.s1.EMAIL_LOGIN_USED_KEY),
            rb.o.delete(l.s1.EMAIL),
            rb.o.delete(l.s1.LAST_USED_CHAIN_KEY),
            rb.o.delete(l.s1.SOCIAL_USERNAME);
        }
        setLastUsedChainId(e) {
          e && rb.o.set(l.s1.LAST_USED_CHAIN_KEY, String(e));
        }
        getLastUsedChainId() {
          let e = rb.o.get(l.s1.LAST_USED_CHAIN_KEY) ?? void 0,
            t = Number(e);
          return isNaN(t) ? e : t;
        }
        persistSmartAccountEnabledNetworks(e) {
          rb.o.set(l.s1.SMART_ACCOUNT_ENABLED_NETWORKS, e.join(","));
        }
      }
      class rw {
        constructor() {}
        static getInstance({
          projectId: e,
          chainId: t,
          enableLogger: r,
          onTimeout: i,
        }) {
          return (
            rw.instance ||
              (rw.instance = new ry({
                projectId: e,
                chainId: t,
                enableLogger: r,
                onTimeout: i,
              })),
            rw.instance
          );
        }
      }
    },
    83941: (e, t, r) => {
      "use strict";
      r.d(t, { s: () => o });
      var i = r(58051),
        s = r(44826),
        n = r(73442),
        a = r(3824);
      let o = {
        async getTokenList() {
          let e = n.W.state.activeCaipNetwork,
            t = await s.T.fetchSwapTokens({ chainId: e?.caipNetworkId });
          return (
            t?.tokens?.map((e) => ({
              ...e,
              eip2612: !1,
              quantity: { decimals: "0", numeric: "0" },
              price: 0,
              value: 0,
            })) || []
          );
        },
        async fetchGasPrice() {
          let e = n.W.state.activeCaipNetwork;
          if (!e) return null;
          try {
            if ("solana" === e.chainNamespace) {
              let e = (
                await a.x?.estimateGas({ chainNamespace: "solana" })
              )?.toString();
              return { standard: e, fast: e, instant: e };
            }
            return await s.T.fetchGasPrice({ chainId: e.caipNetworkId });
          } catch {
            return null;
          }
        },
        async fetchSwapAllowance({
          tokenAddress: e,
          userAddress: t,
          sourceTokenAmount: r,
          sourceTokenDecimals: i,
        }) {
          let n = await s.T.fetchSwapAllowance({
            tokenAddress: e,
            userAddress: t,
          });
          if (n?.allowance && r && i) {
            let e = a.x.parseUnits(r, i) || 0;
            return BigInt(n.allowance) >= e;
          }
          return !1;
        },
        async getMyTokensWithBalance(e) {
          let t = i.U.state.address,
            r = n.W.state.activeCaipNetwork;
          if (!t || !r) return [];
          let a = (await s.T.getBalance(t, r.caipNetworkId, e)).balances.filter(
            (e) => "0" !== e.quantity.decimals
          );
          return (
            i.U.setTokenBalance(a, n.W.state.activeChain),
            this.mapBalancesToSwapTokens(a)
          );
        },
        mapBalancesToSwapTokens: (e) =>
          e?.map((e) => ({
            ...e,
            address: e?.address
              ? e.address
              : n.W.getActiveNetworkTokenAddress(),
            decimals: parseInt(e.quantity.decimals, 10),
            logoUri: e.iconUrl,
            eip2612: !1,
          })) || [],
      };
    },
    85454: (e, t, r) => {
      "use strict";
      r.d(t, { b: () => s });
      var i = r(13933);
      class s extends i.C {
        constructor() {
          super(
            "No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",
            { docsPath: "/docs/clients/intro", name: "UrlRequiredError" }
          );
        }
      }
    },
    85574: (e, t, r) => {
      "use strict";
      var i = r(78239),
        s = r(98392),
        n = r(43770),
        a = r(92963),
        o = i.assert;
      function c(e) {
        (this.twisted = (0 | e.a) != 1),
          (this.mOneA = this.twisted && (0 | e.a) == -1),
          (this.extended = this.mOneA),
          a.call(this, "edwards", e),
          (this.a = new s(e.a, 16).umod(this.red.m)),
          (this.a = this.a.toRed(this.red)),
          (this.c = new s(e.c, 16).toRed(this.red)),
          (this.c2 = this.c.redSqr()),
          (this.d = new s(e.d, 16).toRed(this.red)),
          (this.dd = this.d.redAdd(this.d)),
          o(!this.twisted || 0 === this.c.fromRed().cmpn(1)),
          (this.oneC = (0 | e.c) == 1);
      }
      function l(e, t, r, i, n) {
        a.BasePoint.call(this, e, "projective"),
          null === t && null === r && null === i
            ? ((this.x = this.curve.zero),
              (this.y = this.curve.one),
              (this.z = this.curve.one),
              (this.t = this.curve.zero),
              (this.zOne = !0))
            : ((this.x = new s(t, 16)),
              (this.y = new s(r, 16)),
              (this.z = i ? new s(i, 16) : this.curve.one),
              (this.t = n && new s(n, 16)),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.y.red || (this.y = this.y.toRed(this.curve.red)),
              this.z.red || (this.z = this.z.toRed(this.curve.red)),
              this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)),
              (this.zOne = this.z === this.curve.one),
              !this.curve.extended ||
                this.t ||
                ((this.t = this.x.redMul(this.y)),
                this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
      }
      n(c, a),
        (e.exports = c),
        (c.prototype._mulA = function (e) {
          return this.mOneA ? e.redNeg() : this.a.redMul(e);
        }),
        (c.prototype._mulC = function (e) {
          return this.oneC ? e : this.c.redMul(e);
        }),
        (c.prototype.jpoint = function (e, t, r, i) {
          return this.point(e, t, r, i);
        }),
        (c.prototype.pointFromX = function (e, t) {
          (e = new s(e, 16)).red || (e = e.toRed(this.red));
          var r = e.redSqr(),
            i = this.c2.redSub(this.a.redMul(r)),
            n = this.one.redSub(this.c2.redMul(this.d).redMul(r)),
            a = i.redMul(n.redInvm()),
            o = a.redSqrt();
          if (0 !== o.redSqr().redSub(a).cmp(this.zero))
            throw Error("invalid point");
          var c = o.fromRed().isOdd();
          return ((t && !c) || (!t && c)) && (o = o.redNeg()), this.point(e, o);
        }),
        (c.prototype.pointFromY = function (e, t) {
          (e = new s(e, 16)).red || (e = e.toRed(this.red));
          var r = e.redSqr(),
            i = r.redSub(this.c2),
            n = r.redMul(this.d).redMul(this.c2).redSub(this.a),
            a = i.redMul(n.redInvm());
          if (0 === a.cmp(this.zero)) {
            if (!t) return this.point(this.zero, e);
            throw Error("invalid point");
          }
          var o = a.redSqrt();
          if (0 !== o.redSqr().redSub(a).cmp(this.zero))
            throw Error("invalid point");
          return (
            o.fromRed().isOdd() !== t && (o = o.redNeg()), this.point(o, e)
          );
        }),
        (c.prototype.validate = function (e) {
          if (e.isInfinity()) return !0;
          e.normalize();
          var t = e.x.redSqr(),
            r = e.y.redSqr(),
            i = t.redMul(this.a).redAdd(r),
            s = this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(r)));
          return 0 === i.cmp(s);
        }),
        n(l, a.BasePoint),
        (c.prototype.pointFromJSON = function (e) {
          return l.fromJSON(this, e);
        }),
        (c.prototype.point = function (e, t, r, i) {
          return new l(this, e, t, r, i);
        }),
        (l.fromJSON = function (e, t) {
          return new l(e, t[0], t[1], t[2]);
        }),
        (l.prototype.inspect = function () {
          return this.isInfinity()
            ? "<EC Point Infinity>"
            : "<EC Point x: " +
                this.x.fromRed().toString(16, 2) +
                " y: " +
                this.y.fromRed().toString(16, 2) +
                " z: " +
                this.z.fromRed().toString(16, 2) +
                ">";
        }),
        (l.prototype.isInfinity = function () {
          return (
            0 === this.x.cmpn(0) &&
            (0 === this.y.cmp(this.z) ||
              (this.zOne && 0 === this.y.cmp(this.curve.c)))
          );
        }),
        (l.prototype._extDbl = function () {
          var e = this.x.redSqr(),
            t = this.y.redSqr(),
            r = this.z.redSqr();
          r = r.redIAdd(r);
          var i = this.curve._mulA(e),
            s = this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),
            n = i.redAdd(t),
            a = n.redSub(r),
            o = i.redSub(t),
            c = s.redMul(a),
            l = n.redMul(o),
            d = s.redMul(o),
            u = a.redMul(n);
          return this.curve.point(c, l, u, d);
        }),
        (l.prototype._projDbl = function () {
          var e,
            t,
            r,
            i,
            s,
            n,
            a = this.x.redAdd(this.y).redSqr(),
            o = this.x.redSqr(),
            c = this.y.redSqr();
          if (this.curve.twisted) {
            var l = (i = this.curve._mulA(o)).redAdd(c);
            this.zOne
              ? ((e = a.redSub(o).redSub(c).redMul(l.redSub(this.curve.two))),
                (t = l.redMul(i.redSub(c))),
                (r = l.redSqr().redSub(l).redSub(l)))
              : ((s = this.z.redSqr()),
                (n = l.redSub(s).redISub(s)),
                (e = a.redSub(o).redISub(c).redMul(n)),
                (t = l.redMul(i.redSub(c))),
                (r = l.redMul(n)));
          } else
            (i = o.redAdd(c)),
              (s = this.curve._mulC(this.z).redSqr()),
              (n = i.redSub(s).redSub(s)),
              (e = this.curve._mulC(a.redISub(i)).redMul(n)),
              (t = this.curve._mulC(i).redMul(o.redISub(c))),
              (r = i.redMul(n));
          return this.curve.point(e, t, r);
        }),
        (l.prototype.dbl = function () {
          return this.isInfinity()
            ? this
            : this.curve.extended
            ? this._extDbl()
            : this._projDbl();
        }),
        (l.prototype._extAdd = function (e) {
          var t = this.y.redSub(this.x).redMul(e.y.redSub(e.x)),
            r = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),
            i = this.t.redMul(this.curve.dd).redMul(e.t),
            s = this.z.redMul(e.z.redAdd(e.z)),
            n = r.redSub(t),
            a = s.redSub(i),
            o = s.redAdd(i),
            c = r.redAdd(t),
            l = n.redMul(a),
            d = o.redMul(c),
            u = n.redMul(c),
            h = a.redMul(o);
          return this.curve.point(l, d, h, u);
        }),
        (l.prototype._projAdd = function (e) {
          var t,
            r,
            i = this.z.redMul(e.z),
            s = i.redSqr(),
            n = this.x.redMul(e.x),
            a = this.y.redMul(e.y),
            o = this.curve.d.redMul(n).redMul(a),
            c = s.redSub(o),
            l = s.redAdd(o),
            d = this.x
              .redAdd(this.y)
              .redMul(e.x.redAdd(e.y))
              .redISub(n)
              .redISub(a),
            u = i.redMul(c).redMul(d);
          return (
            this.curve.twisted
              ? ((t = i.redMul(l).redMul(a.redSub(this.curve._mulA(n)))),
                (r = c.redMul(l)))
              : ((t = i.redMul(l).redMul(a.redSub(n))),
                (r = this.curve._mulC(c).redMul(l))),
            this.curve.point(u, t, r)
          );
        }),
        (l.prototype.add = function (e) {
          return this.isInfinity()
            ? e
            : e.isInfinity()
            ? this
            : this.curve.extended
            ? this._extAdd(e)
            : this._projAdd(e);
        }),
        (l.prototype.mul = function (e) {
          return this._hasDoubles(e)
            ? this.curve._fixedNafMul(this, e)
            : this.curve._wnafMul(this, e);
        }),
        (l.prototype.mulAdd = function (e, t, r) {
          return this.curve._wnafMulAdd(1, [this, t], [e, r], 2, !1);
        }),
        (l.prototype.jmulAdd = function (e, t, r) {
          return this.curve._wnafMulAdd(1, [this, t], [e, r], 2, !0);
        }),
        (l.prototype.normalize = function () {
          if (this.zOne) return this;
          var e = this.z.redInvm();
          return (
            (this.x = this.x.redMul(e)),
            (this.y = this.y.redMul(e)),
            this.t && (this.t = this.t.redMul(e)),
            (this.z = this.curve.one),
            (this.zOne = !0),
            this
          );
        }),
        (l.prototype.neg = function () {
          return this.curve.point(
            this.x.redNeg(),
            this.y,
            this.z,
            this.t && this.t.redNeg()
          );
        }),
        (l.prototype.getX = function () {
          return this.normalize(), this.x.fromRed();
        }),
        (l.prototype.getY = function () {
          return this.normalize(), this.y.fromRed();
        }),
        (l.prototype.eq = function (e) {
          return (
            this === e ||
            (0 === this.getX().cmp(e.getX()) && 0 === this.getY().cmp(e.getY()))
          );
        }),
        (l.prototype.eqXToP = function (e) {
          var t = e.toRed(this.curve.red).redMul(this.z);
          if (0 === this.x.cmp(t)) return !0;
          for (var r = e.clone(), i = this.curve.redN.redMul(this.z); ; ) {
            if ((r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0)) return !1;
            if ((t.redIAdd(i), 0 === this.x.cmp(t))) return !0;
          }
        }),
        (l.prototype.toP = l.prototype.normalize),
        (l.prototype.mixedAdd = l.prototype.add);
    },
    85896: (e, t, r) => {
      "use strict";
      r.d(t, {
        AH: () => i.AH,
        JW: () => i.JW,
        WF: () => i.WF,
        iz: () => i.iz,
        qy: () => i.qy,
      }),
        r(98502),
        r(52321);
      var i = r(43997);
    },
    86186: (e, t, r) => {
      "use strict";
      r.d(t, { l: () => s });
      var i = r(13933);
      class s extends i.C {
        constructor({ blockHash: e, blockNumber: t }) {
          let r = "Block";
          e && (r = `Block at hash "${e}"`),
            t && (r = `Block at number "${t}"`),
            super(`${r} could not be found.`, { name: "BlockNotFoundError" });
        }
      }
    },
    87094: (e, t, r) => {
      "use strict";
      var i = r(98392),
        s = r(78239).assert;
      function n(e, t) {
        (this.ec = e),
          (this.priv = null),
          (this.pub = null),
          t.priv && this._importPrivate(t.priv, t.privEnc),
          t.pub && this._importPublic(t.pub, t.pubEnc);
      }
      (e.exports = n),
        (n.fromPublic = function (e, t, r) {
          return t instanceof n ? t : new n(e, { pub: t, pubEnc: r });
        }),
        (n.fromPrivate = function (e, t, r) {
          return t instanceof n ? t : new n(e, { priv: t, privEnc: r });
        }),
        (n.prototype.validate = function () {
          var e = this.getPublic();
          return e.isInfinity()
            ? { result: !1, reason: "Invalid public key" }
            : e.validate()
            ? e.mul(this.ec.curve.n).isInfinity()
              ? { result: !0, reason: null }
              : { result: !1, reason: "Public key * N != O" }
            : { result: !1, reason: "Public key is not a point" };
        }),
        (n.prototype.getPublic = function (e, t) {
          return ("string" == typeof e && ((t = e), (e = null)),
          this.pub || (this.pub = this.ec.g.mul(this.priv)),
          t)
            ? this.pub.encode(t, e)
            : this.pub;
        }),
        (n.prototype.getPrivate = function (e) {
          return "hex" === e ? this.priv.toString(16, 2) : this.priv;
        }),
        (n.prototype._importPrivate = function (e, t) {
          (this.priv = new i(e, t || 16)),
            (this.priv = this.priv.umod(this.ec.curve.n));
        }),
        (n.prototype._importPublic = function (e, t) {
          if (e.x || e.y) {
            "mont" === this.ec.curve.type
              ? s(e.x, "Need x coordinate")
              : ("short" === this.ec.curve.type ||
                  "edwards" === this.ec.curve.type) &&
                s(e.x && e.y, "Need both x and y coordinate"),
              (this.pub = this.ec.curve.point(e.x, e.y));
            return;
          }
          this.pub = this.ec.curve.decodePoint(e, t);
        }),
        (n.prototype.derive = function (e) {
          return (
            e.validate() || s(e.validate(), "public point not validated"),
            e.mul(this.priv).getX()
          );
        }),
        (n.prototype.sign = function (e, t, r) {
          return this.ec.sign(e, this, t, r);
        }),
        (n.prototype.verify = function (e, t, r) {
          return this.ec.verify(e, t, this, void 0, r);
        }),
        (n.prototype.inspect = function () {
          return (
            "<Key priv: " +
            (this.priv && this.priv.toString(16, 2)) +
            " pub: " +
            (this.pub && this.pub.inspect()) +
            " >"
          );
        });
    },
    87822: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      let i = r(11870);
      i.__exportStar(r(64663), t), i.__exportStar(r(91609), t);
    },
    88487: (e, t, r) => {
      "use strict";
      function i(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function s(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function n(e) {
        if ("function" != typeof e || "function" != typeof e.create)
          throw Error("Hash should be wrapped by utils.wrapConstructor");
        i(e.outputLen), i(e.blockLen);
      }
      function a(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function o(e, t) {
        s(e);
        let r = t.outputLen;
        if (e.length < r)
          throw Error(
            "digestInto() expects output buffer of length at least " + r
          );
      }
      r.d(t, {
        CC: () => a,
        DO: () => s,
        Fe: () => i,
        Ht: () => o,
        sd: () => n,
      });
    },
    88759: (e) => {
      "use strict";
      function t(e) {
        try {
          return JSON.stringify(e);
        } catch (e) {
          return '"[Circular]"';
        }
      }
      e.exports = function (e, r, i) {
        var s = (i && i.stringify) || t;
        if ("object" == typeof e && null !== e) {
          var n = r.length + 1;
          if (1 === n) return e;
          var a = Array(n);
          a[0] = s(e);
          for (var o = 1; o < n; o++) a[o] = s(r[o]);
          return a.join(" ");
        }
        if ("string" != typeof e) return e;
        var c = r.length;
        if (0 === c) return e;
        for (
          var l = "", d = 0, u = -1, h = (e && e.length) || 0, f = 0;
          f < h;

        ) {
          if (37 === e.charCodeAt(f) && f + 1 < h) {
            switch (((u = u > -1 ? u : 0), e.charCodeAt(f + 1))) {
              case 100:
              case 102:
                if (d >= c || null == r[d]) break;
                u < f && (l += e.slice(u, f)),
                  (l += Number(r[d])),
                  (u = f + 2),
                  f++;
                break;
              case 105:
                if (d >= c || null == r[d]) break;
                u < f && (l += e.slice(u, f)),
                  (l += Math.floor(Number(r[d]))),
                  (u = f + 2),
                  f++;
                break;
              case 79:
              case 111:
              case 106:
                if (d >= c || void 0 === r[d]) break;
                u < f && (l += e.slice(u, f));
                var p = typeof r[d];
                if ("string" === p) {
                  (l += "'" + r[d] + "'"), (u = f + 2), f++;
                  break;
                }
                if ("function" === p) {
                  (l += r[d].name || "<anonymous>"), (u = f + 2), f++;
                  break;
                }
                (l += s(r[d])), (u = f + 2), f++;
                break;
              case 115:
                if (d >= c) break;
                u < f && (l += e.slice(u, f)),
                  (l += String(r[d])),
                  (u = f + 2),
                  f++;
                break;
              case 37:
                u < f && (l += e.slice(u, f)),
                  (l += "%"),
                  (u = f + 2),
                  f++,
                  d--;
            }
            ++d;
          }
          ++f;
        }
        return -1 === u ? e : (u < h && (l += e.slice(u)), l);
      };
    },
    88955: (e, t, r) => {
      "use strict";
      t.g = void 0;
      let i = r(26662);
      t.g = function () {
        let e, t, r;
        try {
          (e = i.getDocumentOrThrow()), (t = i.getLocationOrThrow());
        } catch (e) {
          return null;
        }
        function s(...t) {
          let r = e.getElementsByTagName("meta");
          for (let e = 0; e < r.length; e++) {
            let i = r[e],
              s = ["itemprop", "property", "name"]
                .map((e) => i.getAttribute(e))
                .filter((e) => !!e && t.includes(e));
            if (s.length && s) {
              let e = i.getAttribute("content");
              if (e) return e;
            }
          }
          return "";
        }
        let n =
            ((r = s("name", "og:site_name", "og:title", "twitter:title")) ||
              (r = e.title),
            r),
          a = s(
            "description",
            "og:description",
            "twitter:description",
            "keywords"
          ),
          o = t.origin;
        return {
          description: a,
          url: o,
          icons: (function () {
            let r = e.getElementsByTagName("link"),
              i = [];
            for (let e = 0; e < r.length; e++) {
              let s = r[e],
                n = s.getAttribute("rel");
              if (n && n.toLowerCase().indexOf("icon") > -1) {
                let e = s.getAttribute("href");
                if (e) {
                  if (
                    -1 === e.toLowerCase().indexOf("https:") &&
                    -1 === e.toLowerCase().indexOf("http:") &&
                    0 !== e.indexOf("//")
                  ) {
                    let r = t.protocol + "//" + t.host;
                    if (0 === e.indexOf("/")) r += e;
                    else {
                      let i = t.pathname.split("/");
                      i.pop(), (r += i.join("/") + "/" + e);
                    }
                    i.push(r);
                  } else if (0 === e.indexOf("//")) {
                    let r = t.protocol + e;
                    i.push(r);
                  } else i.push(e);
                }
              }
            }
            return i;
          })(),
          name: n,
        };
      };
    },
    89600: (e, t, r) => {
      "use strict";
      r.d(t, { R: () => i });
      let i = {
        UniversalProviderErrors: {
          UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
            message: "Unauthorized: origin not allowed",
            alertErrorKey: "INVALID_APP_CONFIGURATION",
          },
          JWT_VALIDATION_ERROR: {
            message: "JWT validation error: JWT Token is not yet valid",
            alertErrorKey: "JWT_TOKEN_NOT_VALID",
          },
          INVALID_KEY: {
            message: "Unauthorized: invalid key",
            alertErrorKey: "INVALID_PROJECT_ID",
          },
        },
        ALERT_ERRORS: {
          SWITCH_NETWORK_NOT_FOUND: {
            shortMessage: "Network Not Found",
            longMessage:
              "Network not found - please make sure it is included in 'networks' array in createAppKit function",
          },
          INVALID_APP_CONFIGURATION: {
            shortMessage: "Invalid App Configuration",
            longMessage: () =>
              `Origin ${
                "undefined" != typeof window ? window.origin : "unknown"
              } not found on Allowlist - update configuration on cloud.reown.com`,
          },
          SOCIALS_TIMEOUT: {
            shortMessage: "Invalid App Configuration",
            longMessage: () =>
              "There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com",
          },
          JWT_TOKEN_NOT_VALID: {
            shortMessage: "Session Expired",
            longMessage:
              "Invalid session found on UniversalProvider - please check your time settings and connect again",
          },
          INVALID_PROJECT_ID: {
            shortMessage: "Invalid App Configuration",
            longMessage: "Invalid Project ID - update configuration",
          },
          PROJECT_ID_NOT_CONFIGURED: {
            shortMessage: "Project ID Not Configured",
            longMessage:
              "Project ID Not Configured - update configuration on cloud.reown.com",
          },
        },
      };
    },
    89709: (e, t, r) => {
      "use strict";
      function i(e, t) {
        let r = e.exec(t);
        return r?.groups;
      }
      r.d(t, { BD: () => s, Ge: () => n, Yv: () => i, wj: () => a });
      let s = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
        n =
          /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
        a = /^\(.+?\).*?$/;
    },
    89863: (e, t, r) => {
      "use strict";
      r.d(t, { Zr: () => n, eh: () => i });
      let i = (e) => (t, r, i) => {
          let s = i.subscribe;
          return (
            (i.subscribe = (e, t, r) => {
              let n = e;
              if (t) {
                let s = (null == r ? void 0 : r.equalityFn) || Object.is,
                  a = e(i.getState());
                (n = (r) => {
                  let i = e(r);
                  if (!s(a, i)) {
                    let e = a;
                    t((a = i), e);
                  }
                }),
                  (null == r ? void 0 : r.fireImmediately) && t(a, a);
              }
              return s(n);
            }),
            e(t, r, i)
          );
        },
        s = (e) => (t) => {
          try {
            let r = e(t);
            if (r instanceof Promise) return r;
            return {
              then: (e) => s(e)(r),
              catch(e) {
                return this;
              },
            };
          } catch (e) {
            return {
              then(e) {
                return this;
              },
              catch: (t) => s(t)(e),
            };
          }
        },
        n = (e, t) => (r, i, n) => {
          let a,
            o = {
              storage: (function (e, t) {
                let r;
                try {
                  r = e();
                } catch (e) {
                  return;
                }
                return {
                  getItem: (e) => {
                    var t;
                    let i = (e) => (null === e ? null : JSON.parse(e, void 0)),
                      s = null != (t = r.getItem(e)) ? t : null;
                    return s instanceof Promise ? s.then(i) : i(s);
                  },
                  setItem: (e, t) => r.setItem(e, JSON.stringify(t, void 0)),
                  removeItem: (e) => r.removeItem(e),
                };
              })(() => localStorage),
              partialize: (e) => e,
              version: 0,
              merge: (e, t) => ({ ...t, ...e }),
              ...t,
            },
            c = !1,
            l = new Set(),
            d = new Set(),
            u = o.storage;
          if (!u)
            return e(
              (...e) => {
                console.warn(
                  `[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`
                ),
                  r(...e);
              },
              i,
              n
            );
          let h = () => {
              let e = o.partialize({ ...i() });
              return u.setItem(o.name, { state: e, version: o.version });
            },
            f = n.setState;
          n.setState = (e, t) => {
            f(e, t), h();
          };
          let p = e(
            (...e) => {
              r(...e), h();
            },
            i,
            n
          );
          n.getInitialState = () => p;
          let g = () => {
            var e, t;
            if (!u) return;
            (c = !1),
              l.forEach((e) => {
                var t;
                return e(null != (t = i()) ? t : p);
              });
            let n =
              (null == (t = o.onRehydrateStorage)
                ? void 0
                : t.call(o, null != (e = i()) ? e : p)) || void 0;
            return s(u.getItem.bind(u))(o.name)
              .then((e) => {
                if (e) {
                  if ("number" != typeof e.version || e.version === o.version)
                    return [!1, e.state];
                  if (o.migrate) return [!0, o.migrate(e.state, e.version)];
                  console.error(
                    "State loaded from storage couldn't be migrated since no migrate function was provided"
                  );
                }
                return [!1, void 0];
              })
              .then((e) => {
                var t;
                let [s, n] = e;
                if ((r((a = o.merge(n, null != (t = i()) ? t : p)), !0), s))
                  return h();
              })
              .then(() => {
                null == n || n(a, void 0),
                  (a = i()),
                  (c = !0),
                  d.forEach((e) => e(a));
              })
              .catch((e) => {
                null == n || n(void 0, e);
              });
          };
          return (
            (n.persist = {
              setOptions: (e) => {
                (o = { ...o, ...e }), e.storage && (u = e.storage);
              },
              clearStorage: () => {
                null == u || u.removeItem(o.name);
              },
              getOptions: () => o,
              rehydrate: () => g(),
              hasHydrated: () => c,
              onHydrate: (e) => (
                l.add(e),
                () => {
                  l.delete(e);
                }
              ),
              onFinishHydration: (e) => (
                d.add(e),
                () => {
                  d.delete(e);
                }
              ),
            }),
            o.skipHydration || g(),
            a || p
          );
        };
    },
    90332: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        r(12590).__exportStar(r(19511), t);
    },
    90490: (e, t, r) => {
      "use strict";
      r.d(t, { y: () => s });
      let i = (e) => {
          let t;
          let r = new Set(),
            i = (e, i) => {
              let s = "function" == typeof e ? e(t) : e;
              if (!Object.is(s, t)) {
                let e = t;
                (t = (null != i ? i : "object" != typeof s || null === s)
                  ? s
                  : Object.assign({}, t, s)),
                  r.forEach((r) => r(t, e));
              }
            },
            s = () => t,
            n = {
              setState: i,
              getState: s,
              getInitialState: () => a,
              subscribe: (e) => (r.add(e), () => r.delete(e)),
            },
            a = (t = e(i, s, n));
          return n;
        },
        s = (e) => (e ? i(e) : i);
    },
    90737: (e, t, r) => {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "AmpStateContext", {
          enumerable: !0,
          get: function () {
            return i;
          },
        });
      let i = r(28140)._(r(12115)).default.createContext({});
    },
    90871: (e, t, r) => {
      "use strict";
      let i, s;
      r.d(t, {
        sX: () => _,
        JS: () => v,
        G8: () => y,
        Ks: () => E,
        uP: () => w,
        XV: () => A,
      });
      var n = r(12319),
        a = r(43238),
        o = r(12115),
        c = r(29461),
        l = r(65607),
        d = r(1220);
      let { use: u } = o,
        { useSyncExternalStore: h } = l,
        f = (e, t) => {
          let r = (0, o.useRef)();
          (0, o.useEffect)(() => {
            r.current = (0, c.JR)(e, t, !0);
          }),
            (0, o.useDebugValue)(r.current);
        },
        p = new WeakMap();
      var g = r(73442),
        m = r(3824),
        b = r(66254);
      function y(e) {
        let t = (function (e, t) {
            let r = void 0,
              i = (0, o.useRef)(),
              s = (0, o.useRef)(),
              n = !0,
              a = h(
                (0, o.useCallback)(
                  (t) => {
                    let i = (0, d.B1)(e, t, r);
                    return t(), i;
                  },
                  [e, r]
                ),
                () => {
                  let t = (0, d.P9)(e, u);
                  try {
                    if (
                      !n &&
                      i.current &&
                      s.current &&
                      !(0, c.Hq)(i.current, t, s.current, new WeakMap())
                    )
                      return i.current;
                  } catch (e) {}
                  return t;
                },
                () => (0, d.P9)(e, u)
              );
            n = !1;
            let l = new WeakMap();
            (0, o.useEffect)(() => {
              (i.current = a), (s.current = l);
            }),
              f(a, l);
            let g = (0, o.useMemo)(() => new WeakMap(), []);
            return (0, c.tz)(a, l, g, p);
          })(g.W.state),
          r = e?.namespace || t.activeChain;
        if (!r)
          return {
            allAccounts: [],
            address: void 0,
            caipAddress: void 0,
            status: void 0,
            isConnected: !1,
            embeddedWalletInfo: void 0,
          };
        let i = t.chains.get(r)?.accountState,
          s = b.a.getAuthConnector(r);
        return {
          allAccounts: i?.allAccounts || [],
          caipAddress: i?.caipAddress,
          address: n.w.getPlainAddress(i?.caipAddress),
          isConnected: !!i?.caipAddress,
          status: i?.status,
          embeddedWalletInfo: s
            ? {
                user: i?.user,
                authProvider: i?.socialProvider || "email",
                accountType: i?.preferredAccountType,
                isSmartAccountDeployed: !!i?.smartAccountDeployed,
              }
            : void 0,
        };
      }
      function w() {
        return {
          disconnect: async function (e) {
            await m.x.disconnect(e?.namespace);
          },
        };
      }
      function v() {
        if (!i)
          throw Error(
            'Please call "createAppKit" before using "useAppKit" hook'
          );
        return {
          open: async function (e) {
            await i?.open(e);
          },
          close: async function () {
            await i?.close();
          },
        };
      }
      function A() {
        if (!i)
          throw Error(
            'Please call "createAppKit" before using "useWalletInfo" hook'
          );
        return {
          walletInfo: (0, o.useSyncExternalStore)(
            i.subscribeWalletInfo,
            i.getWalletInfo,
            i.getWalletInfo
          ),
        };
      }
      function E() {
        if (!i)
          throw Error(
            'Please call "createAppKit" before using "useAppKitEvents" hook'
          );
        let [e, t] = (0, o.useState)(i.getEvent());
        return (
          (0, o.useEffect)(() => {
            let e = i?.subscribeEvents((e) => {
              t({ ...e });
            });
            return () => {
              e?.();
            };
          }, []),
          e
        );
      }
      function _(e) {
        if (!s)
          i = s = new a._({
            ...e,
            sdkVersion: n.w.generateSdkVersion(
              e.adapters ?? [],
              "react",
              "1.7.1"
            ),
          });
        return s;
      }
      r(94842);
    },
    91136: (e, t, r) => {
      "use strict";
      r.d(t, {
        A9: () => s,
        NO: () => o,
        Pj: () => c,
        dV: () => n,
        nx: () => l,
        zd: () => a,
      });
      var i = r(63542);
      i.C;
      class s extends i.C {
        constructor({ params: e }) {
          super("Failed to parse ABI parameters.", {
            details: `parseAbiParameters(${JSON.stringify(e, null, 2)})`,
            docsPath: "/api/human#parseabiparameters-1",
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "InvalidAbiParametersError",
            });
        }
      }
      class n extends i.C {
        constructor({ param: e }) {
          super("Invalid ABI parameter.", { details: e }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "InvalidParameterError",
            });
        }
      }
      class a extends i.C {
        constructor({ param: e, name: t }) {
          super("Invalid ABI parameter.", {
            details: e,
            metaMessages: [
              `"${t}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,
            ],
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "SolidityProtectedKeywordError",
            });
        }
      }
      class o extends i.C {
        constructor({ param: e, type: t, modifier: r }) {
          super("Invalid ABI parameter.", {
            details: e,
            metaMessages: [
              `Modifier "${r}" not allowed${t ? ` in "${t}" type` : ""}.`,
            ],
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "InvalidModifierError",
            });
        }
      }
      class c extends i.C {
        constructor({ param: e, type: t, modifier: r }) {
          super("Invalid ABI parameter.", {
            details: e,
            metaMessages: [
              `Modifier "${r}" not allowed${t ? ` in "${t}" type` : ""}.`,
              `Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`,
            ],
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "InvalidFunctionModifierError",
            });
        }
      }
      class l extends i.C {
        constructor({ abiParameter: e }) {
          super("Invalid ABI parameter.", {
            details: JSON.stringify(e, null, 2),
            metaMessages: ["ABI parameter type is invalid."],
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "InvalidAbiTypeParameterError",
            });
        }
      }
    },
    91609: (e, t, r) => {
      "use strict";
      var i = r(87358);
      function s() {
        return (
          "undefined" == typeof document &&
          "undefined" != typeof navigator &&
          "ReactNative" === navigator.product
        );
      }
      function n() {
        return (
          void 0 !== i && void 0 !== i.versions && void 0 !== i.versions.node
        );
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.isBrowser = t.isNode = t.isReactNative = void 0),
        (t.isReactNative = s),
        (t.isNode = n),
        (t.isBrowser = function () {
          return !s() && !n();
        });
    },
    91867: (e, t, r) => {
      "use strict";
      r.d(t, { o: () => s });
      var i = r(87358);
      let s = {
        ACCOUNT_TABS: [
          { label: "Tokens" },
          { label: "NFTs" },
          { label: "Activity" },
        ],
        SECURE_SITE_ORIGIN:
          (void 0 !== i && void 0 !== i.env
            ? i.env.NEXT_PUBLIC_SECURE_SITE_ORIGIN
            : void 0) || "https://secure.walletconnect.org",
        VIEW_DIRECTION: { Next: "next", Prev: "prev" },
        DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
        ANIMATION_DURATIONS: {
          HeaderText: 120,
          ModalHeight: 150,
          ViewTransition: 150,
        },
      };
    },
    92302: (e, t, r) => {
      "use strict";
      r.d(t, { X: () => c }), r(77931);
      var i = r(45553),
        s = r(58051),
        n = r(55480),
        a = r(75578),
        o = r(10763);
      class c {
        constructor(e) {
          (this.availableConnectors = []),
            (this.eventListeners = new Map()),
            e && this.construct(e);
        }
        construct(e) {
          (this.caipNetworks = e.networks),
            (this.projectId = e.projectId),
            (this.namespace = e.namespace);
        }
        get connectors() {
          return this.availableConnectors;
        }
        get networks() {
          return this.caipNetworks || [];
        }
        setAuthProvider(e) {
          this.addConnector({
            id: i.o.CONNECTOR_ID.AUTH,
            type: "AUTH",
            name: i.o.CONNECTOR_NAMES.AUTH,
            provider: e,
            imageId: a.L.ConnectorImageIds[i.o.CONNECTOR_ID.AUTH],
            chain: this.namespace,
            chains: [],
          });
        }
        addConnector(...e) {
          let t = new Set();
          (this.availableConnectors = [
            ...e,
            ...this.availableConnectors,
          ].filter((e) => !t.has(e.id) && (t.add(e.id), !0))),
            this.emit("connectors", this.availableConnectors);
        }
        setStatus(e, t) {
          s.U.setStatus(e, t);
        }
        on(e, t) {
          this.eventListeners.has(e) || this.eventListeners.set(e, new Set()),
            this.eventListeners.get(e)?.add(t);
        }
        off(e, t) {
          let r = this.eventListeners.get(e);
          r && r.delete(t);
        }
        removeAllEventListeners() {
          this.eventListeners.forEach((e) => {
            e.clear();
          });
        }
        emit(e, t) {
          let r = this.eventListeners.get(e);
          r && r.forEach((e) => e(t));
        }
        async connectWalletConnect(e) {
          let t = this.getWalletConnectConnector();
          return { clientId: (await t.connectWalletConnect()).clientId };
        }
        async switchNetwork(e) {
          let { caipNetwork: t, providerType: r } = e;
          if (!e.provider) return;
          let i = "provider" in e.provider ? e.provider.provider : e.provider;
          if ("WALLET_CONNECT" === r) {
            i.setDefaultChain(t.caipNetworkId);
            return;
          }
          if (i && "AUTH" === r) {
            await i.switchNetwork(t.caipNetworkId);
            let e = await i.getUser({
              chainId: t.caipNetworkId,
              preferredAccountType:
                n.H.state.defaultAccountTypes[t.chainNamespace],
            });
            this.emit("switchNetwork", e);
          }
        }
        getWalletConnectConnector() {
          let e = this.connectors.find((e) => e instanceof o.F);
          if (!e) throw Error("WalletConnectConnector not found");
          return e;
        }
      }
    },
    92963: (e, t, r) => {
      "use strict";
      var i = r(98392),
        s = r(78239),
        n = s.getNAF,
        a = s.getJSF,
        o = s.assert;
      function c(e, t) {
        (this.type = e),
          (this.p = new i(t.p, 16)),
          (this.red = t.prime ? i.red(t.prime) : i.mont(this.p)),
          (this.zero = new i(0).toRed(this.red)),
          (this.one = new i(1).toRed(this.red)),
          (this.two = new i(2).toRed(this.red)),
          (this.n = t.n && new i(t.n, 16)),
          (this.g = t.g && this.pointFromJSON(t.g, t.gRed)),
          (this._wnafT1 = [, , , ,]),
          (this._wnafT2 = [, , , ,]),
          (this._wnafT3 = [, , , ,]),
          (this._wnafT4 = [, , , ,]),
          (this._bitLength = this.n ? this.n.bitLength() : 0);
        var r = this.n && this.p.div(this.n);
        !r || r.cmpn(100) > 0
          ? (this.redN = null)
          : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)));
      }
      function l(e, t) {
        (this.curve = e), (this.type = t), (this.precomputed = null);
      }
      (e.exports = c),
        (c.prototype.point = function () {
          throw Error("Not implemented");
        }),
        (c.prototype.validate = function () {
          throw Error("Not implemented");
        }),
        (c.prototype._fixedNafMul = function (e, t) {
          o(e.precomputed);
          var r,
            i,
            s = e._getDoubles(),
            a = n(t, 1, this._bitLength),
            c = (1 << (s.step + 1)) - (s.step % 2 == 0 ? 2 : 1);
          c /= 3;
          var l = [];
          for (r = 0; r < a.length; r += s.step) {
            i = 0;
            for (var d = r + s.step - 1; d >= r; d--) i = (i << 1) + a[d];
            l.push(i);
          }
          for (
            var u = this.jpoint(null, null, null),
              h = this.jpoint(null, null, null),
              f = c;
            f > 0;
            f--
          ) {
            for (r = 0; r < l.length; r++)
              (i = l[r]) === f
                ? (h = h.mixedAdd(s.points[r]))
                : i === -f && (h = h.mixedAdd(s.points[r].neg()));
            u = u.add(h);
          }
          return u.toP();
        }),
        (c.prototype._wnafMul = function (e, t) {
          var r = 4,
            i = e._getNAFPoints(r);
          r = i.wnd;
          for (
            var s = i.points,
              a = n(t, r, this._bitLength),
              c = this.jpoint(null, null, null),
              l = a.length - 1;
            l >= 0;
            l--
          ) {
            for (var d = 0; l >= 0 && 0 === a[l]; l--) d++;
            if ((l >= 0 && d++, (c = c.dblp(d)), l < 0)) break;
            var u = a[l];
            o(0 !== u),
              (c =
                "affine" === e.type
                  ? u > 0
                    ? c.mixedAdd(s[(u - 1) >> 1])
                    : c.mixedAdd(s[(-u - 1) >> 1].neg())
                  : u > 0
                  ? c.add(s[(u - 1) >> 1])
                  : c.add(s[(-u - 1) >> 1].neg()));
          }
          return "affine" === e.type ? c.toP() : c;
        }),
        (c.prototype._wnafMulAdd = function (e, t, r, i, s) {
          var o,
            c,
            l,
            d = this._wnafT1,
            u = this._wnafT2,
            h = this._wnafT3,
            f = 0;
          for (o = 0; o < i; o++) {
            var p = (l = t[o])._getNAFPoints(e);
            (d[o] = p.wnd), (u[o] = p.points);
          }
          for (o = i - 1; o >= 1; o -= 2) {
            var g = o - 1,
              m = o;
            if (1 !== d[g] || 1 !== d[m]) {
              (h[g] = n(r[g], d[g], this._bitLength)),
                (h[m] = n(r[m], d[m], this._bitLength)),
                (f = Math.max(h[g].length, f)),
                (f = Math.max(h[m].length, f));
              continue;
            }
            var b = [t[g], null, null, t[m]];
            0 === t[g].y.cmp(t[m].y)
              ? ((b[1] = t[g].add(t[m])),
                (b[2] = t[g].toJ().mixedAdd(t[m].neg())))
              : 0 === t[g].y.cmp(t[m].y.redNeg())
              ? ((b[1] = t[g].toJ().mixedAdd(t[m])),
                (b[2] = t[g].add(t[m].neg())))
              : ((b[1] = t[g].toJ().mixedAdd(t[m])),
                (b[2] = t[g].toJ().mixedAdd(t[m].neg())));
            var y = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
              w = a(r[g], r[m]);
            for (
              c = 0,
                f = Math.max(w[0].length, f),
                h[g] = Array(f),
                h[m] = Array(f);
              c < f;
              c++
            ) {
              var v = 0 | w[0][c],
                A = 0 | w[1][c];
              (h[g][c] = y[(v + 1) * 3 + (A + 1)]), (h[m][c] = 0), (u[g] = b);
            }
          }
          var E = this.jpoint(null, null, null),
            _ = this._wnafT4;
          for (o = f; o >= 0; o--) {
            for (var C = 0; o >= 0; ) {
              var I = !0;
              for (c = 0; c < i; c++)
                (_[c] = 0 | h[c][o]), 0 !== _[c] && (I = !1);
              if (!I) break;
              C++, o--;
            }
            if ((o >= 0 && C++, (E = E.dblp(C)), o < 0)) break;
            for (c = 0; c < i; c++) {
              var S = _[c];
              0 !== S &&
                (S > 0
                  ? (l = u[c][(S - 1) >> 1])
                  : S < 0 && (l = u[c][(-S - 1) >> 1].neg()),
                (E = "affine" === l.type ? E.mixedAdd(l) : E.add(l)));
            }
          }
          for (o = 0; o < i; o++) u[o] = null;
          return s ? E : E.toP();
        }),
        (c.BasePoint = l),
        (l.prototype.eq = function () {
          throw Error("Not implemented");
        }),
        (l.prototype.validate = function () {
          return this.curve.validate(this);
        }),
        (c.prototype.decodePoint = function (e, t) {
          e = s.toArray(e, t);
          var r = this.p.byteLength();
          if ((4 === e[0] || 6 === e[0] || 7 === e[0]) && e.length - 1 == 2 * r)
            return (
              6 === e[0]
                ? o(e[e.length - 1] % 2 == 0)
                : 7 === e[0] && o(e[e.length - 1] % 2 == 1),
              this.point(e.slice(1, 1 + r), e.slice(1 + r, 1 + 2 * r))
            );
          if ((2 === e[0] || 3 === e[0]) && e.length - 1 === r)
            return this.pointFromX(e.slice(1, 1 + r), 3 === e[0]);
          throw Error("Unknown point format");
        }),
        (l.prototype.encodeCompressed = function (e) {
          return this.encode(e, !0);
        }),
        (l.prototype._encode = function (e) {
          var t = this.curve.p.byteLength(),
            r = this.getX().toArray("be", t);
          return e
            ? [this.getY().isEven() ? 2 : 3].concat(r)
            : [4].concat(r, this.getY().toArray("be", t));
        }),
        (l.prototype.encode = function (e, t) {
          return s.encode(this._encode(t), e);
        }),
        (l.prototype.precompute = function (e) {
          if (this.precomputed) return this;
          var t = { doubles: null, naf: null, beta: null };
          return (
            (t.naf = this._getNAFPoints(8)),
            (t.doubles = this._getDoubles(4, e)),
            (t.beta = this._getBeta()),
            (this.precomputed = t),
            this
          );
        }),
        (l.prototype._hasDoubles = function (e) {
          if (!this.precomputed) return !1;
          var t = this.precomputed.doubles;
          return (
            !!t && t.points.length >= Math.ceil((e.bitLength() + 1) / t.step)
          );
        }),
        (l.prototype._getDoubles = function (e, t) {
          if (this.precomputed && this.precomputed.doubles)
            return this.precomputed.doubles;
          for (var r = [this], i = this, s = 0; s < t; s += e) {
            for (var n = 0; n < e; n++) i = i.dbl();
            r.push(i);
          }
          return { step: e, points: r };
        }),
        (l.prototype._getNAFPoints = function (e) {
          if (this.precomputed && this.precomputed.naf)
            return this.precomputed.naf;
          for (
            var t = [this],
              r = (1 << e) - 1,
              i = 1 === r ? null : this.dbl(),
              s = 1;
            s < r;
            s++
          )
            t[s] = t[s - 1].add(i);
          return { wnd: e, points: t };
        }),
        (l.prototype._getBeta = function () {
          return null;
        }),
        (l.prototype.dblp = function (e) {
          for (var t = this, r = 0; r < e; r++) t = t.dbl();
          return t;
        });
    },
    93420: (e, t, r) => {
      "use strict";
      r.d(t, { N: () => s, V: () => n });
      var i = r(28698);
      class s extends i.C {
        constructor() {
          super("Provider not found."),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "ProviderNotFoundError",
            });
        }
      }
      class n extends i.C {
        constructor({ connector: e }) {
          super(`"${e.name}" does not support programmatic chain switching.`),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "SwitchChainNotSupportedError",
            });
        }
      }
    },
    93965: (e, t, r) => {
      "use strict";
      r.d(t, { IP: () => a, T8: () => s, Ud: () => n, Ws: () => i });
      let i = {
        WALLET_ID: "@appkit/wallet_id",
        WALLET_NAME: "@appkit/wallet_name",
        SOLANA_WALLET: "@appkit/solana_wallet",
        SOLANA_CAIP_CHAIN: "@appkit/solana_caip_chain",
        ACTIVE_CAIP_NETWORK_ID: "@appkit/active_caip_network_id",
        CONNECTED_SOCIAL: "@appkit/connected_social",
        CONNECTED_SOCIAL_USERNAME: "@appkit-wallet/SOCIAL_USERNAME",
        RECENT_WALLETS: "@appkit/recent_wallets",
        DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
        ACTIVE_NAMESPACE: "@appkit/active_namespace",
        CONNECTED_NAMESPACES: "@appkit/connected_namespaces",
        CONNECTION_STATUS: "@appkit/connection_status",
        SIWX_AUTH_TOKEN: "@appkit/siwx-auth-token",
        SIWX_NONCE_TOKEN: "@appkit/siwx-nonce-token",
        TELEGRAM_SOCIAL_PROVIDER: "@appkit/social_provider",
        NATIVE_BALANCE_CACHE: "@appkit/native_balance_cache",
        PORTFOLIO_CACHE: "@appkit/portfolio_cache",
        ENS_CACHE: "@appkit/ens_cache",
        IDENTITY_CACHE: "@appkit/identity_cache",
      };
      function s(e) {
        if (!e) throw Error("Namespace is required for CONNECTED_CONNECTOR_ID");
        return `@appkit/${e}:connected_connector_id`;
      }
      let n = {
        setItem(e, t) {
          a() && void 0 !== t && localStorage.setItem(e, t);
        },
        getItem(e) {
          if (a()) return localStorage.getItem(e) || void 0;
        },
        removeItem(e) {
          a() && localStorage.removeItem(e);
        },
        clear() {
          a() && localStorage.clear();
        },
      };
      function a() {
        return (
          "undefined" != typeof window && "undefined" != typeof localStorage
        );
      }
    },
    94820: (e) => {
      "use strict";
      var t = Object.prototype.hasOwnProperty,
        r = "~";
      function i() {}
      function s(e, t, r) {
        (this.fn = e), (this.context = t), (this.once = r || !1);
      }
      function n(e, t, i, n, a) {
        if ("function" != typeof i)
          throw TypeError("The listener must be a function");
        var o = new s(i, n || e, a),
          c = r ? r + t : t;
        return (
          e._events[c]
            ? e._events[c].fn
              ? (e._events[c] = [e._events[c], o])
              : e._events[c].push(o)
            : ((e._events[c] = o), e._eventsCount++),
          e
        );
      }
      function a(e, t) {
        0 == --e._eventsCount ? (e._events = new i()) : delete e._events[t];
      }
      function o() {
        (this._events = new i()), (this._eventsCount = 0);
      }
      Object.create &&
        ((i.prototype = Object.create(null)), new i().__proto__ || (r = !1)),
        (o.prototype.eventNames = function () {
          var e,
            i,
            s = [];
          if (0 === this._eventsCount) return s;
          for (i in (e = this._events))
            t.call(e, i) && s.push(r ? i.slice(1) : i);
          return Object.getOwnPropertySymbols
            ? s.concat(Object.getOwnPropertySymbols(e))
            : s;
        }),
        (o.prototype.listeners = function (e) {
          var t = r ? r + e : e,
            i = this._events[t];
          if (!i) return [];
          if (i.fn) return [i.fn];
          for (var s = 0, n = i.length, a = Array(n); s < n; s++)
            a[s] = i[s].fn;
          return a;
        }),
        (o.prototype.listenerCount = function (e) {
          var t = r ? r + e : e,
            i = this._events[t];
          return i ? (i.fn ? 1 : i.length) : 0;
        }),
        (o.prototype.emit = function (e, t, i, s, n, a) {
          var o = r ? r + e : e;
          if (!this._events[o]) return !1;
          var c,
            l,
            d = this._events[o],
            u = arguments.length;
          if (d.fn) {
            switch ((d.once && this.removeListener(e, d.fn, void 0, !0), u)) {
              case 1:
                return d.fn.call(d.context), !0;
              case 2:
                return d.fn.call(d.context, t), !0;
              case 3:
                return d.fn.call(d.context, t, i), !0;
              case 4:
                return d.fn.call(d.context, t, i, s), !0;
              case 5:
                return d.fn.call(d.context, t, i, s, n), !0;
              case 6:
                return d.fn.call(d.context, t, i, s, n, a), !0;
            }
            for (l = 1, c = Array(u - 1); l < u; l++) c[l - 1] = arguments[l];
            d.fn.apply(d.context, c);
          } else {
            var h,
              f = d.length;
            for (l = 0; l < f; l++)
              switch (
                (d[l].once && this.removeListener(e, d[l].fn, void 0, !0), u)
              ) {
                case 1:
                  d[l].fn.call(d[l].context);
                  break;
                case 2:
                  d[l].fn.call(d[l].context, t);
                  break;
                case 3:
                  d[l].fn.call(d[l].context, t, i);
                  break;
                case 4:
                  d[l].fn.call(d[l].context, t, i, s);
                  break;
                default:
                  if (!c)
                    for (h = 1, c = Array(u - 1); h < u; h++)
                      c[h - 1] = arguments[h];
                  d[l].fn.apply(d[l].context, c);
              }
          }
          return !0;
        }),
        (o.prototype.on = function (e, t, r) {
          return n(this, e, t, r, !1);
        }),
        (o.prototype.once = function (e, t, r) {
          return n(this, e, t, r, !0);
        }),
        (o.prototype.removeListener = function (e, t, i, s) {
          var n = r ? r + e : e;
          if (!this._events[n]) return this;
          if (!t) return a(this, n), this;
          var o = this._events[n];
          if (o.fn)
            o.fn !== t ||
              (s && !o.once) ||
              (i && o.context !== i) ||
              a(this, n);
          else {
            for (var c = 0, l = [], d = o.length; c < d; c++)
              (o[c].fn !== t ||
                (s && !o[c].once) ||
                (i && o[c].context !== i)) &&
                l.push(o[c]);
            l.length
              ? (this._events[n] = 1 === l.length ? l[0] : l)
              : a(this, n);
          }
          return this;
        }),
        (o.prototype.removeAllListeners = function (e) {
          var t;
          return (
            e
              ? ((t = r ? r + e : e), this._events[t] && a(this, t))
              : ((this._events = new i()), (this._eventsCount = 0)),
            this
          );
        }),
        (o.prototype.off = o.prototype.removeListener),
        (o.prototype.addListener = o.prototype.on),
        (o.prefixed = r),
        (o.EventEmitter = o),
        (e.exports = o);
    },
    94842: (e, t, r) => {
      "use strict";
      r.d(t, { k: () => n }), r(72557);
      var i = r(62609),
        s = r(5831);
      let n = {
        getMethodsByChainNamespace(e) {
          switch (e) {
            case "solana":
              return [
                "solana_signMessage",
                "solana_signTransaction",
                "solana_requestAccounts",
                "solana_getAccounts",
                "solana_signAllTransactions",
                "solana_signAndSendTransaction",
              ];
            case "eip155":
              return [
                "eth_accounts",
                "eth_requestAccounts",
                "eth_sendRawTransaction",
                "eth_sign",
                "eth_signTransaction",
                "eth_signTypedData",
                "eth_signTypedData_v3",
                "eth_signTypedData_v4",
                "eth_sendTransaction",
                "personal_sign",
                "wallet_switchEthereumChain",
                "wallet_addEthereumChain",
                "wallet_getPermissions",
                "wallet_requestPermissions",
                "wallet_registerOnboarding",
                "wallet_watchAsset",
                "wallet_scanQRCode",
                "wallet_getCallsStatus",
                "wallet_showCallsStatus",
                "wallet_sendCalls",
                "wallet_getCapabilities",
                "wallet_grantPermissions",
                "wallet_revokePermissions",
                "wallet_getAssets",
              ];
            case "bip122":
              return [
                "sendTransfer",
                "signMessage",
                "signPsbt",
                "getAccountAddresses",
              ];
            default:
              return [];
          }
        },
        createNamespaces(e) {
          return e.reduce((e, t) => {
            let { id: r, chainNamespace: i, rpcUrls: n } = t,
              a = n.default.http[0],
              o = this.getMethodsByChainNamespace(i);
            e[i] ||
              (e[i] = {
                methods: o,
                events: ["accountsChanged", "chainChanged"],
                chains: [],
                rpcMap: {},
              });
            let c = `${i}:${r}`,
              l = e[i];
            switch ((l.chains.push(c), c)) {
              case s.tWt.caipNetworkId:
                l.chains.push(s.tWt.deprecatedCaipNetworkId);
                break;
              case s.Rn0.caipNetworkId:
                l.chains.push(s.Rn0.deprecatedCaipNetworkId);
            }
            return l?.rpcMap && a && (l.rpcMap[r] = a), e;
          }, {});
        },
        resolveReownName: async (e) => {
          let t = await i.f.resolveName(e),
            r = Object.values(t?.addresses) || [];
          return r[0]?.address || !1;
        },
        getChainsFromNamespaces: (e = {}) =>
          Object.values(e).flatMap((e) =>
            Array.from(
              new Set([
                ...(e.chains || []),
                ...e.accounts.map((e) => {
                  let [t, r] = e.split(":");
                  return `${t}:${r}`;
                }),
              ])
            )
          ),
        isSessionEventData: (e) =>
          "object" == typeof e &&
          null !== e &&
          "id" in e &&
          "topic" in e &&
          "params" in e &&
          "object" == typeof e.params &&
          null !== e.params &&
          "chainId" in e.params &&
          "event" in e.params &&
          "object" == typeof e.params.event &&
          null !== e.params.event,
      };
    },
    95089: (e, t, r) => {
      "use strict";
      r.d(t, { U: () => n });
      var i = r(97152),
        s = r(95789);
      function n(e) {
        let {
            batch: t,
            cacheTime: r = e.pollingInterval ?? 4e3,
            ccipRead: n,
            key: a = "base",
            name: o = "Base Client",
            pollingInterval: c = 4e3,
            type: l = "base",
          } = e,
          d = e.chain,
          u = e.account ? (0, i.J)(e.account) : void 0,
          {
            config: h,
            request: f,
            value: p,
          } = e.transport({ chain: d, pollingInterval: c }),
          g = {
            account: u,
            batch: t,
            cacheTime: r,
            ccipRead: n,
            chain: d,
            key: a,
            name: o,
            pollingInterval: c,
            request: f,
            transport: { ...h, ...p },
            type: l,
            uid: (0, s.L)(),
          };
        return Object.assign(g, {
          extend: (function e(t) {
            return (r) => {
              let i = r(t);
              for (let e in g) delete i[e];
              let s = { ...t, ...i };
              return Object.assign(s, { extend: e(s) });
            };
          })(g),
        });
      }
    },
    95119: (e, t) => {
      "use strict";
      function r(e) {
        return 1 === e.length ? "0" + e : e;
      }
      function i(e) {
        for (var t = "", i = 0; i < e.length; i++) t += r(e[i].toString(16));
        return t;
      }
      (t.toArray = function (e, t) {
        if (Array.isArray(e)) return e.slice();
        if (!e) return [];
        var r = [];
        if ("string" != typeof e) {
          for (var i = 0; i < e.length; i++) r[i] = 0 | e[i];
          return r;
        }
        if ("hex" === t) {
          (e = e.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e = "0" + e);
          for (var i = 0; i < e.length; i += 2)
            r.push(parseInt(e[i] + e[i + 1], 16));
        } else
          for (var i = 0; i < e.length; i++) {
            var s = e.charCodeAt(i),
              n = s >> 8,
              a = 255 & s;
            n ? r.push(n, a) : r.push(a);
          }
        return r;
      }),
        (t.zero2 = r),
        (t.toHex = i),
        (t.encode = function (e, t) {
          return "hex" === t ? i(e) : e;
        });
    },
    95789: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { L: () => n });
      let s = 256;
      function n(e = 11) {
        if (!i || s + e > 512) {
          (i = ""), (s = 0);
          for (let e = 0; e < 256; e++)
            i += ((256 + 256 * Math.random()) | 0).toString(16).substring(1);
        }
        return i.substring(s, s++ + e);
      }
    },
    97152: (e, t, r) => {
      "use strict";
      function i(e) {
        return "string" == typeof e ? { address: e, type: "json-rpc" } : e;
      }
      r.d(t, { J: () => i });
    },
    97919: (e) => {
      e.exports = {
        doubles: {
          step: 4,
          points: [
            [
              "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
              "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821",
            ],
            [
              "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
              "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf",
            ],
            [
              "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
              "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695",
            ],
            [
              "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
              "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9",
            ],
            [
              "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
              "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36",
            ],
            [
              "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
              "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f",
            ],
            [
              "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
              "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999",
            ],
            [
              "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
              "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09",
            ],
            [
              "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
              "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d",
            ],
            [
              "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
              "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088",
            ],
            [
              "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
              "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d",
            ],
            [
              "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
              "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8",
            ],
            [
              "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
              "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a",
            ],
            [
              "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
              "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453",
            ],
            [
              "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
              "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160",
            ],
            [
              "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
              "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0",
            ],
            [
              "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
              "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6",
            ],
            [
              "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
              "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589",
            ],
            [
              "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
              "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17",
            ],
            [
              "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
              "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda",
            ],
            [
              "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
              "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd",
            ],
            [
              "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
              "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2",
            ],
            [
              "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
              "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6",
            ],
            [
              "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
              "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f",
            ],
            [
              "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
              "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01",
            ],
            [
              "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
              "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3",
            ],
            [
              "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
              "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f",
            ],
            [
              "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
              "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7",
            ],
            [
              "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
              "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78",
            ],
            [
              "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
              "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1",
            ],
            [
              "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
              "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150",
            ],
            [
              "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
              "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82",
            ],
            [
              "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
              "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc",
            ],
            [
              "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
              "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b",
            ],
            [
              "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
              "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51",
            ],
            [
              "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
              "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45",
            ],
            [
              "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
              "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120",
            ],
            [
              "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
              "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84",
            ],
            [
              "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
              "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d",
            ],
            [
              "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
              "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d",
            ],
            [
              "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
              "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8",
            ],
            [
              "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
              "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8",
            ],
            [
              "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
              "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac",
            ],
            [
              "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
              "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f",
            ],
            [
              "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
              "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962",
            ],
            [
              "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
              "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907",
            ],
            [
              "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
              "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec",
            ],
            [
              "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
              "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d",
            ],
            [
              "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
              "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414",
            ],
            [
              "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
              "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd",
            ],
            [
              "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
              "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0",
            ],
            [
              "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
              "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811",
            ],
            [
              "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
              "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1",
            ],
            [
              "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
              "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c",
            ],
            [
              "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
              "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73",
            ],
            [
              "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
              "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd",
            ],
            [
              "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
              "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405",
            ],
            [
              "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
              "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589",
            ],
            [
              "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
              "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e",
            ],
            [
              "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
              "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27",
            ],
            [
              "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
              "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1",
            ],
            [
              "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
              "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482",
            ],
            [
              "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
              "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945",
            ],
            [
              "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
              "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573",
            ],
            [
              "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
              "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82",
            ],
          ],
        },
        naf: {
          wnd: 7,
          points: [
            [
              "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
              "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672",
            ],
            [
              "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
              "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6",
            ],
            [
              "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
              "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da",
            ],
            [
              "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
              "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37",
            ],
            [
              "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
              "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b",
            ],
            [
              "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
              "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81",
            ],
            [
              "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
              "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58",
            ],
            [
              "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
              "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77",
            ],
            [
              "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
              "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a",
            ],
            [
              "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
              "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c",
            ],
            [
              "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
              "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67",
            ],
            [
              "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
              "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402",
            ],
            [
              "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
              "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55",
            ],
            [
              "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
              "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482",
            ],
            [
              "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
              "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82",
            ],
            [
              "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
              "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396",
            ],
            [
              "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
              "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49",
            ],
            [
              "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
              "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf",
            ],
            [
              "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
              "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a",
            ],
            [
              "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
              "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7",
            ],
            [
              "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
              "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933",
            ],
            [
              "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
              "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a",
            ],
            [
              "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
              "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6",
            ],
            [
              "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
              "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37",
            ],
            [
              "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
              "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e",
            ],
            [
              "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
              "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6",
            ],
            [
              "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
              "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476",
            ],
            [
              "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
              "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40",
            ],
            [
              "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
              "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61",
            ],
            [
              "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
              "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683",
            ],
            [
              "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
              "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5",
            ],
            [
              "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
              "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b",
            ],
            [
              "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
              "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417",
            ],
            [
              "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
              "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868",
            ],
            [
              "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
              "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a",
            ],
            [
              "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
              "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6",
            ],
            [
              "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
              "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996",
            ],
            [
              "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
              "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e",
            ],
            [
              "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
              "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d",
            ],
            [
              "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
              "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2",
            ],
            [
              "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
              "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e",
            ],
            [
              "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
              "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437",
            ],
            [
              "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
              "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311",
            ],
            [
              "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
              "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4",
            ],
            [
              "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
              "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575",
            ],
            [
              "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
              "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d",
            ],
            [
              "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
              "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d",
            ],
            [
              "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
              "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629",
            ],
            [
              "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
              "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06",
            ],
            [
              "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
              "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374",
            ],
            [
              "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
              "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee",
            ],
            [
              "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
              "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1",
            ],
            [
              "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
              "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b",
            ],
            [
              "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
              "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661",
            ],
            [
              "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
              "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6",
            ],
            [
              "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
              "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e",
            ],
            [
              "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
              "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d",
            ],
            [
              "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
              "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc",
            ],
            [
              "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
              "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4",
            ],
            [
              "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
              "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c",
            ],
            [
              "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
              "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b",
            ],
            [
              "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
              "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913",
            ],
            [
              "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
              "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154",
            ],
            [
              "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
              "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865",
            ],
            [
              "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
              "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc",
            ],
            [
              "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
              "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224",
            ],
            [
              "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
              "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e",
            ],
            [
              "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
              "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6",
            ],
            [
              "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
              "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511",
            ],
            [
              "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
              "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b",
            ],
            [
              "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
              "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2",
            ],
            [
              "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
              "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c",
            ],
            [
              "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
              "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3",
            ],
            [
              "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
              "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d",
            ],
            [
              "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
              "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700",
            ],
            [
              "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
              "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4",
            ],
            [
              "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
              "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196",
            ],
            [
              "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
              "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4",
            ],
            [
              "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
              "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257",
            ],
            [
              "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
              "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13",
            ],
            [
              "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
              "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096",
            ],
            [
              "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
              "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38",
            ],
            [
              "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
              "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f",
            ],
            [
              "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
              "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448",
            ],
            [
              "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
              "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a",
            ],
            [
              "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
              "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4",
            ],
            [
              "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
              "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437",
            ],
            [
              "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
              "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7",
            ],
            [
              "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
              "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d",
            ],
            [
              "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
              "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a",
            ],
            [
              "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
              "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54",
            ],
            [
              "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
              "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77",
            ],
            [
              "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
              "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517",
            ],
            [
              "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
              "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10",
            ],
            [
              "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
              "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125",
            ],
            [
              "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
              "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e",
            ],
            [
              "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
              "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1",
            ],
            [
              "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
              "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2",
            ],
            [
              "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
              "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423",
            ],
            [
              "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
              "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8",
            ],
            [
              "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
              "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758",
            ],
            [
              "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
              "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375",
            ],
            [
              "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
              "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d",
            ],
            [
              "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
              "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec",
            ],
            [
              "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
              "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0",
            ],
            [
              "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
              "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c",
            ],
            [
              "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
              "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4",
            ],
            [
              "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
              "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f",
            ],
            [
              "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
              "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649",
            ],
            [
              "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
              "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826",
            ],
            [
              "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
              "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5",
            ],
            [
              "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
              "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87",
            ],
            [
              "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
              "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b",
            ],
            [
              "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
              "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc",
            ],
            [
              "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
              "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c",
            ],
            [
              "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
              "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f",
            ],
            [
              "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
              "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a",
            ],
            [
              "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
              "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46",
            ],
            [
              "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
              "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f",
            ],
            [
              "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
              "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03",
            ],
            [
              "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
              "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08",
            ],
            [
              "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
              "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8",
            ],
            [
              "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
              "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373",
            ],
            [
              "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
              "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3",
            ],
            [
              "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
              "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8",
            ],
            [
              "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
              "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1",
            ],
            [
              "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
              "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9",
            ],
          ],
        },
      };
    },
    98392: function (e, t, r) {
      !(function (e, t) {
        "use strict";
        function i(e, t) {
          if (!e) throw Error(t || "Assertion failed");
        }
        function s(e, t) {
          e.super_ = t;
          var r = function () {};
          (r.prototype = t.prototype),
            (e.prototype = new r()),
            (e.prototype.constructor = e);
        }
        function n(e, t, r) {
          if (n.isBN(e)) return e;
          (this.negative = 0),
            (this.words = null),
            (this.length = 0),
            (this.red = null),
            null !== e &&
              (("le" === t || "be" === t) && ((r = t), (t = 10)),
              this._init(e || 0, t || 10, r || "be"));
        }
        "object" == typeof e ? (e.exports = n) : (t.BN = n),
          (n.BN = n),
          (n.wordSize = 26);
        try {
          l =
            "undefined" != typeof window && void 0 !== window.Buffer
              ? window.Buffer
              : r(79368).Buffer;
        } catch (e) {}
        function a(e, t) {
          var r = e.charCodeAt(t);
          return r >= 65 && r <= 70
            ? r - 55
            : r >= 97 && r <= 102
            ? r - 87
            : (r - 48) & 15;
        }
        function o(e, t, r) {
          var i = a(e, r);
          return r - 1 >= t && (i |= a(e, r - 1) << 4), i;
        }
        function c(e, t, r, i) {
          for (var s = 0, n = Math.min(e.length, r), a = t; a < n; a++) {
            var o = e.charCodeAt(a) - 48;
            (s *= i),
              o >= 49
                ? (s += o - 49 + 10)
                : o >= 17
                ? (s += o - 17 + 10)
                : (s += o);
          }
          return s;
        }
        (n.isBN = function (e) {
          return (
            e instanceof n ||
            (null !== e &&
              "object" == typeof e &&
              e.constructor.wordSize === n.wordSize &&
              Array.isArray(e.words))
          );
        }),
          (n.max = function (e, t) {
            return e.cmp(t) > 0 ? e : t;
          }),
          (n.min = function (e, t) {
            return 0 > e.cmp(t) ? e : t;
          }),
          (n.prototype._init = function (e, t, r) {
            if ("number" == typeof e) return this._initNumber(e, t, r);
            if ("object" == typeof e) return this._initArray(e, t, r);
            "hex" === t && (t = 16), i(t === (0 | t) && t >= 2 && t <= 36);
            var s = 0;
            "-" === (e = e.toString().replace(/\s+/g, ""))[0] &&
              (s++, (this.negative = 1)),
              s < e.length &&
                (16 === t
                  ? this._parseHex(e, s, r)
                  : (this._parseBase(e, t, s),
                    "le" === r && this._initArray(this.toArray(), t, r)));
          }),
          (n.prototype._initNumber = function (e, t, r) {
            e < 0 && ((this.negative = 1), (e = -e)),
              e < 0x4000000
                ? ((this.words = [0x3ffffff & e]), (this.length = 1))
                : e < 0x10000000000000
                ? ((this.words = [0x3ffffff & e, (e / 0x4000000) & 0x3ffffff]),
                  (this.length = 2))
                : (i(e < 0x20000000000000),
                  (this.words = [
                    0x3ffffff & e,
                    (e / 0x4000000) & 0x3ffffff,
                    1,
                  ]),
                  (this.length = 3)),
              "le" === r && this._initArray(this.toArray(), t, r);
          }),
          (n.prototype._initArray = function (e, t, r) {
            if ((i("number" == typeof e.length), e.length <= 0))
              return (this.words = [0]), (this.length = 1), this;
            (this.length = Math.ceil(e.length / 3)),
              (this.words = Array(this.length));
            for (var s, n, a = 0; a < this.length; a++) this.words[a] = 0;
            var o = 0;
            if ("be" === r)
              for (a = e.length - 1, s = 0; a >= 0; a -= 3)
                (n = e[a] | (e[a - 1] << 8) | (e[a - 2] << 16)),
                  (this.words[s] |= (n << o) & 0x3ffffff),
                  (this.words[s + 1] = (n >>> (26 - o)) & 0x3ffffff),
                  (o += 24) >= 26 && ((o -= 26), s++);
            else if ("le" === r)
              for (a = 0, s = 0; a < e.length; a += 3)
                (n = e[a] | (e[a + 1] << 8) | (e[a + 2] << 16)),
                  (this.words[s] |= (n << o) & 0x3ffffff),
                  (this.words[s + 1] = (n >>> (26 - o)) & 0x3ffffff),
                  (o += 24) >= 26 && ((o -= 26), s++);
            return this.strip();
          }),
          (n.prototype._parseHex = function (e, t, r) {
            (this.length = Math.ceil((e.length - t) / 6)),
              (this.words = Array(this.length));
            for (var i, s = 0; s < this.length; s++) this.words[s] = 0;
            var n = 0,
              a = 0;
            if ("be" === r)
              for (s = e.length - 1; s >= t; s -= 2)
                (i = o(e, t, s) << n),
                  (this.words[a] |= 0x3ffffff & i),
                  n >= 18
                    ? ((n -= 18), (a += 1), (this.words[a] |= i >>> 26))
                    : (n += 8);
            else
              for (
                s = (e.length - t) % 2 == 0 ? t + 1 : t;
                s < e.length;
                s += 2
              )
                (i = o(e, t, s) << n),
                  (this.words[a] |= 0x3ffffff & i),
                  n >= 18
                    ? ((n -= 18), (a += 1), (this.words[a] |= i >>> 26))
                    : (n += 8);
            this.strip();
          }),
          (n.prototype._parseBase = function (e, t, r) {
            (this.words = [0]), (this.length = 1);
            for (var i = 0, s = 1; s <= 0x3ffffff; s *= t) i++;
            i--, (s = (s / t) | 0);
            for (
              var n = e.length - r,
                a = n % i,
                o = Math.min(n, n - a) + r,
                l = 0,
                d = r;
              d < o;
              d += i
            )
              (l = c(e, d, d + i, t)),
                this.imuln(s),
                this.words[0] + l < 0x4000000
                  ? (this.words[0] += l)
                  : this._iaddn(l);
            if (0 !== a) {
              var u = 1;
              for (l = c(e, d, e.length, t), d = 0; d < a; d++) u *= t;
              this.imuln(u),
                this.words[0] + l < 0x4000000
                  ? (this.words[0] += l)
                  : this._iaddn(l);
            }
            this.strip();
          }),
          (n.prototype.copy = function (e) {
            e.words = Array(this.length);
            for (var t = 0; t < this.length; t++) e.words[t] = this.words[t];
            (e.length = this.length),
              (e.negative = this.negative),
              (e.red = this.red);
          }),
          (n.prototype.clone = function () {
            var e = new n(null);
            return this.copy(e), e;
          }),
          (n.prototype._expand = function (e) {
            for (; this.length < e; ) this.words[this.length++] = 0;
            return this;
          }),
          (n.prototype.strip = function () {
            for (; this.length > 1 && 0 === this.words[this.length - 1]; )
              this.length--;
            return this._normSign();
          }),
          (n.prototype._normSign = function () {
            return (
              1 === this.length && 0 === this.words[0] && (this.negative = 0),
              this
            );
          }),
          (n.prototype.inspect = function () {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
          });
        var l,
          d = [
            "",
            "0",
            "00",
            "000",
            "0000",
            "00000",
            "000000",
            "0000000",
            "00000000",
            "000000000",
            "0000000000",
            "00000000000",
            "000000000000",
            "0000000000000",
            "00000000000000",
            "000000000000000",
            "0000000000000000",
            "00000000000000000",
            "000000000000000000",
            "0000000000000000000",
            "00000000000000000000",
            "000000000000000000000",
            "0000000000000000000000",
            "00000000000000000000000",
            "000000000000000000000000",
            "0000000000000000000000000",
          ],
          u = [
            0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
          ],
          h = [
            0, 0, 0x2000000, 0x290d741, 0x1000000, 0x2e90edd, 0x39aa400,
            0x267bf47, 0x1000000, 0x290d741, 1e7, 0x12959c3, 0x222c000,
            0x3bd7765, 7529536, 0xadcea1, 0x1000000, 0x1704f61, 0x206fc40,
            0x2cddcf9, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625,
            0xb54ba0, 0xdaf26b, 0x1069c00, 0x138f9ad, 243e5, 0x1b4d89f,
            0x2000000, 0x25528a1, 0x2b54a20, 0x3216b93, 0x39aa400,
          ];
        function f(e, t, r) {
          r.negative = t.negative ^ e.negative;
          var i = (e.length + t.length) | 0;
          (r.length = i), (i = (i - 1) | 0);
          var s = 0 | e.words[0],
            n = 0 | t.words[0],
            a = s * n,
            o = 0x3ffffff & a,
            c = (a / 0x4000000) | 0;
          r.words[0] = o;
          for (var l = 1; l < i; l++) {
            for (
              var d = c >>> 26,
                u = 0x3ffffff & c,
                h = Math.min(l, t.length - 1),
                f = Math.max(0, l - e.length + 1);
              f <= h;
              f++
            ) {
              var p = (l - f) | 0;
              (d +=
                ((a = (s = 0 | e.words[p]) * (n = 0 | t.words[f]) + u) /
                  0x4000000) |
                0),
                (u = 0x3ffffff & a);
            }
            (r.words[l] = 0 | u), (c = 0 | d);
          }
          return 0 !== c ? (r.words[l] = 0 | c) : r.length--, r.strip();
        }
        (n.prototype.toString = function (e, t) {
          if (((t = 0 | t || 1), 16 === (e = e || 10) || "hex" === e)) {
            for (var r = "", s = 0, n = 0, a = 0; a < this.length; a++) {
              var o = this.words[a],
                c = (((o << s) | n) & 0xffffff).toString(16);
              (n = (o >>> (24 - s)) & 0xffffff),
                (s += 2) >= 26 && ((s -= 26), a--),
                (r =
                  0 !== n || a !== this.length - 1
                    ? d[6 - c.length] + c + r
                    : c + r);
            }
            for (0 !== n && (r = n.toString(16) + r); r.length % t != 0; )
              r = "0" + r;
            return 0 !== this.negative && (r = "-" + r), r;
          }
          if (e === (0 | e) && e >= 2 && e <= 36) {
            var l = u[e],
              f = h[e];
            r = "";
            var p = this.clone();
            for (p.negative = 0; !p.isZero(); ) {
              var g = p.modn(f).toString(e);
              r = (p = p.idivn(f)).isZero() ? g + r : d[l - g.length] + g + r;
            }
            for (this.isZero() && (r = "0" + r); r.length % t != 0; )
              r = "0" + r;
            return 0 !== this.negative && (r = "-" + r), r;
          }
          i(!1, "Base should be between 2 and 36");
        }),
          (n.prototype.toNumber = function () {
            var e = this.words[0];
            return (
              2 === this.length
                ? (e += 0x4000000 * this.words[1])
                : 3 === this.length && 1 === this.words[2]
                ? (e += 0x10000000000000 + 0x4000000 * this.words[1])
                : this.length > 2 &&
                  i(!1, "Number can only safely store up to 53 bits"),
              0 !== this.negative ? -e : e
            );
          }),
          (n.prototype.toJSON = function () {
            return this.toString(16);
          }),
          (n.prototype.toBuffer = function (e, t) {
            return i(void 0 !== l), this.toArrayLike(l, e, t);
          }),
          (n.prototype.toArray = function (e, t) {
            return this.toArrayLike(Array, e, t);
          }),
          (n.prototype.toArrayLike = function (e, t, r) {
            var s,
              n,
              a = this.byteLength(),
              o = r || Math.max(1, a);
            i(a <= o, "byte array longer than desired length"),
              i(o > 0, "Requested array length <= 0"),
              this.strip();
            var c = new e(o),
              l = this.clone();
            if ("le" === t) {
              for (n = 0; !l.isZero(); n++)
                (s = l.andln(255)), l.iushrn(8), (c[n] = s);
              for (; n < o; n++) c[n] = 0;
            } else {
              for (n = 0; n < o - a; n++) c[n] = 0;
              for (n = 0; !l.isZero(); n++)
                (s = l.andln(255)), l.iushrn(8), (c[o - n - 1] = s);
            }
            return c;
          }),
          Math.clz32
            ? (n.prototype._countBits = function (e) {
                return 32 - Math.clz32(e);
              })
            : (n.prototype._countBits = function (e) {
                var t = e,
                  r = 0;
                return (
                  t >= 4096 && ((r += 13), (t >>>= 13)),
                  t >= 64 && ((r += 7), (t >>>= 7)),
                  t >= 8 && ((r += 4), (t >>>= 4)),
                  t >= 2 && ((r += 2), (t >>>= 2)),
                  r + t
                );
              }),
          (n.prototype._zeroBits = function (e) {
            if (0 === e) return 26;
            var t = e,
              r = 0;
            return (
              (8191 & t) == 0 && ((r += 13), (t >>>= 13)),
              (127 & t) == 0 && ((r += 7), (t >>>= 7)),
              (15 & t) == 0 && ((r += 4), (t >>>= 4)),
              (3 & t) == 0 && ((r += 2), (t >>>= 2)),
              (1 & t) == 0 && r++,
              r
            );
          }),
          (n.prototype.bitLength = function () {
            var e = this.words[this.length - 1],
              t = this._countBits(e);
            return (this.length - 1) * 26 + t;
          }),
          (n.prototype.zeroBits = function () {
            if (this.isZero()) return 0;
            for (var e = 0, t = 0; t < this.length; t++) {
              var r = this._zeroBits(this.words[t]);
              if (((e += r), 26 !== r)) break;
            }
            return e;
          }),
          (n.prototype.byteLength = function () {
            return Math.ceil(this.bitLength() / 8);
          }),
          (n.prototype.toTwos = function (e) {
            return 0 !== this.negative
              ? this.abs().inotn(e).iaddn(1)
              : this.clone();
          }),
          (n.prototype.fromTwos = function (e) {
            return this.testn(e - 1)
              ? this.notn(e).iaddn(1).ineg()
              : this.clone();
          }),
          (n.prototype.isNeg = function () {
            return 0 !== this.negative;
          }),
          (n.prototype.neg = function () {
            return this.clone().ineg();
          }),
          (n.prototype.ineg = function () {
            return this.isZero() || (this.negative ^= 1), this;
          }),
          (n.prototype.iuor = function (e) {
            for (; this.length < e.length; ) this.words[this.length++] = 0;
            for (var t = 0; t < e.length; t++)
              this.words[t] = this.words[t] | e.words[t];
            return this.strip();
          }),
          (n.prototype.ior = function (e) {
            return i((this.negative | e.negative) == 0), this.iuor(e);
          }),
          (n.prototype.or = function (e) {
            return this.length > e.length
              ? this.clone().ior(e)
              : e.clone().ior(this);
          }),
          (n.prototype.uor = function (e) {
            return this.length > e.length
              ? this.clone().iuor(e)
              : e.clone().iuor(this);
          }),
          (n.prototype.iuand = function (e) {
            var t;
            t = this.length > e.length ? e : this;
            for (var r = 0; r < t.length; r++)
              this.words[r] = this.words[r] & e.words[r];
            return (this.length = t.length), this.strip();
          }),
          (n.prototype.iand = function (e) {
            return i((this.negative | e.negative) == 0), this.iuand(e);
          }),
          (n.prototype.and = function (e) {
            return this.length > e.length
              ? this.clone().iand(e)
              : e.clone().iand(this);
          }),
          (n.prototype.uand = function (e) {
            return this.length > e.length
              ? this.clone().iuand(e)
              : e.clone().iuand(this);
          }),
          (n.prototype.iuxor = function (e) {
            this.length > e.length
              ? ((t = this), (r = e))
              : ((t = e), (r = this));
            for (var t, r, i = 0; i < r.length; i++)
              this.words[i] = t.words[i] ^ r.words[i];
            if (this !== t)
              for (; i < t.length; i++) this.words[i] = t.words[i];
            return (this.length = t.length), this.strip();
          }),
          (n.prototype.ixor = function (e) {
            return i((this.negative | e.negative) == 0), this.iuxor(e);
          }),
          (n.prototype.xor = function (e) {
            return this.length > e.length
              ? this.clone().ixor(e)
              : e.clone().ixor(this);
          }),
          (n.prototype.uxor = function (e) {
            return this.length > e.length
              ? this.clone().iuxor(e)
              : e.clone().iuxor(this);
          }),
          (n.prototype.inotn = function (e) {
            i("number" == typeof e && e >= 0);
            var t = 0 | Math.ceil(e / 26),
              r = e % 26;
            this._expand(t), r > 0 && t--;
            for (var s = 0; s < t; s++)
              this.words[s] = 0x3ffffff & ~this.words[s];
            return (
              r > 0 &&
                (this.words[s] = ~this.words[s] & (0x3ffffff >> (26 - r))),
              this.strip()
            );
          }),
          (n.prototype.notn = function (e) {
            return this.clone().inotn(e);
          }),
          (n.prototype.setn = function (e, t) {
            i("number" == typeof e && e >= 0);
            var r = (e / 26) | 0,
              s = e % 26;
            return (
              this._expand(r + 1),
              t
                ? (this.words[r] = this.words[r] | (1 << s))
                : (this.words[r] = this.words[r] & ~(1 << s)),
              this.strip()
            );
          }),
          (n.prototype.iadd = function (e) {
            if (0 !== this.negative && 0 === e.negative)
              return (
                (this.negative = 0),
                (t = this.isub(e)),
                (this.negative ^= 1),
                this._normSign()
              );
            if (0 === this.negative && 0 !== e.negative)
              return (
                (e.negative = 0),
                (t = this.isub(e)),
                (e.negative = 1),
                t._normSign()
              );
            this.length > e.length
              ? ((r = this), (i = e))
              : ((r = e), (i = this));
            for (var t, r, i, s = 0, n = 0; n < i.length; n++)
              (t = (0 | r.words[n]) + (0 | i.words[n]) + s),
                (this.words[n] = 0x3ffffff & t),
                (s = t >>> 26);
            for (; 0 !== s && n < r.length; n++)
              (t = (0 | r.words[n]) + s),
                (this.words[n] = 0x3ffffff & t),
                (s = t >>> 26);
            if (((this.length = r.length), 0 !== s))
              (this.words[this.length] = s), this.length++;
            else if (r !== this)
              for (; n < r.length; n++) this.words[n] = r.words[n];
            return this;
          }),
          (n.prototype.add = function (e) {
            var t;
            return 0 !== e.negative && 0 === this.negative
              ? ((e.negative = 0), (t = this.sub(e)), (e.negative ^= 1), t)
              : 0 === e.negative && 0 !== this.negative
              ? ((this.negative = 0), (t = e.sub(this)), (this.negative = 1), t)
              : this.length > e.length
              ? this.clone().iadd(e)
              : e.clone().iadd(this);
          }),
          (n.prototype.isub = function (e) {
            if (0 !== e.negative) {
              e.negative = 0;
              var t,
                r,
                i = this.iadd(e);
              return (e.negative = 1), i._normSign();
            }
            if (0 !== this.negative)
              return (
                (this.negative = 0),
                this.iadd(e),
                (this.negative = 1),
                this._normSign()
              );
            var s = this.cmp(e);
            if (0 === s)
              return (
                (this.negative = 0),
                (this.length = 1),
                (this.words[0] = 0),
                this
              );
            s > 0 ? ((t = this), (r = e)) : ((t = e), (r = this));
            for (var n = 0, a = 0; a < r.length; a++)
              (n = (i = (0 | t.words[a]) - (0 | r.words[a]) + n) >> 26),
                (this.words[a] = 0x3ffffff & i);
            for (; 0 !== n && a < t.length; a++)
              (n = (i = (0 | t.words[a]) + n) >> 26),
                (this.words[a] = 0x3ffffff & i);
            if (0 === n && a < t.length && t !== this)
              for (; a < t.length; a++) this.words[a] = t.words[a];
            return (
              (this.length = Math.max(this.length, a)),
              t !== this && (this.negative = 1),
              this.strip()
            );
          }),
          (n.prototype.sub = function (e) {
            return this.clone().isub(e);
          });
        var p = function (e, t, r) {
          var i,
            s,
            n,
            a = e.words,
            o = t.words,
            c = r.words,
            l = 0,
            d = 0 | a[0],
            u = 8191 & d,
            h = d >>> 13,
            f = 0 | a[1],
            p = 8191 & f,
            g = f >>> 13,
            m = 0 | a[2],
            b = 8191 & m,
            y = m >>> 13,
            w = 0 | a[3],
            v = 8191 & w,
            A = w >>> 13,
            E = 0 | a[4],
            _ = 8191 & E,
            C = E >>> 13,
            I = 0 | a[5],
            S = 8191 & I,
            x = I >>> 13,
            N = 0 | a[6],
            T = 8191 & N,
            P = N >>> 13,
            O = 0 | a[7],
            k = 8191 & O,
            R = O >>> 13,
            D = 0 | a[8],
            M = 8191 & D,
            U = D >>> 13,
            L = 0 | a[9],
            B = 8191 & L,
            j = L >>> 13,
            F = 0 | o[0],
            $ = 8191 & F,
            z = F >>> 13,
            W = 0 | o[1],
            H = 8191 & W,
            q = W >>> 13,
            V = 0 | o[2],
            K = 8191 & V,
            G = V >>> 13,
            Y = 0 | o[3],
            Q = 8191 & Y,
            Z = Y >>> 13,
            J = 0 | o[4],
            X = 8191 & J,
            ee = J >>> 13,
            et = 0 | o[5],
            er = 8191 & et,
            ei = et >>> 13,
            es = 0 | o[6],
            en = 8191 & es,
            ea = es >>> 13,
            eo = 0 | o[7],
            ec = 8191 & eo,
            el = eo >>> 13,
            ed = 0 | o[8],
            eu = 8191 & ed,
            eh = ed >>> 13,
            ef = 0 | o[9],
            ep = 8191 & ef,
            eg = ef >>> 13;
          (r.negative = e.negative ^ t.negative),
            (r.length = 19),
            (i = Math.imul(u, $));
          var em =
            (((l + i) | 0) +
              ((8191 & (s = ((s = Math.imul(u, z)) + Math.imul(h, $)) | 0)) <<
                13)) |
            0;
          (l = ((((n = Math.imul(h, z)) + (s >>> 13)) | 0) + (em >>> 26)) | 0),
            (em &= 0x3ffffff),
            (i = Math.imul(p, $)),
            (s = ((s = Math.imul(p, z)) + Math.imul(g, $)) | 0),
            (n = Math.imul(g, z)),
            (i = (i + Math.imul(u, H)) | 0);
          var eb =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(u, q)) | 0) + Math.imul(h, H)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(h, q)) | 0) + (s >>> 13)) | 0) +
              (eb >>> 26)) |
            0),
            (eb &= 0x3ffffff),
            (i = Math.imul(b, $)),
            (s = ((s = Math.imul(b, z)) + Math.imul(y, $)) | 0),
            (n = Math.imul(y, z)),
            (i = (i + Math.imul(p, H)) | 0),
            (s = ((s = (s + Math.imul(p, q)) | 0) + Math.imul(g, H)) | 0),
            (n = (n + Math.imul(g, q)) | 0),
            (i = (i + Math.imul(u, K)) | 0);
          var ey =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(u, G)) | 0) + Math.imul(h, K)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(h, G)) | 0) + (s >>> 13)) | 0) +
              (ey >>> 26)) |
            0),
            (ey &= 0x3ffffff),
            (i = Math.imul(v, $)),
            (s = ((s = Math.imul(v, z)) + Math.imul(A, $)) | 0),
            (n = Math.imul(A, z)),
            (i = (i + Math.imul(b, H)) | 0),
            (s = ((s = (s + Math.imul(b, q)) | 0) + Math.imul(y, H)) | 0),
            (n = (n + Math.imul(y, q)) | 0),
            (i = (i + Math.imul(p, K)) | 0),
            (s = ((s = (s + Math.imul(p, G)) | 0) + Math.imul(g, K)) | 0),
            (n = (n + Math.imul(g, G)) | 0),
            (i = (i + Math.imul(u, Q)) | 0);
          var ew =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(u, Z)) | 0) + Math.imul(h, Q)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(h, Z)) | 0) + (s >>> 13)) | 0) +
              (ew >>> 26)) |
            0),
            (ew &= 0x3ffffff),
            (i = Math.imul(_, $)),
            (s = ((s = Math.imul(_, z)) + Math.imul(C, $)) | 0),
            (n = Math.imul(C, z)),
            (i = (i + Math.imul(v, H)) | 0),
            (s = ((s = (s + Math.imul(v, q)) | 0) + Math.imul(A, H)) | 0),
            (n = (n + Math.imul(A, q)) | 0),
            (i = (i + Math.imul(b, K)) | 0),
            (s = ((s = (s + Math.imul(b, G)) | 0) + Math.imul(y, K)) | 0),
            (n = (n + Math.imul(y, G)) | 0),
            (i = (i + Math.imul(p, Q)) | 0),
            (s = ((s = (s + Math.imul(p, Z)) | 0) + Math.imul(g, Q)) | 0),
            (n = (n + Math.imul(g, Z)) | 0),
            (i = (i + Math.imul(u, X)) | 0);
          var ev =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(u, ee)) | 0) + Math.imul(h, X)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(h, ee)) | 0) + (s >>> 13)) | 0) +
              (ev >>> 26)) |
            0),
            (ev &= 0x3ffffff),
            (i = Math.imul(S, $)),
            (s = ((s = Math.imul(S, z)) + Math.imul(x, $)) | 0),
            (n = Math.imul(x, z)),
            (i = (i + Math.imul(_, H)) | 0),
            (s = ((s = (s + Math.imul(_, q)) | 0) + Math.imul(C, H)) | 0),
            (n = (n + Math.imul(C, q)) | 0),
            (i = (i + Math.imul(v, K)) | 0),
            (s = ((s = (s + Math.imul(v, G)) | 0) + Math.imul(A, K)) | 0),
            (n = (n + Math.imul(A, G)) | 0),
            (i = (i + Math.imul(b, Q)) | 0),
            (s = ((s = (s + Math.imul(b, Z)) | 0) + Math.imul(y, Q)) | 0),
            (n = (n + Math.imul(y, Z)) | 0),
            (i = (i + Math.imul(p, X)) | 0),
            (s = ((s = (s + Math.imul(p, ee)) | 0) + Math.imul(g, X)) | 0),
            (n = (n + Math.imul(g, ee)) | 0),
            (i = (i + Math.imul(u, er)) | 0);
          var eA =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(u, ei)) | 0) + Math.imul(h, er)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(h, ei)) | 0) + (s >>> 13)) | 0) +
              (eA >>> 26)) |
            0),
            (eA &= 0x3ffffff),
            (i = Math.imul(T, $)),
            (s = ((s = Math.imul(T, z)) + Math.imul(P, $)) | 0),
            (n = Math.imul(P, z)),
            (i = (i + Math.imul(S, H)) | 0),
            (s = ((s = (s + Math.imul(S, q)) | 0) + Math.imul(x, H)) | 0),
            (n = (n + Math.imul(x, q)) | 0),
            (i = (i + Math.imul(_, K)) | 0),
            (s = ((s = (s + Math.imul(_, G)) | 0) + Math.imul(C, K)) | 0),
            (n = (n + Math.imul(C, G)) | 0),
            (i = (i + Math.imul(v, Q)) | 0),
            (s = ((s = (s + Math.imul(v, Z)) | 0) + Math.imul(A, Q)) | 0),
            (n = (n + Math.imul(A, Z)) | 0),
            (i = (i + Math.imul(b, X)) | 0),
            (s = ((s = (s + Math.imul(b, ee)) | 0) + Math.imul(y, X)) | 0),
            (n = (n + Math.imul(y, ee)) | 0),
            (i = (i + Math.imul(p, er)) | 0),
            (s = ((s = (s + Math.imul(p, ei)) | 0) + Math.imul(g, er)) | 0),
            (n = (n + Math.imul(g, ei)) | 0),
            (i = (i + Math.imul(u, en)) | 0);
          var eE =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(u, ea)) | 0) + Math.imul(h, en)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(h, ea)) | 0) + (s >>> 13)) | 0) +
              (eE >>> 26)) |
            0),
            (eE &= 0x3ffffff),
            (i = Math.imul(k, $)),
            (s = ((s = Math.imul(k, z)) + Math.imul(R, $)) | 0),
            (n = Math.imul(R, z)),
            (i = (i + Math.imul(T, H)) | 0),
            (s = ((s = (s + Math.imul(T, q)) | 0) + Math.imul(P, H)) | 0),
            (n = (n + Math.imul(P, q)) | 0),
            (i = (i + Math.imul(S, K)) | 0),
            (s = ((s = (s + Math.imul(S, G)) | 0) + Math.imul(x, K)) | 0),
            (n = (n + Math.imul(x, G)) | 0),
            (i = (i + Math.imul(_, Q)) | 0),
            (s = ((s = (s + Math.imul(_, Z)) | 0) + Math.imul(C, Q)) | 0),
            (n = (n + Math.imul(C, Z)) | 0),
            (i = (i + Math.imul(v, X)) | 0),
            (s = ((s = (s + Math.imul(v, ee)) | 0) + Math.imul(A, X)) | 0),
            (n = (n + Math.imul(A, ee)) | 0),
            (i = (i + Math.imul(b, er)) | 0),
            (s = ((s = (s + Math.imul(b, ei)) | 0) + Math.imul(y, er)) | 0),
            (n = (n + Math.imul(y, ei)) | 0),
            (i = (i + Math.imul(p, en)) | 0),
            (s = ((s = (s + Math.imul(p, ea)) | 0) + Math.imul(g, en)) | 0),
            (n = (n + Math.imul(g, ea)) | 0),
            (i = (i + Math.imul(u, ec)) | 0);
          var e_ =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(u, el)) | 0) + Math.imul(h, ec)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(h, el)) | 0) + (s >>> 13)) | 0) +
              (e_ >>> 26)) |
            0),
            (e_ &= 0x3ffffff),
            (i = Math.imul(M, $)),
            (s = ((s = Math.imul(M, z)) + Math.imul(U, $)) | 0),
            (n = Math.imul(U, z)),
            (i = (i + Math.imul(k, H)) | 0),
            (s = ((s = (s + Math.imul(k, q)) | 0) + Math.imul(R, H)) | 0),
            (n = (n + Math.imul(R, q)) | 0),
            (i = (i + Math.imul(T, K)) | 0),
            (s = ((s = (s + Math.imul(T, G)) | 0) + Math.imul(P, K)) | 0),
            (n = (n + Math.imul(P, G)) | 0),
            (i = (i + Math.imul(S, Q)) | 0),
            (s = ((s = (s + Math.imul(S, Z)) | 0) + Math.imul(x, Q)) | 0),
            (n = (n + Math.imul(x, Z)) | 0),
            (i = (i + Math.imul(_, X)) | 0),
            (s = ((s = (s + Math.imul(_, ee)) | 0) + Math.imul(C, X)) | 0),
            (n = (n + Math.imul(C, ee)) | 0),
            (i = (i + Math.imul(v, er)) | 0),
            (s = ((s = (s + Math.imul(v, ei)) | 0) + Math.imul(A, er)) | 0),
            (n = (n + Math.imul(A, ei)) | 0),
            (i = (i + Math.imul(b, en)) | 0),
            (s = ((s = (s + Math.imul(b, ea)) | 0) + Math.imul(y, en)) | 0),
            (n = (n + Math.imul(y, ea)) | 0),
            (i = (i + Math.imul(p, ec)) | 0),
            (s = ((s = (s + Math.imul(p, el)) | 0) + Math.imul(g, ec)) | 0),
            (n = (n + Math.imul(g, el)) | 0),
            (i = (i + Math.imul(u, eu)) | 0);
          var eC =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(u, eh)) | 0) + Math.imul(h, eu)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(h, eh)) | 0) + (s >>> 13)) | 0) +
              (eC >>> 26)) |
            0),
            (eC &= 0x3ffffff),
            (i = Math.imul(B, $)),
            (s = ((s = Math.imul(B, z)) + Math.imul(j, $)) | 0),
            (n = Math.imul(j, z)),
            (i = (i + Math.imul(M, H)) | 0),
            (s = ((s = (s + Math.imul(M, q)) | 0) + Math.imul(U, H)) | 0),
            (n = (n + Math.imul(U, q)) | 0),
            (i = (i + Math.imul(k, K)) | 0),
            (s = ((s = (s + Math.imul(k, G)) | 0) + Math.imul(R, K)) | 0),
            (n = (n + Math.imul(R, G)) | 0),
            (i = (i + Math.imul(T, Q)) | 0),
            (s = ((s = (s + Math.imul(T, Z)) | 0) + Math.imul(P, Q)) | 0),
            (n = (n + Math.imul(P, Z)) | 0),
            (i = (i + Math.imul(S, X)) | 0),
            (s = ((s = (s + Math.imul(S, ee)) | 0) + Math.imul(x, X)) | 0),
            (n = (n + Math.imul(x, ee)) | 0),
            (i = (i + Math.imul(_, er)) | 0),
            (s = ((s = (s + Math.imul(_, ei)) | 0) + Math.imul(C, er)) | 0),
            (n = (n + Math.imul(C, ei)) | 0),
            (i = (i + Math.imul(v, en)) | 0),
            (s = ((s = (s + Math.imul(v, ea)) | 0) + Math.imul(A, en)) | 0),
            (n = (n + Math.imul(A, ea)) | 0),
            (i = (i + Math.imul(b, ec)) | 0),
            (s = ((s = (s + Math.imul(b, el)) | 0) + Math.imul(y, ec)) | 0),
            (n = (n + Math.imul(y, el)) | 0),
            (i = (i + Math.imul(p, eu)) | 0),
            (s = ((s = (s + Math.imul(p, eh)) | 0) + Math.imul(g, eu)) | 0),
            (n = (n + Math.imul(g, eh)) | 0),
            (i = (i + Math.imul(u, ep)) | 0);
          var eI =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(u, eg)) | 0) + Math.imul(h, ep)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(h, eg)) | 0) + (s >>> 13)) | 0) +
              (eI >>> 26)) |
            0),
            (eI &= 0x3ffffff),
            (i = Math.imul(B, H)),
            (s = ((s = Math.imul(B, q)) + Math.imul(j, H)) | 0),
            (n = Math.imul(j, q)),
            (i = (i + Math.imul(M, K)) | 0),
            (s = ((s = (s + Math.imul(M, G)) | 0) + Math.imul(U, K)) | 0),
            (n = (n + Math.imul(U, G)) | 0),
            (i = (i + Math.imul(k, Q)) | 0),
            (s = ((s = (s + Math.imul(k, Z)) | 0) + Math.imul(R, Q)) | 0),
            (n = (n + Math.imul(R, Z)) | 0),
            (i = (i + Math.imul(T, X)) | 0),
            (s = ((s = (s + Math.imul(T, ee)) | 0) + Math.imul(P, X)) | 0),
            (n = (n + Math.imul(P, ee)) | 0),
            (i = (i + Math.imul(S, er)) | 0),
            (s = ((s = (s + Math.imul(S, ei)) | 0) + Math.imul(x, er)) | 0),
            (n = (n + Math.imul(x, ei)) | 0),
            (i = (i + Math.imul(_, en)) | 0),
            (s = ((s = (s + Math.imul(_, ea)) | 0) + Math.imul(C, en)) | 0),
            (n = (n + Math.imul(C, ea)) | 0),
            (i = (i + Math.imul(v, ec)) | 0),
            (s = ((s = (s + Math.imul(v, el)) | 0) + Math.imul(A, ec)) | 0),
            (n = (n + Math.imul(A, el)) | 0),
            (i = (i + Math.imul(b, eu)) | 0),
            (s = ((s = (s + Math.imul(b, eh)) | 0) + Math.imul(y, eu)) | 0),
            (n = (n + Math.imul(y, eh)) | 0),
            (i = (i + Math.imul(p, ep)) | 0);
          var eS =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(p, eg)) | 0) + Math.imul(g, ep)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(g, eg)) | 0) + (s >>> 13)) | 0) +
              (eS >>> 26)) |
            0),
            (eS &= 0x3ffffff),
            (i = Math.imul(B, K)),
            (s = ((s = Math.imul(B, G)) + Math.imul(j, K)) | 0),
            (n = Math.imul(j, G)),
            (i = (i + Math.imul(M, Q)) | 0),
            (s = ((s = (s + Math.imul(M, Z)) | 0) + Math.imul(U, Q)) | 0),
            (n = (n + Math.imul(U, Z)) | 0),
            (i = (i + Math.imul(k, X)) | 0),
            (s = ((s = (s + Math.imul(k, ee)) | 0) + Math.imul(R, X)) | 0),
            (n = (n + Math.imul(R, ee)) | 0),
            (i = (i + Math.imul(T, er)) | 0),
            (s = ((s = (s + Math.imul(T, ei)) | 0) + Math.imul(P, er)) | 0),
            (n = (n + Math.imul(P, ei)) | 0),
            (i = (i + Math.imul(S, en)) | 0),
            (s = ((s = (s + Math.imul(S, ea)) | 0) + Math.imul(x, en)) | 0),
            (n = (n + Math.imul(x, ea)) | 0),
            (i = (i + Math.imul(_, ec)) | 0),
            (s = ((s = (s + Math.imul(_, el)) | 0) + Math.imul(C, ec)) | 0),
            (n = (n + Math.imul(C, el)) | 0),
            (i = (i + Math.imul(v, eu)) | 0),
            (s = ((s = (s + Math.imul(v, eh)) | 0) + Math.imul(A, eu)) | 0),
            (n = (n + Math.imul(A, eh)) | 0),
            (i = (i + Math.imul(b, ep)) | 0);
          var ex =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(b, eg)) | 0) + Math.imul(y, ep)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(y, eg)) | 0) + (s >>> 13)) | 0) +
              (ex >>> 26)) |
            0),
            (ex &= 0x3ffffff),
            (i = Math.imul(B, Q)),
            (s = ((s = Math.imul(B, Z)) + Math.imul(j, Q)) | 0),
            (n = Math.imul(j, Z)),
            (i = (i + Math.imul(M, X)) | 0),
            (s = ((s = (s + Math.imul(M, ee)) | 0) + Math.imul(U, X)) | 0),
            (n = (n + Math.imul(U, ee)) | 0),
            (i = (i + Math.imul(k, er)) | 0),
            (s = ((s = (s + Math.imul(k, ei)) | 0) + Math.imul(R, er)) | 0),
            (n = (n + Math.imul(R, ei)) | 0),
            (i = (i + Math.imul(T, en)) | 0),
            (s = ((s = (s + Math.imul(T, ea)) | 0) + Math.imul(P, en)) | 0),
            (n = (n + Math.imul(P, ea)) | 0),
            (i = (i + Math.imul(S, ec)) | 0),
            (s = ((s = (s + Math.imul(S, el)) | 0) + Math.imul(x, ec)) | 0),
            (n = (n + Math.imul(x, el)) | 0),
            (i = (i + Math.imul(_, eu)) | 0),
            (s = ((s = (s + Math.imul(_, eh)) | 0) + Math.imul(C, eu)) | 0),
            (n = (n + Math.imul(C, eh)) | 0),
            (i = (i + Math.imul(v, ep)) | 0);
          var eN =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(v, eg)) | 0) + Math.imul(A, ep)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(A, eg)) | 0) + (s >>> 13)) | 0) +
              (eN >>> 26)) |
            0),
            (eN &= 0x3ffffff),
            (i = Math.imul(B, X)),
            (s = ((s = Math.imul(B, ee)) + Math.imul(j, X)) | 0),
            (n = Math.imul(j, ee)),
            (i = (i + Math.imul(M, er)) | 0),
            (s = ((s = (s + Math.imul(M, ei)) | 0) + Math.imul(U, er)) | 0),
            (n = (n + Math.imul(U, ei)) | 0),
            (i = (i + Math.imul(k, en)) | 0),
            (s = ((s = (s + Math.imul(k, ea)) | 0) + Math.imul(R, en)) | 0),
            (n = (n + Math.imul(R, ea)) | 0),
            (i = (i + Math.imul(T, ec)) | 0),
            (s = ((s = (s + Math.imul(T, el)) | 0) + Math.imul(P, ec)) | 0),
            (n = (n + Math.imul(P, el)) | 0),
            (i = (i + Math.imul(S, eu)) | 0),
            (s = ((s = (s + Math.imul(S, eh)) | 0) + Math.imul(x, eu)) | 0),
            (n = (n + Math.imul(x, eh)) | 0),
            (i = (i + Math.imul(_, ep)) | 0);
          var eT =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(_, eg)) | 0) + Math.imul(C, ep)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(C, eg)) | 0) + (s >>> 13)) | 0) +
              (eT >>> 26)) |
            0),
            (eT &= 0x3ffffff),
            (i = Math.imul(B, er)),
            (s = ((s = Math.imul(B, ei)) + Math.imul(j, er)) | 0),
            (n = Math.imul(j, ei)),
            (i = (i + Math.imul(M, en)) | 0),
            (s = ((s = (s + Math.imul(M, ea)) | 0) + Math.imul(U, en)) | 0),
            (n = (n + Math.imul(U, ea)) | 0),
            (i = (i + Math.imul(k, ec)) | 0),
            (s = ((s = (s + Math.imul(k, el)) | 0) + Math.imul(R, ec)) | 0),
            (n = (n + Math.imul(R, el)) | 0),
            (i = (i + Math.imul(T, eu)) | 0),
            (s = ((s = (s + Math.imul(T, eh)) | 0) + Math.imul(P, eu)) | 0),
            (n = (n + Math.imul(P, eh)) | 0),
            (i = (i + Math.imul(S, ep)) | 0);
          var eP =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(S, eg)) | 0) + Math.imul(x, ep)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(x, eg)) | 0) + (s >>> 13)) | 0) +
              (eP >>> 26)) |
            0),
            (eP &= 0x3ffffff),
            (i = Math.imul(B, en)),
            (s = ((s = Math.imul(B, ea)) + Math.imul(j, en)) | 0),
            (n = Math.imul(j, ea)),
            (i = (i + Math.imul(M, ec)) | 0),
            (s = ((s = (s + Math.imul(M, el)) | 0) + Math.imul(U, ec)) | 0),
            (n = (n + Math.imul(U, el)) | 0),
            (i = (i + Math.imul(k, eu)) | 0),
            (s = ((s = (s + Math.imul(k, eh)) | 0) + Math.imul(R, eu)) | 0),
            (n = (n + Math.imul(R, eh)) | 0),
            (i = (i + Math.imul(T, ep)) | 0);
          var eO =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(T, eg)) | 0) + Math.imul(P, ep)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(P, eg)) | 0) + (s >>> 13)) | 0) +
              (eO >>> 26)) |
            0),
            (eO &= 0x3ffffff),
            (i = Math.imul(B, ec)),
            (s = ((s = Math.imul(B, el)) + Math.imul(j, ec)) | 0),
            (n = Math.imul(j, el)),
            (i = (i + Math.imul(M, eu)) | 0),
            (s = ((s = (s + Math.imul(M, eh)) | 0) + Math.imul(U, eu)) | 0),
            (n = (n + Math.imul(U, eh)) | 0),
            (i = (i + Math.imul(k, ep)) | 0);
          var ek =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(k, eg)) | 0) + Math.imul(R, ep)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(R, eg)) | 0) + (s >>> 13)) | 0) +
              (ek >>> 26)) |
            0),
            (ek &= 0x3ffffff),
            (i = Math.imul(B, eu)),
            (s = ((s = Math.imul(B, eh)) + Math.imul(j, eu)) | 0),
            (n = Math.imul(j, eh)),
            (i = (i + Math.imul(M, ep)) | 0);
          var eR =
            (((l + i) | 0) +
              ((8191 &
                (s =
                  ((s = (s + Math.imul(M, eg)) | 0) + Math.imul(U, ep)) | 0)) <<
                13)) |
            0;
          (l =
            ((((n = (n + Math.imul(U, eg)) | 0) + (s >>> 13)) | 0) +
              (eR >>> 26)) |
            0),
            (eR &= 0x3ffffff),
            (i = Math.imul(B, ep));
          var eD =
            (((l + i) | 0) +
              ((8191 & (s = ((s = Math.imul(B, eg)) + Math.imul(j, ep)) | 0)) <<
                13)) |
            0;
          return (
            (l =
              ((((n = Math.imul(j, eg)) + (s >>> 13)) | 0) + (eD >>> 26)) | 0),
            (eD &= 0x3ffffff),
            (c[0] = em),
            (c[1] = eb),
            (c[2] = ey),
            (c[3] = ew),
            (c[4] = ev),
            (c[5] = eA),
            (c[6] = eE),
            (c[7] = e_),
            (c[8] = eC),
            (c[9] = eI),
            (c[10] = eS),
            (c[11] = ex),
            (c[12] = eN),
            (c[13] = eT),
            (c[14] = eP),
            (c[15] = eO),
            (c[16] = ek),
            (c[17] = eR),
            (c[18] = eD),
            0 !== l && ((c[19] = l), r.length++),
            r
          );
        };
        function g(e, t, r) {
          return new m().mulp(e, t, r);
        }
        function m(e, t) {
          (this.x = e), (this.y = t);
        }
        Math.imul || (p = f),
          (n.prototype.mulTo = function (e, t) {
            var r,
              i = this.length + e.length;
            return 10 === this.length && 10 === e.length
              ? p(this, e, t)
              : i < 63
              ? f(this, e, t)
              : i < 1024
              ? (function (e, t, r) {
                  (r.negative = t.negative ^ e.negative),
                    (r.length = e.length + t.length);
                  for (var i = 0, s = 0, n = 0; n < r.length - 1; n++) {
                    var a = s;
                    s = 0;
                    for (
                      var o = 0x3ffffff & i,
                        c = Math.min(n, t.length - 1),
                        l = Math.max(0, n - e.length + 1);
                      l <= c;
                      l++
                    ) {
                      var d = n - l,
                        u = (0 | e.words[d]) * (0 | t.words[l]),
                        h = 0x3ffffff & u;
                      (a = (a + ((u / 0x4000000) | 0)) | 0),
                        (o = 0x3ffffff & (h = (h + o) | 0)),
                        (s += (a = (a + (h >>> 26)) | 0) >>> 26),
                        (a &= 0x3ffffff);
                    }
                    (r.words[n] = o), (i = a), (a = s);
                  }
                  return 0 !== i ? (r.words[n] = i) : r.length--, r.strip();
                })(this, e, t)
              : g(this, e, t);
          }),
          (m.prototype.makeRBT = function (e) {
            for (
              var t = Array(e), r = n.prototype._countBits(e) - 1, i = 0;
              i < e;
              i++
            )
              t[i] = this.revBin(i, r, e);
            return t;
          }),
          (m.prototype.revBin = function (e, t, r) {
            if (0 === e || e === r - 1) return e;
            for (var i = 0, s = 0; s < t; s++)
              (i |= (1 & e) << (t - s - 1)), (e >>= 1);
            return i;
          }),
          (m.prototype.permute = function (e, t, r, i, s, n) {
            for (var a = 0; a < n; a++) (i[a] = t[e[a]]), (s[a] = r[e[a]]);
          }),
          (m.prototype.transform = function (e, t, r, i, s, n) {
            this.permute(n, e, t, r, i, s);
            for (var a = 1; a < s; a <<= 1)
              for (
                var o = a << 1,
                  c = Math.cos((2 * Math.PI) / o),
                  l = Math.sin((2 * Math.PI) / o),
                  d = 0;
                d < s;
                d += o
              )
                for (var u = c, h = l, f = 0; f < a; f++) {
                  var p = r[d + f],
                    g = i[d + f],
                    m = r[d + f + a],
                    b = i[d + f + a],
                    y = u * m - h * b;
                  (b = u * b + h * m),
                    (m = y),
                    (r[d + f] = p + m),
                    (i[d + f] = g + b),
                    (r[d + f + a] = p - m),
                    (i[d + f + a] = g - b),
                    f !== o &&
                      ((y = c * u - l * h), (h = c * h + l * u), (u = y));
                }
          }),
          (m.prototype.guessLen13b = function (e, t) {
            var r = 1 | Math.max(t, e),
              i = 1 & r,
              s = 0;
            for (r = (r / 2) | 0; r; r >>>= 1) s++;
            return 1 << (s + 1 + i);
          }),
          (m.prototype.conjugate = function (e, t, r) {
            if (!(r <= 1))
              for (var i = 0; i < r / 2; i++) {
                var s = e[i];
                (e[i] = e[r - i - 1]),
                  (e[r - i - 1] = s),
                  (s = t[i]),
                  (t[i] = -t[r - i - 1]),
                  (t[r - i - 1] = -s);
              }
          }),
          (m.prototype.normalize13b = function (e, t) {
            for (var r = 0, i = 0; i < t / 2; i++) {
              var s =
                8192 * Math.round(e[2 * i + 1] / t) +
                Math.round(e[2 * i] / t) +
                r;
              (e[i] = 0x3ffffff & s),
                (r = s < 0x4000000 ? 0 : (s / 0x4000000) | 0);
            }
            return e;
          }),
          (m.prototype.convert13b = function (e, t, r, s) {
            for (var n = 0, a = 0; a < t; a++)
              (n += 0 | e[a]),
                (r[2 * a] = 8191 & n),
                (n >>>= 13),
                (r[2 * a + 1] = 8191 & n),
                (n >>>= 13);
            for (a = 2 * t; a < s; ++a) r[a] = 0;
            i(0 === n), i((-8192 & n) == 0);
          }),
          (m.prototype.stub = function (e) {
            for (var t = Array(e), r = 0; r < e; r++) t[r] = 0;
            return t;
          }),
          (m.prototype.mulp = function (e, t, r) {
            var i = 2 * this.guessLen13b(e.length, t.length),
              s = this.makeRBT(i),
              n = this.stub(i),
              a = Array(i),
              o = Array(i),
              c = Array(i),
              l = Array(i),
              d = Array(i),
              u = Array(i),
              h = r.words;
            (h.length = i),
              this.convert13b(e.words, e.length, a, i),
              this.convert13b(t.words, t.length, l, i),
              this.transform(a, n, o, c, i, s),
              this.transform(l, n, d, u, i, s);
            for (var f = 0; f < i; f++) {
              var p = o[f] * d[f] - c[f] * u[f];
              (c[f] = o[f] * u[f] + c[f] * d[f]), (o[f] = p);
            }
            return (
              this.conjugate(o, c, i),
              this.transform(o, c, h, n, i, s),
              this.conjugate(h, n, i),
              this.normalize13b(h, i),
              (r.negative = e.negative ^ t.negative),
              (r.length = e.length + t.length),
              r.strip()
            );
          }),
          (n.prototype.mul = function (e) {
            var t = new n(null);
            return (t.words = Array(this.length + e.length)), this.mulTo(e, t);
          }),
          (n.prototype.mulf = function (e) {
            var t = new n(null);
            return (t.words = Array(this.length + e.length)), g(this, e, t);
          }),
          (n.prototype.imul = function (e) {
            return this.clone().mulTo(e, this);
          }),
          (n.prototype.imuln = function (e) {
            i("number" == typeof e), i(e < 0x4000000);
            for (var t = 0, r = 0; r < this.length; r++) {
              var s = (0 | this.words[r]) * e,
                n = (0x3ffffff & s) + (0x3ffffff & t);
              (t >>= 26),
                (t += ((s / 0x4000000) | 0) + (n >>> 26)),
                (this.words[r] = 0x3ffffff & n);
            }
            return 0 !== t && ((this.words[r] = t), this.length++), this;
          }),
          (n.prototype.muln = function (e) {
            return this.clone().imuln(e);
          }),
          (n.prototype.sqr = function () {
            return this.mul(this);
          }),
          (n.prototype.isqr = function () {
            return this.imul(this.clone());
          }),
          (n.prototype.pow = function (e) {
            var t = (function (e) {
              for (var t = Array(e.bitLength()), r = 0; r < t.length; r++) {
                var i = (r / 26) | 0,
                  s = r % 26;
                t[r] = (e.words[i] & (1 << s)) >>> s;
              }
              return t;
            })(e);
            if (0 === t.length) return new n(1);
            for (
              var r = this, i = 0;
              i < t.length && 0 === t[i];
              i++, r = r.sqr()
            );
            if (++i < t.length)
              for (var s = r.sqr(); i < t.length; i++, s = s.sqr())
                0 !== t[i] && (r = r.mul(s));
            return r;
          }),
          (n.prototype.iushln = function (e) {
            i("number" == typeof e && e >= 0);
            var t,
              r = e % 26,
              s = (e - r) / 26,
              n = (0x3ffffff >>> (26 - r)) << (26 - r);
            if (0 !== r) {
              var a = 0;
              for (t = 0; t < this.length; t++) {
                var o = this.words[t] & n,
                  c = ((0 | this.words[t]) - o) << r;
                (this.words[t] = c | a), (a = o >>> (26 - r));
              }
              a && ((this.words[t] = a), this.length++);
            }
            if (0 !== s) {
              for (t = this.length - 1; t >= 0; t--)
                this.words[t + s] = this.words[t];
              for (t = 0; t < s; t++) this.words[t] = 0;
              this.length += s;
            }
            return this.strip();
          }),
          (n.prototype.ishln = function (e) {
            return i(0 === this.negative), this.iushln(e);
          }),
          (n.prototype.iushrn = function (e, t, r) {
            i("number" == typeof e && e >= 0);
            var s = t ? (t - (t % 26)) / 26 : 0,
              n = e % 26,
              a = Math.min((e - n) / 26, this.length),
              o = 0x3ffffff ^ ((0x3ffffff >>> n) << n);
            if (((s -= a), (s = Math.max(0, s)), r)) {
              for (var c = 0; c < a; c++) r.words[c] = this.words[c];
              r.length = a;
            }
            if (0 === a);
            else if (this.length > a)
              for (this.length -= a, c = 0; c < this.length; c++)
                this.words[c] = this.words[c + a];
            else (this.words[0] = 0), (this.length = 1);
            var l = 0;
            for (c = this.length - 1; c >= 0 && (0 !== l || c >= s); c--) {
              var d = 0 | this.words[c];
              (this.words[c] = (l << (26 - n)) | (d >>> n)), (l = d & o);
            }
            return (
              r && 0 !== l && (r.words[r.length++] = l),
              0 === this.length && ((this.words[0] = 0), (this.length = 1)),
              this.strip()
            );
          }),
          (n.prototype.ishrn = function (e, t, r) {
            return i(0 === this.negative), this.iushrn(e, t, r);
          }),
          (n.prototype.shln = function (e) {
            return this.clone().ishln(e);
          }),
          (n.prototype.ushln = function (e) {
            return this.clone().iushln(e);
          }),
          (n.prototype.shrn = function (e) {
            return this.clone().ishrn(e);
          }),
          (n.prototype.ushrn = function (e) {
            return this.clone().iushrn(e);
          }),
          (n.prototype.testn = function (e) {
            i("number" == typeof e && e >= 0);
            var t = e % 26,
              r = (e - t) / 26;
            return !(this.length <= r) && !!(this.words[r] & (1 << t));
          }),
          (n.prototype.imaskn = function (e) {
            i("number" == typeof e && e >= 0);
            var t = e % 26,
              r = (e - t) / 26;
            return (i(
              0 === this.negative,
              "imaskn works only with positive numbers"
            ),
            this.length <= r)
              ? this
              : (0 !== t && r++,
                (this.length = Math.min(r, this.length)),
                0 !== t &&
                  (this.words[this.length - 1] &=
                    0x3ffffff ^ ((0x3ffffff >>> t) << t)),
                this.strip());
          }),
          (n.prototype.maskn = function (e) {
            return this.clone().imaskn(e);
          }),
          (n.prototype.iaddn = function (e) {
            return (i("number" == typeof e), i(e < 0x4000000), e < 0)
              ? this.isubn(-e)
              : 0 !== this.negative
              ? (1 === this.length && (0 | this.words[0]) < e
                  ? ((this.words[0] = e - (0 | this.words[0])),
                    (this.negative = 0))
                  : ((this.negative = 0), this.isubn(e), (this.negative = 1)),
                this)
              : this._iaddn(e);
          }),
          (n.prototype._iaddn = function (e) {
            this.words[0] += e;
            for (var t = 0; t < this.length && this.words[t] >= 0x4000000; t++)
              (this.words[t] -= 0x4000000),
                t === this.length - 1
                  ? (this.words[t + 1] = 1)
                  : this.words[t + 1]++;
            return (this.length = Math.max(this.length, t + 1)), this;
          }),
          (n.prototype.isubn = function (e) {
            if ((i("number" == typeof e), i(e < 0x4000000), e < 0))
              return this.iaddn(-e);
            if (0 !== this.negative)
              return (
                (this.negative = 0), this.iaddn(e), (this.negative = 1), this
              );
            if (((this.words[0] -= e), 1 === this.length && this.words[0] < 0))
              (this.words[0] = -this.words[0]), (this.negative = 1);
            else
              for (var t = 0; t < this.length && this.words[t] < 0; t++)
                (this.words[t] += 0x4000000), (this.words[t + 1] -= 1);
            return this.strip();
          }),
          (n.prototype.addn = function (e) {
            return this.clone().iaddn(e);
          }),
          (n.prototype.subn = function (e) {
            return this.clone().isubn(e);
          }),
          (n.prototype.iabs = function () {
            return (this.negative = 0), this;
          }),
          (n.prototype.abs = function () {
            return this.clone().iabs();
          }),
          (n.prototype._ishlnsubmul = function (e, t, r) {
            var s,
              n,
              a = e.length + r;
            this._expand(a);
            var o = 0;
            for (s = 0; s < e.length; s++) {
              n = (0 | this.words[s + r]) + o;
              var c = (0 | e.words[s]) * t;
              (n -= 0x3ffffff & c),
                (o = (n >> 26) - ((c / 0x4000000) | 0)),
                (this.words[s + r] = 0x3ffffff & n);
            }
            for (; s < this.length - r; s++)
              (o = (n = (0 | this.words[s + r]) + o) >> 26),
                (this.words[s + r] = 0x3ffffff & n);
            if (0 === o) return this.strip();
            for (i(-1 === o), o = 0, s = 0; s < this.length; s++)
              (o = (n = -(0 | this.words[s]) + o) >> 26),
                (this.words[s] = 0x3ffffff & n);
            return (this.negative = 1), this.strip();
          }),
          (n.prototype._wordDiv = function (e, t) {
            var r,
              i = this.length - e.length,
              s = this.clone(),
              a = e,
              o = 0 | a.words[a.length - 1];
            0 != (i = 26 - this._countBits(o)) &&
              ((a = a.ushln(i)), s.iushln(i), (o = 0 | a.words[a.length - 1]));
            var c = s.length - a.length;
            if ("mod" !== t) {
              ((r = new n(null)).length = c + 1), (r.words = Array(r.length));
              for (var l = 0; l < r.length; l++) r.words[l] = 0;
            }
            var d = s.clone()._ishlnsubmul(a, 1, c);
            0 === d.negative && ((s = d), r && (r.words[c] = 1));
            for (var u = c - 1; u >= 0; u--) {
              var h =
                (0 | s.words[a.length + u]) * 0x4000000 +
                (0 | s.words[a.length + u - 1]);
              for (
                h = Math.min((h / o) | 0, 0x3ffffff), s._ishlnsubmul(a, h, u);
                0 !== s.negative;

              )
                h--,
                  (s.negative = 0),
                  s._ishlnsubmul(a, 1, u),
                  s.isZero() || (s.negative ^= 1);
              r && (r.words[u] = h);
            }
            return (
              r && r.strip(),
              s.strip(),
              "div" !== t && 0 !== i && s.iushrn(i),
              { div: r || null, mod: s }
            );
          }),
          (n.prototype.divmod = function (e, t, r) {
            var s, a, o;
            return (i(!e.isZero()), this.isZero())
              ? { div: new n(0), mod: new n(0) }
              : 0 !== this.negative && 0 === e.negative
              ? ((o = this.neg().divmod(e, t)),
                "mod" !== t && (s = o.div.neg()),
                "div" !== t &&
                  ((a = o.mod.neg()), r && 0 !== a.negative && a.iadd(e)),
                { div: s, mod: a })
              : 0 === this.negative && 0 !== e.negative
              ? ((o = this.divmod(e.neg(), t)),
                "mod" !== t && (s = o.div.neg()),
                { div: s, mod: o.mod })
              : (this.negative & e.negative) != 0
              ? ((o = this.neg().divmod(e.neg(), t)),
                "div" !== t &&
                  ((a = o.mod.neg()), r && 0 !== a.negative && a.isub(e)),
                { div: o.div, mod: a })
              : e.length > this.length || 0 > this.cmp(e)
              ? { div: new n(0), mod: this }
              : 1 === e.length
              ? "div" === t
                ? { div: this.divn(e.words[0]), mod: null }
                : "mod" === t
                ? { div: null, mod: new n(this.modn(e.words[0])) }
                : {
                    div: this.divn(e.words[0]),
                    mod: new n(this.modn(e.words[0])),
                  }
              : this._wordDiv(e, t);
          }),
          (n.prototype.div = function (e) {
            return this.divmod(e, "div", !1).div;
          }),
          (n.prototype.mod = function (e) {
            return this.divmod(e, "mod", !1).mod;
          }),
          (n.prototype.umod = function (e) {
            return this.divmod(e, "mod", !0).mod;
          }),
          (n.prototype.divRound = function (e) {
            var t = this.divmod(e);
            if (t.mod.isZero()) return t.div;
            var r = 0 !== t.div.negative ? t.mod.isub(e) : t.mod,
              i = e.ushrn(1),
              s = e.andln(1),
              n = r.cmp(i);
            return n < 0 || (1 === s && 0 === n)
              ? t.div
              : 0 !== t.div.negative
              ? t.div.isubn(1)
              : t.div.iaddn(1);
          }),
          (n.prototype.modn = function (e) {
            i(e <= 0x3ffffff);
            for (var t = 0x4000000 % e, r = 0, s = this.length - 1; s >= 0; s--)
              r = (t * r + (0 | this.words[s])) % e;
            return r;
          }),
          (n.prototype.idivn = function (e) {
            i(e <= 0x3ffffff);
            for (var t = 0, r = this.length - 1; r >= 0; r--) {
              var s = (0 | this.words[r]) + 0x4000000 * t;
              (this.words[r] = (s / e) | 0), (t = s % e);
            }
            return this.strip();
          }),
          (n.prototype.divn = function (e) {
            return this.clone().idivn(e);
          }),
          (n.prototype.egcd = function (e) {
            i(0 === e.negative), i(!e.isZero());
            var t = this,
              r = e.clone();
            t = 0 !== t.negative ? t.umod(e) : t.clone();
            for (
              var s = new n(1), a = new n(0), o = new n(0), c = new n(1), l = 0;
              t.isEven() && r.isEven();

            )
              t.iushrn(1), r.iushrn(1), ++l;
            for (var d = r.clone(), u = t.clone(); !t.isZero(); ) {
              for (
                var h = 0, f = 1;
                (t.words[0] & f) == 0 && h < 26;
                ++h, f <<= 1
              );
              if (h > 0)
                for (t.iushrn(h); h-- > 0; )
                  (s.isOdd() || a.isOdd()) && (s.iadd(d), a.isub(u)),
                    s.iushrn(1),
                    a.iushrn(1);
              for (
                var p = 0, g = 1;
                (r.words[0] & g) == 0 && p < 26;
                ++p, g <<= 1
              );
              if (p > 0)
                for (r.iushrn(p); p-- > 0; )
                  (o.isOdd() || c.isOdd()) && (o.iadd(d), c.isub(u)),
                    o.iushrn(1),
                    c.iushrn(1);
              t.cmp(r) >= 0
                ? (t.isub(r), s.isub(o), a.isub(c))
                : (r.isub(t), o.isub(s), c.isub(a));
            }
            return { a: o, b: c, gcd: r.iushln(l) };
          }),
          (n.prototype._invmp = function (e) {
            i(0 === e.negative), i(!e.isZero());
            var t,
              r = this,
              s = e.clone();
            r = 0 !== r.negative ? r.umod(e) : r.clone();
            for (
              var a = new n(1), o = new n(0), c = s.clone();
              r.cmpn(1) > 0 && s.cmpn(1) > 0;

            ) {
              for (
                var l = 0, d = 1;
                (r.words[0] & d) == 0 && l < 26;
                ++l, d <<= 1
              );
              if (l > 0)
                for (r.iushrn(l); l-- > 0; )
                  a.isOdd() && a.iadd(c), a.iushrn(1);
              for (
                var u = 0, h = 1;
                (s.words[0] & h) == 0 && u < 26;
                ++u, h <<= 1
              );
              if (u > 0)
                for (s.iushrn(u); u-- > 0; )
                  o.isOdd() && o.iadd(c), o.iushrn(1);
              r.cmp(s) >= 0 ? (r.isub(s), a.isub(o)) : (s.isub(r), o.isub(a));
            }
            return 0 > (t = 0 === r.cmpn(1) ? a : o).cmpn(0) && t.iadd(e), t;
          }),
          (n.prototype.gcd = function (e) {
            if (this.isZero()) return e.abs();
            if (e.isZero()) return this.abs();
            var t = this.clone(),
              r = e.clone();
            (t.negative = 0), (r.negative = 0);
            for (var i = 0; t.isEven() && r.isEven(); i++)
              t.iushrn(1), r.iushrn(1);
            for (;;) {
              for (; t.isEven(); ) t.iushrn(1);
              for (; r.isEven(); ) r.iushrn(1);
              var s = t.cmp(r);
              if (s < 0) {
                var n = t;
                (t = r), (r = n);
              } else if (0 === s || 0 === r.cmpn(1)) break;
              t.isub(r);
            }
            return r.iushln(i);
          }),
          (n.prototype.invm = function (e) {
            return this.egcd(e).a.umod(e);
          }),
          (n.prototype.isEven = function () {
            return (1 & this.words[0]) == 0;
          }),
          (n.prototype.isOdd = function () {
            return (1 & this.words[0]) == 1;
          }),
          (n.prototype.andln = function (e) {
            return this.words[0] & e;
          }),
          (n.prototype.bincn = function (e) {
            i("number" == typeof e);
            var t = e % 26,
              r = (e - t) / 26,
              s = 1 << t;
            if (this.length <= r)
              return this._expand(r + 1), (this.words[r] |= s), this;
            for (var n = s, a = r; 0 !== n && a < this.length; a++) {
              var o = 0 | this.words[a];
              (o += n), (n = o >>> 26), (o &= 0x3ffffff), (this.words[a] = o);
            }
            return 0 !== n && ((this.words[a] = n), this.length++), this;
          }),
          (n.prototype.isZero = function () {
            return 1 === this.length && 0 === this.words[0];
          }),
          (n.prototype.cmpn = function (e) {
            var t,
              r = e < 0;
            if (0 !== this.negative && !r) return -1;
            if (0 === this.negative && r) return 1;
            if ((this.strip(), this.length > 1)) t = 1;
            else {
              r && (e = -e), i(e <= 0x3ffffff, "Number is too big");
              var s = 0 | this.words[0];
              t = s === e ? 0 : s < e ? -1 : 1;
            }
            return 0 !== this.negative ? 0 | -t : t;
          }),
          (n.prototype.cmp = function (e) {
            if (0 !== this.negative && 0 === e.negative) return -1;
            if (0 === this.negative && 0 !== e.negative) return 1;
            var t = this.ucmp(e);
            return 0 !== this.negative ? 0 | -t : t;
          }),
          (n.prototype.ucmp = function (e) {
            if (this.length > e.length) return 1;
            if (this.length < e.length) return -1;
            for (var t = 0, r = this.length - 1; r >= 0; r--) {
              var i = 0 | this.words[r],
                s = 0 | e.words[r];
              if (i !== s) {
                i < s ? (t = -1) : i > s && (t = 1);
                break;
              }
            }
            return t;
          }),
          (n.prototype.gtn = function (e) {
            return 1 === this.cmpn(e);
          }),
          (n.prototype.gt = function (e) {
            return 1 === this.cmp(e);
          }),
          (n.prototype.gten = function (e) {
            return this.cmpn(e) >= 0;
          }),
          (n.prototype.gte = function (e) {
            return this.cmp(e) >= 0;
          }),
          (n.prototype.ltn = function (e) {
            return -1 === this.cmpn(e);
          }),
          (n.prototype.lt = function (e) {
            return -1 === this.cmp(e);
          }),
          (n.prototype.lten = function (e) {
            return 0 >= this.cmpn(e);
          }),
          (n.prototype.lte = function (e) {
            return 0 >= this.cmp(e);
          }),
          (n.prototype.eqn = function (e) {
            return 0 === this.cmpn(e);
          }),
          (n.prototype.eq = function (e) {
            return 0 === this.cmp(e);
          }),
          (n.red = function (e) {
            return new _(e);
          }),
          (n.prototype.toRed = function (e) {
            return (
              i(!this.red, "Already a number in reduction context"),
              i(0 === this.negative, "red works only with positives"),
              e.convertTo(this)._forceRed(e)
            );
          }),
          (n.prototype.fromRed = function () {
            return (
              i(
                this.red,
                "fromRed works only with numbers in reduction context"
              ),
              this.red.convertFrom(this)
            );
          }),
          (n.prototype._forceRed = function (e) {
            return (this.red = e), this;
          }),
          (n.prototype.forceRed = function (e) {
            return (
              i(!this.red, "Already a number in reduction context"),
              this._forceRed(e)
            );
          }),
          (n.prototype.redAdd = function (e) {
            return (
              i(this.red, "redAdd works only with red numbers"),
              this.red.add(this, e)
            );
          }),
          (n.prototype.redIAdd = function (e) {
            return (
              i(this.red, "redIAdd works only with red numbers"),
              this.red.iadd(this, e)
            );
          }),
          (n.prototype.redSub = function (e) {
            return (
              i(this.red, "redSub works only with red numbers"),
              this.red.sub(this, e)
            );
          }),
          (n.prototype.redISub = function (e) {
            return (
              i(this.red, "redISub works only with red numbers"),
              this.red.isub(this, e)
            );
          }),
          (n.prototype.redShl = function (e) {
            return (
              i(this.red, "redShl works only with red numbers"),
              this.red.shl(this, e)
            );
          }),
          (n.prototype.redMul = function (e) {
            return (
              i(this.red, "redMul works only with red numbers"),
              this.red._verify2(this, e),
              this.red.mul(this, e)
            );
          }),
          (n.prototype.redIMul = function (e) {
            return (
              i(this.red, "redMul works only with red numbers"),
              this.red._verify2(this, e),
              this.red.imul(this, e)
            );
          }),
          (n.prototype.redSqr = function () {
            return (
              i(this.red, "redSqr works only with red numbers"),
              this.red._verify1(this),
              this.red.sqr(this)
            );
          }),
          (n.prototype.redISqr = function () {
            return (
              i(this.red, "redISqr works only with red numbers"),
              this.red._verify1(this),
              this.red.isqr(this)
            );
          }),
          (n.prototype.redSqrt = function () {
            return (
              i(this.red, "redSqrt works only with red numbers"),
              this.red._verify1(this),
              this.red.sqrt(this)
            );
          }),
          (n.prototype.redInvm = function () {
            return (
              i(this.red, "redInvm works only with red numbers"),
              this.red._verify1(this),
              this.red.invm(this)
            );
          }),
          (n.prototype.redNeg = function () {
            return (
              i(this.red, "redNeg works only with red numbers"),
              this.red._verify1(this),
              this.red.neg(this)
            );
          }),
          (n.prototype.redPow = function (e) {
            return (
              i(this.red && !e.red, "redPow(normalNum)"),
              this.red._verify1(this),
              this.red.pow(this, e)
            );
          });
        var b = { k256: null, p224: null, p192: null, p25519: null };
        function y(e, t) {
          (this.name = e),
            (this.p = new n(t, 16)),
            (this.n = this.p.bitLength()),
            (this.k = new n(1).iushln(this.n).isub(this.p)),
            (this.tmp = this._tmp());
        }
        function w() {
          y.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        function v() {
          y.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        function A() {
          y.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        function E() {
          y.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        function _(e) {
          if ("string" == typeof e) {
            var t = n._prime(e);
            (this.m = t.p), (this.prime = t);
          } else
            i(e.gtn(1), "modulus must be greater than 1"),
              (this.m = e),
              (this.prime = null);
        }
        function C(e) {
          _.call(this, e),
            (this.shift = this.m.bitLength()),
            this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
            (this.r = new n(1).iushln(this.shift)),
            (this.r2 = this.imod(this.r.sqr())),
            (this.rinv = this.r._invmp(this.m)),
            (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
            (this.minv = this.minv.umod(this.r)),
            (this.minv = this.r.sub(this.minv));
        }
        (y.prototype._tmp = function () {
          var e = new n(null);
          return (e.words = Array(Math.ceil(this.n / 13))), e;
        }),
          (y.prototype.ireduce = function (e) {
            var t,
              r = e;
            do
              this.split(r, this.tmp),
                (t = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength());
            while (t > this.n);
            var i = t < this.n ? -1 : r.ucmp(this.p);
            return (
              0 === i
                ? ((r.words[0] = 0), (r.length = 1))
                : i > 0
                ? r.isub(this.p)
                : void 0 !== r.strip
                ? r.strip()
                : r._strip(),
              r
            );
          }),
          (y.prototype.split = function (e, t) {
            e.iushrn(this.n, 0, t);
          }),
          (y.prototype.imulK = function (e) {
            return e.imul(this.k);
          }),
          s(w, y),
          (w.prototype.split = function (e, t) {
            for (var r = Math.min(e.length, 9), i = 0; i < r; i++)
              t.words[i] = e.words[i];
            if (((t.length = r), e.length <= 9)) {
              (e.words[0] = 0), (e.length = 1);
              return;
            }
            var s = e.words[9];
            for (i = 10, t.words[t.length++] = 4194303 & s; i < e.length; i++) {
              var n = 0 | e.words[i];
              (e.words[i - 10] = ((4194303 & n) << 4) | (s >>> 22)), (s = n);
            }
            (s >>>= 22),
              (e.words[i - 10] = s),
              0 === s && e.length > 10 ? (e.length -= 10) : (e.length -= 9);
          }),
          (w.prototype.imulK = function (e) {
            (e.words[e.length] = 0),
              (e.words[e.length + 1] = 0),
              (e.length += 2);
            for (var t = 0, r = 0; r < e.length; r++) {
              var i = 0 | e.words[r];
              (t += 977 * i),
                (e.words[r] = 0x3ffffff & t),
                (t = 64 * i + ((t / 0x4000000) | 0));
            }
            return (
              0 === e.words[e.length - 1] &&
                (e.length--, 0 === e.words[e.length - 1] && e.length--),
              e
            );
          }),
          s(v, y),
          s(A, y),
          s(E, y),
          (E.prototype.imulK = function (e) {
            for (var t = 0, r = 0; r < e.length; r++) {
              var i = (0 | e.words[r]) * 19 + t,
                s = 0x3ffffff & i;
              (i >>>= 26), (e.words[r] = s), (t = i);
            }
            return 0 !== t && (e.words[e.length++] = t), e;
          }),
          (n._prime = function (e) {
            var t;
            if (b[e]) return b[e];
            if ("k256" === e) t = new w();
            else if ("p224" === e) t = new v();
            else if ("p192" === e) t = new A();
            else if ("p25519" === e) t = new E();
            else throw Error("Unknown prime " + e);
            return (b[e] = t), t;
          }),
          (_.prototype._verify1 = function (e) {
            i(0 === e.negative, "red works only with positives"),
              i(e.red, "red works only with red numbers");
          }),
          (_.prototype._verify2 = function (e, t) {
            i((e.negative | t.negative) == 0, "red works only with positives"),
              i(e.red && e.red === t.red, "red works only with red numbers");
          }),
          (_.prototype.imod = function (e) {
            return this.prime
              ? this.prime.ireduce(e)._forceRed(this)
              : e.umod(this.m)._forceRed(this);
          }),
          (_.prototype.neg = function (e) {
            return e.isZero() ? e.clone() : this.m.sub(e)._forceRed(this);
          }),
          (_.prototype.add = function (e, t) {
            this._verify2(e, t);
            var r = e.add(t);
            return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this);
          }),
          (_.prototype.iadd = function (e, t) {
            this._verify2(e, t);
            var r = e.iadd(t);
            return r.cmp(this.m) >= 0 && r.isub(this.m), r;
          }),
          (_.prototype.sub = function (e, t) {
            this._verify2(e, t);
            var r = e.sub(t);
            return 0 > r.cmpn(0) && r.iadd(this.m), r._forceRed(this);
          }),
          (_.prototype.isub = function (e, t) {
            this._verify2(e, t);
            var r = e.isub(t);
            return 0 > r.cmpn(0) && r.iadd(this.m), r;
          }),
          (_.prototype.shl = function (e, t) {
            return this._verify1(e), this.imod(e.ushln(t));
          }),
          (_.prototype.imul = function (e, t) {
            return this._verify2(e, t), this.imod(e.imul(t));
          }),
          (_.prototype.mul = function (e, t) {
            return this._verify2(e, t), this.imod(e.mul(t));
          }),
          (_.prototype.isqr = function (e) {
            return this.imul(e, e.clone());
          }),
          (_.prototype.sqr = function (e) {
            return this.mul(e, e);
          }),
          (_.prototype.sqrt = function (e) {
            if (e.isZero()) return e.clone();
            var t = this.m.andln(3);
            if ((i(t % 2 == 1), 3 === t)) {
              var r = this.m.add(new n(1)).iushrn(2);
              return this.pow(e, r);
            }
            for (
              var s = this.m.subn(1), a = 0;
              !s.isZero() && 0 === s.andln(1);

            )
              a++, s.iushrn(1);
            i(!s.isZero());
            var o = new n(1).toRed(this),
              c = o.redNeg(),
              l = this.m.subn(1).iushrn(1),
              d = this.m.bitLength();
            for (
              d = new n(2 * d * d).toRed(this);
              0 !== this.pow(d, l).cmp(c);

            )
              d.redIAdd(c);
            for (
              var u = this.pow(d, s),
                h = this.pow(e, s.addn(1).iushrn(1)),
                f = this.pow(e, s),
                p = a;
              0 !== f.cmp(o);

            ) {
              for (var g = f, m = 0; 0 !== g.cmp(o); m++) g = g.redSqr();
              i(m < p);
              var b = this.pow(u, new n(1).iushln(p - m - 1));
              (h = h.redMul(b)), (u = b.redSqr()), (f = f.redMul(u)), (p = m);
            }
            return h;
          }),
          (_.prototype.invm = function (e) {
            var t = e._invmp(this.m);
            return 0 !== t.negative
              ? ((t.negative = 0), this.imod(t).redNeg())
              : this.imod(t);
          }),
          (_.prototype.pow = function (e, t) {
            if (t.isZero()) return new n(1).toRed(this);
            if (0 === t.cmpn(1)) return e.clone();
            var r = Array(16);
            (r[0] = new n(1).toRed(this)), (r[1] = e);
            for (var i = 2; i < r.length; i++) r[i] = this.mul(r[i - 1], e);
            var s = r[0],
              a = 0,
              o = 0,
              c = t.bitLength() % 26;
            for (0 === c && (c = 26), i = t.length - 1; i >= 0; i--) {
              for (var l = t.words[i], d = c - 1; d >= 0; d--) {
                var u = (l >> d) & 1;
                if ((s !== r[0] && (s = this.sqr(s)), 0 === u && 0 === a)) {
                  o = 0;
                  continue;
                }
                (a <<= 1),
                  (a |= u),
                  (4 == ++o || (0 === i && 0 === d)) &&
                    ((s = this.mul(s, r[a])), (o = 0), (a = 0));
              }
              c = 26;
            }
            return s;
          }),
          (_.prototype.convertTo = function (e) {
            var t = e.umod(this.m);
            return t === e ? t.clone() : t;
          }),
          (_.prototype.convertFrom = function (e) {
            var t = e.clone();
            return (t.red = null), t;
          }),
          (n.mont = function (e) {
            return new C(e);
          }),
          s(C, _),
          (C.prototype.convertTo = function (e) {
            return this.imod(e.ushln(this.shift));
          }),
          (C.prototype.convertFrom = function (e) {
            var t = this.imod(e.mul(this.rinv));
            return (t.red = null), t;
          }),
          (C.prototype.imul = function (e, t) {
            if (e.isZero() || t.isZero())
              return (e.words[0] = 0), (e.length = 1), e;
            var r = e.imul(t),
              i = r
                .maskn(this.shift)
                .mul(this.minv)
                .imaskn(this.shift)
                .mul(this.m),
              s = r.isub(i).iushrn(this.shift),
              n = s;
            return (
              s.cmp(this.m) >= 0
                ? (n = s.isub(this.m))
                : 0 > s.cmpn(0) && (n = s.iadd(this.m)),
              n._forceRed(this)
            );
          }),
          (C.prototype.mul = function (e, t) {
            if (e.isZero() || t.isZero()) return new n(0)._forceRed(this);
            var r = e.mul(t),
              i = r
                .maskn(this.shift)
                .mul(this.minv)
                .imaskn(this.shift)
                .mul(this.m),
              s = r.isub(i).iushrn(this.shift),
              a = s;
            return (
              s.cmp(this.m) >= 0
                ? (a = s.isub(this.m))
                : 0 > s.cmpn(0) && (a = s.iadd(this.m)),
              a._forceRed(this)
            );
          }),
          (C.prototype.invm = function (e) {
            return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this);
          });
      })((e = r.nmd(e)), this);
    },
    98502: (e, t, r) => {
      "use strict";
      r.d(t, {
        mN: () => S,
        AH: () => l,
        W3: () => _,
        Ec: () => C,
        iz: () => c,
      });
      let i = globalThis,
        s =
          i.ShadowRoot &&
          (void 0 === i.ShadyCSS || i.ShadyCSS.nativeShadow) &&
          "adoptedStyleSheets" in Document.prototype &&
          "replace" in CSSStyleSheet.prototype,
        n = Symbol(),
        a = new WeakMap();
      class o {
        constructor(e, t, r) {
          if (((this._$cssResult$ = !0), r !== n))
            throw Error(
              "CSSResult is not constructable. Use `unsafeCSS` or `css` instead."
            );
          (this.cssText = e), (this.t = t);
        }
        get styleSheet() {
          let e = this.o,
            t = this.t;
          if (s && void 0 === e) {
            let r = void 0 !== t && 1 === t.length;
            r && (e = a.get(t)),
              void 0 === e &&
                ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText),
                r && a.set(t, e));
          }
          return e;
        }
        toString() {
          return this.cssText;
        }
      }
      let c = (e) => new o("string" == typeof e ? e : e + "", void 0, n),
        l = (e, ...t) =>
          new o(
            1 === e.length
              ? e[0]
              : t.reduce(
                  (t, r, i) =>
                    t +
                    ((e) => {
                      if (!0 === e._$cssResult$) return e.cssText;
                      if ("number" == typeof e) return e;
                      throw Error(
                        "Value passed to 'css' function must be a 'css' function result: " +
                          e +
                          ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security."
                      );
                    })(r) +
                    e[i + 1],
                  e[0]
                ),
            e,
            n
          ),
        d = (e, t) => {
          if (s)
            e.adoptedStyleSheets = t.map((e) =>
              e instanceof CSSStyleSheet ? e : e.styleSheet
            );
          else
            for (let r of t) {
              let t = document.createElement("style"),
                s = i.litNonce;
              void 0 !== s && t.setAttribute("nonce", s),
                (t.textContent = r.cssText),
                e.appendChild(t);
            }
        },
        u = s
          ? (e) => e
          : (e) =>
              e instanceof CSSStyleSheet
                ? ((e) => {
                    let t = "";
                    for (let r of e.cssRules) t += r.cssText;
                    return c(t);
                  })(e)
                : e,
        {
          is: h,
          defineProperty: f,
          getOwnPropertyDescriptor: p,
          getOwnPropertyNames: g,
          getOwnPropertySymbols: m,
          getPrototypeOf: b,
        } = Object,
        y = globalThis,
        w = y.trustedTypes,
        v = w ? w.emptyScript : "",
        A = y.reactiveElementPolyfillSupport,
        E = (e, t) => e,
        _ = {
          toAttribute(e, t) {
            switch (t) {
              case Boolean:
                e = e ? v : null;
                break;
              case Object:
              case Array:
                e = null == e ? e : JSON.stringify(e);
            }
            return e;
          },
          fromAttribute(e, t) {
            let r = e;
            switch (t) {
              case Boolean:
                r = null !== e;
                break;
              case Number:
                r = null === e ? null : Number(e);
                break;
              case Object:
              case Array:
                try {
                  r = JSON.parse(e);
                } catch (e) {
                  r = null;
                }
            }
            return r;
          },
        },
        C = (e, t) => !h(e, t),
        I = {
          attribute: !0,
          type: String,
          converter: _,
          reflect: !1,
          hasChanged: C,
        };
      (Symbol.metadata ??= Symbol("metadata")),
        (y.litPropertyMetadata ??= new WeakMap());
      class S extends HTMLElement {
        static addInitializer(e) {
          this._$Ei(), (this.l ??= []).push(e);
        }
        static get observedAttributes() {
          return this.finalize(), this._$Eh && [...this._$Eh.keys()];
        }
        static createProperty(e, t = I) {
          if (
            (t.state && (t.attribute = !1),
            this._$Ei(),
            this.elementProperties.set(e, t),
            !t.noAccessor)
          ) {
            let r = Symbol(),
              i = this.getPropertyDescriptor(e, r, t);
            void 0 !== i && f(this.prototype, e, i);
          }
        }
        static getPropertyDescriptor(e, t, r) {
          let { get: i, set: s } = p(this.prototype, e) ?? {
            get() {
              return this[t];
            },
            set(e) {
              this[t] = e;
            },
          };
          return {
            get() {
              return i?.call(this);
            },
            set(t) {
              let n = i?.call(this);
              s.call(this, t), this.requestUpdate(e, n, r);
            },
            configurable: !0,
            enumerable: !0,
          };
        }
        static getPropertyOptions(e) {
          return this.elementProperties.get(e) ?? I;
        }
        static _$Ei() {
          if (this.hasOwnProperty(E("elementProperties"))) return;
          let e = b(this);
          e.finalize(),
            void 0 !== e.l && (this.l = [...e.l]),
            (this.elementProperties = new Map(e.elementProperties));
        }
        static finalize() {
          if (this.hasOwnProperty(E("finalized"))) return;
          if (
            ((this.finalized = !0),
            this._$Ei(),
            this.hasOwnProperty(E("properties")))
          ) {
            let e = this.properties;
            for (let t of [...g(e), ...m(e)]) this.createProperty(t, e[t]);
          }
          let e = this[Symbol.metadata];
          if (null !== e) {
            let t = litPropertyMetadata.get(e);
            if (void 0 !== t)
              for (let [e, r] of t) this.elementProperties.set(e, r);
          }
          for (let [e, t] of ((this._$Eh = new Map()),
          this.elementProperties)) {
            let r = this._$Eu(e, t);
            void 0 !== r && this._$Eh.set(r, e);
          }
          this.elementStyles = this.finalizeStyles(this.styles);
        }
        static finalizeStyles(e) {
          let t = [];
          if (Array.isArray(e))
            for (let r of new Set(e.flat(1 / 0).reverse())) t.unshift(u(r));
          else void 0 !== e && t.push(u(e));
          return t;
        }
        static _$Eu(e, t) {
          let r = t.attribute;
          return !1 === r
            ? void 0
            : "string" == typeof r
            ? r
            : "string" == typeof e
            ? e.toLowerCase()
            : void 0;
        }
        constructor() {
          super(),
            (this._$Ep = void 0),
            (this.isUpdatePending = !1),
            (this.hasUpdated = !1),
            (this._$Em = null),
            this._$Ev();
        }
        _$Ev() {
          (this._$ES = new Promise((e) => (this.enableUpdating = e))),
            (this._$AL = new Map()),
            this._$E_(),
            this.requestUpdate(),
            this.constructor.l?.forEach((e) => e(this));
        }
        addController(e) {
          (this._$EO ??= new Set()).add(e),
            void 0 !== this.renderRoot &&
              this.isConnected &&
              e.hostConnected?.();
        }
        removeController(e) {
          this._$EO?.delete(e);
        }
        _$E_() {
          let e = new Map();
          for (let t of this.constructor.elementProperties.keys())
            this.hasOwnProperty(t) && (e.set(t, this[t]), delete this[t]);
          e.size > 0 && (this._$Ep = e);
        }
        createRenderRoot() {
          let e =
            this.shadowRoot ??
            this.attachShadow(this.constructor.shadowRootOptions);
          return d(e, this.constructor.elementStyles), e;
        }
        connectedCallback() {
          (this.renderRoot ??= this.createRenderRoot()),
            this.enableUpdating(!0),
            this._$EO?.forEach((e) => e.hostConnected?.());
        }
        enableUpdating(e) {}
        disconnectedCallback() {
          this._$EO?.forEach((e) => e.hostDisconnected?.());
        }
        attributeChangedCallback(e, t, r) {
          this._$AK(e, r);
        }
        _$EC(e, t) {
          let r = this.constructor.elementProperties.get(e),
            i = this.constructor._$Eu(e, r);
          if (void 0 !== i && !0 === r.reflect) {
            let s = (
              void 0 !== r.converter?.toAttribute ? r.converter : _
            ).toAttribute(t, r.type);
            (this._$Em = e),
              null == s ? this.removeAttribute(i) : this.setAttribute(i, s),
              (this._$Em = null);
          }
        }
        _$AK(e, t) {
          let r = this.constructor,
            i = r._$Eh.get(e);
          if (void 0 !== i && this._$Em !== i) {
            let e = r.getPropertyOptions(i),
              s =
                "function" == typeof e.converter
                  ? { fromAttribute: e.converter }
                  : void 0 !== e.converter?.fromAttribute
                  ? e.converter
                  : _;
            (this._$Em = i),
              (this[i] = s.fromAttribute(t, e.type)),
              (this._$Em = null);
          }
        }
        requestUpdate(e, t, r) {
          if (void 0 !== e) {
            if (
              !((r ??= this.constructor.getPropertyOptions(e)).hasChanged ?? C)(
                this[e],
                t
              )
            )
              return;
            this.P(e, t, r);
          }
          !1 === this.isUpdatePending && (this._$ES = this._$ET());
        }
        P(e, t, r) {
          this._$AL.has(e) || this._$AL.set(e, t),
            !0 === r.reflect &&
              this._$Em !== e &&
              (this._$Ej ??= new Set()).add(e);
        }
        async _$ET() {
          this.isUpdatePending = !0;
          try {
            await this._$ES;
          } catch (e) {
            Promise.reject(e);
          }
          let e = this.scheduleUpdate();
          return null != e && (await e), !this.isUpdatePending;
        }
        scheduleUpdate() {
          return this.performUpdate();
        }
        performUpdate() {
          if (!this.isUpdatePending) return;
          if (!this.hasUpdated) {
            if (((this.renderRoot ??= this.createRenderRoot()), this._$Ep)) {
              for (let [e, t] of this._$Ep) this[e] = t;
              this._$Ep = void 0;
            }
            let e = this.constructor.elementProperties;
            if (e.size > 0)
              for (let [t, r] of e)
                !0 !== r.wrapped ||
                  this._$AL.has(t) ||
                  void 0 === this[t] ||
                  this.P(t, this[t], r);
          }
          let e = !1,
            t = this._$AL;
          try {
            (e = this.shouldUpdate(t))
              ? (this.willUpdate(t),
                this._$EO?.forEach((e) => e.hostUpdate?.()),
                this.update(t))
              : this._$EU();
          } catch (t) {
            throw ((e = !1), this._$EU(), t);
          }
          e && this._$AE(t);
        }
        willUpdate(e) {}
        _$AE(e) {
          this._$EO?.forEach((e) => e.hostUpdated?.()),
            this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(e)),
            this.updated(e);
        }
        _$EU() {
          (this._$AL = new Map()), (this.isUpdatePending = !1);
        }
        get updateComplete() {
          return this.getUpdateComplete();
        }
        getUpdateComplete() {
          return this._$ES;
        }
        shouldUpdate(e) {
          return !0;
        }
        update(e) {
          (this._$Ej &&= this._$Ej.forEach((e) => this._$EC(e, this[e]))),
            this._$EU();
        }
        updated(e) {}
        firstUpdated(e) {}
      }
      (S.elementStyles = []),
        (S.shadowRootOptions = { mode: "open" }),
        (S[E("elementProperties")] = new Map()),
        (S[E("finalized")] = new Map()),
        A?.({ ReactiveElement: S }),
        (y.reactiveElementVersions ??= []).push("2.0.4");
    },
    98782: (e, t, r) => {
      "use strict";
      r.d(t, { UG: () => a, xo: () => s, zz: () => n });
      var i = r(63542);
      class s extends i.C {
        constructor({ signature: e }) {
          super("Failed to parse ABI item.", {
            details: `parseAbiItem(${JSON.stringify(e, null, 2)})`,
            docsPath: "/api/human#parseabiitem-1",
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "InvalidAbiItemError",
            });
        }
      }
      class n extends i.C {
        constructor({ type: e }) {
          super("Unknown type.", {
            metaMessages: [
              `Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,
            ],
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "UnknownTypeError",
            });
        }
      }
      class a extends i.C {
        constructor({ type: e }) {
          super("Unknown type.", {
            metaMessages: [`Type "${e}" is not a valid ABI type.`],
          }),
            Object.defineProperty(this, "name", {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: "UnknownSolidityTypeError",
            });
        }
      }
    },
    98866: (e, t, r) => {
      "use strict";
      let i;
      r.d(t, { u$: () => n, zC: () => o });
      var s = r(1220);
      function n(e, t, r, i) {
        let n = e[t];
        return (0, s.B1)(
          e,
          () => {
            let i = e[t];
            Object.is(n, i) || r((n = i));
          },
          i
        );
      }
      Symbol();
      let a = (e) => "object" == typeof e && null !== e;
      function o(e) {
        let t = (0, s.BX)({
          data: Array.from(e || []),
          has(e) {
            return this.data.some((t) => t[0] === e);
          },
          set(e, t) {
            let r = this.data.find((t) => t[0] === e);
            return r ? (r[1] = t) : this.data.push([e, t]), this;
          },
          get(e) {
            var t;
            return null == (t = this.data.find((t) => t[0] === e))
              ? void 0
              : t[1];
          },
          delete(e) {
            let t = this.data.findIndex((t) => t[0] === e);
            return -1 !== t && (this.data.splice(t, 1), !0);
          },
          clear() {
            this.data.splice(0);
          },
          get size() {
            return this.data.length;
          },
          toJSON() {
            return new Map(this.data);
          },
          forEach(e) {
            this.data.forEach((t) => {
              e(t[1], t[0], this);
            });
          },
          keys() {
            return this.data.map((e) => e[0]).values();
          },
          values() {
            return this.data.map((e) => e[1]).values();
          },
          entries() {
            return new Map(this.data).entries();
          },
          get [Symbol.toStringTag]() {
            return "Map";
          },
          [Symbol.iterator]() {
            return this.entries();
          },
        });
        return (
          Object.defineProperties(t, {
            data: { enumerable: !1 },
            size: { enumerable: !1 },
            toJSON: { enumerable: !1 },
          }),
          Object.seal(t),
          t
        );
      }
    },
    98957: (e, t, r) => {
      "use strict";
      r.d(t, {
        Dv: () => C,
        FO: () => g,
        If: () => A,
        Ji: () => u,
        Rv: () => c,
        WL: () => p,
        Yo: () => y,
        ej: () => h,
        fC: () => I,
        iB: () => l,
        kz: () => a,
        l9: () => b,
        pc: () => n,
        sP: () => _,
        v7: () => S,
        v8: () => v,
      });
      var i = r(89709);
      let s = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
      function n(e) {
        return s.test(e);
      }
      function a(e) {
        return (0, i.Yv)(s, e);
      }
      let o = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
      function c(e) {
        return o.test(e);
      }
      function l(e) {
        return (0, i.Yv)(o, e);
      }
      let d =
        /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
      function u(e) {
        return d.test(e);
      }
      function h(e) {
        return (0, i.Yv)(d, e);
      }
      let f =
        /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
      function p(e) {
        return f.test(e);
      }
      function g(e) {
        return (0, i.Yv)(f, e);
      }
      let m =
        /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
      function b(e) {
        return m.test(e);
      }
      function y(e) {
        return (0, i.Yv)(m, e);
      }
      let w = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
      function v(e) {
        return w.test(e);
      }
      function A(e) {
        return (0, i.Yv)(w, e);
      }
      let E = /^receive\(\) external payable$/;
      function _(e) {
        return E.test(e);
      }
      let C = new Set(["memory", "indexed", "storage", "calldata"]),
        I = new Set(["indexed"]),
        S = new Set(["calldata", "memory", "storage"]);
    },
  },
]);
